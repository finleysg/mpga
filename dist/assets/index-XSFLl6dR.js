var MQ = Object.defineProperty
var IQ = (e, t, n) =>
	t in e ? MQ(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : (e[t] = n)
var RQ = (e, t) => () => (t || e((t = { exports: {} }).exports, t), t.exports)
var q = (e, t, n) => IQ(e, typeof t != "symbol" ? t + "" : t, n)
var WSt = RQ((pa, ei) => {
	function LQ(e, t) {
		for (var n = 0; n < t.length; n++) {
			const r = t[n]
			if (typeof r != "string" && !Array.isArray(r)) {
				for (const i in r)
					if (i !== "default" && !(i in e)) {
						const a = Object.getOwnPropertyDescriptor(r, i)
						a && Object.defineProperty(e, i, a.get ? a : { enumerable: !0, get: () => r[i] })
					}
			}
		}
		return Object.freeze(Object.defineProperty(e, Symbol.toStringTag, { value: "Module" }))
	}
	;(function () {
		const t = document.createElement("link").relList
		if (t && t.supports && t.supports("modulepreload")) return
		for (const i of document.querySelectorAll('link[rel="modulepreload"]')) r(i)
		new MutationObserver((i) => {
			for (const a of i)
				if (a.type === "childList")
					for (const o of a.addedNodes) o.tagName === "LINK" && o.rel === "modulepreload" && r(o)
		}).observe(document, { childList: !0, subtree: !0 })
		function n(i) {
			const a = {}
			return (
				i.integrity && (a.integrity = i.integrity),
				i.referrerPolicy && (a.referrerPolicy = i.referrerPolicy),
				i.crossOrigin === "use-credentials"
					? (a.credentials = "include")
					: i.crossOrigin === "anonymous"
					? (a.credentials = "omit")
					: (a.credentials = "same-origin"),
				a
			)
		}
		function r(i) {
			if (i.ep) return
			i.ep = !0
			const a = n(i)
			fetch(i.href, a)
		}
	})()
	var L0 =
		typeof globalThis < "u"
			? globalThis
			: typeof window < "u"
			? window
			: typeof global < "u"
			? global
			: typeof self < "u"
			? self
			: {}
	function Ti(e) {
		return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e
	}
	var CC = { exports: {} },
		Vh = {},
		TC = { exports: {} },
		wt = {}
	/**
	 * @license React
	 * react.production.min.js
	 *
	 * Copyright (c) Facebook, Inc. and its affiliates.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */ var FI
	function PQ() {
		if (FI) return wt
		FI = 1
		var e = Symbol.for("react.element"),
			t = Symbol.for("react.portal"),
			n = Symbol.for("react.fragment"),
			r = Symbol.for("react.strict_mode"),
			i = Symbol.for("react.profiler"),
			a = Symbol.for("react.provider"),
			o = Symbol.for("react.context"),
			s = Symbol.for("react.forward_ref"),
			l = Symbol.for("react.suspense"),
			u = Symbol.for("react.memo"),
			d = Symbol.for("react.lazy"),
			p = Symbol.iterator
		function m(Y) {
			return Y === null || typeof Y != "object"
				? null
				: ((Y = (p && Y[p]) || Y["@@iterator"]), typeof Y == "function" ? Y : null)
		}
		var v = {
				isMounted: function () {
					return !1
				},
				enqueueForceUpdate: function () {},
				enqueueReplaceState: function () {},
				enqueueSetState: function () {},
			},
			y = Object.assign,
			b = {}
		function x(Y, ee, $) {
			;(this.props = Y), (this.context = ee), (this.refs = b), (this.updater = $ || v)
		}
		;(x.prototype.isReactComponent = {}),
			(x.prototype.setState = function (Y, ee) {
				if (typeof Y != "object" && typeof Y != "function" && Y != null)
					throw Error(
						"setState(...): takes an object of state variables to update or a function which returns an object of state variables.",
					)
				this.updater.enqueueSetState(this, Y, ee, "setState")
			}),
			(x.prototype.forceUpdate = function (Y) {
				this.updater.enqueueForceUpdate(this, Y, "forceUpdate")
			})
		function E() {}
		E.prototype = x.prototype
		function T(Y, ee, $) {
			;(this.props = Y), (this.context = ee), (this.refs = b), (this.updater = $ || v)
		}
		var C = (T.prototype = new E())
		;(C.constructor = T), y(C, x.prototype), (C.isPureReactComponent = !0)
		var D = Array.isArray,
			O = Object.prototype.hasOwnProperty,
			A = { current: null },
			N = { key: !0, ref: !0, __self: !0, __source: !0 }
		function I(Y, ee, $) {
			var ge,
				Se = {},
				Ee = null,
				be = null
			if (ee != null)
				for (ge in (ee.ref !== void 0 && (be = ee.ref),
				ee.key !== void 0 && (Ee = "" + ee.key),
				ee))
					O.call(ee, ge) && !N.hasOwnProperty(ge) && (Se[ge] = ee[ge])
			var Le = arguments.length - 2
			if (Le === 1) Se.children = $
			else if (1 < Le) {
				for (var Be = Array(Le), et = 0; et < Le; et++) Be[et] = arguments[et + 2]
				Se.children = Be
			}
			if (Y && Y.defaultProps)
				for (ge in ((Le = Y.defaultProps), Le)) Se[ge] === void 0 && (Se[ge] = Le[ge])
			return { $$typeof: e, type: Y, key: Ee, ref: be, props: Se, _owner: A.current }
		}
		function P(Y, ee) {
			return { $$typeof: e, type: Y.type, key: ee, ref: Y.ref, props: Y.props, _owner: Y._owner }
		}
		function L(Y) {
			return typeof Y == "object" && Y !== null && Y.$$typeof === e
		}
		function B(Y) {
			var ee = { "=": "=0", ":": "=2" }
			return (
				"$" +
				Y.replace(/[=:]/g, function ($) {
					return ee[$]
				})
			)
		}
		var z = /\/+/g
		function V(Y, ee) {
			return typeof Y == "object" && Y !== null && Y.key != null ? B("" + Y.key) : ee.toString(36)
		}
		function K(Y, ee, $, ge, Se) {
			var Ee = typeof Y
			;(Ee === "undefined" || Ee === "boolean") && (Y = null)
			var be = !1
			if (Y === null) be = !0
			else
				switch (Ee) {
					case "string":
					case "number":
						be = !0
						break
					case "object":
						switch (Y.$$typeof) {
							case e:
							case t:
								be = !0
						}
				}
			if (be)
				return (
					(be = Y),
					(Se = Se(be)),
					(Y = ge === "" ? "." + V(be, 0) : ge),
					D(Se)
						? (($ = ""),
						  Y != null && ($ = Y.replace(z, "$&/") + "/"),
						  K(Se, ee, $, "", function (et) {
								return et
						  }))
						: Se != null &&
						  (L(Se) &&
								(Se = P(
									Se,
									$ +
										(!Se.key || (be && be.key === Se.key)
											? ""
											: ("" + Se.key).replace(z, "$&/") + "/") +
										Y,
								)),
						  ee.push(Se)),
					1
				)
			if (((be = 0), (ge = ge === "" ? "." : ge + ":"), D(Y)))
				for (var Le = 0; Le < Y.length; Le++) {
					Ee = Y[Le]
					var Be = ge + V(Ee, Le)
					be += K(Ee, ee, $, Be, Se)
				}
			else if (((Be = m(Y)), typeof Be == "function"))
				for (Y = Be.call(Y), Le = 0; !(Ee = Y.next()).done; )
					(Ee = Ee.value), (Be = ge + V(Ee, Le++)), (be += K(Ee, ee, $, Be, Se))
			else if (Ee === "object")
				throw (
					((ee = String(Y)),
					Error(
						"Objects are not valid as a React child (found: " +
							(ee === "[object Object]"
								? "object with keys {" + Object.keys(Y).join(", ") + "}"
								: ee) +
							"). If you meant to render a collection of children, use an array instead.",
					))
				)
			return be
		}
		function ne(Y, ee, $) {
			if (Y == null) return Y
			var ge = [],
				Se = 0
			return (
				K(Y, ge, "", "", function (Ee) {
					return ee.call($, Ee, Se++)
				}),
				ge
			)
		}
		function re(Y) {
			if (Y._status === -1) {
				var ee = Y._result
				;(ee = ee()),
					ee.then(
						function ($) {
							;(Y._status === 0 || Y._status === -1) && ((Y._status = 1), (Y._result = $))
						},
						function ($) {
							;(Y._status === 0 || Y._status === -1) && ((Y._status = 2), (Y._result = $))
						},
					),
					Y._status === -1 && ((Y._status = 0), (Y._result = ee))
			}
			if (Y._status === 1) return Y._result.default
			throw Y._result
		}
		var ie = { current: null },
			J = { transition: null },
			le = { ReactCurrentDispatcher: ie, ReactCurrentBatchConfig: J, ReactCurrentOwner: A }
		function F() {
			throw Error("act(...) is not supported in production builds of React.")
		}
		return (
			(wt.Children = {
				map: ne,
				forEach: function (Y, ee, $) {
					ne(
						Y,
						function () {
							ee.apply(this, arguments)
						},
						$,
					)
				},
				count: function (Y) {
					var ee = 0
					return (
						ne(Y, function () {
							ee++
						}),
						ee
					)
				},
				toArray: function (Y) {
					return (
						ne(Y, function (ee) {
							return ee
						}) || []
					)
				},
				only: function (Y) {
					if (!L(Y))
						throw Error("React.Children.only expected to receive a single React element child.")
					return Y
				},
			}),
			(wt.Component = x),
			(wt.Fragment = n),
			(wt.Profiler = i),
			(wt.PureComponent = T),
			(wt.StrictMode = r),
			(wt.Suspense = l),
			(wt.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = le),
			(wt.act = F),
			(wt.cloneElement = function (Y, ee, $) {
				if (Y == null)
					throw Error(
						"React.cloneElement(...): The argument must be a React element, but you passed " +
							Y +
							".",
					)
				var ge = y({}, Y.props),
					Se = Y.key,
					Ee = Y.ref,
					be = Y._owner
				if (ee != null) {
					if (
						(ee.ref !== void 0 && ((Ee = ee.ref), (be = A.current)),
						ee.key !== void 0 && (Se = "" + ee.key),
						Y.type && Y.type.defaultProps)
					)
						var Le = Y.type.defaultProps
					for (Be in ee)
						O.call(ee, Be) &&
							!N.hasOwnProperty(Be) &&
							(ge[Be] = ee[Be] === void 0 && Le !== void 0 ? Le[Be] : ee[Be])
				}
				var Be = arguments.length - 2
				if (Be === 1) ge.children = $
				else if (1 < Be) {
					Le = Array(Be)
					for (var et = 0; et < Be; et++) Le[et] = arguments[et + 2]
					ge.children = Le
				}
				return { $$typeof: e, type: Y.type, key: Se, ref: Ee, props: ge, _owner: be }
			}),
			(wt.createContext = function (Y) {
				return (
					(Y = {
						$$typeof: o,
						_currentValue: Y,
						_currentValue2: Y,
						_threadCount: 0,
						Provider: null,
						Consumer: null,
						_defaultValue: null,
						_globalName: null,
					}),
					(Y.Provider = { $$typeof: a, _context: Y }),
					(Y.Consumer = Y)
				)
			}),
			(wt.createElement = I),
			(wt.createFactory = function (Y) {
				var ee = I.bind(null, Y)
				return (ee.type = Y), ee
			}),
			(wt.createRef = function () {
				return { current: null }
			}),
			(wt.forwardRef = function (Y) {
				return { $$typeof: s, render: Y }
			}),
			(wt.isValidElement = L),
			(wt.lazy = function (Y) {
				return { $$typeof: d, _payload: { _status: -1, _result: Y }, _init: re }
			}),
			(wt.memo = function (Y, ee) {
				return { $$typeof: u, type: Y, compare: ee === void 0 ? null : ee }
			}),
			(wt.startTransition = function (Y) {
				var ee = J.transition
				J.transition = {}
				try {
					Y()
				} finally {
					J.transition = ee
				}
			}),
			(wt.unstable_act = F),
			(wt.useCallback = function (Y, ee) {
				return ie.current.useCallback(Y, ee)
			}),
			(wt.useContext = function (Y) {
				return ie.current.useContext(Y)
			}),
			(wt.useDebugValue = function () {}),
			(wt.useDeferredValue = function (Y) {
				return ie.current.useDeferredValue(Y)
			}),
			(wt.useEffect = function (Y, ee) {
				return ie.current.useEffect(Y, ee)
			}),
			(wt.useId = function () {
				return ie.current.useId()
			}),
			(wt.useImperativeHandle = function (Y, ee, $) {
				return ie.current.useImperativeHandle(Y, ee, $)
			}),
			(wt.useInsertionEffect = function (Y, ee) {
				return ie.current.useInsertionEffect(Y, ee)
			}),
			(wt.useLayoutEffect = function (Y, ee) {
				return ie.current.useLayoutEffect(Y, ee)
			}),
			(wt.useMemo = function (Y, ee) {
				return ie.current.useMemo(Y, ee)
			}),
			(wt.useReducer = function (Y, ee, $) {
				return ie.current.useReducer(Y, ee, $)
			}),
			(wt.useRef = function (Y) {
				return ie.current.useRef(Y)
			}),
			(wt.useState = function (Y) {
				return ie.current.useState(Y)
			}),
			(wt.useSyncExternalStore = function (Y, ee, $) {
				return ie.current.useSyncExternalStore(Y, ee, $)
			}),
			(wt.useTransition = function () {
				return ie.current.useTransition()
			}),
			(wt.version = "18.3.1"),
			wt
		)
	}
	var BI
	function sx() {
		return BI || ((BI = 1), (TC.exports = PQ())), TC.exports
	}
	/**
	 * @license React
	 * react-jsx-runtime.production.min.js
	 *
	 * Copyright (c) Facebook, Inc. and its affiliates.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */ var HI
	function jQ() {
		if (HI) return Vh
		HI = 1
		var e = sx(),
			t = Symbol.for("react.element"),
			n = Symbol.for("react.fragment"),
			r = Object.prototype.hasOwnProperty,
			i = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,
			a = { key: !0, ref: !0, __self: !0, __source: !0 }
		function o(s, l, u) {
			var d,
				p = {},
				m = null,
				v = null
			u !== void 0 && (m = "" + u),
				l.key !== void 0 && (m = "" + l.key),
				l.ref !== void 0 && (v = l.ref)
			for (d in l) r.call(l, d) && !a.hasOwnProperty(d) && (p[d] = l[d])
			if (s && s.defaultProps) for (d in ((l = s.defaultProps), l)) p[d] === void 0 && (p[d] = l[d])
			return { $$typeof: t, type: s, key: m, ref: v, props: p, _owner: i.current }
		}
		return (Vh.Fragment = n), (Vh.jsx = o), (Vh.jsxs = o), Vh
	}
	var $I
	function FQ() {
		return $I || (($I = 1), (CC.exports = jQ())), CC.exports
	}
	var h = FQ(),
		_ = sx()
	const H = Ti(_),
		CS = LQ({ __proto__: null, default: H }, [_])
	var kC = { exports: {} },
		SC,
		UI
	function BQ() {
		if (UI) return SC
		UI = 1
		var e = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED"
		return (SC = e), SC
	}
	var DC, zI
	function HQ() {
		if (zI) return DC
		zI = 1
		var e = BQ()
		function t() {}
		function n() {}
		return (
			(n.resetWarningCache = t),
			(DC = function () {
				function r(o, s, l, u, d, p) {
					if (p !== e) {
						var m = new Error(
							"Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types",
						)
						throw ((m.name = "Invariant Violation"), m)
					}
				}
				r.isRequired = r
				function i() {
					return r
				}
				var a = {
					array: r,
					bigint: r,
					bool: r,
					func: r,
					number: r,
					object: r,
					string: r,
					symbol: r,
					any: r,
					arrayOf: i,
					element: r,
					elementType: r,
					instanceOf: i,
					node: r,
					objectOf: i,
					oneOf: i,
					oneOfType: i,
					shape: i,
					exact: i,
					checkPropTypes: n,
					resetWarningCache: t,
				}
				return (a.PropTypes = a), a
			}),
			DC
		)
	}
	var qI
	function $Q() {
		return qI || ((qI = 1), (kC.exports = HQ()())), kC.exports
	}
	var ea = $Q()
	const he = Ti(ea)
	function VI(e, t) {
		var n = Object.keys(e)
		if (Object.getOwnPropertySymbols) {
			var r = Object.getOwnPropertySymbols(e)
			t &&
				(r = r.filter(function (i) {
					return Object.getOwnPropertyDescriptor(e, i).enumerable
				})),
				n.push.apply(n, r)
		}
		return n
	}
	function WI(e) {
		for (var t = 1; t < arguments.length; t++) {
			var n = arguments[t] != null ? arguments[t] : {}
			t % 2
				? VI(Object(n), !0).forEach(function (r) {
						l8(e, r, n[r])
				  })
				: Object.getOwnPropertyDescriptors
				? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n))
				: VI(Object(n)).forEach(function (r) {
						Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r))
				  })
		}
		return e
	}
	function jy(e) {
		"@babel/helpers - typeof"
		return (
			typeof Symbol == "function" && typeof Symbol.iterator == "symbol"
				? (jy = function (t) {
						return typeof t
				  })
				: (jy = function (t) {
						return t &&
							typeof Symbol == "function" &&
							t.constructor === Symbol &&
							t !== Symbol.prototype
							? "symbol"
							: typeof t
				  }),
			jy(e)
		)
	}
	function l8(e, t, n) {
		return (
			t in e
				? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 })
				: (e[t] = n),
			e
		)
	}
	function Fy(e, t) {
		return UQ(e) || zQ(e, t) || qQ(e, t) || VQ()
	}
	function UQ(e) {
		if (Array.isArray(e)) return e
	}
	function zQ(e, t) {
		var n = e && ((typeof Symbol < "u" && e[Symbol.iterator]) || e["@@iterator"])
		if (n != null) {
			var r = [],
				i = !0,
				a = !1,
				o,
				s
			try {
				for (
					n = n.call(e);
					!(i = (o = n.next()).done) && (r.push(o.value), !(t && r.length === t));
					i = !0
				);
			} catch (l) {
				;(a = !0), (s = l)
			} finally {
				try {
					!i && n.return != null && n.return()
				} finally {
					if (a) throw s
				}
			}
			return r
		}
	}
	function qQ(e, t) {
		if (e) {
			if (typeof e == "string") return YI(e, t)
			var n = Object.prototype.toString.call(e).slice(8, -1)
			if ((n === "Object" && e.constructor && (n = e.constructor.name), n === "Map" || n === "Set"))
				return Array.from(e)
			if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return YI(e, t)
		}
	}
	function YI(e, t) {
		;(t == null || t > e.length) && (t = e.length)
		for (var n = 0, r = new Array(t); n < t; n++) r[n] = e[n]
		return r
	}
	function VQ() {
		throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
	}
	var TS = function (t) {
			var n = H.useRef(t)
			return (
				H.useEffect(
					function () {
						n.current = t
					},
					[t],
				),
				n.current
			)
		},
		Zf = function (t) {
			return t !== null && jy(t) === "object"
		},
		WQ = function (t) {
			return Zf(t) && typeof t.then == "function"
		},
		YQ = function (t) {
			return (
				Zf(t) &&
				typeof t.elements == "function" &&
				typeof t.createToken == "function" &&
				typeof t.createPaymentMethod == "function" &&
				typeof t.confirmCardPayment == "function"
			)
		},
		GI = "[object Object]",
		GQ = function e(t, n) {
			if (!Zf(t) || !Zf(n)) return t === n
			var r = Array.isArray(t),
				i = Array.isArray(n)
			if (r !== i) return !1
			var a = Object.prototype.toString.call(t) === GI,
				o = Object.prototype.toString.call(n) === GI
			if (a !== o) return !1
			if (!a && !r) return t === n
			var s = Object.keys(t),
				l = Object.keys(n)
			if (s.length !== l.length) return !1
			for (var u = {}, d = 0; d < s.length; d += 1) u[s[d]] = !0
			for (var p = 0; p < l.length; p += 1) u[l[p]] = !0
			var m = Object.keys(u)
			if (m.length !== s.length) return !1
			var v = t,
				y = n,
				b = function (E) {
					return e(v[E], y[E])
				}
			return m.every(b)
		},
		u8 = function (t, n, r) {
			return Zf(t)
				? Object.keys(t).reduce(function (i, a) {
						var o = !Zf(n) || !GQ(t[a], n[a])
						return r.includes(a)
							? (o &&
									console.warn(
										"Unsupported prop change: options.".concat(a, " is not a mutable property."),
									),
							  i)
							: o
							? WI(WI({}, i || {}), {}, l8({}, a, t[a]))
							: i
				  }, null)
				: null
		},
		KQ =
			"Invalid prop `stripe` supplied to `Elements`. We recommend using the `loadStripe` utility from `@stripe/stripe-js`. See https://stripe.com/docs/stripe-js/react#elements-props-stripe for details.",
		KI = function (t) {
			if (t === null || YQ(t)) return t
			throw new Error(KQ)
		},
		QQ = function (t) {
			if (WQ(t)) return { tag: "async", stripePromise: Promise.resolve(t).then(KI) }
			var n = KI(t)
			return n === null ? { tag: "empty" } : { tag: "sync", stripe: n }
		},
		BD = H.createContext(null)
	BD.displayName = "ElementsContext"
	var XQ = function (t, n) {
			if (!t)
				throw new Error(
					"Could not find Elements context; You need to wrap the part of your app that ".concat(
						n,
						" in an <Elements> provider.",
					),
				)
			return t
		},
		HD = H.createContext(null)
	HD.displayName = "CartElementContext"
	var JQ = function (t, n) {
			if (!t)
				throw new Error(
					"Could not find Elements context; You need to wrap the part of your app that ".concat(
						n,
						" in an <Elements> provider.",
					),
				)
			return t
		},
		c8 = function (t) {
			var n = t.stripe,
				r = t.options,
				i = t.children,
				a = H.useMemo(
					function () {
						return QQ(n)
					},
					[n],
				),
				o = H.useState(null),
				s = Fy(o, 2),
				l = s[0],
				u = s[1],
				d = H.useState(null),
				p = Fy(d, 2),
				m = p[0],
				v = p[1],
				y = H.useState(function () {
					return {
						stripe: a.tag === "sync" ? a.stripe : null,
						elements: a.tag === "sync" ? a.stripe.elements(r) : null,
					}
				}),
				b = Fy(y, 2),
				x = b[0],
				E = b[1]
			H.useEffect(
				function () {
					var D = !0,
						O = function (N) {
							E(function (I) {
								return I.stripe ? I : { stripe: N, elements: N.elements(r) }
							})
						}
					return (
						a.tag === "async" && !x.stripe
							? a.stripePromise.then(function (A) {
									A && D && O(A)
							  })
							: a.tag === "sync" && !x.stripe && O(a.stripe),
						function () {
							D = !1
						}
					)
				},
				[a, x, r],
			)
			var T = TS(n)
			H.useEffect(
				function () {
					T !== null &&
						T !== n &&
						console.warn(
							"Unsupported prop change on Elements: You cannot change the `stripe` prop after setting it.",
						)
				},
				[T, n],
			)
			var C = TS(r)
			return (
				H.useEffect(
					function () {
						if (x.elements) {
							var D = u8(r, C, ["clientSecret", "fonts"])
							D && x.elements.update(D)
						}
					},
					[r, C, x.elements],
				),
				H.useEffect(
					function () {
						var D = x.stripe
						!D ||
							!D._registerWrapper ||
							!D.registerAppInfo ||
							(D._registerWrapper({ name: "react-stripe-js", version: "1.16.5" }),
							D.registerAppInfo({
								name: "react-stripe-js",
								version: "1.16.5",
								url: "https://stripe.com/docs/stripe-js/react",
							}))
					},
					[x.stripe],
				),
				H.createElement(
					BD.Provider,
					{ value: x },
					H.createElement(
						HD.Provider,
						{ value: { cart: l, setCart: u, cartState: m, setCartState: v } },
						i,
					),
				)
			)
		}
	c8.propTypes = { stripe: he.any, options: he.object }
	var O1 = function (t) {
			var n = H.useContext(BD)
			return XQ(n, t)
		},
		QI = function (t) {
			var n = H.useContext(HD)
			return JQ(n, t)
		},
		ZQ = function () {
			var t = O1("calls useElements()"),
				n = t.elements
			return n
		},
		d8 = function () {
			var t = O1("calls useStripe()"),
				n = t.stripe
			return n
		}
	he.func.isRequired
	var fi = function (t, n, r) {
			var i = !!r,
				a = H.useRef(r)
			H.useEffect(
				function () {
					a.current = r
				},
				[r],
			),
				H.useEffect(
					function () {
						if (!i || !t) return function () {}
						var o = function () {
							a.current && a.current.apply(a, arguments)
						}
						return (
							t.on(n, o),
							function () {
								t.off(n, o)
							}
						)
					},
					[i, n, t, a],
				)
		},
		eX = function (t) {
			return t.charAt(0).toUpperCase() + t.slice(1)
		},
		ar = function (t, n) {
			var r = "".concat(eX(t), "Element"),
				i = function (l) {
					var u = l.id,
						d = l.className,
						p = l.options,
						m = p === void 0 ? {} : p,
						v = l.onBlur,
						y = l.onFocus,
						b = l.onReady,
						x = l.onChange,
						E = l.onEscape,
						T = l.onClick,
						C = l.onLoadError,
						D = l.onLoaderStart,
						O = l.onNetworksChange,
						A = l.onCheckout,
						N = l.onLineItemClick,
						I = l.onConfirm,
						P = l.onCancel,
						L = l.onShippingAddressChange,
						B = l.onShippingRateChange,
						z = O1("mounts <".concat(r, ">")),
						V = z.elements,
						K = H.useState(null),
						ne = Fy(K, 2),
						re = ne[0],
						ie = ne[1],
						J = H.useRef(null),
						le = H.useRef(null),
						F = QI("mounts <".concat(r, ">")),
						Y = F.setCart,
						ee = F.setCartState
					fi(re, "blur", v),
						fi(re, "focus", y),
						fi(re, "escape", E),
						fi(re, "click", T),
						fi(re, "loaderror", C),
						fi(re, "loaderstart", D),
						fi(re, "networkschange", O),
						fi(re, "lineitemclick", N),
						fi(re, "confirm", I),
						fi(re, "cancel", P),
						fi(re, "shippingaddresschange", L),
						fi(re, "shippingratechange", B)
					var $
					t === "cart"
						? ($ = function (Le) {
								ee(Le), b && b(Le)
						  })
						: b &&
						  (t === "payButton"
								? ($ = b)
								: ($ = function () {
										b(re)
								  })),
						fi(re, "ready", $)
					var ge =
						t === "cart"
							? function (be) {
									ee(be), x && x(be)
							  }
							: x
					fi(re, "change", ge)
					var Se =
						t === "cart"
							? function (be) {
									ee(be), A && A(be)
							  }
							: A
					fi(re, "checkout", Se),
						H.useLayoutEffect(
							function () {
								if (J.current === null && V && le.current !== null) {
									var be = V.create(t, m)
									t === "cart" && Y && Y(be), (J.current = be), ie(be), be.mount(le.current)
								}
							},
							[V, m, Y],
						)
					var Ee = TS(m)
					return (
						H.useEffect(
							function () {
								if (J.current) {
									var be = u8(m, Ee, ["paymentRequest"])
									be && J.current.update(be)
								}
							},
							[m, Ee],
						),
						H.useLayoutEffect(function () {
							return function () {
								J.current && (J.current.destroy(), (J.current = null))
							}
						}, []),
						H.createElement("div", { id: u, className: d, ref: le })
					)
				},
				a = function (l) {
					O1("mounts <".concat(r, ">")), QI("mounts <".concat(r, ">"))
					var u = l.id,
						d = l.className
					return H.createElement("div", { id: u, className: d })
				},
				o = n ? a : i
			return (
				(o.propTypes = {
					id: he.string,
					className: he.string,
					onChange: he.func,
					onBlur: he.func,
					onFocus: he.func,
					onReady: he.func,
					onEscape: he.func,
					onClick: he.func,
					onLoadError: he.func,
					onLoaderStart: he.func,
					onNetworksChange: he.func,
					onCheckout: he.func,
					onLineItemClick: he.func,
					onConfirm: he.func,
					onCancel: he.func,
					onShippingAddressChange: he.func,
					onShippingRateChange: he.func,
					options: he.object,
				}),
				(o.displayName = r),
				(o.__elementType = t),
				o
			)
		},
		or = typeof window > "u"
	ar("auBankAccount", or)
	var XI = ar("card", or)
	ar("cardNumber", or)
	ar("cardExpiry", or)
	ar("cardCvc", or)
	ar("fpxBank", or)
	ar("iban", or)
	ar("idealBank", or)
	ar("p24Bank", or)
	ar("epsBank", or)
	ar("payment", or)
	ar("payButton", or)
	ar("paymentRequestButton", or)
	ar("linkAuthentication", or)
	ar("address", or)
	ar("shippingAddress", or)
	ar("cart", or)
	ar("paymentMethodMessaging", or)
	ar("affirmMessage", or)
	ar("afterpayClearpayMessage", or)
	var f8 = "https://js.stripe.com/v3",
		tX = /^https:\/\/js\.stripe\.com\/v3\/?(\?.*)?$/,
		JI =
			"loadStripe.setLoadParameters was called but an existing Stripe.js script already exists in the document; existing script parameters will be used",
		nX = function () {
			for (
				var t = document.querySelectorAll('script[src^="'.concat(f8, '"]')), n = 0;
				n < t.length;
				n++
			) {
				var r = t[n]
				if (tX.test(r.src)) return r
			}
			return null
		},
		rX = function (t) {
			var n = "",
				r = document.createElement("script")
			r.src = "".concat(f8).concat(n)
			var i = document.head || document.body
			if (!i)
				throw new Error(
					"Expected document.body not to be null. Stripe.js requires a <body> element.",
				)
			return i.appendChild(r), r
		},
		iX = function (t, n) {
			!t ||
				!t._registerWrapper ||
				t._registerWrapper({ name: "stripe-js", version: "1.54.2", startTime: n })
		},
		P0 = null,
		aX = function (t) {
			return (
				P0 !== null ||
					(P0 = new Promise(function (n, r) {
						if (typeof window > "u" || typeof document > "u") {
							n(null)
							return
						}
						if ((window.Stripe && t && console.warn(JI), window.Stripe)) {
							n(window.Stripe)
							return
						}
						try {
							var i = nX()
							i && t ? console.warn(JI) : i || (i = rX(t)),
								i.addEventListener("load", function () {
									window.Stripe ? n(window.Stripe) : r(new Error("Stripe.js not available"))
								}),
								i.addEventListener("error", function () {
									r(new Error("Failed to load Stripe.js"))
								})
						} catch (a) {
							r(a)
							return
						}
					})),
				P0
			)
		},
		oX = function (t, n, r) {
			if (t === null) return null
			var i = t.apply(void 0, n)
			return iX(i, r), i
		},
		p8 = Promise.resolve().then(function () {
			return aX(null)
		}),
		h8 = !1
	p8.catch(function (e) {
		h8 || console.warn(e)
	})
	var sX = function () {
			for (var t = arguments.length, n = new Array(t), r = 0; r < t; r++) n[r] = arguments[r]
			h8 = !0
			var i = Date.now()
			return p8.then(function (a) {
				return oX(a, n, i)
			})
		},
		_C = { exports: {} },
		Ni = {},
		OC = { exports: {} },
		AC = {}
	/**
	 * @license React
	 * scheduler.production.min.js
	 *
	 * Copyright (c) Facebook, Inc. and its affiliates.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */ var ZI
	function lX() {
		return (
			ZI ||
				((ZI = 1),
				(function (e) {
					function t(J, le) {
						var F = J.length
						J.push(le)
						e: for (; 0 < F; ) {
							var Y = (F - 1) >>> 1,
								ee = J[Y]
							if (0 < i(ee, le)) (J[Y] = le), (J[F] = ee), (F = Y)
							else break e
						}
					}
					function n(J) {
						return J.length === 0 ? null : J[0]
					}
					function r(J) {
						if (J.length === 0) return null
						var le = J[0],
							F = J.pop()
						if (F !== le) {
							J[0] = F
							e: for (var Y = 0, ee = J.length, $ = ee >>> 1; Y < $; ) {
								var ge = 2 * (Y + 1) - 1,
									Se = J[ge],
									Ee = ge + 1,
									be = J[Ee]
								if (0 > i(Se, F))
									Ee < ee && 0 > i(be, Se)
										? ((J[Y] = be), (J[Ee] = F), (Y = Ee))
										: ((J[Y] = Se), (J[ge] = F), (Y = ge))
								else if (Ee < ee && 0 > i(be, F)) (J[Y] = be), (J[Ee] = F), (Y = Ee)
								else break e
							}
						}
						return le
					}
					function i(J, le) {
						var F = J.sortIndex - le.sortIndex
						return F !== 0 ? F : J.id - le.id
					}
					if (typeof performance == "object" && typeof performance.now == "function") {
						var a = performance
						e.unstable_now = function () {
							return a.now()
						}
					} else {
						var o = Date,
							s = o.now()
						e.unstable_now = function () {
							return o.now() - s
						}
					}
					var l = [],
						u = [],
						d = 1,
						p = null,
						m = 3,
						v = !1,
						y = !1,
						b = !1,
						x = typeof setTimeout == "function" ? setTimeout : null,
						E = typeof clearTimeout == "function" ? clearTimeout : null,
						T = typeof setImmediate < "u" ? setImmediate : null
					typeof navigator < "u" &&
						navigator.scheduling !== void 0 &&
						navigator.scheduling.isInputPending !== void 0 &&
						navigator.scheduling.isInputPending.bind(navigator.scheduling)
					function C(J) {
						for (var le = n(u); le !== null; ) {
							if (le.callback === null) r(u)
							else if (le.startTime <= J) r(u), (le.sortIndex = le.expirationTime), t(l, le)
							else break
							le = n(u)
						}
					}
					function D(J) {
						if (((b = !1), C(J), !y))
							if (n(l) !== null) (y = !0), re(O)
							else {
								var le = n(u)
								le !== null && ie(D, le.startTime - J)
							}
					}
					function O(J, le) {
						;(y = !1), b && ((b = !1), E(I), (I = -1)), (v = !0)
						var F = m
						try {
							for (C(le), p = n(l); p !== null && (!(p.expirationTime > le) || (J && !B())); ) {
								var Y = p.callback
								if (typeof Y == "function") {
									;(p.callback = null), (m = p.priorityLevel)
									var ee = Y(p.expirationTime <= le)
									;(le = e.unstable_now()),
										typeof ee == "function" ? (p.callback = ee) : p === n(l) && r(l),
										C(le)
								} else r(l)
								p = n(l)
							}
							if (p !== null) var $ = !0
							else {
								var ge = n(u)
								ge !== null && ie(D, ge.startTime - le), ($ = !1)
							}
							return $
						} finally {
							;(p = null), (m = F), (v = !1)
						}
					}
					var A = !1,
						N = null,
						I = -1,
						P = 5,
						L = -1
					function B() {
						return !(e.unstable_now() - L < P)
					}
					function z() {
						if (N !== null) {
							var J = e.unstable_now()
							L = J
							var le = !0
							try {
								le = N(!0, J)
							} finally {
								le ? V() : ((A = !1), (N = null))
							}
						} else A = !1
					}
					var V
					if (typeof T == "function")
						V = function () {
							T(z)
						}
					else if (typeof MessageChannel < "u") {
						var K = new MessageChannel(),
							ne = K.port2
						;(K.port1.onmessage = z),
							(V = function () {
								ne.postMessage(null)
							})
					} else
						V = function () {
							x(z, 0)
						}
					function re(J) {
						;(N = J), A || ((A = !0), V())
					}
					function ie(J, le) {
						I = x(function () {
							J(e.unstable_now())
						}, le)
					}
					;(e.unstable_IdlePriority = 5),
						(e.unstable_ImmediatePriority = 1),
						(e.unstable_LowPriority = 4),
						(e.unstable_NormalPriority = 3),
						(e.unstable_Profiling = null),
						(e.unstable_UserBlockingPriority = 2),
						(e.unstable_cancelCallback = function (J) {
							J.callback = null
						}),
						(e.unstable_continueExecution = function () {
							y || v || ((y = !0), re(O))
						}),
						(e.unstable_forceFrameRate = function (J) {
							0 > J || 125 < J
								? console.error(
										"forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported",
								  )
								: (P = 0 < J ? Math.floor(1e3 / J) : 5)
						}),
						(e.unstable_getCurrentPriorityLevel = function () {
							return m
						}),
						(e.unstable_getFirstCallbackNode = function () {
							return n(l)
						}),
						(e.unstable_next = function (J) {
							switch (m) {
								case 1:
								case 2:
								case 3:
									var le = 3
									break
								default:
									le = m
							}
							var F = m
							m = le
							try {
								return J()
							} finally {
								m = F
							}
						}),
						(e.unstable_pauseExecution = function () {}),
						(e.unstable_requestPaint = function () {}),
						(e.unstable_runWithPriority = function (J, le) {
							switch (J) {
								case 1:
								case 2:
								case 3:
								case 4:
								case 5:
									break
								default:
									J = 3
							}
							var F = m
							m = J
							try {
								return le()
							} finally {
								m = F
							}
						}),
						(e.unstable_scheduleCallback = function (J, le, F) {
							var Y = e.unstable_now()
							switch (
								(typeof F == "object" && F !== null
									? ((F = F.delay), (F = typeof F == "number" && 0 < F ? Y + F : Y))
									: (F = Y),
								J)
							) {
								case 1:
									var ee = -1
									break
								case 2:
									ee = 250
									break
								case 5:
									ee = 1073741823
									break
								case 4:
									ee = 1e4
									break
								default:
									ee = 5e3
							}
							return (
								(ee = F + ee),
								(J = {
									id: d++,
									callback: le,
									priorityLevel: J,
									startTime: F,
									expirationTime: ee,
									sortIndex: -1,
								}),
								F > Y
									? ((J.sortIndex = F),
									  t(u, J),
									  n(l) === null && J === n(u) && (b ? (E(I), (I = -1)) : (b = !0), ie(D, F - Y)))
									: ((J.sortIndex = ee), t(l, J), y || v || ((y = !0), re(O))),
								J
							)
						}),
						(e.unstable_shouldYield = B),
						(e.unstable_wrapCallback = function (J) {
							var le = m
							return function () {
								var F = m
								m = le
								try {
									return J.apply(this, arguments)
								} finally {
									m = F
								}
							}
						})
				})(AC)),
			AC
		)
	}
	var eR
	function uX() {
		return eR || ((eR = 1), (OC.exports = lX())), OC.exports
	}
	/**
	 * @license React
	 * react-dom.production.min.js
	 *
	 * Copyright (c) Facebook, Inc. and its affiliates.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */ var tR
	function cX() {
		if (tR) return Ni
		tR = 1
		var e = sx(),
			t = uX()
		function n(c) {
			for (
				var f = "https://reactjs.org/docs/error-decoder.html?invariant=" + c, g = 1;
				g < arguments.length;
				g++
			)
				f += "&args[]=" + encodeURIComponent(arguments[g])
			return (
				"Minified React error #" +
				c +
				"; visit " +
				f +
				" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
			)
		}
		var r = new Set(),
			i = {}
		function a(c, f) {
			o(c, f), o(c + "Capture", f)
		}
		function o(c, f) {
			for (i[c] = f, c = 0; c < f.length; c++) r.add(f[c])
		}
		var s = !(
				typeof window > "u" ||
				typeof window.document > "u" ||
				typeof window.document.createElement > "u"
			),
			l = Object.prototype.hasOwnProperty,
			u =
				/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,
			d = {},
			p = {}
		function m(c) {
			return l.call(p, c) ? !0 : l.call(d, c) ? !1 : u.test(c) ? (p[c] = !0) : ((d[c] = !0), !1)
		}
		function v(c, f, g, w) {
			if (g !== null && g.type === 0) return !1
			switch (typeof f) {
				case "function":
				case "symbol":
					return !0
				case "boolean":
					return w
						? !1
						: g !== null
						? !g.acceptsBooleans
						: ((c = c.toLowerCase().slice(0, 5)), c !== "data-" && c !== "aria-")
				default:
					return !1
			}
		}
		function y(c, f, g, w) {
			if (f === null || typeof f > "u" || v(c, f, g, w)) return !0
			if (w) return !1
			if (g !== null)
				switch (g.type) {
					case 3:
						return !f
					case 4:
						return f === !1
					case 5:
						return isNaN(f)
					case 6:
						return isNaN(f) || 1 > f
				}
			return !1
		}
		function b(c, f, g, w, S, M, j) {
			;(this.acceptsBooleans = f === 2 || f === 3 || f === 4),
				(this.attributeName = w),
				(this.attributeNamespace = S),
				(this.mustUseProperty = g),
				(this.propertyName = c),
				(this.type = f),
				(this.sanitizeURL = M),
				(this.removeEmptyString = j)
		}
		var x = {}
		"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style"
			.split(" ")
			.forEach(function (c) {
				x[c] = new b(c, 0, !1, c, null, !1, !1)
			}),
			[
				["acceptCharset", "accept-charset"],
				["className", "class"],
				["htmlFor", "for"],
				["httpEquiv", "http-equiv"],
			].forEach(function (c) {
				var f = c[0]
				x[f] = new b(f, 1, !1, c[1], null, !1, !1)
			}),
			["contentEditable", "draggable", "spellCheck", "value"].forEach(function (c) {
				x[c] = new b(c, 2, !1, c.toLowerCase(), null, !1, !1)
			}),
			["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function (
				c,
			) {
				x[c] = new b(c, 2, !1, c, null, !1, !1)
			}),
			"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope"
				.split(" ")
				.forEach(function (c) {
					x[c] = new b(c, 3, !1, c.toLowerCase(), null, !1, !1)
				}),
			["checked", "multiple", "muted", "selected"].forEach(function (c) {
				x[c] = new b(c, 3, !0, c, null, !1, !1)
			}),
			["capture", "download"].forEach(function (c) {
				x[c] = new b(c, 4, !1, c, null, !1, !1)
			}),
			["cols", "rows", "size", "span"].forEach(function (c) {
				x[c] = new b(c, 6, !1, c, null, !1, !1)
			}),
			["rowSpan", "start"].forEach(function (c) {
				x[c] = new b(c, 5, !1, c.toLowerCase(), null, !1, !1)
			})
		var E = /[\-:]([a-z])/g
		function T(c) {
			return c[1].toUpperCase()
		}
		"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height"
			.split(" ")
			.forEach(function (c) {
				var f = c.replace(E, T)
				x[f] = new b(f, 1, !1, c, null, !1, !1)
			}),
			"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type"
				.split(" ")
				.forEach(function (c) {
					var f = c.replace(E, T)
					x[f] = new b(f, 1, !1, c, "http://www.w3.org/1999/xlink", !1, !1)
				}),
			["xml:base", "xml:lang", "xml:space"].forEach(function (c) {
				var f = c.replace(E, T)
				x[f] = new b(f, 1, !1, c, "http://www.w3.org/XML/1998/namespace", !1, !1)
			}),
			["tabIndex", "crossOrigin"].forEach(function (c) {
				x[c] = new b(c, 1, !1, c.toLowerCase(), null, !1, !1)
			}),
			(x.xlinkHref = new b(
				"xlinkHref",
				1,
				!1,
				"xlink:href",
				"http://www.w3.org/1999/xlink",
				!0,
				!1,
			)),
			["src", "href", "action", "formAction"].forEach(function (c) {
				x[c] = new b(c, 1, !1, c.toLowerCase(), null, !0, !0)
			})
		function C(c, f, g, w) {
			var S = x.hasOwnProperty(f) ? x[f] : null
			;(S !== null
				? S.type !== 0
				: w ||
				  !(2 < f.length) ||
				  (f[0] !== "o" && f[0] !== "O") ||
				  (f[1] !== "n" && f[1] !== "N")) &&
				(y(f, g, S, w) && (g = null),
				w || S === null
					? m(f) && (g === null ? c.removeAttribute(f) : c.setAttribute(f, "" + g))
					: S.mustUseProperty
					? (c[S.propertyName] = g === null ? (S.type === 3 ? !1 : "") : g)
					: ((f = S.attributeName),
					  (w = S.attributeNamespace),
					  g === null
							? c.removeAttribute(f)
							: ((S = S.type),
							  (g = S === 3 || (S === 4 && g === !0) ? "" : "" + g),
							  w ? c.setAttributeNS(w, f, g) : c.setAttribute(f, g))))
		}
		var D = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,
			O = Symbol.for("react.element"),
			A = Symbol.for("react.portal"),
			N = Symbol.for("react.fragment"),
			I = Symbol.for("react.strict_mode"),
			P = Symbol.for("react.profiler"),
			L = Symbol.for("react.provider"),
			B = Symbol.for("react.context"),
			z = Symbol.for("react.forward_ref"),
			V = Symbol.for("react.suspense"),
			K = Symbol.for("react.suspense_list"),
			ne = Symbol.for("react.memo"),
			re = Symbol.for("react.lazy"),
			ie = Symbol.for("react.offscreen"),
			J = Symbol.iterator
		function le(c) {
			return c === null || typeof c != "object"
				? null
				: ((c = (J && c[J]) || c["@@iterator"]), typeof c == "function" ? c : null)
		}
		var F = Object.assign,
			Y
		function ee(c) {
			if (Y === void 0)
				try {
					throw Error()
				} catch (g) {
					var f = g.stack.trim().match(/\n( *(at )?)/)
					Y = (f && f[1]) || ""
				}
			return (
				`
` +
				Y +
				c
			)
		}
		var $ = !1
		function ge(c, f) {
			if (!c || $) return ""
			$ = !0
			var g = Error.prepareStackTrace
			Error.prepareStackTrace = void 0
			try {
				if (f)
					if (
						((f = function () {
							throw Error()
						}),
						Object.defineProperty(f.prototype, "props", {
							set: function () {
								throw Error()
							},
						}),
						typeof Reflect == "object" && Reflect.construct)
					) {
						try {
							Reflect.construct(f, [])
						} catch (fe) {
							var w = fe
						}
						Reflect.construct(c, [], f)
					} else {
						try {
							f.call()
						} catch (fe) {
							w = fe
						}
						c.call(f.prototype)
					}
				else {
					try {
						throw Error()
					} catch (fe) {
						w = fe
					}
					c()
				}
			} catch (fe) {
				if (fe && w && typeof fe.stack == "string") {
					for (
						var S = fe.stack.split(`
`),
							M = w.stack.split(`
`),
							j = S.length - 1,
							G = M.length - 1;
						1 <= j && 0 <= G && S[j] !== M[G];

					)
						G--
					for (; 1 <= j && 0 <= G; j--, G--)
						if (S[j] !== M[G]) {
							if (j !== 1 || G !== 1)
								do
									if ((j--, G--, 0 > G || S[j] !== M[G])) {
										var Z =
											`
` + S[j].replace(" at new ", " at ")
										return (
											c.displayName &&
												Z.includes("<anonymous>") &&
												(Z = Z.replace("<anonymous>", c.displayName)),
											Z
										)
									}
								while (1 <= j && 0 <= G)
							break
						}
				}
			} finally {
				;($ = !1), (Error.prepareStackTrace = g)
			}
			return (c = c ? c.displayName || c.name : "") ? ee(c) : ""
		}
		function Se(c) {
			switch (c.tag) {
				case 5:
					return ee(c.type)
				case 16:
					return ee("Lazy")
				case 13:
					return ee("Suspense")
				case 19:
					return ee("SuspenseList")
				case 0:
				case 2:
				case 15:
					return (c = ge(c.type, !1)), c
				case 11:
					return (c = ge(c.type.render, !1)), c
				case 1:
					return (c = ge(c.type, !0)), c
				default:
					return ""
			}
		}
		function Ee(c) {
			if (c == null) return null
			if (typeof c == "function") return c.displayName || c.name || null
			if (typeof c == "string") return c
			switch (c) {
				case N:
					return "Fragment"
				case A:
					return "Portal"
				case P:
					return "Profiler"
				case I:
					return "StrictMode"
				case V:
					return "Suspense"
				case K:
					return "SuspenseList"
			}
			if (typeof c == "object")
				switch (c.$$typeof) {
					case B:
						return (c.displayName || "Context") + ".Consumer"
					case L:
						return (c._context.displayName || "Context") + ".Provider"
					case z:
						var f = c.render
						return (
							(c = c.displayName),
							c ||
								((c = f.displayName || f.name || ""),
								(c = c !== "" ? "ForwardRef(" + c + ")" : "ForwardRef")),
							c
						)
					case ne:
						return (f = c.displayName || null), f !== null ? f : Ee(c.type) || "Memo"
					case re:
						;(f = c._payload), (c = c._init)
						try {
							return Ee(c(f))
						} catch {}
				}
			return null
		}
		function be(c) {
			var f = c.type
			switch (c.tag) {
				case 24:
					return "Cache"
				case 9:
					return (f.displayName || "Context") + ".Consumer"
				case 10:
					return (f._context.displayName || "Context") + ".Provider"
				case 18:
					return "DehydratedFragment"
				case 11:
					return (
						(c = f.render),
						(c = c.displayName || c.name || ""),
						f.displayName || (c !== "" ? "ForwardRef(" + c + ")" : "ForwardRef")
					)
				case 7:
					return "Fragment"
				case 5:
					return f
				case 4:
					return "Portal"
				case 3:
					return "Root"
				case 6:
					return "Text"
				case 16:
					return Ee(f)
				case 8:
					return f === I ? "StrictMode" : "Mode"
				case 22:
					return "Offscreen"
				case 12:
					return "Profiler"
				case 21:
					return "Scope"
				case 13:
					return "Suspense"
				case 19:
					return "SuspenseList"
				case 25:
					return "TracingMarker"
				case 1:
				case 0:
				case 17:
				case 2:
				case 14:
				case 15:
					if (typeof f == "function") return f.displayName || f.name || null
					if (typeof f == "string") return f
			}
			return null
		}
		function Le(c) {
			switch (typeof c) {
				case "boolean":
				case "number":
				case "string":
				case "undefined":
					return c
				case "object":
					return c
				default:
					return ""
			}
		}
		function Be(c) {
			var f = c.type
			return (c = c.nodeName) && c.toLowerCase() === "input" && (f === "checkbox" || f === "radio")
		}
		function et(c) {
			var f = Be(c) ? "checked" : "value",
				g = Object.getOwnPropertyDescriptor(c.constructor.prototype, f),
				w = "" + c[f]
			if (
				!c.hasOwnProperty(f) &&
				typeof g < "u" &&
				typeof g.get == "function" &&
				typeof g.set == "function"
			) {
				var S = g.get,
					M = g.set
				return (
					Object.defineProperty(c, f, {
						configurable: !0,
						get: function () {
							return S.call(this)
						},
						set: function (j) {
							;(w = "" + j), M.call(this, j)
						},
					}),
					Object.defineProperty(c, f, { enumerable: g.enumerable }),
					{
						getValue: function () {
							return w
						},
						setValue: function (j) {
							w = "" + j
						},
						stopTracking: function () {
							;(c._valueTracker = null), delete c[f]
						},
					}
				)
			}
		}
		function pt(c) {
			c._valueTracker || (c._valueTracker = et(c))
		}
		function mt(c) {
			if (!c) return !1
			var f = c._valueTracker
			if (!f) return !0
			var g = f.getValue(),
				w = ""
			return (
				c && (w = Be(c) ? (c.checked ? "true" : "false") : c.value),
				(c = w),
				c !== g ? (f.setValue(c), !0) : !1
			)
		}
		function Xt(c) {
			if (((c = c || (typeof document < "u" ? document : void 0)), typeof c > "u")) return null
			try {
				return c.activeElement || c.body
			} catch {
				return c.body
			}
		}
		function on(c, f) {
			var g = f.checked
			return F({}, f, {
				defaultChecked: void 0,
				defaultValue: void 0,
				value: void 0,
				checked: g ?? c._wrapperState.initialChecked,
			})
		}
		function dt(c, f) {
			var g = f.defaultValue == null ? "" : f.defaultValue,
				w = f.checked != null ? f.checked : f.defaultChecked
			;(g = Le(f.value != null ? f.value : g)),
				(c._wrapperState = {
					initialChecked: w,
					initialValue: g,
					controlled:
						f.type === "checkbox" || f.type === "radio" ? f.checked != null : f.value != null,
				})
		}
		function cn(c, f) {
			;(f = f.checked), f != null && C(c, "checked", f, !1)
		}
		function sn(c, f) {
			cn(c, f)
			var g = Le(f.value),
				w = f.type
			if (g != null)
				w === "number"
					? ((g === 0 && c.value === "") || c.value != g) && (c.value = "" + g)
					: c.value !== "" + g && (c.value = "" + g)
			else if (w === "submit" || w === "reset") {
				c.removeAttribute("value")
				return
			}
			f.hasOwnProperty("value")
				? Hn(c, f.type, g)
				: f.hasOwnProperty("defaultValue") && Hn(c, f.type, Le(f.defaultValue)),
				f.checked == null && f.defaultChecked != null && (c.defaultChecked = !!f.defaultChecked)
		}
		function ur(c, f, g) {
			if (f.hasOwnProperty("value") || f.hasOwnProperty("defaultValue")) {
				var w = f.type
				if (!((w !== "submit" && w !== "reset") || (f.value !== void 0 && f.value !== null))) return
				;(f = "" + c._wrapperState.initialValue),
					g || f === c.value || (c.value = f),
					(c.defaultValue = f)
			}
			;(g = c.name),
				g !== "" && (c.name = ""),
				(c.defaultChecked = !!c._wrapperState.initialChecked),
				g !== "" && (c.name = g)
		}
		function Hn(c, f, g) {
			;(f !== "number" || Xt(c.ownerDocument) !== c) &&
				(g == null
					? (c.defaultValue = "" + c._wrapperState.initialValue)
					: c.defaultValue !== "" + g && (c.defaultValue = "" + g))
		}
		var Jt = Array.isArray
		function mn(c, f, g, w) {
			if (((c = c.options), f)) {
				f = {}
				for (var S = 0; S < g.length; S++) f["$" + g[S]] = !0
				for (g = 0; g < c.length; g++)
					(S = f.hasOwnProperty("$" + c[g].value)),
						c[g].selected !== S && (c[g].selected = S),
						S && w && (c[g].defaultSelected = !0)
			} else {
				for (g = "" + Le(g), f = null, S = 0; S < c.length; S++) {
					if (c[S].value === g) {
						;(c[S].selected = !0), w && (c[S].defaultSelected = !0)
						return
					}
					f !== null || c[S].disabled || (f = c[S])
				}
				f !== null && (f.selected = !0)
			}
		}
		function ue(c, f) {
			if (f.dangerouslySetInnerHTML != null) throw Error(n(91))
			return F({}, f, {
				value: void 0,
				defaultValue: void 0,
				children: "" + c._wrapperState.initialValue,
			})
		}
		function Re(c, f) {
			var g = f.value
			if (g == null) {
				if (((g = f.children), (f = f.defaultValue), g != null)) {
					if (f != null) throw Error(n(92))
					if (Jt(g)) {
						if (1 < g.length) throw Error(n(93))
						g = g[0]
					}
					f = g
				}
				f == null && (f = ""), (g = f)
			}
			c._wrapperState = { initialValue: Le(g) }
		}
		function pe(c, f) {
			var g = Le(f.value),
				w = Le(f.defaultValue)
			g != null &&
				((g = "" + g),
				g !== c.value && (c.value = g),
				f.defaultValue == null && c.defaultValue !== g && (c.defaultValue = g)),
				w != null && (c.defaultValue = "" + w)
		}
		function ye(c) {
			var f = c.textContent
			f === c._wrapperState.initialValue && f !== "" && f !== null && (c.value = f)
		}
		function X(c) {
			switch (c) {
				case "svg":
					return "http://www.w3.org/2000/svg"
				case "math":
					return "http://www.w3.org/1998/Math/MathML"
				default:
					return "http://www.w3.org/1999/xhtml"
			}
		}
		function de(c, f) {
			return c == null || c === "http://www.w3.org/1999/xhtml"
				? X(f)
				: c === "http://www.w3.org/2000/svg" && f === "foreignObject"
				? "http://www.w3.org/1999/xhtml"
				: c
		}
		var Me,
			Ze = (function (c) {
				return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction
					? function (f, g, w, S) {
							MSApp.execUnsafeLocalFunction(function () {
								return c(f, g, w, S)
							})
					  }
					: c
			})(function (c, f) {
				if (c.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML" in c) c.innerHTML = f
				else {
					for (
						Me = Me || document.createElement("div"),
							Me.innerHTML = "<svg>" + f.valueOf().toString() + "</svg>",
							f = Me.firstChild;
						c.firstChild;

					)
						c.removeChild(c.firstChild)
					for (; f.firstChild; ) c.appendChild(f.firstChild)
				}
			})
		function ct(c, f) {
			if (f) {
				var g = c.firstChild
				if (g && g === c.lastChild && g.nodeType === 3) {
					g.nodeValue = f
					return
				}
			}
			c.textContent = f
		}
		var Ot = {
				animationIterationCount: !0,
				aspectRatio: !0,
				borderImageOutset: !0,
				borderImageSlice: !0,
				borderImageWidth: !0,
				boxFlex: !0,
				boxFlexGroup: !0,
				boxOrdinalGroup: !0,
				columnCount: !0,
				columns: !0,
				flex: !0,
				flexGrow: !0,
				flexPositive: !0,
				flexShrink: !0,
				flexNegative: !0,
				flexOrder: !0,
				gridArea: !0,
				gridRow: !0,
				gridRowEnd: !0,
				gridRowSpan: !0,
				gridRowStart: !0,
				gridColumn: !0,
				gridColumnEnd: !0,
				gridColumnSpan: !0,
				gridColumnStart: !0,
				fontWeight: !0,
				lineClamp: !0,
				lineHeight: !0,
				opacity: !0,
				order: !0,
				orphans: !0,
				tabSize: !0,
				widows: !0,
				zIndex: !0,
				zoom: !0,
				fillOpacity: !0,
				floodOpacity: !0,
				stopOpacity: !0,
				strokeDasharray: !0,
				strokeDashoffset: !0,
				strokeMiterlimit: !0,
				strokeOpacity: !0,
				strokeWidth: !0,
			},
			tr = ["Webkit", "ms", "Moz", "O"]
		Object.keys(Ot).forEach(function (c) {
			tr.forEach(function (f) {
				;(f = f + c.charAt(0).toUpperCase() + c.substring(1)), (Ot[f] = Ot[c])
			})
		})
		function Wn(c, f, g) {
			return f == null || typeof f == "boolean" || f === ""
				? ""
				: g || typeof f != "number" || f === 0 || (Ot.hasOwnProperty(c) && Ot[c])
				? ("" + f).trim()
				: f + "px"
		}
		function An(c, f) {
			c = c.style
			for (var g in f)
				if (f.hasOwnProperty(g)) {
					var w = g.indexOf("--") === 0,
						S = Wn(g, f[g], w)
					g === "float" && (g = "cssFloat"), w ? c.setProperty(g, S) : (c[g] = S)
				}
		}
		var li = F(
			{ menuitem: !0 },
			{
				area: !0,
				base: !0,
				br: !0,
				col: !0,
				embed: !0,
				hr: !0,
				img: !0,
				input: !0,
				keygen: !0,
				link: !0,
				meta: !0,
				param: !0,
				source: !0,
				track: !0,
				wbr: !0,
			},
		)
		function Nn(c, f) {
			if (f) {
				if (li[c] && (f.children != null || f.dangerouslySetInnerHTML != null))
					throw Error(n(137, c))
				if (f.dangerouslySetInnerHTML != null) {
					if (f.children != null) throw Error(n(60))
					if (
						typeof f.dangerouslySetInnerHTML != "object" ||
						!("__html" in f.dangerouslySetInnerHTML)
					)
						throw Error(n(61))
				}
				if (f.style != null && typeof f.style != "object") throw Error(n(62))
			}
		}
		function Yn(c, f) {
			if (c.indexOf("-") === -1) return typeof f.is == "string"
			switch (c) {
				case "annotation-xml":
				case "color-profile":
				case "font-face":
				case "font-face-src":
				case "font-face-uri":
				case "font-face-format":
				case "font-face-name":
				case "missing-glyph":
					return !1
				default:
					return !0
			}
		}
		var Tn = null
		function rc(c) {
			return (
				(c = c.target || c.srcElement || window),
				c.correspondingUseElement && (c = c.correspondingUseElement),
				c.nodeType === 3 ? c.parentNode : c
			)
		}
		var ic = null,
			Ms = null,
			Is = null
		function ac(c) {
			if ((c = Ah(c))) {
				if (typeof ic != "function") throw Error(n(280))
				var f = c.stateNode
				f && ((f = Qg(f)), ic(c.stateNode, c.type, f))
			}
		}
		function Hd(c) {
			Ms ? (Is ? Is.push(c) : (Is = [c])) : (Ms = c)
		}
		function Dg() {
			if (Ms) {
				var c = Ms,
					f = Is
				if (((Is = Ms = null), ac(c), f)) for (c = 0; c < f.length; c++) ac(f[c])
			}
		}
		function ka(c, f) {
			return c(f)
		}
		function uh() {}
		var $d = !1
		function ch(c, f, g) {
			if ($d) return c(f, g)
			$d = !0
			try {
				return ka(c, f, g)
			} finally {
				;($d = !1), (Ms !== null || Is !== null) && (uh(), Dg())
			}
		}
		function oc(c, f) {
			var g = c.stateNode
			if (g === null) return null
			var w = Qg(g)
			if (w === null) return null
			g = w[f]
			e: switch (f) {
				case "onClick":
				case "onClickCapture":
				case "onDoubleClick":
				case "onDoubleClickCapture":
				case "onMouseDown":
				case "onMouseDownCapture":
				case "onMouseMove":
				case "onMouseMoveCapture":
				case "onMouseUp":
				case "onMouseUpCapture":
				case "onMouseEnter":
					;(w = !w.disabled) ||
						((c = c.type),
						(w = !(c === "button" || c === "input" || c === "select" || c === "textarea"))),
						(c = !w)
					break e
				default:
					c = !1
			}
			if (c) return null
			if (g && typeof g != "function") throw Error(n(231, f, typeof g))
			return g
		}
		var Rs = !1
		if (s)
			try {
				var ui = {}
				Object.defineProperty(ui, "passive", {
					get: function () {
						Rs = !0
					},
				}),
					window.addEventListener("test", ui, ui),
					window.removeEventListener("test", ui, ui)
			} catch {
				Rs = !1
			}
		function _g(c, f, g, w, S, M, j, G, Z) {
			var fe = Array.prototype.slice.call(arguments, 3)
			try {
				f.apply(g, fe)
			} catch (Ce) {
				this.onError(Ce)
			}
		}
		var Ll = !1,
			sc = null,
			Ud = !1,
			tt = null,
			oe = {
				onError: function (c) {
					;(Ll = !0), (sc = c)
				},
			}
		function Pe(c, f, g, w, S, M, j, G, Z) {
			;(Ll = !1), (sc = null), _g.apply(oe, arguments)
		}
		function Xe(c, f, g, w, S, M, j, G, Z) {
			if ((Pe.apply(this, arguments), Ll)) {
				if (Ll) {
					var fe = sc
					;(Ll = !1), (sc = null)
				} else throw Error(n(198))
				Ud || ((Ud = !0), (tt = fe))
			}
		}
		function St(c) {
			var f = c,
				g = c
			if (c.alternate) for (; f.return; ) f = f.return
			else {
				c = f
				do (f = c), f.flags & 4098 && (g = f.return), (c = f.return)
				while (c)
			}
			return f.tag === 3 ? g : null
		}
		function cr(c) {
			if (c.tag === 13) {
				var f = c.memoizedState
				if ((f === null && ((c = c.alternate), c !== null && (f = c.memoizedState)), f !== null))
					return f.dehydrated
			}
			return null
		}
		function dr(c) {
			if (St(c) !== c) throw Error(n(188))
		}
		function xr(c) {
			var f = c.alternate
			if (!f) {
				if (((f = St(c)), f === null)) throw Error(n(188))
				return f !== c ? null : c
			}
			for (var g = c, w = f; ; ) {
				var S = g.return
				if (S === null) break
				var M = S.alternate
				if (M === null) {
					if (((w = S.return), w !== null)) {
						g = w
						continue
					}
					break
				}
				if (S.child === M.child) {
					for (M = S.child; M; ) {
						if (M === g) return dr(S), c
						if (M === w) return dr(S), f
						M = M.sibling
					}
					throw Error(n(188))
				}
				if (g.return !== w.return) (g = S), (w = M)
				else {
					for (var j = !1, G = S.child; G; ) {
						if (G === g) {
							;(j = !0), (g = S), (w = M)
							break
						}
						if (G === w) {
							;(j = !0), (w = S), (g = M)
							break
						}
						G = G.sibling
					}
					if (!j) {
						for (G = M.child; G; ) {
							if (G === g) {
								;(j = !0), (g = M), (w = S)
								break
							}
							if (G === w) {
								;(j = !0), (w = M), (g = S)
								break
							}
							G = G.sibling
						}
						if (!j) throw Error(n(189))
					}
				}
				if (g.alternate !== w) throw Error(n(190))
			}
			if (g.tag !== 3) throw Error(n(188))
			return g.stateNode.current === g ? c : f
		}
		function Sa(c) {
			return (c = xr(c)), c !== null ? Pl(c) : null
		}
		function Pl(c) {
			if (c.tag === 5 || c.tag === 6) return c
			for (c = c.child; c !== null; ) {
				var f = Pl(c)
				if (f !== null) return f
				c = c.sibling
			}
			return null
		}
		var dh = t.unstable_scheduleCallback,
			Og = t.unstable_cancelCallback,
			fN = t.unstable_shouldYield,
			qG = t.unstable_requestPaint,
			Gn = t.unstable_now,
			VG = t.unstable_getCurrentPriorityLevel,
			zw = t.unstable_ImmediatePriority,
			pN = t.unstable_UserBlockingPriority,
			Ag = t.unstable_NormalPriority,
			WG = t.unstable_LowPriority,
			hN = t.unstable_IdlePriority,
			Ng = null,
			Lo = null
		function YG(c) {
			if (Lo && typeof Lo.onCommitFiberRoot == "function")
				try {
					Lo.onCommitFiberRoot(Ng, c, void 0, (c.current.flags & 128) === 128)
				} catch {}
		}
		var no = Math.clz32 ? Math.clz32 : QG,
			GG = Math.log,
			KG = Math.LN2
		function QG(c) {
			return (c >>>= 0), c === 0 ? 32 : (31 - ((GG(c) / KG) | 0)) | 0
		}
		var Mg = 64,
			Ig = 4194304
		function fh(c) {
			switch (c & -c) {
				case 1:
					return 1
				case 2:
					return 2
				case 4:
					return 4
				case 8:
					return 8
				case 16:
					return 16
				case 32:
					return 32
				case 64:
				case 128:
				case 256:
				case 512:
				case 1024:
				case 2048:
				case 4096:
				case 8192:
				case 16384:
				case 32768:
				case 65536:
				case 131072:
				case 262144:
				case 524288:
				case 1048576:
				case 2097152:
					return c & 4194240
				case 4194304:
				case 8388608:
				case 16777216:
				case 33554432:
				case 67108864:
					return c & 130023424
				case 134217728:
					return 134217728
				case 268435456:
					return 268435456
				case 536870912:
					return 536870912
				case 1073741824:
					return 1073741824
				default:
					return c
			}
		}
		function Rg(c, f) {
			var g = c.pendingLanes
			if (g === 0) return 0
			var w = 0,
				S = c.suspendedLanes,
				M = c.pingedLanes,
				j = g & 268435455
			if (j !== 0) {
				var G = j & ~S
				G !== 0 ? (w = fh(G)) : ((M &= j), M !== 0 && (w = fh(M)))
			} else (j = g & ~S), j !== 0 ? (w = fh(j)) : M !== 0 && (w = fh(M))
			if (w === 0) return 0
			if (
				f !== 0 &&
				f !== w &&
				!(f & S) &&
				((S = w & -w), (M = f & -f), S >= M || (S === 16 && (M & 4194240) !== 0))
			)
				return f
			if ((w & 4 && (w |= g & 16), (f = c.entangledLanes), f !== 0))
				for (c = c.entanglements, f &= w; 0 < f; )
					(g = 31 - no(f)), (S = 1 << g), (w |= c[g]), (f &= ~S)
			return w
		}
		function XG(c, f) {
			switch (c) {
				case 1:
				case 2:
				case 4:
					return f + 250
				case 8:
				case 16:
				case 32:
				case 64:
				case 128:
				case 256:
				case 512:
				case 1024:
				case 2048:
				case 4096:
				case 8192:
				case 16384:
				case 32768:
				case 65536:
				case 131072:
				case 262144:
				case 524288:
				case 1048576:
				case 2097152:
					return f + 5e3
				case 4194304:
				case 8388608:
				case 16777216:
				case 33554432:
				case 67108864:
					return -1
				case 134217728:
				case 268435456:
				case 536870912:
				case 1073741824:
					return -1
				default:
					return -1
			}
		}
		function JG(c, f) {
			for (
				var g = c.suspendedLanes, w = c.pingedLanes, S = c.expirationTimes, M = c.pendingLanes;
				0 < M;

			) {
				var j = 31 - no(M),
					G = 1 << j,
					Z = S[j]
				Z === -1 ? (!(G & g) || G & w) && (S[j] = XG(G, f)) : Z <= f && (c.expiredLanes |= G),
					(M &= ~G)
			}
		}
		function qw(c) {
			return (c = c.pendingLanes & -1073741825), c !== 0 ? c : c & 1073741824 ? 1073741824 : 0
		}
		function mN() {
			var c = Mg
			return (Mg <<= 1), !(Mg & 4194240) && (Mg = 64), c
		}
		function Vw(c) {
			for (var f = [], g = 0; 31 > g; g++) f.push(c)
			return f
		}
		function ph(c, f, g) {
			;(c.pendingLanes |= f),
				f !== 536870912 && ((c.suspendedLanes = 0), (c.pingedLanes = 0)),
				(c = c.eventTimes),
				(f = 31 - no(f)),
				(c[f] = g)
		}
		function ZG(c, f) {
			var g = c.pendingLanes & ~f
			;(c.pendingLanes = f),
				(c.suspendedLanes = 0),
				(c.pingedLanes = 0),
				(c.expiredLanes &= f),
				(c.mutableReadLanes &= f),
				(c.entangledLanes &= f),
				(f = c.entanglements)
			var w = c.eventTimes
			for (c = c.expirationTimes; 0 < g; ) {
				var S = 31 - no(g),
					M = 1 << S
				;(f[S] = 0), (w[S] = -1), (c[S] = -1), (g &= ~M)
			}
		}
		function Ww(c, f) {
			var g = (c.entangledLanes |= f)
			for (c = c.entanglements; g; ) {
				var w = 31 - no(g),
					S = 1 << w
				;(S & f) | (c[w] & f) && (c[w] |= f), (g &= ~S)
			}
		}
		var Zt = 0
		function vN(c) {
			return (c &= -c), 1 < c ? (4 < c ? (c & 268435455 ? 16 : 536870912) : 4) : 1
		}
		var gN,
			Yw,
			yN,
			bN,
			xN,
			Gw = !1,
			Lg = [],
			jl = null,
			Fl = null,
			Bl = null,
			hh = new Map(),
			mh = new Map(),
			Hl = [],
			eK =
				"mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(
					" ",
				)
		function wN(c, f) {
			switch (c) {
				case "focusin":
				case "focusout":
					jl = null
					break
				case "dragenter":
				case "dragleave":
					Fl = null
					break
				case "mouseover":
				case "mouseout":
					Bl = null
					break
				case "pointerover":
				case "pointerout":
					hh.delete(f.pointerId)
					break
				case "gotpointercapture":
				case "lostpointercapture":
					mh.delete(f.pointerId)
			}
		}
		function vh(c, f, g, w, S, M) {
			return c === null || c.nativeEvent !== M
				? ((c = {
						blockedOn: f,
						domEventName: g,
						eventSystemFlags: w,
						nativeEvent: M,
						targetContainers: [S],
				  }),
				  f !== null && ((f = Ah(f)), f !== null && Yw(f)),
				  c)
				: ((c.eventSystemFlags |= w),
				  (f = c.targetContainers),
				  S !== null && f.indexOf(S) === -1 && f.push(S),
				  c)
		}
		function tK(c, f, g, w, S) {
			switch (f) {
				case "focusin":
					return (jl = vh(jl, c, f, g, w, S)), !0
				case "dragenter":
					return (Fl = vh(Fl, c, f, g, w, S)), !0
				case "mouseover":
					return (Bl = vh(Bl, c, f, g, w, S)), !0
				case "pointerover":
					var M = S.pointerId
					return hh.set(M, vh(hh.get(M) || null, c, f, g, w, S)), !0
				case "gotpointercapture":
					return (M = S.pointerId), mh.set(M, vh(mh.get(M) || null, c, f, g, w, S)), !0
			}
			return !1
		}
		function EN(c) {
			var f = lc(c.target)
			if (f !== null) {
				var g = St(f)
				if (g !== null) {
					if (((f = g.tag), f === 13)) {
						if (((f = cr(g)), f !== null)) {
							;(c.blockedOn = f),
								xN(c.priority, function () {
									yN(g)
								})
							return
						}
					} else if (f === 3 && g.stateNode.current.memoizedState.isDehydrated) {
						c.blockedOn = g.tag === 3 ? g.stateNode.containerInfo : null
						return
					}
				}
			}
			c.blockedOn = null
		}
		function Pg(c) {
			if (c.blockedOn !== null) return !1
			for (var f = c.targetContainers; 0 < f.length; ) {
				var g = Qw(c.domEventName, c.eventSystemFlags, f[0], c.nativeEvent)
				if (g === null) {
					g = c.nativeEvent
					var w = new g.constructor(g.type, g)
					;(Tn = w), g.target.dispatchEvent(w), (Tn = null)
				} else return (f = Ah(g)), f !== null && Yw(f), (c.blockedOn = g), !1
				f.shift()
			}
			return !0
		}
		function CN(c, f, g) {
			Pg(c) && g.delete(f)
		}
		function nK() {
			;(Gw = !1),
				jl !== null && Pg(jl) && (jl = null),
				Fl !== null && Pg(Fl) && (Fl = null),
				Bl !== null && Pg(Bl) && (Bl = null),
				hh.forEach(CN),
				mh.forEach(CN)
		}
		function gh(c, f) {
			c.blockedOn === f &&
				((c.blockedOn = null),
				Gw || ((Gw = !0), t.unstable_scheduleCallback(t.unstable_NormalPriority, nK)))
		}
		function yh(c) {
			function f(S) {
				return gh(S, c)
			}
			if (0 < Lg.length) {
				gh(Lg[0], c)
				for (var g = 1; g < Lg.length; g++) {
					var w = Lg[g]
					w.blockedOn === c && (w.blockedOn = null)
				}
			}
			for (
				jl !== null && gh(jl, c),
					Fl !== null && gh(Fl, c),
					Bl !== null && gh(Bl, c),
					hh.forEach(f),
					mh.forEach(f),
					g = 0;
				g < Hl.length;
				g++
			)
				(w = Hl[g]), w.blockedOn === c && (w.blockedOn = null)
			for (; 0 < Hl.length && ((g = Hl[0]), g.blockedOn === null); )
				EN(g), g.blockedOn === null && Hl.shift()
		}
		var zd = D.ReactCurrentBatchConfig,
			jg = !0
		function rK(c, f, g, w) {
			var S = Zt,
				M = zd.transition
			zd.transition = null
			try {
				;(Zt = 1), Kw(c, f, g, w)
			} finally {
				;(Zt = S), (zd.transition = M)
			}
		}
		function iK(c, f, g, w) {
			var S = Zt,
				M = zd.transition
			zd.transition = null
			try {
				;(Zt = 4), Kw(c, f, g, w)
			} finally {
				;(Zt = S), (zd.transition = M)
			}
		}
		function Kw(c, f, g, w) {
			if (jg) {
				var S = Qw(c, f, g, w)
				if (S === null) pE(c, f, w, Fg, g), wN(c, w)
				else if (tK(S, c, f, g, w)) w.stopPropagation()
				else if ((wN(c, w), f & 4 && -1 < eK.indexOf(c))) {
					for (; S !== null; ) {
						var M = Ah(S)
						if (
							(M !== null && gN(M), (M = Qw(c, f, g, w)), M === null && pE(c, f, w, Fg, g), M === S)
						)
							break
						S = M
					}
					S !== null && w.stopPropagation()
				} else pE(c, f, w, null, g)
			}
		}
		var Fg = null
		function Qw(c, f, g, w) {
			if (((Fg = null), (c = rc(w)), (c = lc(c)), c !== null))
				if (((f = St(c)), f === null)) c = null
				else if (((g = f.tag), g === 13)) {
					if (((c = cr(f)), c !== null)) return c
					c = null
				} else if (g === 3) {
					if (f.stateNode.current.memoizedState.isDehydrated)
						return f.tag === 3 ? f.stateNode.containerInfo : null
					c = null
				} else f !== c && (c = null)
			return (Fg = c), null
		}
		function TN(c) {
			switch (c) {
				case "cancel":
				case "click":
				case "close":
				case "contextmenu":
				case "copy":
				case "cut":
				case "auxclick":
				case "dblclick":
				case "dragend":
				case "dragstart":
				case "drop":
				case "focusin":
				case "focusout":
				case "input":
				case "invalid":
				case "keydown":
				case "keypress":
				case "keyup":
				case "mousedown":
				case "mouseup":
				case "paste":
				case "pause":
				case "play":
				case "pointercancel":
				case "pointerdown":
				case "pointerup":
				case "ratechange":
				case "reset":
				case "resize":
				case "seeked":
				case "submit":
				case "touchcancel":
				case "touchend":
				case "touchstart":
				case "volumechange":
				case "change":
				case "selectionchange":
				case "textInput":
				case "compositionstart":
				case "compositionend":
				case "compositionupdate":
				case "beforeblur":
				case "afterblur":
				case "beforeinput":
				case "blur":
				case "fullscreenchange":
				case "focus":
				case "hashchange":
				case "popstate":
				case "select":
				case "selectstart":
					return 1
				case "drag":
				case "dragenter":
				case "dragexit":
				case "dragleave":
				case "dragover":
				case "mousemove":
				case "mouseout":
				case "mouseover":
				case "pointermove":
				case "pointerout":
				case "pointerover":
				case "scroll":
				case "toggle":
				case "touchmove":
				case "wheel":
				case "mouseenter":
				case "mouseleave":
				case "pointerenter":
				case "pointerleave":
					return 4
				case "message":
					switch (VG()) {
						case zw:
							return 1
						case pN:
							return 4
						case Ag:
						case WG:
							return 16
						case hN:
							return 536870912
						default:
							return 16
					}
				default:
					return 16
			}
		}
		var $l = null,
			Xw = null,
			Bg = null
		function kN() {
			if (Bg) return Bg
			var c,
				f = Xw,
				g = f.length,
				w,
				S = "value" in $l ? $l.value : $l.textContent,
				M = S.length
			for (c = 0; c < g && f[c] === S[c]; c++);
			var j = g - c
			for (w = 1; w <= j && f[g - w] === S[M - w]; w++);
			return (Bg = S.slice(c, 1 < w ? 1 - w : void 0))
		}
		function Hg(c) {
			var f = c.keyCode
			return (
				"charCode" in c ? ((c = c.charCode), c === 0 && f === 13 && (c = 13)) : (c = f),
				c === 10 && (c = 13),
				32 <= c || c === 13 ? c : 0
			)
		}
		function $g() {
			return !0
		}
		function SN() {
			return !1
		}
		function Qi(c) {
			function f(g, w, S, M, j) {
				;(this._reactName = g),
					(this._targetInst = S),
					(this.type = w),
					(this.nativeEvent = M),
					(this.target = j),
					(this.currentTarget = null)
				for (var G in c) c.hasOwnProperty(G) && ((g = c[G]), (this[G] = g ? g(M) : M[G]))
				return (
					(this.isDefaultPrevented = (
						M.defaultPrevented != null ? M.defaultPrevented : M.returnValue === !1
					)
						? $g
						: SN),
					(this.isPropagationStopped = SN),
					this
				)
			}
			return (
				F(f.prototype, {
					preventDefault: function () {
						this.defaultPrevented = !0
						var g = this.nativeEvent
						g &&
							(g.preventDefault
								? g.preventDefault()
								: typeof g.returnValue != "unknown" && (g.returnValue = !1),
							(this.isDefaultPrevented = $g))
					},
					stopPropagation: function () {
						var g = this.nativeEvent
						g &&
							(g.stopPropagation
								? g.stopPropagation()
								: typeof g.cancelBubble != "unknown" && (g.cancelBubble = !0),
							(this.isPropagationStopped = $g))
					},
					persist: function () {},
					isPersistent: $g,
				}),
				f
			)
		}
		var qd = {
				eventPhase: 0,
				bubbles: 0,
				cancelable: 0,
				timeStamp: function (c) {
					return c.timeStamp || Date.now()
				},
				defaultPrevented: 0,
				isTrusted: 0,
			},
			Jw = Qi(qd),
			bh = F({}, qd, { view: 0, detail: 0 }),
			aK = Qi(bh),
			Zw,
			eE,
			xh,
			Ug = F({}, bh, {
				screenX: 0,
				screenY: 0,
				clientX: 0,
				clientY: 0,
				pageX: 0,
				pageY: 0,
				ctrlKey: 0,
				shiftKey: 0,
				altKey: 0,
				metaKey: 0,
				getModifierState: nE,
				button: 0,
				buttons: 0,
				relatedTarget: function (c) {
					return c.relatedTarget === void 0
						? c.fromElement === c.srcElement
							? c.toElement
							: c.fromElement
						: c.relatedTarget
				},
				movementX: function (c) {
					return "movementX" in c
						? c.movementX
						: (c !== xh &&
								(xh && c.type === "mousemove"
									? ((Zw = c.screenX - xh.screenX), (eE = c.screenY - xh.screenY))
									: (eE = Zw = 0),
								(xh = c)),
						  Zw)
				},
				movementY: function (c) {
					return "movementY" in c ? c.movementY : eE
				},
			}),
			DN = Qi(Ug),
			oK = F({}, Ug, { dataTransfer: 0 }),
			sK = Qi(oK),
			lK = F({}, bh, { relatedTarget: 0 }),
			tE = Qi(lK),
			uK = F({}, qd, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }),
			cK = Qi(uK),
			dK = F({}, qd, {
				clipboardData: function (c) {
					return "clipboardData" in c ? c.clipboardData : window.clipboardData
				},
			}),
			fK = Qi(dK),
			pK = F({}, qd, { data: 0 }),
			_N = Qi(pK),
			hK = {
				Esc: "Escape",
				Spacebar: " ",
				Left: "ArrowLeft",
				Up: "ArrowUp",
				Right: "ArrowRight",
				Down: "ArrowDown",
				Del: "Delete",
				Win: "OS",
				Menu: "ContextMenu",
				Apps: "ContextMenu",
				Scroll: "ScrollLock",
				MozPrintableKey: "Unidentified",
			},
			mK = {
				8: "Backspace",
				9: "Tab",
				12: "Clear",
				13: "Enter",
				16: "Shift",
				17: "Control",
				18: "Alt",
				19: "Pause",
				20: "CapsLock",
				27: "Escape",
				32: " ",
				33: "PageUp",
				34: "PageDown",
				35: "End",
				36: "Home",
				37: "ArrowLeft",
				38: "ArrowUp",
				39: "ArrowRight",
				40: "ArrowDown",
				45: "Insert",
				46: "Delete",
				112: "F1",
				113: "F2",
				114: "F3",
				115: "F4",
				116: "F5",
				117: "F6",
				118: "F7",
				119: "F8",
				120: "F9",
				121: "F10",
				122: "F11",
				123: "F12",
				144: "NumLock",
				145: "ScrollLock",
				224: "Meta",
			},
			vK = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" }
		function gK(c) {
			var f = this.nativeEvent
			return f.getModifierState ? f.getModifierState(c) : (c = vK[c]) ? !!f[c] : !1
		}
		function nE() {
			return gK
		}
		var yK = F({}, bh, {
				key: function (c) {
					if (c.key) {
						var f = hK[c.key] || c.key
						if (f !== "Unidentified") return f
					}
					return c.type === "keypress"
						? ((c = Hg(c)), c === 13 ? "Enter" : String.fromCharCode(c))
						: c.type === "keydown" || c.type === "keyup"
						? mK[c.keyCode] || "Unidentified"
						: ""
				},
				code: 0,
				location: 0,
				ctrlKey: 0,
				shiftKey: 0,
				altKey: 0,
				metaKey: 0,
				repeat: 0,
				locale: 0,
				getModifierState: nE,
				charCode: function (c) {
					return c.type === "keypress" ? Hg(c) : 0
				},
				keyCode: function (c) {
					return c.type === "keydown" || c.type === "keyup" ? c.keyCode : 0
				},
				which: function (c) {
					return c.type === "keypress"
						? Hg(c)
						: c.type === "keydown" || c.type === "keyup"
						? c.keyCode
						: 0
				},
			}),
			bK = Qi(yK),
			xK = F({}, Ug, {
				pointerId: 0,
				width: 0,
				height: 0,
				pressure: 0,
				tangentialPressure: 0,
				tiltX: 0,
				tiltY: 0,
				twist: 0,
				pointerType: 0,
				isPrimary: 0,
			}),
			ON = Qi(xK),
			wK = F({}, bh, {
				touches: 0,
				targetTouches: 0,
				changedTouches: 0,
				altKey: 0,
				metaKey: 0,
				ctrlKey: 0,
				shiftKey: 0,
				getModifierState: nE,
			}),
			EK = Qi(wK),
			CK = F({}, qd, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }),
			TK = Qi(CK),
			kK = F({}, Ug, {
				deltaX: function (c) {
					return "deltaX" in c ? c.deltaX : "wheelDeltaX" in c ? -c.wheelDeltaX : 0
				},
				deltaY: function (c) {
					return "deltaY" in c
						? c.deltaY
						: "wheelDeltaY" in c
						? -c.wheelDeltaY
						: "wheelDelta" in c
						? -c.wheelDelta
						: 0
				},
				deltaZ: 0,
				deltaMode: 0,
			}),
			SK = Qi(kK),
			DK = [9, 13, 27, 32],
			rE = s && "CompositionEvent" in window,
			wh = null
		s && "documentMode" in document && (wh = document.documentMode)
		var _K = s && "TextEvent" in window && !wh,
			AN = s && (!rE || (wh && 8 < wh && 11 >= wh)),
			NN = " ",
			MN = !1
		function IN(c, f) {
			switch (c) {
				case "keyup":
					return DK.indexOf(f.keyCode) !== -1
				case "keydown":
					return f.keyCode !== 229
				case "keypress":
				case "mousedown":
				case "focusout":
					return !0
				default:
					return !1
			}
		}
		function RN(c) {
			return (c = c.detail), typeof c == "object" && "data" in c ? c.data : null
		}
		var Vd = !1
		function OK(c, f) {
			switch (c) {
				case "compositionend":
					return RN(f)
				case "keypress":
					return f.which !== 32 ? null : ((MN = !0), NN)
				case "textInput":
					return (c = f.data), c === NN && MN ? null : c
				default:
					return null
			}
		}
		function AK(c, f) {
			if (Vd)
				return c === "compositionend" || (!rE && IN(c, f))
					? ((c = kN()), (Bg = Xw = $l = null), (Vd = !1), c)
					: null
			switch (c) {
				case "paste":
					return null
				case "keypress":
					if (!(f.ctrlKey || f.altKey || f.metaKey) || (f.ctrlKey && f.altKey)) {
						if (f.char && 1 < f.char.length) return f.char
						if (f.which) return String.fromCharCode(f.which)
					}
					return null
				case "compositionend":
					return AN && f.locale !== "ko" ? null : f.data
				default:
					return null
			}
		}
		var NK = {
			color: !0,
			date: !0,
			datetime: !0,
			"datetime-local": !0,
			email: !0,
			month: !0,
			number: !0,
			password: !0,
			range: !0,
			search: !0,
			tel: !0,
			text: !0,
			time: !0,
			url: !0,
			week: !0,
		}
		function LN(c) {
			var f = c && c.nodeName && c.nodeName.toLowerCase()
			return f === "input" ? !!NK[c.type] : f === "textarea"
		}
		function PN(c, f, g, w) {
			Hd(w),
				(f = Yg(f, "onChange")),
				0 < f.length &&
					((g = new Jw("onChange", "change", null, g, w)), c.push({ event: g, listeners: f }))
		}
		var Eh = null,
			Ch = null
		function MK(c) {
			eM(c, 0)
		}
		function zg(c) {
			var f = Qd(c)
			if (mt(f)) return c
		}
		function IK(c, f) {
			if (c === "change") return f
		}
		var jN = !1
		if (s) {
			var iE
			if (s) {
				var aE = "oninput" in document
				if (!aE) {
					var FN = document.createElement("div")
					FN.setAttribute("oninput", "return;"), (aE = typeof FN.oninput == "function")
				}
				iE = aE
			} else iE = !1
			jN = iE && (!document.documentMode || 9 < document.documentMode)
		}
		function BN() {
			Eh && (Eh.detachEvent("onpropertychange", HN), (Ch = Eh = null))
		}
		function HN(c) {
			if (c.propertyName === "value" && zg(Ch)) {
				var f = []
				PN(f, Ch, c, rc(c)), ch(MK, f)
			}
		}
		function RK(c, f, g) {
			c === "focusin"
				? (BN(), (Eh = f), (Ch = g), Eh.attachEvent("onpropertychange", HN))
				: c === "focusout" && BN()
		}
		function LK(c) {
			if (c === "selectionchange" || c === "keyup" || c === "keydown") return zg(Ch)
		}
		function PK(c, f) {
			if (c === "click") return zg(f)
		}
		function jK(c, f) {
			if (c === "input" || c === "change") return zg(f)
		}
		function FK(c, f) {
			return (c === f && (c !== 0 || 1 / c === 1 / f)) || (c !== c && f !== f)
		}
		var ro = typeof Object.is == "function" ? Object.is : FK
		function Th(c, f) {
			if (ro(c, f)) return !0
			if (typeof c != "object" || c === null || typeof f != "object" || f === null) return !1
			var g = Object.keys(c),
				w = Object.keys(f)
			if (g.length !== w.length) return !1
			for (w = 0; w < g.length; w++) {
				var S = g[w]
				if (!l.call(f, S) || !ro(c[S], f[S])) return !1
			}
			return !0
		}
		function $N(c) {
			for (; c && c.firstChild; ) c = c.firstChild
			return c
		}
		function UN(c, f) {
			var g = $N(c)
			c = 0
			for (var w; g; ) {
				if (g.nodeType === 3) {
					if (((w = c + g.textContent.length), c <= f && w >= f)) return { node: g, offset: f - c }
					c = w
				}
				e: {
					for (; g; ) {
						if (g.nextSibling) {
							g = g.nextSibling
							break e
						}
						g = g.parentNode
					}
					g = void 0
				}
				g = $N(g)
			}
		}
		function zN(c, f) {
			return c && f
				? c === f
					? !0
					: c && c.nodeType === 3
					? !1
					: f && f.nodeType === 3
					? zN(c, f.parentNode)
					: "contains" in c
					? c.contains(f)
					: c.compareDocumentPosition
					? !!(c.compareDocumentPosition(f) & 16)
					: !1
				: !1
		}
		function qN() {
			for (var c = window, f = Xt(); f instanceof c.HTMLIFrameElement; ) {
				try {
					var g = typeof f.contentWindow.location.href == "string"
				} catch {
					g = !1
				}
				if (g) c = f.contentWindow
				else break
				f = Xt(c.document)
			}
			return f
		}
		function oE(c) {
			var f = c && c.nodeName && c.nodeName.toLowerCase()
			return (
				f &&
				((f === "input" &&
					(c.type === "text" ||
						c.type === "search" ||
						c.type === "tel" ||
						c.type === "url" ||
						c.type === "password")) ||
					f === "textarea" ||
					c.contentEditable === "true")
			)
		}
		function BK(c) {
			var f = qN(),
				g = c.focusedElem,
				w = c.selectionRange
			if (f !== g && g && g.ownerDocument && zN(g.ownerDocument.documentElement, g)) {
				if (w !== null && oE(g)) {
					if (((f = w.start), (c = w.end), c === void 0 && (c = f), "selectionStart" in g))
						(g.selectionStart = f), (g.selectionEnd = Math.min(c, g.value.length))
					else if (
						((c = ((f = g.ownerDocument || document) && f.defaultView) || window), c.getSelection)
					) {
						c = c.getSelection()
						var S = g.textContent.length,
							M = Math.min(w.start, S)
						;(w = w.end === void 0 ? M : Math.min(w.end, S)),
							!c.extend && M > w && ((S = w), (w = M), (M = S)),
							(S = UN(g, M))
						var j = UN(g, w)
						S &&
							j &&
							(c.rangeCount !== 1 ||
								c.anchorNode !== S.node ||
								c.anchorOffset !== S.offset ||
								c.focusNode !== j.node ||
								c.focusOffset !== j.offset) &&
							((f = f.createRange()),
							f.setStart(S.node, S.offset),
							c.removeAllRanges(),
							M > w
								? (c.addRange(f), c.extend(j.node, j.offset))
								: (f.setEnd(j.node, j.offset), c.addRange(f)))
					}
				}
				for (f = [], c = g; (c = c.parentNode); )
					c.nodeType === 1 && f.push({ element: c, left: c.scrollLeft, top: c.scrollTop })
				for (typeof g.focus == "function" && g.focus(), g = 0; g < f.length; g++)
					(c = f[g]), (c.element.scrollLeft = c.left), (c.element.scrollTop = c.top)
			}
		}
		var HK = s && "documentMode" in document && 11 >= document.documentMode,
			Wd = null,
			sE = null,
			kh = null,
			lE = !1
		function VN(c, f, g) {
			var w = g.window === g ? g.document : g.nodeType === 9 ? g : g.ownerDocument
			lE ||
				Wd == null ||
				Wd !== Xt(w) ||
				((w = Wd),
				"selectionStart" in w && oE(w)
					? (w = { start: w.selectionStart, end: w.selectionEnd })
					: ((w = ((w.ownerDocument && w.ownerDocument.defaultView) || window).getSelection()),
					  (w = {
							anchorNode: w.anchorNode,
							anchorOffset: w.anchorOffset,
							focusNode: w.focusNode,
							focusOffset: w.focusOffset,
					  })),
				(kh && Th(kh, w)) ||
					((kh = w),
					(w = Yg(sE, "onSelect")),
					0 < w.length &&
						((f = new Jw("onSelect", "select", null, f, g)),
						c.push({ event: f, listeners: w }),
						(f.target = Wd))))
		}
		function qg(c, f) {
			var g = {}
			return (
				(g[c.toLowerCase()] = f.toLowerCase()),
				(g["Webkit" + c] = "webkit" + f),
				(g["Moz" + c] = "moz" + f),
				g
			)
		}
		var Yd = {
				animationend: qg("Animation", "AnimationEnd"),
				animationiteration: qg("Animation", "AnimationIteration"),
				animationstart: qg("Animation", "AnimationStart"),
				transitionend: qg("Transition", "TransitionEnd"),
			},
			uE = {},
			WN = {}
		s &&
			((WN = document.createElement("div").style),
			"AnimationEvent" in window ||
				(delete Yd.animationend.animation,
				delete Yd.animationiteration.animation,
				delete Yd.animationstart.animation),
			"TransitionEvent" in window || delete Yd.transitionend.transition)
		function Vg(c) {
			if (uE[c]) return uE[c]
			if (!Yd[c]) return c
			var f = Yd[c],
				g
			for (g in f) if (f.hasOwnProperty(g) && g in WN) return (uE[c] = f[g])
			return c
		}
		var YN = Vg("animationend"),
			GN = Vg("animationiteration"),
			KN = Vg("animationstart"),
			QN = Vg("transitionend"),
			XN = new Map(),
			JN =
				"abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(
					" ",
				)
		function Ul(c, f) {
			XN.set(c, f), a(f, [c])
		}
		for (var cE = 0; cE < JN.length; cE++) {
			var dE = JN[cE],
				$K = dE.toLowerCase(),
				UK = dE[0].toUpperCase() + dE.slice(1)
			Ul($K, "on" + UK)
		}
		Ul(YN, "onAnimationEnd"),
			Ul(GN, "onAnimationIteration"),
			Ul(KN, "onAnimationStart"),
			Ul("dblclick", "onDoubleClick"),
			Ul("focusin", "onFocus"),
			Ul("focusout", "onBlur"),
			Ul(QN, "onTransitionEnd"),
			o("onMouseEnter", ["mouseout", "mouseover"]),
			o("onMouseLeave", ["mouseout", "mouseover"]),
			o("onPointerEnter", ["pointerout", "pointerover"]),
			o("onPointerLeave", ["pointerout", "pointerover"]),
			a("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" ")),
			a(
				"onSelect",
				"focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(
					" ",
				),
			),
			a("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]),
			a("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" ")),
			a(
				"onCompositionStart",
				"compositionstart focusout keydown keypress keyup mousedown".split(" "),
			),
			a(
				"onCompositionUpdate",
				"compositionupdate focusout keydown keypress keyup mousedown".split(" "),
			)
		var Sh =
				"abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(
					" ",
				),
			zK = new Set("cancel close invalid load scroll toggle".split(" ").concat(Sh))
		function ZN(c, f, g) {
			var w = c.type || "unknown-event"
			;(c.currentTarget = g), Xe(w, f, void 0, c), (c.currentTarget = null)
		}
		function eM(c, f) {
			f = (f & 4) !== 0
			for (var g = 0; g < c.length; g++) {
				var w = c[g],
					S = w.event
				w = w.listeners
				e: {
					var M = void 0
					if (f)
						for (var j = w.length - 1; 0 <= j; j--) {
							var G = w[j],
								Z = G.instance,
								fe = G.currentTarget
							if (((G = G.listener), Z !== M && S.isPropagationStopped())) break e
							ZN(S, G, fe), (M = Z)
						}
					else
						for (j = 0; j < w.length; j++) {
							if (
								((G = w[j]),
								(Z = G.instance),
								(fe = G.currentTarget),
								(G = G.listener),
								Z !== M && S.isPropagationStopped())
							)
								break e
							ZN(S, G, fe), (M = Z)
						}
				}
			}
			if (Ud) throw ((c = tt), (Ud = !1), (tt = null), c)
		}
		function vn(c, f) {
			var g = f[bE]
			g === void 0 && (g = f[bE] = new Set())
			var w = c + "__bubble"
			g.has(w) || (tM(f, c, 2, !1), g.add(w))
		}
		function fE(c, f, g) {
			var w = 0
			f && (w |= 4), tM(g, c, w, f)
		}
		var Wg = "_reactListening" + Math.random().toString(36).slice(2)
		function Dh(c) {
			if (!c[Wg]) {
				;(c[Wg] = !0),
					r.forEach(function (g) {
						g !== "selectionchange" && (zK.has(g) || fE(g, !1, c), fE(g, !0, c))
					})
				var f = c.nodeType === 9 ? c : c.ownerDocument
				f === null || f[Wg] || ((f[Wg] = !0), fE("selectionchange", !1, f))
			}
		}
		function tM(c, f, g, w) {
			switch (TN(f)) {
				case 1:
					var S = rK
					break
				case 4:
					S = iK
					break
				default:
					S = Kw
			}
			;(g = S.bind(null, f, g, c)),
				(S = void 0),
				!Rs || (f !== "touchstart" && f !== "touchmove" && f !== "wheel") || (S = !0),
				w
					? S !== void 0
						? c.addEventListener(f, g, { capture: !0, passive: S })
						: c.addEventListener(f, g, !0)
					: S !== void 0
					? c.addEventListener(f, g, { passive: S })
					: c.addEventListener(f, g, !1)
		}
		function pE(c, f, g, w, S) {
			var M = w
			if (!(f & 1) && !(f & 2) && w !== null)
				e: for (;;) {
					if (w === null) return
					var j = w.tag
					if (j === 3 || j === 4) {
						var G = w.stateNode.containerInfo
						if (G === S || (G.nodeType === 8 && G.parentNode === S)) break
						if (j === 4)
							for (j = w.return; j !== null; ) {
								var Z = j.tag
								if (
									(Z === 3 || Z === 4) &&
									((Z = j.stateNode.containerInfo),
									Z === S || (Z.nodeType === 8 && Z.parentNode === S))
								)
									return
								j = j.return
							}
						for (; G !== null; ) {
							if (((j = lc(G)), j === null)) return
							if (((Z = j.tag), Z === 5 || Z === 6)) {
								w = M = j
								continue e
							}
							G = G.parentNode
						}
					}
					w = w.return
				}
			ch(function () {
				var fe = M,
					Ce = rc(g),
					De = []
				e: {
					var xe = XN.get(c)
					if (xe !== void 0) {
						var $e = Jw,
							Ye = c
						switch (c) {
							case "keypress":
								if (Hg(g) === 0) break e
							case "keydown":
							case "keyup":
								$e = bK
								break
							case "focusin":
								;(Ye = "focus"), ($e = tE)
								break
							case "focusout":
								;(Ye = "blur"), ($e = tE)
								break
							case "beforeblur":
							case "afterblur":
								$e = tE
								break
							case "click":
								if (g.button === 2) break e
							case "auxclick":
							case "dblclick":
							case "mousedown":
							case "mousemove":
							case "mouseup":
							case "mouseout":
							case "mouseover":
							case "contextmenu":
								$e = DN
								break
							case "drag":
							case "dragend":
							case "dragenter":
							case "dragexit":
							case "dragleave":
							case "dragover":
							case "dragstart":
							case "drop":
								$e = sK
								break
							case "touchcancel":
							case "touchend":
							case "touchmove":
							case "touchstart":
								$e = EK
								break
							case YN:
							case GN:
							case KN:
								$e = cK
								break
							case QN:
								$e = TK
								break
							case "scroll":
								$e = aK
								break
							case "wheel":
								$e = SK
								break
							case "copy":
							case "cut":
							case "paste":
								$e = fK
								break
							case "gotpointercapture":
							case "lostpointercapture":
							case "pointercancel":
							case "pointerdown":
							case "pointermove":
							case "pointerout":
							case "pointerover":
							case "pointerup":
								$e = ON
						}
						var Ke = (f & 4) !== 0,
							Kn = !Ke && c === "scroll",
							ae = Ke ? (xe !== null ? xe + "Capture" : null) : xe
						Ke = []
						for (var te = fe, ce; te !== null; ) {
							ce = te
							var Ie = ce.stateNode
							if (
								(ce.tag === 5 &&
									Ie !== null &&
									((ce = Ie),
									ae !== null && ((Ie = oc(te, ae)), Ie != null && Ke.push(_h(te, Ie, ce)))),
								Kn)
							)
								break
							te = te.return
						}
						0 < Ke.length &&
							((xe = new $e(xe, Ye, null, g, Ce)), De.push({ event: xe, listeners: Ke }))
					}
				}
				if (!(f & 7)) {
					e: {
						if (
							((xe = c === "mouseover" || c === "pointerover"),
							($e = c === "mouseout" || c === "pointerout"),
							xe && g !== Tn && (Ye = g.relatedTarget || g.fromElement) && (lc(Ye) || Ye[Ls]))
						)
							break e
						if (
							($e || xe) &&
							((xe =
								Ce.window === Ce
									? Ce
									: (xe = Ce.ownerDocument)
									? xe.defaultView || xe.parentWindow
									: window),
							$e
								? ((Ye = g.relatedTarget || g.toElement),
								  ($e = fe),
								  (Ye = Ye ? lc(Ye) : null),
								  Ye !== null &&
										((Kn = St(Ye)), Ye !== Kn || (Ye.tag !== 5 && Ye.tag !== 6)) &&
										(Ye = null))
								: (($e = null), (Ye = fe)),
							$e !== Ye)
						) {
							if (
								((Ke = DN),
								(Ie = "onMouseLeave"),
								(ae = "onMouseEnter"),
								(te = "mouse"),
								(c === "pointerout" || c === "pointerover") &&
									((Ke = ON), (Ie = "onPointerLeave"), (ae = "onPointerEnter"), (te = "pointer")),
								(Kn = $e == null ? xe : Qd($e)),
								(ce = Ye == null ? xe : Qd(Ye)),
								(xe = new Ke(Ie, te + "leave", $e, g, Ce)),
								(xe.target = Kn),
								(xe.relatedTarget = ce),
								(Ie = null),
								lc(Ce) === fe &&
									((Ke = new Ke(ae, te + "enter", Ye, g, Ce)),
									(Ke.target = ce),
									(Ke.relatedTarget = Kn),
									(Ie = Ke)),
								(Kn = Ie),
								$e && Ye)
							)
								t: {
									for (Ke = $e, ae = Ye, te = 0, ce = Ke; ce; ce = Gd(ce)) te++
									for (ce = 0, Ie = ae; Ie; Ie = Gd(Ie)) ce++
									for (; 0 < te - ce; ) (Ke = Gd(Ke)), te--
									for (; 0 < ce - te; ) (ae = Gd(ae)), ce--
									for (; te--; ) {
										if (Ke === ae || (ae !== null && Ke === ae.alternate)) break t
										;(Ke = Gd(Ke)), (ae = Gd(ae))
									}
									Ke = null
								}
							else Ke = null
							$e !== null && nM(De, xe, $e, Ke, !1),
								Ye !== null && Kn !== null && nM(De, Kn, Ye, Ke, !0)
						}
					}
					e: {
						if (
							((xe = fe ? Qd(fe) : window),
							($e = xe.nodeName && xe.nodeName.toLowerCase()),
							$e === "select" || ($e === "input" && xe.type === "file"))
						)
							var Je = IK
						else if (LN(xe))
							if (jN) Je = jK
							else {
								Je = LK
								var at = RK
							}
						else
							($e = xe.nodeName) &&
								$e.toLowerCase() === "input" &&
								(xe.type === "checkbox" || xe.type === "radio") &&
								(Je = PK)
						if (Je && (Je = Je(c, fe))) {
							PN(De, Je, g, Ce)
							break e
						}
						at && at(c, xe, fe),
							c === "focusout" &&
								(at = xe._wrapperState) &&
								at.controlled &&
								xe.type === "number" &&
								Hn(xe, "number", xe.value)
					}
					switch (((at = fe ? Qd(fe) : window), c)) {
						case "focusin":
							;(LN(at) || at.contentEditable === "true") && ((Wd = at), (sE = fe), (kh = null))
							break
						case "focusout":
							kh = sE = Wd = null
							break
						case "mousedown":
							lE = !0
							break
						case "contextmenu":
						case "mouseup":
						case "dragend":
							;(lE = !1), VN(De, g, Ce)
							break
						case "selectionchange":
							if (HK) break
						case "keydown":
						case "keyup":
							VN(De, g, Ce)
					}
					var ot
					if (rE)
						e: {
							switch (c) {
								case "compositionstart":
									var ft = "onCompositionStart"
									break e
								case "compositionend":
									ft = "onCompositionEnd"
									break e
								case "compositionupdate":
									ft = "onCompositionUpdate"
									break e
							}
							ft = void 0
						}
					else
						Vd
							? IN(c, g) && (ft = "onCompositionEnd")
							: c === "keydown" && g.keyCode === 229 && (ft = "onCompositionStart")
					ft &&
						(AN &&
							g.locale !== "ko" &&
							(Vd || ft !== "onCompositionStart"
								? ft === "onCompositionEnd" && Vd && (ot = kN())
								: (($l = Ce), (Xw = "value" in $l ? $l.value : $l.textContent), (Vd = !0))),
						(at = Yg(fe, ft)),
						0 < at.length &&
							((ft = new _N(ft, c, null, g, Ce)),
							De.push({ event: ft, listeners: at }),
							ot ? (ft.data = ot) : ((ot = RN(g)), ot !== null && (ft.data = ot)))),
						(ot = _K ? OK(c, g) : AK(c, g)) &&
							((fe = Yg(fe, "onBeforeInput")),
							0 < fe.length &&
								((Ce = new _N("onBeforeInput", "beforeinput", null, g, Ce)),
								De.push({ event: Ce, listeners: fe }),
								(Ce.data = ot)))
				}
				eM(De, f)
			})
		}
		function _h(c, f, g) {
			return { instance: c, listener: f, currentTarget: g }
		}
		function Yg(c, f) {
			for (var g = f + "Capture", w = []; c !== null; ) {
				var S = c,
					M = S.stateNode
				S.tag === 5 &&
					M !== null &&
					((S = M),
					(M = oc(c, g)),
					M != null && w.unshift(_h(c, M, S)),
					(M = oc(c, f)),
					M != null && w.push(_h(c, M, S))),
					(c = c.return)
			}
			return w
		}
		function Gd(c) {
			if (c === null) return null
			do c = c.return
			while (c && c.tag !== 5)
			return c || null
		}
		function nM(c, f, g, w, S) {
			for (var M = f._reactName, j = []; g !== null && g !== w; ) {
				var G = g,
					Z = G.alternate,
					fe = G.stateNode
				if (Z !== null && Z === w) break
				G.tag === 5 &&
					fe !== null &&
					((G = fe),
					S
						? ((Z = oc(g, M)), Z != null && j.unshift(_h(g, Z, G)))
						: S || ((Z = oc(g, M)), Z != null && j.push(_h(g, Z, G)))),
					(g = g.return)
			}
			j.length !== 0 && c.push({ event: f, listeners: j })
		}
		var qK = /\r\n?/g,
			VK = /\u0000|\uFFFD/g
		function rM(c) {
			return (typeof c == "string" ? c : "" + c)
				.replace(
					qK,
					`
`,
				)
				.replace(VK, "")
		}
		function Gg(c, f, g) {
			if (((f = rM(f)), rM(c) !== f && g)) throw Error(n(425))
		}
		function Kg() {}
		var hE = null,
			mE = null
		function vE(c, f) {
			return (
				c === "textarea" ||
				c === "noscript" ||
				typeof f.children == "string" ||
				typeof f.children == "number" ||
				(typeof f.dangerouslySetInnerHTML == "object" &&
					f.dangerouslySetInnerHTML !== null &&
					f.dangerouslySetInnerHTML.__html != null)
			)
		}
		var gE = typeof setTimeout == "function" ? setTimeout : void 0,
			WK = typeof clearTimeout == "function" ? clearTimeout : void 0,
			iM = typeof Promise == "function" ? Promise : void 0,
			YK =
				typeof queueMicrotask == "function"
					? queueMicrotask
					: typeof iM < "u"
					? function (c) {
							return iM.resolve(null).then(c).catch(GK)
					  }
					: gE
		function GK(c) {
			setTimeout(function () {
				throw c
			})
		}
		function yE(c, f) {
			var g = f,
				w = 0
			do {
				var S = g.nextSibling
				if ((c.removeChild(g), S && S.nodeType === 8))
					if (((g = S.data), g === "/$")) {
						if (w === 0) {
							c.removeChild(S), yh(f)
							return
						}
						w--
					} else (g !== "$" && g !== "$?" && g !== "$!") || w++
				g = S
			} while (g)
			yh(f)
		}
		function zl(c) {
			for (; c != null; c = c.nextSibling) {
				var f = c.nodeType
				if (f === 1 || f === 3) break
				if (f === 8) {
					if (((f = c.data), f === "$" || f === "$!" || f === "$?")) break
					if (f === "/$") return null
				}
			}
			return c
		}
		function aM(c) {
			c = c.previousSibling
			for (var f = 0; c; ) {
				if (c.nodeType === 8) {
					var g = c.data
					if (g === "$" || g === "$!" || g === "$?") {
						if (f === 0) return c
						f--
					} else g === "/$" && f++
				}
				c = c.previousSibling
			}
			return null
		}
		var Kd = Math.random().toString(36).slice(2),
			Po = "__reactFiber$" + Kd,
			Oh = "__reactProps$" + Kd,
			Ls = "__reactContainer$" + Kd,
			bE = "__reactEvents$" + Kd,
			KK = "__reactListeners$" + Kd,
			QK = "__reactHandles$" + Kd
		function lc(c) {
			var f = c[Po]
			if (f) return f
			for (var g = c.parentNode; g; ) {
				if ((f = g[Ls] || g[Po])) {
					if (((g = f.alternate), f.child !== null || (g !== null && g.child !== null)))
						for (c = aM(c); c !== null; ) {
							if ((g = c[Po])) return g
							c = aM(c)
						}
					return f
				}
				;(c = g), (g = c.parentNode)
			}
			return null
		}
		function Ah(c) {
			return (
				(c = c[Po] || c[Ls]),
				!c || (c.tag !== 5 && c.tag !== 6 && c.tag !== 13 && c.tag !== 3) ? null : c
			)
		}
		function Qd(c) {
			if (c.tag === 5 || c.tag === 6) return c.stateNode
			throw Error(n(33))
		}
		function Qg(c) {
			return c[Oh] || null
		}
		var xE = [],
			Xd = -1
		function ql(c) {
			return { current: c }
		}
		function gn(c) {
			0 > Xd || ((c.current = xE[Xd]), (xE[Xd] = null), Xd--)
		}
		function dn(c, f) {
			Xd++, (xE[Xd] = c.current), (c.current = f)
		}
		var Vl = {},
			Yr = ql(Vl),
			Si = ql(!1),
			uc = Vl
		function Jd(c, f) {
			var g = c.type.contextTypes
			if (!g) return Vl
			var w = c.stateNode
			if (w && w.__reactInternalMemoizedUnmaskedChildContext === f)
				return w.__reactInternalMemoizedMaskedChildContext
			var S = {},
				M
			for (M in g) S[M] = f[M]
			return (
				w &&
					((c = c.stateNode),
					(c.__reactInternalMemoizedUnmaskedChildContext = f),
					(c.__reactInternalMemoizedMaskedChildContext = S)),
				S
			)
		}
		function Di(c) {
			return (c = c.childContextTypes), c != null
		}
		function Xg() {
			gn(Si), gn(Yr)
		}
		function oM(c, f, g) {
			if (Yr.current !== Vl) throw Error(n(168))
			dn(Yr, f), dn(Si, g)
		}
		function sM(c, f, g) {
			var w = c.stateNode
			if (((f = f.childContextTypes), typeof w.getChildContext != "function")) return g
			w = w.getChildContext()
			for (var S in w) if (!(S in f)) throw Error(n(108, be(c) || "Unknown", S))
			return F({}, g, w)
		}
		function Jg(c) {
			return (
				(c = ((c = c.stateNode) && c.__reactInternalMemoizedMergedChildContext) || Vl),
				(uc = Yr.current),
				dn(Yr, c),
				dn(Si, Si.current),
				!0
			)
		}
		function lM(c, f, g) {
			var w = c.stateNode
			if (!w) throw Error(n(169))
			g
				? ((c = sM(c, f, uc)),
				  (w.__reactInternalMemoizedMergedChildContext = c),
				  gn(Si),
				  gn(Yr),
				  dn(Yr, c))
				: gn(Si),
				dn(Si, g)
		}
		var Ps = null,
			Zg = !1,
			wE = !1
		function uM(c) {
			Ps === null ? (Ps = [c]) : Ps.push(c)
		}
		function XK(c) {
			;(Zg = !0), uM(c)
		}
		function Wl() {
			if (!wE && Ps !== null) {
				wE = !0
				var c = 0,
					f = Zt
				try {
					var g = Ps
					for (Zt = 1; c < g.length; c++) {
						var w = g[c]
						do w = w(!0)
						while (w !== null)
					}
					;(Ps = null), (Zg = !1)
				} catch (S) {
					throw (Ps !== null && (Ps = Ps.slice(c + 1)), dh(zw, Wl), S)
				} finally {
					;(Zt = f), (wE = !1)
				}
			}
			return null
		}
		var Zd = [],
			ef = 0,
			e0 = null,
			t0 = 0,
			Da = [],
			_a = 0,
			cc = null,
			js = 1,
			Fs = ""
		function dc(c, f) {
			;(Zd[ef++] = t0), (Zd[ef++] = e0), (e0 = c), (t0 = f)
		}
		function cM(c, f, g) {
			;(Da[_a++] = js), (Da[_a++] = Fs), (Da[_a++] = cc), (cc = c)
			var w = js
			c = Fs
			var S = 32 - no(w) - 1
			;(w &= ~(1 << S)), (g += 1)
			var M = 32 - no(f) + S
			if (30 < M) {
				var j = S - (S % 5)
				;(M = (w & ((1 << j) - 1)).toString(32)),
					(w >>= j),
					(S -= j),
					(js = (1 << (32 - no(f) + S)) | (g << S) | w),
					(Fs = M + c)
			} else (js = (1 << M) | (g << S) | w), (Fs = c)
		}
		function EE(c) {
			c.return !== null && (dc(c, 1), cM(c, 1, 0))
		}
		function CE(c) {
			for (; c === e0; ) (e0 = Zd[--ef]), (Zd[ef] = null), (t0 = Zd[--ef]), (Zd[ef] = null)
			for (; c === cc; )
				(cc = Da[--_a]),
					(Da[_a] = null),
					(Fs = Da[--_a]),
					(Da[_a] = null),
					(js = Da[--_a]),
					(Da[_a] = null)
		}
		var Xi = null,
			Ji = null,
			kn = !1,
			io = null
		function dM(c, f) {
			var g = Ma(5, null, null, 0)
			;(g.elementType = "DELETED"),
				(g.stateNode = f),
				(g.return = c),
				(f = c.deletions),
				f === null ? ((c.deletions = [g]), (c.flags |= 16)) : f.push(g)
		}
		function fM(c, f) {
			switch (c.tag) {
				case 5:
					var g = c.type
					return (
						(f = f.nodeType !== 1 || g.toLowerCase() !== f.nodeName.toLowerCase() ? null : f),
						f !== null ? ((c.stateNode = f), (Xi = c), (Ji = zl(f.firstChild)), !0) : !1
					)
				case 6:
					return (
						(f = c.pendingProps === "" || f.nodeType !== 3 ? null : f),
						f !== null ? ((c.stateNode = f), (Xi = c), (Ji = null), !0) : !1
					)
				case 13:
					return (
						(f = f.nodeType !== 8 ? null : f),
						f !== null
							? ((g = cc !== null ? { id: js, overflow: Fs } : null),
							  (c.memoizedState = { dehydrated: f, treeContext: g, retryLane: 1073741824 }),
							  (g = Ma(18, null, null, 0)),
							  (g.stateNode = f),
							  (g.return = c),
							  (c.child = g),
							  (Xi = c),
							  (Ji = null),
							  !0)
							: !1
					)
				default:
					return !1
			}
		}
		function TE(c) {
			return (c.mode & 1) !== 0 && (c.flags & 128) === 0
		}
		function kE(c) {
			if (kn) {
				var f = Ji
				if (f) {
					var g = f
					if (!fM(c, f)) {
						if (TE(c)) throw Error(n(418))
						f = zl(g.nextSibling)
						var w = Xi
						f && fM(c, f) ? dM(w, g) : ((c.flags = (c.flags & -4097) | 2), (kn = !1), (Xi = c))
					}
				} else {
					if (TE(c)) throw Error(n(418))
					;(c.flags = (c.flags & -4097) | 2), (kn = !1), (Xi = c)
				}
			}
		}
		function pM(c) {
			for (c = c.return; c !== null && c.tag !== 5 && c.tag !== 3 && c.tag !== 13; ) c = c.return
			Xi = c
		}
		function n0(c) {
			if (c !== Xi) return !1
			if (!kn) return pM(c), (kn = !0), !1
			var f
			if (
				((f = c.tag !== 3) &&
					!(f = c.tag !== 5) &&
					((f = c.type), (f = f !== "head" && f !== "body" && !vE(c.type, c.memoizedProps))),
				f && (f = Ji))
			) {
				if (TE(c)) throw (hM(), Error(n(418)))
				for (; f; ) dM(c, f), (f = zl(f.nextSibling))
			}
			if ((pM(c), c.tag === 13)) {
				if (((c = c.memoizedState), (c = c !== null ? c.dehydrated : null), !c)) throw Error(n(317))
				e: {
					for (c = c.nextSibling, f = 0; c; ) {
						if (c.nodeType === 8) {
							var g = c.data
							if (g === "/$") {
								if (f === 0) {
									Ji = zl(c.nextSibling)
									break e
								}
								f--
							} else (g !== "$" && g !== "$!" && g !== "$?") || f++
						}
						c = c.nextSibling
					}
					Ji = null
				}
			} else Ji = Xi ? zl(c.stateNode.nextSibling) : null
			return !0
		}
		function hM() {
			for (var c = Ji; c; ) c = zl(c.nextSibling)
		}
		function tf() {
			;(Ji = Xi = null), (kn = !1)
		}
		function SE(c) {
			io === null ? (io = [c]) : io.push(c)
		}
		var JK = D.ReactCurrentBatchConfig
		function Nh(c, f, g) {
			if (((c = g.ref), c !== null && typeof c != "function" && typeof c != "object")) {
				if (g._owner) {
					if (((g = g._owner), g)) {
						if (g.tag !== 1) throw Error(n(309))
						var w = g.stateNode
					}
					if (!w) throw Error(n(147, c))
					var S = w,
						M = "" + c
					return f !== null &&
						f.ref !== null &&
						typeof f.ref == "function" &&
						f.ref._stringRef === M
						? f.ref
						: ((f = function (j) {
								var G = S.refs
								j === null ? delete G[M] : (G[M] = j)
						  }),
						  (f._stringRef = M),
						  f)
				}
				if (typeof c != "string") throw Error(n(284))
				if (!g._owner) throw Error(n(290, c))
			}
			return c
		}
		function r0(c, f) {
			throw (
				((c = Object.prototype.toString.call(f)),
				Error(
					n(
						31,
						c === "[object Object]" ? "object with keys {" + Object.keys(f).join(", ") + "}" : c,
					),
				))
			)
		}
		function mM(c) {
			var f = c._init
			return f(c._payload)
		}
		function vM(c) {
			function f(ae, te) {
				if (c) {
					var ce = ae.deletions
					ce === null ? ((ae.deletions = [te]), (ae.flags |= 16)) : ce.push(te)
				}
			}
			function g(ae, te) {
				if (!c) return null
				for (; te !== null; ) f(ae, te), (te = te.sibling)
				return null
			}
			function w(ae, te) {
				for (ae = new Map(); te !== null; )
					te.key !== null ? ae.set(te.key, te) : ae.set(te.index, te), (te = te.sibling)
				return ae
			}
			function S(ae, te) {
				return (ae = eu(ae, te)), (ae.index = 0), (ae.sibling = null), ae
			}
			function M(ae, te, ce) {
				return (
					(ae.index = ce),
					c
						? ((ce = ae.alternate),
						  ce !== null
								? ((ce = ce.index), ce < te ? ((ae.flags |= 2), te) : ce)
								: ((ae.flags |= 2), te))
						: ((ae.flags |= 1048576), te)
				)
			}
			function j(ae) {
				return c && ae.alternate === null && (ae.flags |= 2), ae
			}
			function G(ae, te, ce, Ie) {
				return te === null || te.tag !== 6
					? ((te = gC(ce, ae.mode, Ie)), (te.return = ae), te)
					: ((te = S(te, ce)), (te.return = ae), te)
			}
			function Z(ae, te, ce, Ie) {
				var Je = ce.type
				return Je === N
					? Ce(ae, te, ce.props.children, Ie, ce.key)
					: te !== null &&
					  (te.elementType === Je ||
							(typeof Je == "object" && Je !== null && Je.$$typeof === re && mM(Je) === te.type))
					? ((Ie = S(te, ce.props)), (Ie.ref = Nh(ae, te, ce)), (Ie.return = ae), Ie)
					: ((Ie = D0(ce.type, ce.key, ce.props, null, ae.mode, Ie)),
					  (Ie.ref = Nh(ae, te, ce)),
					  (Ie.return = ae),
					  Ie)
			}
			function fe(ae, te, ce, Ie) {
				return te === null ||
					te.tag !== 4 ||
					te.stateNode.containerInfo !== ce.containerInfo ||
					te.stateNode.implementation !== ce.implementation
					? ((te = yC(ce, ae.mode, Ie)), (te.return = ae), te)
					: ((te = S(te, ce.children || [])), (te.return = ae), te)
			}
			function Ce(ae, te, ce, Ie, Je) {
				return te === null || te.tag !== 7
					? ((te = bc(ce, ae.mode, Ie, Je)), (te.return = ae), te)
					: ((te = S(te, ce)), (te.return = ae), te)
			}
			function De(ae, te, ce) {
				if ((typeof te == "string" && te !== "") || typeof te == "number")
					return (te = gC("" + te, ae.mode, ce)), (te.return = ae), te
				if (typeof te == "object" && te !== null) {
					switch (te.$$typeof) {
						case O:
							return (
								(ce = D0(te.type, te.key, te.props, null, ae.mode, ce)),
								(ce.ref = Nh(ae, null, te)),
								(ce.return = ae),
								ce
							)
						case A:
							return (te = yC(te, ae.mode, ce)), (te.return = ae), te
						case re:
							var Ie = te._init
							return De(ae, Ie(te._payload), ce)
					}
					if (Jt(te) || le(te)) return (te = bc(te, ae.mode, ce, null)), (te.return = ae), te
					r0(ae, te)
				}
				return null
			}
			function xe(ae, te, ce, Ie) {
				var Je = te !== null ? te.key : null
				if ((typeof ce == "string" && ce !== "") || typeof ce == "number")
					return Je !== null ? null : G(ae, te, "" + ce, Ie)
				if (typeof ce == "object" && ce !== null) {
					switch (ce.$$typeof) {
						case O:
							return ce.key === Je ? Z(ae, te, ce, Ie) : null
						case A:
							return ce.key === Je ? fe(ae, te, ce, Ie) : null
						case re:
							return (Je = ce._init), xe(ae, te, Je(ce._payload), Ie)
					}
					if (Jt(ce) || le(ce)) return Je !== null ? null : Ce(ae, te, ce, Ie, null)
					r0(ae, ce)
				}
				return null
			}
			function $e(ae, te, ce, Ie, Je) {
				if ((typeof Ie == "string" && Ie !== "") || typeof Ie == "number")
					return (ae = ae.get(ce) || null), G(te, ae, "" + Ie, Je)
				if (typeof Ie == "object" && Ie !== null) {
					switch (Ie.$$typeof) {
						case O:
							return (ae = ae.get(Ie.key === null ? ce : Ie.key) || null), Z(te, ae, Ie, Je)
						case A:
							return (ae = ae.get(Ie.key === null ? ce : Ie.key) || null), fe(te, ae, Ie, Je)
						case re:
							var at = Ie._init
							return $e(ae, te, ce, at(Ie._payload), Je)
					}
					if (Jt(Ie) || le(Ie)) return (ae = ae.get(ce) || null), Ce(te, ae, Ie, Je, null)
					r0(te, Ie)
				}
				return null
			}
			function Ye(ae, te, ce, Ie) {
				for (
					var Je = null, at = null, ot = te, ft = (te = 0), Cr = null;
					ot !== null && ft < ce.length;
					ft++
				) {
					ot.index > ft ? ((Cr = ot), (ot = null)) : (Cr = ot.sibling)
					var Ht = xe(ae, ot, ce[ft], Ie)
					if (Ht === null) {
						ot === null && (ot = Cr)
						break
					}
					c && ot && Ht.alternate === null && f(ae, ot),
						(te = M(Ht, te, ft)),
						at === null ? (Je = Ht) : (at.sibling = Ht),
						(at = Ht),
						(ot = Cr)
				}
				if (ft === ce.length) return g(ae, ot), kn && dc(ae, ft), Je
				if (ot === null) {
					for (; ft < ce.length; ft++)
						(ot = De(ae, ce[ft], Ie)),
							ot !== null &&
								((te = M(ot, te, ft)), at === null ? (Je = ot) : (at.sibling = ot), (at = ot))
					return kn && dc(ae, ft), Je
				}
				for (ot = w(ae, ot); ft < ce.length; ft++)
					(Cr = $e(ot, ae, ft, ce[ft], Ie)),
						Cr !== null &&
							(c && Cr.alternate !== null && ot.delete(Cr.key === null ? ft : Cr.key),
							(te = M(Cr, te, ft)),
							at === null ? (Je = Cr) : (at.sibling = Cr),
							(at = Cr))
				return (
					c &&
						ot.forEach(function (tu) {
							return f(ae, tu)
						}),
					kn && dc(ae, ft),
					Je
				)
			}
			function Ke(ae, te, ce, Ie) {
				var Je = le(ce)
				if (typeof Je != "function") throw Error(n(150))
				if (((ce = Je.call(ce)), ce == null)) throw Error(n(151))
				for (
					var at = (Je = null), ot = te, ft = (te = 0), Cr = null, Ht = ce.next();
					ot !== null && !Ht.done;
					ft++, Ht = ce.next()
				) {
					ot.index > ft ? ((Cr = ot), (ot = null)) : (Cr = ot.sibling)
					var tu = xe(ae, ot, Ht.value, Ie)
					if (tu === null) {
						ot === null && (ot = Cr)
						break
					}
					c && ot && tu.alternate === null && f(ae, ot),
						(te = M(tu, te, ft)),
						at === null ? (Je = tu) : (at.sibling = tu),
						(at = tu),
						(ot = Cr)
				}
				if (Ht.done) return g(ae, ot), kn && dc(ae, ft), Je
				if (ot === null) {
					for (; !Ht.done; ft++, Ht = ce.next())
						(Ht = De(ae, Ht.value, Ie)),
							Ht !== null &&
								((te = M(Ht, te, ft)), at === null ? (Je = Ht) : (at.sibling = Ht), (at = Ht))
					return kn && dc(ae, ft), Je
				}
				for (ot = w(ae, ot); !Ht.done; ft++, Ht = ce.next())
					(Ht = $e(ot, ae, ft, Ht.value, Ie)),
						Ht !== null &&
							(c && Ht.alternate !== null && ot.delete(Ht.key === null ? ft : Ht.key),
							(te = M(Ht, te, ft)),
							at === null ? (Je = Ht) : (at.sibling = Ht),
							(at = Ht))
				return (
					c &&
						ot.forEach(function (NQ) {
							return f(ae, NQ)
						}),
					kn && dc(ae, ft),
					Je
				)
			}
			function Kn(ae, te, ce, Ie) {
				if (
					(typeof ce == "object" &&
						ce !== null &&
						ce.type === N &&
						ce.key === null &&
						(ce = ce.props.children),
					typeof ce == "object" && ce !== null)
				) {
					switch (ce.$$typeof) {
						case O:
							e: {
								for (var Je = ce.key, at = te; at !== null; ) {
									if (at.key === Je) {
										if (((Je = ce.type), Je === N)) {
											if (at.tag === 7) {
												g(ae, at.sibling),
													(te = S(at, ce.props.children)),
													(te.return = ae),
													(ae = te)
												break e
											}
										} else if (
											at.elementType === Je ||
											(typeof Je == "object" &&
												Je !== null &&
												Je.$$typeof === re &&
												mM(Je) === at.type)
										) {
											g(ae, at.sibling),
												(te = S(at, ce.props)),
												(te.ref = Nh(ae, at, ce)),
												(te.return = ae),
												(ae = te)
											break e
										}
										g(ae, at)
										break
									} else f(ae, at)
									at = at.sibling
								}
								ce.type === N
									? ((te = bc(ce.props.children, ae.mode, Ie, ce.key)), (te.return = ae), (ae = te))
									: ((Ie = D0(ce.type, ce.key, ce.props, null, ae.mode, Ie)),
									  (Ie.ref = Nh(ae, te, ce)),
									  (Ie.return = ae),
									  (ae = Ie))
							}
							return j(ae)
						case A:
							e: {
								for (at = ce.key; te !== null; ) {
									if (te.key === at)
										if (
											te.tag === 4 &&
											te.stateNode.containerInfo === ce.containerInfo &&
											te.stateNode.implementation === ce.implementation
										) {
											g(ae, te.sibling),
												(te = S(te, ce.children || [])),
												(te.return = ae),
												(ae = te)
											break e
										} else {
											g(ae, te)
											break
										}
									else f(ae, te)
									te = te.sibling
								}
								;(te = yC(ce, ae.mode, Ie)), (te.return = ae), (ae = te)
							}
							return j(ae)
						case re:
							return (at = ce._init), Kn(ae, te, at(ce._payload), Ie)
					}
					if (Jt(ce)) return Ye(ae, te, ce, Ie)
					if (le(ce)) return Ke(ae, te, ce, Ie)
					r0(ae, ce)
				}
				return (typeof ce == "string" && ce !== "") || typeof ce == "number"
					? ((ce = "" + ce),
					  te !== null && te.tag === 6
							? (g(ae, te.sibling), (te = S(te, ce)), (te.return = ae), (ae = te))
							: (g(ae, te), (te = gC(ce, ae.mode, Ie)), (te.return = ae), (ae = te)),
					  j(ae))
					: g(ae, te)
			}
			return Kn
		}
		var nf = vM(!0),
			gM = vM(!1),
			i0 = ql(null),
			a0 = null,
			rf = null,
			DE = null
		function _E() {
			DE = rf = a0 = null
		}
		function OE(c) {
			var f = i0.current
			gn(i0), (c._currentValue = f)
		}
		function AE(c, f, g) {
			for (; c !== null; ) {
				var w = c.alternate
				if (
					((c.childLanes & f) !== f
						? ((c.childLanes |= f), w !== null && (w.childLanes |= f))
						: w !== null && (w.childLanes & f) !== f && (w.childLanes |= f),
					c === g)
				)
					break
				c = c.return
			}
		}
		function af(c, f) {
			;(a0 = c),
				(DE = rf = null),
				(c = c.dependencies),
				c !== null && c.firstContext !== null && (c.lanes & f && (_i = !0), (c.firstContext = null))
		}
		function Oa(c) {
			var f = c._currentValue
			if (DE !== c)
				if (((c = { context: c, memoizedValue: f, next: null }), rf === null)) {
					if (a0 === null) throw Error(n(308))
					;(rf = c), (a0.dependencies = { lanes: 0, firstContext: c })
				} else rf = rf.next = c
			return f
		}
		var fc = null
		function NE(c) {
			fc === null ? (fc = [c]) : fc.push(c)
		}
		function yM(c, f, g, w) {
			var S = f.interleaved
			return (
				S === null ? ((g.next = g), NE(f)) : ((g.next = S.next), (S.next = g)),
				(f.interleaved = g),
				Bs(c, w)
			)
		}
		function Bs(c, f) {
			c.lanes |= f
			var g = c.alternate
			for (g !== null && (g.lanes |= f), g = c, c = c.return; c !== null; )
				(c.childLanes |= f),
					(g = c.alternate),
					g !== null && (g.childLanes |= f),
					(g = c),
					(c = c.return)
			return g.tag === 3 ? g.stateNode : null
		}
		var Yl = !1
		function ME(c) {
			c.updateQueue = {
				baseState: c.memoizedState,
				firstBaseUpdate: null,
				lastBaseUpdate: null,
				shared: { pending: null, interleaved: null, lanes: 0 },
				effects: null,
			}
		}
		function bM(c, f) {
			;(c = c.updateQueue),
				f.updateQueue === c &&
					(f.updateQueue = {
						baseState: c.baseState,
						firstBaseUpdate: c.firstBaseUpdate,
						lastBaseUpdate: c.lastBaseUpdate,
						shared: c.shared,
						effects: c.effects,
					})
		}
		function Hs(c, f) {
			return { eventTime: c, lane: f, tag: 0, payload: null, callback: null, next: null }
		}
		function Gl(c, f, g) {
			var w = c.updateQueue
			if (w === null) return null
			if (((w = w.shared), It & 2)) {
				var S = w.pending
				return (
					S === null ? (f.next = f) : ((f.next = S.next), (S.next = f)), (w.pending = f), Bs(c, g)
				)
			}
			return (
				(S = w.interleaved),
				S === null ? ((f.next = f), NE(w)) : ((f.next = S.next), (S.next = f)),
				(w.interleaved = f),
				Bs(c, g)
			)
		}
		function o0(c, f, g) {
			if (((f = f.updateQueue), f !== null && ((f = f.shared), (g & 4194240) !== 0))) {
				var w = f.lanes
				;(w &= c.pendingLanes), (g |= w), (f.lanes = g), Ww(c, g)
			}
		}
		function xM(c, f) {
			var g = c.updateQueue,
				w = c.alternate
			if (w !== null && ((w = w.updateQueue), g === w)) {
				var S = null,
					M = null
				if (((g = g.firstBaseUpdate), g !== null)) {
					do {
						var j = {
							eventTime: g.eventTime,
							lane: g.lane,
							tag: g.tag,
							payload: g.payload,
							callback: g.callback,
							next: null,
						}
						M === null ? (S = M = j) : (M = M.next = j), (g = g.next)
					} while (g !== null)
					M === null ? (S = M = f) : (M = M.next = f)
				} else S = M = f
				;(g = {
					baseState: w.baseState,
					firstBaseUpdate: S,
					lastBaseUpdate: M,
					shared: w.shared,
					effects: w.effects,
				}),
					(c.updateQueue = g)
				return
			}
			;(c = g.lastBaseUpdate),
				c === null ? (g.firstBaseUpdate = f) : (c.next = f),
				(g.lastBaseUpdate = f)
		}
		function s0(c, f, g, w) {
			var S = c.updateQueue
			Yl = !1
			var M = S.firstBaseUpdate,
				j = S.lastBaseUpdate,
				G = S.shared.pending
			if (G !== null) {
				S.shared.pending = null
				var Z = G,
					fe = Z.next
				;(Z.next = null), j === null ? (M = fe) : (j.next = fe), (j = Z)
				var Ce = c.alternate
				Ce !== null &&
					((Ce = Ce.updateQueue),
					(G = Ce.lastBaseUpdate),
					G !== j &&
						(G === null ? (Ce.firstBaseUpdate = fe) : (G.next = fe), (Ce.lastBaseUpdate = Z)))
			}
			if (M !== null) {
				var De = S.baseState
				;(j = 0), (Ce = fe = Z = null), (G = M)
				do {
					var xe = G.lane,
						$e = G.eventTime
					if ((w & xe) === xe) {
						Ce !== null &&
							(Ce = Ce.next =
								{
									eventTime: $e,
									lane: 0,
									tag: G.tag,
									payload: G.payload,
									callback: G.callback,
									next: null,
								})
						e: {
							var Ye = c,
								Ke = G
							switch (((xe = f), ($e = g), Ke.tag)) {
								case 1:
									if (((Ye = Ke.payload), typeof Ye == "function")) {
										De = Ye.call($e, De, xe)
										break e
									}
									De = Ye
									break e
								case 3:
									Ye.flags = (Ye.flags & -65537) | 128
								case 0:
									if (
										((Ye = Ke.payload),
										(xe = typeof Ye == "function" ? Ye.call($e, De, xe) : Ye),
										xe == null)
									)
										break e
									De = F({}, De, xe)
									break e
								case 2:
									Yl = !0
							}
						}
						G.callback !== null &&
							G.lane !== 0 &&
							((c.flags |= 64), (xe = S.effects), xe === null ? (S.effects = [G]) : xe.push(G))
					} else
						($e = {
							eventTime: $e,
							lane: xe,
							tag: G.tag,
							payload: G.payload,
							callback: G.callback,
							next: null,
						}),
							Ce === null ? ((fe = Ce = $e), (Z = De)) : (Ce = Ce.next = $e),
							(j |= xe)
					if (((G = G.next), G === null)) {
						if (((G = S.shared.pending), G === null)) break
						;(xe = G),
							(G = xe.next),
							(xe.next = null),
							(S.lastBaseUpdate = xe),
							(S.shared.pending = null)
					}
				} while (!0)
				if (
					(Ce === null && (Z = De),
					(S.baseState = Z),
					(S.firstBaseUpdate = fe),
					(S.lastBaseUpdate = Ce),
					(f = S.shared.interleaved),
					f !== null)
				) {
					S = f
					do (j |= S.lane), (S = S.next)
					while (S !== f)
				} else M === null && (S.shared.lanes = 0)
				;(mc |= j), (c.lanes = j), (c.memoizedState = De)
			}
		}
		function wM(c, f, g) {
			if (((c = f.effects), (f.effects = null), c !== null))
				for (f = 0; f < c.length; f++) {
					var w = c[f],
						S = w.callback
					if (S !== null) {
						if (((w.callback = null), (w = g), typeof S != "function")) throw Error(n(191, S))
						S.call(w)
					}
				}
		}
		var Mh = {},
			jo = ql(Mh),
			Ih = ql(Mh),
			Rh = ql(Mh)
		function pc(c) {
			if (c === Mh) throw Error(n(174))
			return c
		}
		function IE(c, f) {
			switch ((dn(Rh, f), dn(Ih, c), dn(jo, Mh), (c = f.nodeType), c)) {
				case 9:
				case 11:
					f = (f = f.documentElement) ? f.namespaceURI : de(null, "")
					break
				default:
					;(c = c === 8 ? f.parentNode : f),
						(f = c.namespaceURI || null),
						(c = c.tagName),
						(f = de(f, c))
			}
			gn(jo), dn(jo, f)
		}
		function of() {
			gn(jo), gn(Ih), gn(Rh)
		}
		function EM(c) {
			pc(Rh.current)
			var f = pc(jo.current),
				g = de(f, c.type)
			f !== g && (dn(Ih, c), dn(jo, g))
		}
		function RE(c) {
			Ih.current === c && (gn(jo), gn(Ih))
		}
		var Mn = ql(0)
		function l0(c) {
			for (var f = c; f !== null; ) {
				if (f.tag === 13) {
					var g = f.memoizedState
					if (g !== null && ((g = g.dehydrated), g === null || g.data === "$?" || g.data === "$!"))
						return f
				} else if (f.tag === 19 && f.memoizedProps.revealOrder !== void 0) {
					if (f.flags & 128) return f
				} else if (f.child !== null) {
					;(f.child.return = f), (f = f.child)
					continue
				}
				if (f === c) break
				for (; f.sibling === null; ) {
					if (f.return === null || f.return === c) return null
					f = f.return
				}
				;(f.sibling.return = f.return), (f = f.sibling)
			}
			return null
		}
		var LE = []
		function PE() {
			for (var c = 0; c < LE.length; c++) LE[c]._workInProgressVersionPrimary = null
			LE.length = 0
		}
		var u0 = D.ReactCurrentDispatcher,
			jE = D.ReactCurrentBatchConfig,
			hc = 0,
			In = null,
			fr = null,
			wr = null,
			c0 = !1,
			Lh = !1,
			Ph = 0,
			ZK = 0
		function Gr() {
			throw Error(n(321))
		}
		function FE(c, f) {
			if (f === null) return !1
			for (var g = 0; g < f.length && g < c.length; g++) if (!ro(c[g], f[g])) return !1
			return !0
		}
		function BE(c, f, g, w, S, M) {
			if (
				((hc = M),
				(In = f),
				(f.memoizedState = null),
				(f.updateQueue = null),
				(f.lanes = 0),
				(u0.current = c === null || c.memoizedState === null ? rQ : iQ),
				(c = g(w, S)),
				Lh)
			) {
				M = 0
				do {
					if (((Lh = !1), (Ph = 0), 25 <= M)) throw Error(n(301))
					;(M += 1), (wr = fr = null), (f.updateQueue = null), (u0.current = aQ), (c = g(w, S))
				} while (Lh)
			}
			if (
				((u0.current = p0),
				(f = fr !== null && fr.next !== null),
				(hc = 0),
				(wr = fr = In = null),
				(c0 = !1),
				f)
			)
				throw Error(n(300))
			return c
		}
		function HE() {
			var c = Ph !== 0
			return (Ph = 0), c
		}
		function Fo() {
			var c = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null }
			return wr === null ? (In.memoizedState = wr = c) : (wr = wr.next = c), wr
		}
		function Aa() {
			if (fr === null) {
				var c = In.alternate
				c = c !== null ? c.memoizedState : null
			} else c = fr.next
			var f = wr === null ? In.memoizedState : wr.next
			if (f !== null) (wr = f), (fr = c)
			else {
				if (c === null) throw Error(n(310))
				;(fr = c),
					(c = {
						memoizedState: fr.memoizedState,
						baseState: fr.baseState,
						baseQueue: fr.baseQueue,
						queue: fr.queue,
						next: null,
					}),
					wr === null ? (In.memoizedState = wr = c) : (wr = wr.next = c)
			}
			return wr
		}
		function jh(c, f) {
			return typeof f == "function" ? f(c) : f
		}
		function $E(c) {
			var f = Aa(),
				g = f.queue
			if (g === null) throw Error(n(311))
			g.lastRenderedReducer = c
			var w = fr,
				S = w.baseQueue,
				M = g.pending
			if (M !== null) {
				if (S !== null) {
					var j = S.next
					;(S.next = M.next), (M.next = j)
				}
				;(w.baseQueue = S = M), (g.pending = null)
			}
			if (S !== null) {
				;(M = S.next), (w = w.baseState)
				var G = (j = null),
					Z = null,
					fe = M
				do {
					var Ce = fe.lane
					if ((hc & Ce) === Ce)
						Z !== null &&
							(Z = Z.next =
								{
									lane: 0,
									action: fe.action,
									hasEagerState: fe.hasEagerState,
									eagerState: fe.eagerState,
									next: null,
								}),
							(w = fe.hasEagerState ? fe.eagerState : c(w, fe.action))
					else {
						var De = {
							lane: Ce,
							action: fe.action,
							hasEagerState: fe.hasEagerState,
							eagerState: fe.eagerState,
							next: null,
						}
						Z === null ? ((G = Z = De), (j = w)) : (Z = Z.next = De), (In.lanes |= Ce), (mc |= Ce)
					}
					fe = fe.next
				} while (fe !== null && fe !== M)
				Z === null ? (j = w) : (Z.next = G),
					ro(w, f.memoizedState) || (_i = !0),
					(f.memoizedState = w),
					(f.baseState = j),
					(f.baseQueue = Z),
					(g.lastRenderedState = w)
			}
			if (((c = g.interleaved), c !== null)) {
				S = c
				do (M = S.lane), (In.lanes |= M), (mc |= M), (S = S.next)
				while (S !== c)
			} else S === null && (g.lanes = 0)
			return [f.memoizedState, g.dispatch]
		}
		function UE(c) {
			var f = Aa(),
				g = f.queue
			if (g === null) throw Error(n(311))
			g.lastRenderedReducer = c
			var w = g.dispatch,
				S = g.pending,
				M = f.memoizedState
			if (S !== null) {
				g.pending = null
				var j = (S = S.next)
				do (M = c(M, j.action)), (j = j.next)
				while (j !== S)
				ro(M, f.memoizedState) || (_i = !0),
					(f.memoizedState = M),
					f.baseQueue === null && (f.baseState = M),
					(g.lastRenderedState = M)
			}
			return [M, w]
		}
		function CM() {}
		function TM(c, f) {
			var g = In,
				w = Aa(),
				S = f(),
				M = !ro(w.memoizedState, S)
			if (
				(M && ((w.memoizedState = S), (_i = !0)),
				(w = w.queue),
				zE(DM.bind(null, g, w, c), [c]),
				w.getSnapshot !== f || M || (wr !== null && wr.memoizedState.tag & 1))
			) {
				if (((g.flags |= 2048), Fh(9, SM.bind(null, g, w, S, f), void 0, null), Er === null))
					throw Error(n(349))
				hc & 30 || kM(g, f, S)
			}
			return S
		}
		function kM(c, f, g) {
			;(c.flags |= 16384),
				(c = { getSnapshot: f, value: g }),
				(f = In.updateQueue),
				f === null
					? ((f = { lastEffect: null, stores: null }), (In.updateQueue = f), (f.stores = [c]))
					: ((g = f.stores), g === null ? (f.stores = [c]) : g.push(c))
		}
		function SM(c, f, g, w) {
			;(f.value = g), (f.getSnapshot = w), _M(f) && OM(c)
		}
		function DM(c, f, g) {
			return g(function () {
				_M(f) && OM(c)
			})
		}
		function _M(c) {
			var f = c.getSnapshot
			c = c.value
			try {
				var g = f()
				return !ro(c, g)
			} catch {
				return !0
			}
		}
		function OM(c) {
			var f = Bs(c, 1)
			f !== null && lo(f, c, 1, -1)
		}
		function AM(c) {
			var f = Fo()
			return (
				typeof c == "function" && (c = c()),
				(f.memoizedState = f.baseState = c),
				(c = {
					pending: null,
					interleaved: null,
					lanes: 0,
					dispatch: null,
					lastRenderedReducer: jh,
					lastRenderedState: c,
				}),
				(f.queue = c),
				(c = c.dispatch = nQ.bind(null, In, c)),
				[f.memoizedState, c]
			)
		}
		function Fh(c, f, g, w) {
			return (
				(c = { tag: c, create: f, destroy: g, deps: w, next: null }),
				(f = In.updateQueue),
				f === null
					? ((f = { lastEffect: null, stores: null }),
					  (In.updateQueue = f),
					  (f.lastEffect = c.next = c))
					: ((g = f.lastEffect),
					  g === null
							? (f.lastEffect = c.next = c)
							: ((w = g.next), (g.next = c), (c.next = w), (f.lastEffect = c))),
				c
			)
		}
		function NM() {
			return Aa().memoizedState
		}
		function d0(c, f, g, w) {
			var S = Fo()
			;(In.flags |= c), (S.memoizedState = Fh(1 | f, g, void 0, w === void 0 ? null : w))
		}
		function f0(c, f, g, w) {
			var S = Aa()
			w = w === void 0 ? null : w
			var M = void 0
			if (fr !== null) {
				var j = fr.memoizedState
				if (((M = j.destroy), w !== null && FE(w, j.deps))) {
					S.memoizedState = Fh(f, g, M, w)
					return
				}
			}
			;(In.flags |= c), (S.memoizedState = Fh(1 | f, g, M, w))
		}
		function MM(c, f) {
			return d0(8390656, 8, c, f)
		}
		function zE(c, f) {
			return f0(2048, 8, c, f)
		}
		function IM(c, f) {
			return f0(4, 2, c, f)
		}
		function RM(c, f) {
			return f0(4, 4, c, f)
		}
		function LM(c, f) {
			if (typeof f == "function")
				return (
					(c = c()),
					f(c),
					function () {
						f(null)
					}
				)
			if (f != null)
				return (
					(c = c()),
					(f.current = c),
					function () {
						f.current = null
					}
				)
		}
		function PM(c, f, g) {
			return (g = g != null ? g.concat([c]) : null), f0(4, 4, LM.bind(null, f, c), g)
		}
		function qE() {}
		function jM(c, f) {
			var g = Aa()
			f = f === void 0 ? null : f
			var w = g.memoizedState
			return w !== null && f !== null && FE(f, w[1]) ? w[0] : ((g.memoizedState = [c, f]), c)
		}
		function FM(c, f) {
			var g = Aa()
			f = f === void 0 ? null : f
			var w = g.memoizedState
			return w !== null && f !== null && FE(f, w[1])
				? w[0]
				: ((c = c()), (g.memoizedState = [c, f]), c)
		}
		function BM(c, f, g) {
			return hc & 21
				? (ro(g, f) || ((g = mN()), (In.lanes |= g), (mc |= g), (c.baseState = !0)), f)
				: (c.baseState && ((c.baseState = !1), (_i = !0)), (c.memoizedState = g))
		}
		function eQ(c, f) {
			var g = Zt
			;(Zt = g !== 0 && 4 > g ? g : 4), c(!0)
			var w = jE.transition
			jE.transition = {}
			try {
				c(!1), f()
			} finally {
				;(Zt = g), (jE.transition = w)
			}
		}
		function HM() {
			return Aa().memoizedState
		}
		function tQ(c, f, g) {
			var w = Jl(c)
			if (((g = { lane: w, action: g, hasEagerState: !1, eagerState: null, next: null }), $M(c)))
				UM(f, g)
			else if (((g = yM(c, f, g, w)), g !== null)) {
				var S = di()
				lo(g, c, w, S), zM(g, f, w)
			}
		}
		function nQ(c, f, g) {
			var w = Jl(c),
				S = { lane: w, action: g, hasEagerState: !1, eagerState: null, next: null }
			if ($M(c)) UM(f, S)
			else {
				var M = c.alternate
				if (
					c.lanes === 0 &&
					(M === null || M.lanes === 0) &&
					((M = f.lastRenderedReducer), M !== null)
				)
					try {
						var j = f.lastRenderedState,
							G = M(j, g)
						if (((S.hasEagerState = !0), (S.eagerState = G), ro(G, j))) {
							var Z = f.interleaved
							Z === null ? ((S.next = S), NE(f)) : ((S.next = Z.next), (Z.next = S)),
								(f.interleaved = S)
							return
						}
					} catch {
					} finally {
					}
				;(g = yM(c, f, S, w)), g !== null && ((S = di()), lo(g, c, w, S), zM(g, f, w))
			}
		}
		function $M(c) {
			var f = c.alternate
			return c === In || (f !== null && f === In)
		}
		function UM(c, f) {
			Lh = c0 = !0
			var g = c.pending
			g === null ? (f.next = f) : ((f.next = g.next), (g.next = f)), (c.pending = f)
		}
		function zM(c, f, g) {
			if (g & 4194240) {
				var w = f.lanes
				;(w &= c.pendingLanes), (g |= w), (f.lanes = g), Ww(c, g)
			}
		}
		var p0 = {
				readContext: Oa,
				useCallback: Gr,
				useContext: Gr,
				useEffect: Gr,
				useImperativeHandle: Gr,
				useInsertionEffect: Gr,
				useLayoutEffect: Gr,
				useMemo: Gr,
				useReducer: Gr,
				useRef: Gr,
				useState: Gr,
				useDebugValue: Gr,
				useDeferredValue: Gr,
				useTransition: Gr,
				useMutableSource: Gr,
				useSyncExternalStore: Gr,
				useId: Gr,
				unstable_isNewReconciler: !1,
			},
			rQ = {
				readContext: Oa,
				useCallback: function (c, f) {
					return (Fo().memoizedState = [c, f === void 0 ? null : f]), c
				},
				useContext: Oa,
				useEffect: MM,
				useImperativeHandle: function (c, f, g) {
					return (g = g != null ? g.concat([c]) : null), d0(4194308, 4, LM.bind(null, f, c), g)
				},
				useLayoutEffect: function (c, f) {
					return d0(4194308, 4, c, f)
				},
				useInsertionEffect: function (c, f) {
					return d0(4, 2, c, f)
				},
				useMemo: function (c, f) {
					var g = Fo()
					return (f = f === void 0 ? null : f), (c = c()), (g.memoizedState = [c, f]), c
				},
				useReducer: function (c, f, g) {
					var w = Fo()
					return (
						(f = g !== void 0 ? g(f) : f),
						(w.memoizedState = w.baseState = f),
						(c = {
							pending: null,
							interleaved: null,
							lanes: 0,
							dispatch: null,
							lastRenderedReducer: c,
							lastRenderedState: f,
						}),
						(w.queue = c),
						(c = c.dispatch = tQ.bind(null, In, c)),
						[w.memoizedState, c]
					)
				},
				useRef: function (c) {
					var f = Fo()
					return (c = { current: c }), (f.memoizedState = c)
				},
				useState: AM,
				useDebugValue: qE,
				useDeferredValue: function (c) {
					return (Fo().memoizedState = c)
				},
				useTransition: function () {
					var c = AM(!1),
						f = c[0]
					return (c = eQ.bind(null, c[1])), (Fo().memoizedState = c), [f, c]
				},
				useMutableSource: function () {},
				useSyncExternalStore: function (c, f, g) {
					var w = In,
						S = Fo()
					if (kn) {
						if (g === void 0) throw Error(n(407))
						g = g()
					} else {
						if (((g = f()), Er === null)) throw Error(n(349))
						hc & 30 || kM(w, f, g)
					}
					S.memoizedState = g
					var M = { value: g, getSnapshot: f }
					return (
						(S.queue = M),
						MM(DM.bind(null, w, M, c), [c]),
						(w.flags |= 2048),
						Fh(9, SM.bind(null, w, M, g, f), void 0, null),
						g
					)
				},
				useId: function () {
					var c = Fo(),
						f = Er.identifierPrefix
					if (kn) {
						var g = Fs,
							w = js
						;(g = (w & ~(1 << (32 - no(w) - 1))).toString(32) + g),
							(f = ":" + f + "R" + g),
							(g = Ph++),
							0 < g && (f += "H" + g.toString(32)),
							(f += ":")
					} else (g = ZK++), (f = ":" + f + "r" + g.toString(32) + ":")
					return (c.memoizedState = f)
				},
				unstable_isNewReconciler: !1,
			},
			iQ = {
				readContext: Oa,
				useCallback: jM,
				useContext: Oa,
				useEffect: zE,
				useImperativeHandle: PM,
				useInsertionEffect: IM,
				useLayoutEffect: RM,
				useMemo: FM,
				useReducer: $E,
				useRef: NM,
				useState: function () {
					return $E(jh)
				},
				useDebugValue: qE,
				useDeferredValue: function (c) {
					var f = Aa()
					return BM(f, fr.memoizedState, c)
				},
				useTransition: function () {
					var c = $E(jh)[0],
						f = Aa().memoizedState
					return [c, f]
				},
				useMutableSource: CM,
				useSyncExternalStore: TM,
				useId: HM,
				unstable_isNewReconciler: !1,
			},
			aQ = {
				readContext: Oa,
				useCallback: jM,
				useContext: Oa,
				useEffect: zE,
				useImperativeHandle: PM,
				useInsertionEffect: IM,
				useLayoutEffect: RM,
				useMemo: FM,
				useReducer: UE,
				useRef: NM,
				useState: function () {
					return UE(jh)
				},
				useDebugValue: qE,
				useDeferredValue: function (c) {
					var f = Aa()
					return fr === null ? (f.memoizedState = c) : BM(f, fr.memoizedState, c)
				},
				useTransition: function () {
					var c = UE(jh)[0],
						f = Aa().memoizedState
					return [c, f]
				},
				useMutableSource: CM,
				useSyncExternalStore: TM,
				useId: HM,
				unstable_isNewReconciler: !1,
			}
		function ao(c, f) {
			if (c && c.defaultProps) {
				;(f = F({}, f)), (c = c.defaultProps)
				for (var g in c) f[g] === void 0 && (f[g] = c[g])
				return f
			}
			return f
		}
		function VE(c, f, g, w) {
			;(f = c.memoizedState),
				(g = g(w, f)),
				(g = g == null ? f : F({}, f, g)),
				(c.memoizedState = g),
				c.lanes === 0 && (c.updateQueue.baseState = g)
		}
		var h0 = {
			isMounted: function (c) {
				return (c = c._reactInternals) ? St(c) === c : !1
			},
			enqueueSetState: function (c, f, g) {
				c = c._reactInternals
				var w = di(),
					S = Jl(c),
					M = Hs(w, S)
				;(M.payload = f),
					g != null && (M.callback = g),
					(f = Gl(c, M, S)),
					f !== null && (lo(f, c, S, w), o0(f, c, S))
			},
			enqueueReplaceState: function (c, f, g) {
				c = c._reactInternals
				var w = di(),
					S = Jl(c),
					M = Hs(w, S)
				;(M.tag = 1),
					(M.payload = f),
					g != null && (M.callback = g),
					(f = Gl(c, M, S)),
					f !== null && (lo(f, c, S, w), o0(f, c, S))
			},
			enqueueForceUpdate: function (c, f) {
				c = c._reactInternals
				var g = di(),
					w = Jl(c),
					S = Hs(g, w)
				;(S.tag = 2),
					f != null && (S.callback = f),
					(f = Gl(c, S, w)),
					f !== null && (lo(f, c, w, g), o0(f, c, w))
			},
		}
		function qM(c, f, g, w, S, M, j) {
			return (
				(c = c.stateNode),
				typeof c.shouldComponentUpdate == "function"
					? c.shouldComponentUpdate(w, M, j)
					: f.prototype && f.prototype.isPureReactComponent
					? !Th(g, w) || !Th(S, M)
					: !0
			)
		}
		function VM(c, f, g) {
			var w = !1,
				S = Vl,
				M = f.contextType
			return (
				typeof M == "object" && M !== null
					? (M = Oa(M))
					: ((S = Di(f) ? uc : Yr.current),
					  (w = f.contextTypes),
					  (M = (w = w != null) ? Jd(c, S) : Vl)),
				(f = new f(g, M)),
				(c.memoizedState = f.state !== null && f.state !== void 0 ? f.state : null),
				(f.updater = h0),
				(c.stateNode = f),
				(f._reactInternals = c),
				w &&
					((c = c.stateNode),
					(c.__reactInternalMemoizedUnmaskedChildContext = S),
					(c.__reactInternalMemoizedMaskedChildContext = M)),
				f
			)
		}
		function WM(c, f, g, w) {
			;(c = f.state),
				typeof f.componentWillReceiveProps == "function" && f.componentWillReceiveProps(g, w),
				typeof f.UNSAFE_componentWillReceiveProps == "function" &&
					f.UNSAFE_componentWillReceiveProps(g, w),
				f.state !== c && h0.enqueueReplaceState(f, f.state, null)
		}
		function WE(c, f, g, w) {
			var S = c.stateNode
			;(S.props = g), (S.state = c.memoizedState), (S.refs = {}), ME(c)
			var M = f.contextType
			typeof M == "object" && M !== null
				? (S.context = Oa(M))
				: ((M = Di(f) ? uc : Yr.current), (S.context = Jd(c, M))),
				(S.state = c.memoizedState),
				(M = f.getDerivedStateFromProps),
				typeof M == "function" && (VE(c, f, M, g), (S.state = c.memoizedState)),
				typeof f.getDerivedStateFromProps == "function" ||
					typeof S.getSnapshotBeforeUpdate == "function" ||
					(typeof S.UNSAFE_componentWillMount != "function" &&
						typeof S.componentWillMount != "function") ||
					((f = S.state),
					typeof S.componentWillMount == "function" && S.componentWillMount(),
					typeof S.UNSAFE_componentWillMount == "function" && S.UNSAFE_componentWillMount(),
					f !== S.state && h0.enqueueReplaceState(S, S.state, null),
					s0(c, g, S, w),
					(S.state = c.memoizedState)),
				typeof S.componentDidMount == "function" && (c.flags |= 4194308)
		}
		function sf(c, f) {
			try {
				var g = "",
					w = f
				do (g += Se(w)), (w = w.return)
				while (w)
				var S = g
			} catch (M) {
				S =
					`
Error generating stack: ` +
					M.message +
					`
` +
					M.stack
			}
			return { value: c, source: f, stack: S, digest: null }
		}
		function YE(c, f, g) {
			return { value: c, source: null, stack: g ?? null, digest: f ?? null }
		}
		function GE(c, f) {
			try {
				console.error(f.value)
			} catch (g) {
				setTimeout(function () {
					throw g
				})
			}
		}
		var oQ = typeof WeakMap == "function" ? WeakMap : Map
		function YM(c, f, g) {
			;(g = Hs(-1, g)), (g.tag = 3), (g.payload = { element: null })
			var w = f.value
			return (
				(g.callback = function () {
					w0 || ((w0 = !0), (uC = w)), GE(c, f)
				}),
				g
			)
		}
		function GM(c, f, g) {
			;(g = Hs(-1, g)), (g.tag = 3)
			var w = c.type.getDerivedStateFromError
			if (typeof w == "function") {
				var S = f.value
				;(g.payload = function () {
					return w(S)
				}),
					(g.callback = function () {
						GE(c, f)
					})
			}
			var M = c.stateNode
			return (
				M !== null &&
					typeof M.componentDidCatch == "function" &&
					(g.callback = function () {
						GE(c, f),
							typeof w != "function" && (Ql === null ? (Ql = new Set([this])) : Ql.add(this))
						var j = f.stack
						this.componentDidCatch(f.value, { componentStack: j !== null ? j : "" })
					}),
				g
			)
		}
		function KM(c, f, g) {
			var w = c.pingCache
			if (w === null) {
				w = c.pingCache = new oQ()
				var S = new Set()
				w.set(f, S)
			} else (S = w.get(f)), S === void 0 && ((S = new Set()), w.set(f, S))
			S.has(g) || (S.add(g), (c = xQ.bind(null, c, f, g)), f.then(c, c))
		}
		function QM(c) {
			do {
				var f
				if (
					((f = c.tag === 13) &&
						((f = c.memoizedState), (f = f !== null ? f.dehydrated !== null : !0)),
					f)
				)
					return c
				c = c.return
			} while (c !== null)
			return null
		}
		function XM(c, f, g, w, S) {
			return c.mode & 1
				? ((c.flags |= 65536), (c.lanes = S), c)
				: (c === f
						? (c.flags |= 65536)
						: ((c.flags |= 128),
						  (g.flags |= 131072),
						  (g.flags &= -52805),
						  g.tag === 1 &&
								(g.alternate === null ? (g.tag = 17) : ((f = Hs(-1, 1)), (f.tag = 2), Gl(g, f, 1))),
						  (g.lanes |= 1)),
				  c)
		}
		var sQ = D.ReactCurrentOwner,
			_i = !1
		function ci(c, f, g, w) {
			f.child = c === null ? gM(f, null, g, w) : nf(f, c.child, g, w)
		}
		function JM(c, f, g, w, S) {
			g = g.render
			var M = f.ref
			return (
				af(f, S),
				(w = BE(c, f, g, w, M, S)),
				(g = HE()),
				c !== null && !_i
					? ((f.updateQueue = c.updateQueue), (f.flags &= -2053), (c.lanes &= ~S), $s(c, f, S))
					: (kn && g && EE(f), (f.flags |= 1), ci(c, f, w, S), f.child)
			)
		}
		function ZM(c, f, g, w, S) {
			if (c === null) {
				var M = g.type
				return typeof M == "function" &&
					!vC(M) &&
					M.defaultProps === void 0 &&
					g.compare === null &&
					g.defaultProps === void 0
					? ((f.tag = 15), (f.type = M), eI(c, f, M, w, S))
					: ((c = D0(g.type, null, w, f, f.mode, S)),
					  (c.ref = f.ref),
					  (c.return = f),
					  (f.child = c))
			}
			if (((M = c.child), !(c.lanes & S))) {
				var j = M.memoizedProps
				if (((g = g.compare), (g = g !== null ? g : Th), g(j, w) && c.ref === f.ref))
					return $s(c, f, S)
			}
			return (f.flags |= 1), (c = eu(M, w)), (c.ref = f.ref), (c.return = f), (f.child = c)
		}
		function eI(c, f, g, w, S) {
			if (c !== null) {
				var M = c.memoizedProps
				if (Th(M, w) && c.ref === f.ref)
					if (((_i = !1), (f.pendingProps = w = M), (c.lanes & S) !== 0))
						c.flags & 131072 && (_i = !0)
					else return (f.lanes = c.lanes), $s(c, f, S)
			}
			return KE(c, f, g, w, S)
		}
		function tI(c, f, g) {
			var w = f.pendingProps,
				S = w.children,
				M = c !== null ? c.memoizedState : null
			if (w.mode === "hidden")
				if (!(f.mode & 1))
					(f.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }),
						dn(uf, Zi),
						(Zi |= g)
				else {
					if (!(g & 1073741824))
						return (
							(c = M !== null ? M.baseLanes | g : g),
							(f.lanes = f.childLanes = 1073741824),
							(f.memoizedState = { baseLanes: c, cachePool: null, transitions: null }),
							(f.updateQueue = null),
							dn(uf, Zi),
							(Zi |= c),
							null
						)
					;(f.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }),
						(w = M !== null ? M.baseLanes : g),
						dn(uf, Zi),
						(Zi |= w)
				}
			else
				M !== null ? ((w = M.baseLanes | g), (f.memoizedState = null)) : (w = g),
					dn(uf, Zi),
					(Zi |= w)
			return ci(c, f, S, g), f.child
		}
		function nI(c, f) {
			var g = f.ref
			;((c === null && g !== null) || (c !== null && c.ref !== g)) &&
				((f.flags |= 512), (f.flags |= 2097152))
		}
		function KE(c, f, g, w, S) {
			var M = Di(g) ? uc : Yr.current
			return (
				(M = Jd(f, M)),
				af(f, S),
				(g = BE(c, f, g, w, M, S)),
				(w = HE()),
				c !== null && !_i
					? ((f.updateQueue = c.updateQueue), (f.flags &= -2053), (c.lanes &= ~S), $s(c, f, S))
					: (kn && w && EE(f), (f.flags |= 1), ci(c, f, g, S), f.child)
			)
		}
		function rI(c, f, g, w, S) {
			if (Di(g)) {
				var M = !0
				Jg(f)
			} else M = !1
			if ((af(f, S), f.stateNode === null)) v0(c, f), VM(f, g, w), WE(f, g, w, S), (w = !0)
			else if (c === null) {
				var j = f.stateNode,
					G = f.memoizedProps
				j.props = G
				var Z = j.context,
					fe = g.contextType
				typeof fe == "object" && fe !== null
					? (fe = Oa(fe))
					: ((fe = Di(g) ? uc : Yr.current), (fe = Jd(f, fe)))
				var Ce = g.getDerivedStateFromProps,
					De = typeof Ce == "function" || typeof j.getSnapshotBeforeUpdate == "function"
				De ||
					(typeof j.UNSAFE_componentWillReceiveProps != "function" &&
						typeof j.componentWillReceiveProps != "function") ||
					((G !== w || Z !== fe) && WM(f, j, w, fe)),
					(Yl = !1)
				var xe = f.memoizedState
				;(j.state = xe),
					s0(f, w, j, S),
					(Z = f.memoizedState),
					G !== w || xe !== Z || Si.current || Yl
						? (typeof Ce == "function" && (VE(f, g, Ce, w), (Z = f.memoizedState)),
						  (G = Yl || qM(f, g, G, w, xe, Z, fe))
								? (De ||
										(typeof j.UNSAFE_componentWillMount != "function" &&
											typeof j.componentWillMount != "function") ||
										(typeof j.componentWillMount == "function" && j.componentWillMount(),
										typeof j.UNSAFE_componentWillMount == "function" &&
											j.UNSAFE_componentWillMount()),
								  typeof j.componentDidMount == "function" && (f.flags |= 4194308))
								: (typeof j.componentDidMount == "function" && (f.flags |= 4194308),
								  (f.memoizedProps = w),
								  (f.memoizedState = Z)),
						  (j.props = w),
						  (j.state = Z),
						  (j.context = fe),
						  (w = G))
						: (typeof j.componentDidMount == "function" && (f.flags |= 4194308), (w = !1))
			} else {
				;(j = f.stateNode),
					bM(c, f),
					(G = f.memoizedProps),
					(fe = f.type === f.elementType ? G : ao(f.type, G)),
					(j.props = fe),
					(De = f.pendingProps),
					(xe = j.context),
					(Z = g.contextType),
					typeof Z == "object" && Z !== null
						? (Z = Oa(Z))
						: ((Z = Di(g) ? uc : Yr.current), (Z = Jd(f, Z)))
				var $e = g.getDerivedStateFromProps
				;(Ce = typeof $e == "function" || typeof j.getSnapshotBeforeUpdate == "function") ||
					(typeof j.UNSAFE_componentWillReceiveProps != "function" &&
						typeof j.componentWillReceiveProps != "function") ||
					((G !== De || xe !== Z) && WM(f, j, w, Z)),
					(Yl = !1),
					(xe = f.memoizedState),
					(j.state = xe),
					s0(f, w, j, S)
				var Ye = f.memoizedState
				G !== De || xe !== Ye || Si.current || Yl
					? (typeof $e == "function" && (VE(f, g, $e, w), (Ye = f.memoizedState)),
					  (fe = Yl || qM(f, g, fe, w, xe, Ye, Z) || !1)
							? (Ce ||
									(typeof j.UNSAFE_componentWillUpdate != "function" &&
										typeof j.componentWillUpdate != "function") ||
									(typeof j.componentWillUpdate == "function" && j.componentWillUpdate(w, Ye, Z),
									typeof j.UNSAFE_componentWillUpdate == "function" &&
										j.UNSAFE_componentWillUpdate(w, Ye, Z)),
							  typeof j.componentDidUpdate == "function" && (f.flags |= 4),
							  typeof j.getSnapshotBeforeUpdate == "function" && (f.flags |= 1024))
							: (typeof j.componentDidUpdate != "function" ||
									(G === c.memoizedProps && xe === c.memoizedState) ||
									(f.flags |= 4),
							  typeof j.getSnapshotBeforeUpdate != "function" ||
									(G === c.memoizedProps && xe === c.memoizedState) ||
									(f.flags |= 1024),
							  (f.memoizedProps = w),
							  (f.memoizedState = Ye)),
					  (j.props = w),
					  (j.state = Ye),
					  (j.context = Z),
					  (w = fe))
					: (typeof j.componentDidUpdate != "function" ||
							(G === c.memoizedProps && xe === c.memoizedState) ||
							(f.flags |= 4),
					  typeof j.getSnapshotBeforeUpdate != "function" ||
							(G === c.memoizedProps && xe === c.memoizedState) ||
							(f.flags |= 1024),
					  (w = !1))
			}
			return QE(c, f, g, w, M, S)
		}
		function QE(c, f, g, w, S, M) {
			nI(c, f)
			var j = (f.flags & 128) !== 0
			if (!w && !j) return S && lM(f, g, !1), $s(c, f, M)
			;(w = f.stateNode), (sQ.current = f)
			var G = j && typeof g.getDerivedStateFromError != "function" ? null : w.render()
			return (
				(f.flags |= 1),
				c !== null && j
					? ((f.child = nf(f, c.child, null, M)), (f.child = nf(f, null, G, M)))
					: ci(c, f, G, M),
				(f.memoizedState = w.state),
				S && lM(f, g, !0),
				f.child
			)
		}
		function iI(c) {
			var f = c.stateNode
			f.pendingContext
				? oM(c, f.pendingContext, f.pendingContext !== f.context)
				: f.context && oM(c, f.context, !1),
				IE(c, f.containerInfo)
		}
		function aI(c, f, g, w, S) {
			return tf(), SE(S), (f.flags |= 256), ci(c, f, g, w), f.child
		}
		var XE = { dehydrated: null, treeContext: null, retryLane: 0 }
		function JE(c) {
			return { baseLanes: c, cachePool: null, transitions: null }
		}
		function oI(c, f, g) {
			var w = f.pendingProps,
				S = Mn.current,
				M = !1,
				j = (f.flags & 128) !== 0,
				G
			if (
				((G = j) || (G = c !== null && c.memoizedState === null ? !1 : (S & 2) !== 0),
				G ? ((M = !0), (f.flags &= -129)) : (c === null || c.memoizedState !== null) && (S |= 1),
				dn(Mn, S & 1),
				c === null)
			)
				return (
					kE(f),
					(c = f.memoizedState),
					c !== null && ((c = c.dehydrated), c !== null)
						? (f.mode & 1
								? c.data === "$!"
									? (f.lanes = 8)
									: (f.lanes = 1073741824)
								: (f.lanes = 1),
						  null)
						: ((j = w.children),
						  (c = w.fallback),
						  M
								? ((w = f.mode),
								  (M = f.child),
								  (j = { mode: "hidden", children: j }),
								  !(w & 1) && M !== null
										? ((M.childLanes = 0), (M.pendingProps = j))
										: (M = _0(j, w, 0, null)),
								  (c = bc(c, w, g, null)),
								  (M.return = f),
								  (c.return = f),
								  (M.sibling = c),
								  (f.child = M),
								  (f.child.memoizedState = JE(g)),
								  (f.memoizedState = XE),
								  c)
								: ZE(f, j))
				)
			if (((S = c.memoizedState), S !== null && ((G = S.dehydrated), G !== null)))
				return lQ(c, f, j, w, G, S, g)
			if (M) {
				;(M = w.fallback), (j = f.mode), (S = c.child), (G = S.sibling)
				var Z = { mode: "hidden", children: w.children }
				return (
					!(j & 1) && f.child !== S
						? ((w = f.child), (w.childLanes = 0), (w.pendingProps = Z), (f.deletions = null))
						: ((w = eu(S, Z)), (w.subtreeFlags = S.subtreeFlags & 14680064)),
					G !== null ? (M = eu(G, M)) : ((M = bc(M, j, g, null)), (M.flags |= 2)),
					(M.return = f),
					(w.return = f),
					(w.sibling = M),
					(f.child = w),
					(w = M),
					(M = f.child),
					(j = c.child.memoizedState),
					(j =
						j === null
							? JE(g)
							: { baseLanes: j.baseLanes | g, cachePool: null, transitions: j.transitions }),
					(M.memoizedState = j),
					(M.childLanes = c.childLanes & ~g),
					(f.memoizedState = XE),
					w
				)
			}
			return (
				(M = c.child),
				(c = M.sibling),
				(w = eu(M, { mode: "visible", children: w.children })),
				!(f.mode & 1) && (w.lanes = g),
				(w.return = f),
				(w.sibling = null),
				c !== null &&
					((g = f.deletions), g === null ? ((f.deletions = [c]), (f.flags |= 16)) : g.push(c)),
				(f.child = w),
				(f.memoizedState = null),
				w
			)
		}
		function ZE(c, f) {
			return (
				(f = _0({ mode: "visible", children: f }, c.mode, 0, null)), (f.return = c), (c.child = f)
			)
		}
		function m0(c, f, g, w) {
			return (
				w !== null && SE(w),
				nf(f, c.child, null, g),
				(c = ZE(f, f.pendingProps.children)),
				(c.flags |= 2),
				(f.memoizedState = null),
				c
			)
		}
		function lQ(c, f, g, w, S, M, j) {
			if (g)
				return f.flags & 256
					? ((f.flags &= -257), (w = YE(Error(n(422)))), m0(c, f, j, w))
					: f.memoizedState !== null
					? ((f.child = c.child), (f.flags |= 128), null)
					: ((M = w.fallback),
					  (S = f.mode),
					  (w = _0({ mode: "visible", children: w.children }, S, 0, null)),
					  (M = bc(M, S, j, null)),
					  (M.flags |= 2),
					  (w.return = f),
					  (M.return = f),
					  (w.sibling = M),
					  (f.child = w),
					  f.mode & 1 && nf(f, c.child, null, j),
					  (f.child.memoizedState = JE(j)),
					  (f.memoizedState = XE),
					  M)
			if (!(f.mode & 1)) return m0(c, f, j, null)
			if (S.data === "$!") {
				if (((w = S.nextSibling && S.nextSibling.dataset), w)) var G = w.dgst
				return (w = G), (M = Error(n(419))), (w = YE(M, w, void 0)), m0(c, f, j, w)
			}
			if (((G = (j & c.childLanes) !== 0), _i || G)) {
				if (((w = Er), w !== null)) {
					switch (j & -j) {
						case 4:
							S = 2
							break
						case 16:
							S = 8
							break
						case 64:
						case 128:
						case 256:
						case 512:
						case 1024:
						case 2048:
						case 4096:
						case 8192:
						case 16384:
						case 32768:
						case 65536:
						case 131072:
						case 262144:
						case 524288:
						case 1048576:
						case 2097152:
						case 4194304:
						case 8388608:
						case 16777216:
						case 33554432:
						case 67108864:
							S = 32
							break
						case 536870912:
							S = 268435456
							break
						default:
							S = 0
					}
					;(S = S & (w.suspendedLanes | j) ? 0 : S),
						S !== 0 && S !== M.retryLane && ((M.retryLane = S), Bs(c, S), lo(w, c, S, -1))
				}
				return mC(), (w = YE(Error(n(421)))), m0(c, f, j, w)
			}
			return S.data === "$?"
				? ((f.flags |= 128), (f.child = c.child), (f = wQ.bind(null, c)), (S._reactRetry = f), null)
				: ((c = M.treeContext),
				  (Ji = zl(S.nextSibling)),
				  (Xi = f),
				  (kn = !0),
				  (io = null),
				  c !== null &&
						((Da[_a++] = js),
						(Da[_a++] = Fs),
						(Da[_a++] = cc),
						(js = c.id),
						(Fs = c.overflow),
						(cc = f)),
				  (f = ZE(f, w.children)),
				  (f.flags |= 4096),
				  f)
		}
		function sI(c, f, g) {
			c.lanes |= f
			var w = c.alternate
			w !== null && (w.lanes |= f), AE(c.return, f, g)
		}
		function eC(c, f, g, w, S) {
			var M = c.memoizedState
			M === null
				? (c.memoizedState = {
						isBackwards: f,
						rendering: null,
						renderingStartTime: 0,
						last: w,
						tail: g,
						tailMode: S,
				  })
				: ((M.isBackwards = f),
				  (M.rendering = null),
				  (M.renderingStartTime = 0),
				  (M.last = w),
				  (M.tail = g),
				  (M.tailMode = S))
		}
		function lI(c, f, g) {
			var w = f.pendingProps,
				S = w.revealOrder,
				M = w.tail
			if ((ci(c, f, w.children, g), (w = Mn.current), w & 2)) (w = (w & 1) | 2), (f.flags |= 128)
			else {
				if (c !== null && c.flags & 128)
					e: for (c = f.child; c !== null; ) {
						if (c.tag === 13) c.memoizedState !== null && sI(c, g, f)
						else if (c.tag === 19) sI(c, g, f)
						else if (c.child !== null) {
							;(c.child.return = c), (c = c.child)
							continue
						}
						if (c === f) break e
						for (; c.sibling === null; ) {
							if (c.return === null || c.return === f) break e
							c = c.return
						}
						;(c.sibling.return = c.return), (c = c.sibling)
					}
				w &= 1
			}
			if ((dn(Mn, w), !(f.mode & 1))) f.memoizedState = null
			else
				switch (S) {
					case "forwards":
						for (g = f.child, S = null; g !== null; )
							(c = g.alternate), c !== null && l0(c) === null && (S = g), (g = g.sibling)
						;(g = S),
							g === null
								? ((S = f.child), (f.child = null))
								: ((S = g.sibling), (g.sibling = null)),
							eC(f, !1, S, g, M)
						break
					case "backwards":
						for (g = null, S = f.child, f.child = null; S !== null; ) {
							if (((c = S.alternate), c !== null && l0(c) === null)) {
								f.child = S
								break
							}
							;(c = S.sibling), (S.sibling = g), (g = S), (S = c)
						}
						eC(f, !0, g, null, M)
						break
					case "together":
						eC(f, !1, null, null, void 0)
						break
					default:
						f.memoizedState = null
				}
			return f.child
		}
		function v0(c, f) {
			!(f.mode & 1) && c !== null && ((c.alternate = null), (f.alternate = null), (f.flags |= 2))
		}
		function $s(c, f, g) {
			if ((c !== null && (f.dependencies = c.dependencies), (mc |= f.lanes), !(g & f.childLanes)))
				return null
			if (c !== null && f.child !== c.child) throw Error(n(153))
			if (f.child !== null) {
				for (
					c = f.child, g = eu(c, c.pendingProps), f.child = g, g.return = f;
					c.sibling !== null;

				)
					(c = c.sibling), (g = g.sibling = eu(c, c.pendingProps)), (g.return = f)
				g.sibling = null
			}
			return f.child
		}
		function uQ(c, f, g) {
			switch (f.tag) {
				case 3:
					iI(f), tf()
					break
				case 5:
					EM(f)
					break
				case 1:
					Di(f.type) && Jg(f)
					break
				case 4:
					IE(f, f.stateNode.containerInfo)
					break
				case 10:
					var w = f.type._context,
						S = f.memoizedProps.value
					dn(i0, w._currentValue), (w._currentValue = S)
					break
				case 13:
					if (((w = f.memoizedState), w !== null))
						return w.dehydrated !== null
							? (dn(Mn, Mn.current & 1), (f.flags |= 128), null)
							: g & f.child.childLanes
							? oI(c, f, g)
							: (dn(Mn, Mn.current & 1), (c = $s(c, f, g)), c !== null ? c.sibling : null)
					dn(Mn, Mn.current & 1)
					break
				case 19:
					if (((w = (g & f.childLanes) !== 0), c.flags & 128)) {
						if (w) return lI(c, f, g)
						f.flags |= 128
					}
					if (
						((S = f.memoizedState),
						S !== null && ((S.rendering = null), (S.tail = null), (S.lastEffect = null)),
						dn(Mn, Mn.current),
						w)
					)
						break
					return null
				case 22:
				case 23:
					return (f.lanes = 0), tI(c, f, g)
			}
			return $s(c, f, g)
		}
		var uI, tC, cI, dI
		;(uI = function (c, f) {
			for (var g = f.child; g !== null; ) {
				if (g.tag === 5 || g.tag === 6) c.appendChild(g.stateNode)
				else if (g.tag !== 4 && g.child !== null) {
					;(g.child.return = g), (g = g.child)
					continue
				}
				if (g === f) break
				for (; g.sibling === null; ) {
					if (g.return === null || g.return === f) return
					g = g.return
				}
				;(g.sibling.return = g.return), (g = g.sibling)
			}
		}),
			(tC = function () {}),
			(cI = function (c, f, g, w) {
				var S = c.memoizedProps
				if (S !== w) {
					;(c = f.stateNode), pc(jo.current)
					var M = null
					switch (g) {
						case "input":
							;(S = on(c, S)), (w = on(c, w)), (M = [])
							break
						case "select":
							;(S = F({}, S, { value: void 0 })), (w = F({}, w, { value: void 0 })), (M = [])
							break
						case "textarea":
							;(S = ue(c, S)), (w = ue(c, w)), (M = [])
							break
						default:
							typeof S.onClick != "function" && typeof w.onClick == "function" && (c.onclick = Kg)
					}
					Nn(g, w)
					var j
					g = null
					for (fe in S)
						if (!w.hasOwnProperty(fe) && S.hasOwnProperty(fe) && S[fe] != null)
							if (fe === "style") {
								var G = S[fe]
								for (j in G) G.hasOwnProperty(j) && (g || (g = {}), (g[j] = ""))
							} else
								fe !== "dangerouslySetInnerHTML" &&
									fe !== "children" &&
									fe !== "suppressContentEditableWarning" &&
									fe !== "suppressHydrationWarning" &&
									fe !== "autoFocus" &&
									(i.hasOwnProperty(fe) ? M || (M = []) : (M = M || []).push(fe, null))
					for (fe in w) {
						var Z = w[fe]
						if (
							((G = S != null ? S[fe] : void 0),
							w.hasOwnProperty(fe) && Z !== G && (Z != null || G != null))
						)
							if (fe === "style")
								if (G) {
									for (j in G)
										!G.hasOwnProperty(j) ||
											(Z && Z.hasOwnProperty(j)) ||
											(g || (g = {}), (g[j] = ""))
									for (j in Z)
										Z.hasOwnProperty(j) && G[j] !== Z[j] && (g || (g = {}), (g[j] = Z[j]))
								} else g || (M || (M = []), M.push(fe, g)), (g = Z)
							else
								fe === "dangerouslySetInnerHTML"
									? ((Z = Z ? Z.__html : void 0),
									  (G = G ? G.__html : void 0),
									  Z != null && G !== Z && (M = M || []).push(fe, Z))
									: fe === "children"
									? (typeof Z != "string" && typeof Z != "number") || (M = M || []).push(fe, "" + Z)
									: fe !== "suppressContentEditableWarning" &&
									  fe !== "suppressHydrationWarning" &&
									  (i.hasOwnProperty(fe)
											? (Z != null && fe === "onScroll" && vn("scroll", c),
											  M || G === Z || (M = []))
											: (M = M || []).push(fe, Z))
					}
					g && (M = M || []).push("style", g)
					var fe = M
					;(f.updateQueue = fe) && (f.flags |= 4)
				}
			}),
			(dI = function (c, f, g, w) {
				g !== w && (f.flags |= 4)
			})
		function Bh(c, f) {
			if (!kn)
				switch (c.tailMode) {
					case "hidden":
						f = c.tail
						for (var g = null; f !== null; ) f.alternate !== null && (g = f), (f = f.sibling)
						g === null ? (c.tail = null) : (g.sibling = null)
						break
					case "collapsed":
						g = c.tail
						for (var w = null; g !== null; ) g.alternate !== null && (w = g), (g = g.sibling)
						w === null
							? f || c.tail === null
								? (c.tail = null)
								: (c.tail.sibling = null)
							: (w.sibling = null)
				}
		}
		function Kr(c) {
			var f = c.alternate !== null && c.alternate.child === c.child,
				g = 0,
				w = 0
			if (f)
				for (var S = c.child; S !== null; )
					(g |= S.lanes | S.childLanes),
						(w |= S.subtreeFlags & 14680064),
						(w |= S.flags & 14680064),
						(S.return = c),
						(S = S.sibling)
			else
				for (S = c.child; S !== null; )
					(g |= S.lanes | S.childLanes),
						(w |= S.subtreeFlags),
						(w |= S.flags),
						(S.return = c),
						(S = S.sibling)
			return (c.subtreeFlags |= w), (c.childLanes = g), f
		}
		function cQ(c, f, g) {
			var w = f.pendingProps
			switch ((CE(f), f.tag)) {
				case 2:
				case 16:
				case 15:
				case 0:
				case 11:
				case 7:
				case 8:
				case 12:
				case 9:
				case 14:
					return Kr(f), null
				case 1:
					return Di(f.type) && Xg(), Kr(f), null
				case 3:
					return (
						(w = f.stateNode),
						of(),
						gn(Si),
						gn(Yr),
						PE(),
						w.pendingContext && ((w.context = w.pendingContext), (w.pendingContext = null)),
						(c === null || c.child === null) &&
							(n0(f)
								? (f.flags |= 4)
								: c === null ||
								  (c.memoizedState.isDehydrated && !(f.flags & 256)) ||
								  ((f.flags |= 1024), io !== null && (fC(io), (io = null)))),
						tC(c, f),
						Kr(f),
						null
					)
				case 5:
					RE(f)
					var S = pc(Rh.current)
					if (((g = f.type), c !== null && f.stateNode != null))
						cI(c, f, g, w, S), c.ref !== f.ref && ((f.flags |= 512), (f.flags |= 2097152))
					else {
						if (!w) {
							if (f.stateNode === null) throw Error(n(166))
							return Kr(f), null
						}
						if (((c = pc(jo.current)), n0(f))) {
							;(w = f.stateNode), (g = f.type)
							var M = f.memoizedProps
							switch (((w[Po] = f), (w[Oh] = M), (c = (f.mode & 1) !== 0), g)) {
								case "dialog":
									vn("cancel", w), vn("close", w)
									break
								case "iframe":
								case "object":
								case "embed":
									vn("load", w)
									break
								case "video":
								case "audio":
									for (S = 0; S < Sh.length; S++) vn(Sh[S], w)
									break
								case "source":
									vn("error", w)
									break
								case "img":
								case "image":
								case "link":
									vn("error", w), vn("load", w)
									break
								case "details":
									vn("toggle", w)
									break
								case "input":
									dt(w, M), vn("invalid", w)
									break
								case "select":
									;(w._wrapperState = { wasMultiple: !!M.multiple }), vn("invalid", w)
									break
								case "textarea":
									Re(w, M), vn("invalid", w)
							}
							Nn(g, M), (S = null)
							for (var j in M)
								if (M.hasOwnProperty(j)) {
									var G = M[j]
									j === "children"
										? typeof G == "string"
											? w.textContent !== G &&
											  (M.suppressHydrationWarning !== !0 && Gg(w.textContent, G, c),
											  (S = ["children", G]))
											: typeof G == "number" &&
											  w.textContent !== "" + G &&
											  (M.suppressHydrationWarning !== !0 && Gg(w.textContent, G, c),
											  (S = ["children", "" + G]))
										: i.hasOwnProperty(j) && G != null && j === "onScroll" && vn("scroll", w)
								}
							switch (g) {
								case "input":
									pt(w), ur(w, M, !0)
									break
								case "textarea":
									pt(w), ye(w)
									break
								case "select":
								case "option":
									break
								default:
									typeof M.onClick == "function" && (w.onclick = Kg)
							}
							;(w = S), (f.updateQueue = w), w !== null && (f.flags |= 4)
						} else {
							;(j = S.nodeType === 9 ? S : S.ownerDocument),
								c === "http://www.w3.org/1999/xhtml" && (c = X(g)),
								c === "http://www.w3.org/1999/xhtml"
									? g === "script"
										? ((c = j.createElement("div")),
										  (c.innerHTML = "<script></script>"),
										  (c = c.removeChild(c.firstChild)))
										: typeof w.is == "string"
										? (c = j.createElement(g, { is: w.is }))
										: ((c = j.createElement(g)),
										  g === "select" &&
												((j = c), w.multiple ? (j.multiple = !0) : w.size && (j.size = w.size)))
									: (c = j.createElementNS(c, g)),
								(c[Po] = f),
								(c[Oh] = w),
								uI(c, f, !1, !1),
								(f.stateNode = c)
							e: {
								switch (((j = Yn(g, w)), g)) {
									case "dialog":
										vn("cancel", c), vn("close", c), (S = w)
										break
									case "iframe":
									case "object":
									case "embed":
										vn("load", c), (S = w)
										break
									case "video":
									case "audio":
										for (S = 0; S < Sh.length; S++) vn(Sh[S], c)
										S = w
										break
									case "source":
										vn("error", c), (S = w)
										break
									case "img":
									case "image":
									case "link":
										vn("error", c), vn("load", c), (S = w)
										break
									case "details":
										vn("toggle", c), (S = w)
										break
									case "input":
										dt(c, w), (S = on(c, w)), vn("invalid", c)
										break
									case "option":
										S = w
										break
									case "select":
										;(c._wrapperState = { wasMultiple: !!w.multiple }),
											(S = F({}, w, { value: void 0 })),
											vn("invalid", c)
										break
									case "textarea":
										Re(c, w), (S = ue(c, w)), vn("invalid", c)
										break
									default:
										S = w
								}
								Nn(g, S), (G = S)
								for (M in G)
									if (G.hasOwnProperty(M)) {
										var Z = G[M]
										M === "style"
											? An(c, Z)
											: M === "dangerouslySetInnerHTML"
											? ((Z = Z ? Z.__html : void 0), Z != null && Ze(c, Z))
											: M === "children"
											? typeof Z == "string"
												? (g !== "textarea" || Z !== "") && ct(c, Z)
												: typeof Z == "number" && ct(c, "" + Z)
											: M !== "suppressContentEditableWarning" &&
											  M !== "suppressHydrationWarning" &&
											  M !== "autoFocus" &&
											  (i.hasOwnProperty(M)
													? Z != null && M === "onScroll" && vn("scroll", c)
													: Z != null && C(c, M, Z, j))
									}
								switch (g) {
									case "input":
										pt(c), ur(c, w, !1)
										break
									case "textarea":
										pt(c), ye(c)
										break
									case "option":
										w.value != null && c.setAttribute("value", "" + Le(w.value))
										break
									case "select":
										;(c.multiple = !!w.multiple),
											(M = w.value),
											M != null
												? mn(c, !!w.multiple, M, !1)
												: w.defaultValue != null && mn(c, !!w.multiple, w.defaultValue, !0)
										break
									default:
										typeof S.onClick == "function" && (c.onclick = Kg)
								}
								switch (g) {
									case "button":
									case "input":
									case "select":
									case "textarea":
										w = !!w.autoFocus
										break e
									case "img":
										w = !0
										break e
									default:
										w = !1
								}
							}
							w && (f.flags |= 4)
						}
						f.ref !== null && ((f.flags |= 512), (f.flags |= 2097152))
					}
					return Kr(f), null
				case 6:
					if (c && f.stateNode != null) dI(c, f, c.memoizedProps, w)
					else {
						if (typeof w != "string" && f.stateNode === null) throw Error(n(166))
						if (((g = pc(Rh.current)), pc(jo.current), n0(f))) {
							if (
								((w = f.stateNode),
								(g = f.memoizedProps),
								(w[Po] = f),
								(M = w.nodeValue !== g) && ((c = Xi), c !== null))
							)
								switch (c.tag) {
									case 3:
										Gg(w.nodeValue, g, (c.mode & 1) !== 0)
										break
									case 5:
										c.memoizedProps.suppressHydrationWarning !== !0 &&
											Gg(w.nodeValue, g, (c.mode & 1) !== 0)
								}
							M && (f.flags |= 4)
						} else
							(w = (g.nodeType === 9 ? g : g.ownerDocument).createTextNode(w)),
								(w[Po] = f),
								(f.stateNode = w)
					}
					return Kr(f), null
				case 13:
					if (
						(gn(Mn),
						(w = f.memoizedState),
						c === null || (c.memoizedState !== null && c.memoizedState.dehydrated !== null))
					) {
						if (kn && Ji !== null && f.mode & 1 && !(f.flags & 128))
							hM(), tf(), (f.flags |= 98560), (M = !1)
						else if (((M = n0(f)), w !== null && w.dehydrated !== null)) {
							if (c === null) {
								if (!M) throw Error(n(318))
								if (((M = f.memoizedState), (M = M !== null ? M.dehydrated : null), !M))
									throw Error(n(317))
								M[Po] = f
							} else tf(), !(f.flags & 128) && (f.memoizedState = null), (f.flags |= 4)
							Kr(f), (M = !1)
						} else io !== null && (fC(io), (io = null)), (M = !0)
						if (!M) return f.flags & 65536 ? f : null
					}
					return f.flags & 128
						? ((f.lanes = g), f)
						: ((w = w !== null),
						  w !== (c !== null && c.memoizedState !== null) &&
								w &&
								((f.child.flags |= 8192),
								f.mode & 1 && (c === null || Mn.current & 1 ? pr === 0 && (pr = 3) : mC())),
						  f.updateQueue !== null && (f.flags |= 4),
						  Kr(f),
						  null)
				case 4:
					return of(), tC(c, f), c === null && Dh(f.stateNode.containerInfo), Kr(f), null
				case 10:
					return OE(f.type._context), Kr(f), null
				case 17:
					return Di(f.type) && Xg(), Kr(f), null
				case 19:
					if ((gn(Mn), (M = f.memoizedState), M === null)) return Kr(f), null
					if (((w = (f.flags & 128) !== 0), (j = M.rendering), j === null))
						if (w) Bh(M, !1)
						else {
							if (pr !== 0 || (c !== null && c.flags & 128))
								for (c = f.child; c !== null; ) {
									if (((j = l0(c)), j !== null)) {
										for (
											f.flags |= 128,
												Bh(M, !1),
												w = j.updateQueue,
												w !== null && ((f.updateQueue = w), (f.flags |= 4)),
												f.subtreeFlags = 0,
												w = g,
												g = f.child;
											g !== null;

										)
											(M = g),
												(c = w),
												(M.flags &= 14680066),
												(j = M.alternate),
												j === null
													? ((M.childLanes = 0),
													  (M.lanes = c),
													  (M.child = null),
													  (M.subtreeFlags = 0),
													  (M.memoizedProps = null),
													  (M.memoizedState = null),
													  (M.updateQueue = null),
													  (M.dependencies = null),
													  (M.stateNode = null))
													: ((M.childLanes = j.childLanes),
													  (M.lanes = j.lanes),
													  (M.child = j.child),
													  (M.subtreeFlags = 0),
													  (M.deletions = null),
													  (M.memoizedProps = j.memoizedProps),
													  (M.memoizedState = j.memoizedState),
													  (M.updateQueue = j.updateQueue),
													  (M.type = j.type),
													  (c = j.dependencies),
													  (M.dependencies =
															c === null
																? null
																: { lanes: c.lanes, firstContext: c.firstContext })),
												(g = g.sibling)
										return dn(Mn, (Mn.current & 1) | 2), f.child
									}
									c = c.sibling
								}
							M.tail !== null &&
								Gn() > cf &&
								((f.flags |= 128), (w = !0), Bh(M, !1), (f.lanes = 4194304))
						}
					else {
						if (!w)
							if (((c = l0(j)), c !== null)) {
								if (
									((f.flags |= 128),
									(w = !0),
									(g = c.updateQueue),
									g !== null && ((f.updateQueue = g), (f.flags |= 4)),
									Bh(M, !0),
									M.tail === null && M.tailMode === "hidden" && !j.alternate && !kn)
								)
									return Kr(f), null
							} else
								2 * Gn() - M.renderingStartTime > cf &&
									g !== 1073741824 &&
									((f.flags |= 128), (w = !0), Bh(M, !1), (f.lanes = 4194304))
						M.isBackwards
							? ((j.sibling = f.child), (f.child = j))
							: ((g = M.last), g !== null ? (g.sibling = j) : (f.child = j), (M.last = j))
					}
					return M.tail !== null
						? ((f = M.tail),
						  (M.rendering = f),
						  (M.tail = f.sibling),
						  (M.renderingStartTime = Gn()),
						  (f.sibling = null),
						  (g = Mn.current),
						  dn(Mn, w ? (g & 1) | 2 : g & 1),
						  f)
						: (Kr(f), null)
				case 22:
				case 23:
					return (
						hC(),
						(w = f.memoizedState !== null),
						c !== null && (c.memoizedState !== null) !== w && (f.flags |= 8192),
						w && f.mode & 1
							? Zi & 1073741824 && (Kr(f), f.subtreeFlags & 6 && (f.flags |= 8192))
							: Kr(f),
						null
					)
				case 24:
					return null
				case 25:
					return null
			}
			throw Error(n(156, f.tag))
		}
		function dQ(c, f) {
			switch ((CE(f), f.tag)) {
				case 1:
					return (
						Di(f.type) && Xg(),
						(c = f.flags),
						c & 65536 ? ((f.flags = (c & -65537) | 128), f) : null
					)
				case 3:
					return (
						of(),
						gn(Si),
						gn(Yr),
						PE(),
						(c = f.flags),
						c & 65536 && !(c & 128) ? ((f.flags = (c & -65537) | 128), f) : null
					)
				case 5:
					return RE(f), null
				case 13:
					if ((gn(Mn), (c = f.memoizedState), c !== null && c.dehydrated !== null)) {
						if (f.alternate === null) throw Error(n(340))
						tf()
					}
					return (c = f.flags), c & 65536 ? ((f.flags = (c & -65537) | 128), f) : null
				case 19:
					return gn(Mn), null
				case 4:
					return of(), null
				case 10:
					return OE(f.type._context), null
				case 22:
				case 23:
					return hC(), null
				case 24:
					return null
				default:
					return null
			}
		}
		var g0 = !1,
			Qr = !1,
			fQ = typeof WeakSet == "function" ? WeakSet : Set,
			We = null
		function lf(c, f) {
			var g = c.ref
			if (g !== null)
				if (typeof g == "function")
					try {
						g(null)
					} catch (w) {
						$n(c, f, w)
					}
				else g.current = null
		}
		function nC(c, f, g) {
			try {
				g()
			} catch (w) {
				$n(c, f, w)
			}
		}
		var fI = !1
		function pQ(c, f) {
			if (((hE = jg), (c = qN()), oE(c))) {
				if ("selectionStart" in c) var g = { start: c.selectionStart, end: c.selectionEnd }
				else
					e: {
						g = ((g = c.ownerDocument) && g.defaultView) || window
						var w = g.getSelection && g.getSelection()
						if (w && w.rangeCount !== 0) {
							g = w.anchorNode
							var S = w.anchorOffset,
								M = w.focusNode
							w = w.focusOffset
							try {
								g.nodeType, M.nodeType
							} catch {
								g = null
								break e
							}
							var j = 0,
								G = -1,
								Z = -1,
								fe = 0,
								Ce = 0,
								De = c,
								xe = null
							t: for (;;) {
								for (
									var $e;
									De !== g || (S !== 0 && De.nodeType !== 3) || (G = j + S),
										De !== M || (w !== 0 && De.nodeType !== 3) || (Z = j + w),
										De.nodeType === 3 && (j += De.nodeValue.length),
										($e = De.firstChild) !== null;

								)
									(xe = De), (De = $e)
								for (;;) {
									if (De === c) break t
									if (
										(xe === g && ++fe === S && (G = j),
										xe === M && ++Ce === w && (Z = j),
										($e = De.nextSibling) !== null)
									)
										break
									;(De = xe), (xe = De.parentNode)
								}
								De = $e
							}
							g = G === -1 || Z === -1 ? null : { start: G, end: Z }
						} else g = null
					}
				g = g || { start: 0, end: 0 }
			} else g = null
			for (mE = { focusedElem: c, selectionRange: g }, jg = !1, We = f; We !== null; )
				if (((f = We), (c = f.child), (f.subtreeFlags & 1028) !== 0 && c !== null))
					(c.return = f), (We = c)
				else
					for (; We !== null; ) {
						f = We
						try {
							var Ye = f.alternate
							if (f.flags & 1024)
								switch (f.tag) {
									case 0:
									case 11:
									case 15:
										break
									case 1:
										if (Ye !== null) {
											var Ke = Ye.memoizedProps,
												Kn = Ye.memoizedState,
												ae = f.stateNode,
												te = ae.getSnapshotBeforeUpdate(
													f.elementType === f.type ? Ke : ao(f.type, Ke),
													Kn,
												)
											ae.__reactInternalSnapshotBeforeUpdate = te
										}
										break
									case 3:
										var ce = f.stateNode.containerInfo
										ce.nodeType === 1
											? (ce.textContent = "")
											: ce.nodeType === 9 &&
											  ce.documentElement &&
											  ce.removeChild(ce.documentElement)
										break
									case 5:
									case 6:
									case 4:
									case 17:
										break
									default:
										throw Error(n(163))
								}
						} catch (Ie) {
							$n(f, f.return, Ie)
						}
						if (((c = f.sibling), c !== null)) {
							;(c.return = f.return), (We = c)
							break
						}
						We = f.return
					}
			return (Ye = fI), (fI = !1), Ye
		}
		function Hh(c, f, g) {
			var w = f.updateQueue
			if (((w = w !== null ? w.lastEffect : null), w !== null)) {
				var S = (w = w.next)
				do {
					if ((S.tag & c) === c) {
						var M = S.destroy
						;(S.destroy = void 0), M !== void 0 && nC(f, g, M)
					}
					S = S.next
				} while (S !== w)
			}
		}
		function y0(c, f) {
			if (((f = f.updateQueue), (f = f !== null ? f.lastEffect : null), f !== null)) {
				var g = (f = f.next)
				do {
					if ((g.tag & c) === c) {
						var w = g.create
						g.destroy = w()
					}
					g = g.next
				} while (g !== f)
			}
		}
		function rC(c) {
			var f = c.ref
			if (f !== null) {
				var g = c.stateNode
				switch (c.tag) {
					case 5:
						c = g
						break
					default:
						c = g
				}
				typeof f == "function" ? f(c) : (f.current = c)
			}
		}
		function pI(c) {
			var f = c.alternate
			f !== null && ((c.alternate = null), pI(f)),
				(c.child = null),
				(c.deletions = null),
				(c.sibling = null),
				c.tag === 5 &&
					((f = c.stateNode),
					f !== null && (delete f[Po], delete f[Oh], delete f[bE], delete f[KK], delete f[QK])),
				(c.stateNode = null),
				(c.return = null),
				(c.dependencies = null),
				(c.memoizedProps = null),
				(c.memoizedState = null),
				(c.pendingProps = null),
				(c.stateNode = null),
				(c.updateQueue = null)
		}
		function hI(c) {
			return c.tag === 5 || c.tag === 3 || c.tag === 4
		}
		function mI(c) {
			e: for (;;) {
				for (; c.sibling === null; ) {
					if (c.return === null || hI(c.return)) return null
					c = c.return
				}
				for (
					c.sibling.return = c.return, c = c.sibling;
					c.tag !== 5 && c.tag !== 6 && c.tag !== 18;

				) {
					if (c.flags & 2 || c.child === null || c.tag === 4) continue e
					;(c.child.return = c), (c = c.child)
				}
				if (!(c.flags & 2)) return c.stateNode
			}
		}
		function iC(c, f, g) {
			var w = c.tag
			if (w === 5 || w === 6)
				(c = c.stateNode),
					f
						? g.nodeType === 8
							? g.parentNode.insertBefore(c, f)
							: g.insertBefore(c, f)
						: (g.nodeType === 8
								? ((f = g.parentNode), f.insertBefore(c, g))
								: ((f = g), f.appendChild(c)),
						  (g = g._reactRootContainer),
						  g != null || f.onclick !== null || (f.onclick = Kg))
			else if (w !== 4 && ((c = c.child), c !== null))
				for (iC(c, f, g), c = c.sibling; c !== null; ) iC(c, f, g), (c = c.sibling)
		}
		function aC(c, f, g) {
			var w = c.tag
			if (w === 5 || w === 6) (c = c.stateNode), f ? g.insertBefore(c, f) : g.appendChild(c)
			else if (w !== 4 && ((c = c.child), c !== null))
				for (aC(c, f, g), c = c.sibling; c !== null; ) aC(c, f, g), (c = c.sibling)
		}
		var Rr = null,
			oo = !1
		function Kl(c, f, g) {
			for (g = g.child; g !== null; ) vI(c, f, g), (g = g.sibling)
		}
		function vI(c, f, g) {
			if (Lo && typeof Lo.onCommitFiberUnmount == "function")
				try {
					Lo.onCommitFiberUnmount(Ng, g)
				} catch {}
			switch (g.tag) {
				case 5:
					Qr || lf(g, f)
				case 6:
					var w = Rr,
						S = oo
					;(Rr = null),
						Kl(c, f, g),
						(Rr = w),
						(oo = S),
						Rr !== null &&
							(oo
								? ((c = Rr),
								  (g = g.stateNode),
								  c.nodeType === 8 ? c.parentNode.removeChild(g) : c.removeChild(g))
								: Rr.removeChild(g.stateNode))
					break
				case 18:
					Rr !== null &&
						(oo
							? ((c = Rr),
							  (g = g.stateNode),
							  c.nodeType === 8 ? yE(c.parentNode, g) : c.nodeType === 1 && yE(c, g),
							  yh(c))
							: yE(Rr, g.stateNode))
					break
				case 4:
					;(w = Rr),
						(S = oo),
						(Rr = g.stateNode.containerInfo),
						(oo = !0),
						Kl(c, f, g),
						(Rr = w),
						(oo = S)
					break
				case 0:
				case 11:
				case 14:
				case 15:
					if (!Qr && ((w = g.updateQueue), w !== null && ((w = w.lastEffect), w !== null))) {
						S = w = w.next
						do {
							var M = S,
								j = M.destroy
							;(M = M.tag), j !== void 0 && (M & 2 || M & 4) && nC(g, f, j), (S = S.next)
						} while (S !== w)
					}
					Kl(c, f, g)
					break
				case 1:
					if (!Qr && (lf(g, f), (w = g.stateNode), typeof w.componentWillUnmount == "function"))
						try {
							;(w.props = g.memoizedProps), (w.state = g.memoizedState), w.componentWillUnmount()
						} catch (G) {
							$n(g, f, G)
						}
					Kl(c, f, g)
					break
				case 21:
					Kl(c, f, g)
					break
				case 22:
					g.mode & 1
						? ((Qr = (w = Qr) || g.memoizedState !== null), Kl(c, f, g), (Qr = w))
						: Kl(c, f, g)
					break
				default:
					Kl(c, f, g)
			}
		}
		function gI(c) {
			var f = c.updateQueue
			if (f !== null) {
				c.updateQueue = null
				var g = c.stateNode
				g === null && (g = c.stateNode = new fQ()),
					f.forEach(function (w) {
						var S = EQ.bind(null, c, w)
						g.has(w) || (g.add(w), w.then(S, S))
					})
			}
		}
		function so(c, f) {
			var g = f.deletions
			if (g !== null)
				for (var w = 0; w < g.length; w++) {
					var S = g[w]
					try {
						var M = c,
							j = f,
							G = j
						e: for (; G !== null; ) {
							switch (G.tag) {
								case 5:
									;(Rr = G.stateNode), (oo = !1)
									break e
								case 3:
									;(Rr = G.stateNode.containerInfo), (oo = !0)
									break e
								case 4:
									;(Rr = G.stateNode.containerInfo), (oo = !0)
									break e
							}
							G = G.return
						}
						if (Rr === null) throw Error(n(160))
						vI(M, j, S), (Rr = null), (oo = !1)
						var Z = S.alternate
						Z !== null && (Z.return = null), (S.return = null)
					} catch (fe) {
						$n(S, f, fe)
					}
				}
			if (f.subtreeFlags & 12854) for (f = f.child; f !== null; ) yI(f, c), (f = f.sibling)
		}
		function yI(c, f) {
			var g = c.alternate,
				w = c.flags
			switch (c.tag) {
				case 0:
				case 11:
				case 14:
				case 15:
					if ((so(f, c), Bo(c), w & 4)) {
						try {
							Hh(3, c, c.return), y0(3, c)
						} catch (Ke) {
							$n(c, c.return, Ke)
						}
						try {
							Hh(5, c, c.return)
						} catch (Ke) {
							$n(c, c.return, Ke)
						}
					}
					break
				case 1:
					so(f, c), Bo(c), w & 512 && g !== null && lf(g, g.return)
					break
				case 5:
					if ((so(f, c), Bo(c), w & 512 && g !== null && lf(g, g.return), c.flags & 32)) {
						var S = c.stateNode
						try {
							ct(S, "")
						} catch (Ke) {
							$n(c, c.return, Ke)
						}
					}
					if (w & 4 && ((S = c.stateNode), S != null)) {
						var M = c.memoizedProps,
							j = g !== null ? g.memoizedProps : M,
							G = c.type,
							Z = c.updateQueue
						if (((c.updateQueue = null), Z !== null))
							try {
								G === "input" && M.type === "radio" && M.name != null && cn(S, M), Yn(G, j)
								var fe = Yn(G, M)
								for (j = 0; j < Z.length; j += 2) {
									var Ce = Z[j],
										De = Z[j + 1]
									Ce === "style"
										? An(S, De)
										: Ce === "dangerouslySetInnerHTML"
										? Ze(S, De)
										: Ce === "children"
										? ct(S, De)
										: C(S, Ce, De, fe)
								}
								switch (G) {
									case "input":
										sn(S, M)
										break
									case "textarea":
										pe(S, M)
										break
									case "select":
										var xe = S._wrapperState.wasMultiple
										S._wrapperState.wasMultiple = !!M.multiple
										var $e = M.value
										$e != null
											? mn(S, !!M.multiple, $e, !1)
											: xe !== !!M.multiple &&
											  (M.defaultValue != null
													? mn(S, !!M.multiple, M.defaultValue, !0)
													: mn(S, !!M.multiple, M.multiple ? [] : "", !1))
								}
								S[Oh] = M
							} catch (Ke) {
								$n(c, c.return, Ke)
							}
					}
					break
				case 6:
					if ((so(f, c), Bo(c), w & 4)) {
						if (c.stateNode === null) throw Error(n(162))
						;(S = c.stateNode), (M = c.memoizedProps)
						try {
							S.nodeValue = M
						} catch (Ke) {
							$n(c, c.return, Ke)
						}
					}
					break
				case 3:
					if ((so(f, c), Bo(c), w & 4 && g !== null && g.memoizedState.isDehydrated))
						try {
							yh(f.containerInfo)
						} catch (Ke) {
							$n(c, c.return, Ke)
						}
					break
				case 4:
					so(f, c), Bo(c)
					break
				case 13:
					so(f, c),
						Bo(c),
						(S = c.child),
						S.flags & 8192 &&
							((M = S.memoizedState !== null),
							(S.stateNode.isHidden = M),
							!M || (S.alternate !== null && S.alternate.memoizedState !== null) || (lC = Gn())),
						w & 4 && gI(c)
					break
				case 22:
					if (
						((Ce = g !== null && g.memoizedState !== null),
						c.mode & 1 ? ((Qr = (fe = Qr) || Ce), so(f, c), (Qr = fe)) : so(f, c),
						Bo(c),
						w & 8192)
					) {
						if (((fe = c.memoizedState !== null), (c.stateNode.isHidden = fe) && !Ce && c.mode & 1))
							for (We = c, Ce = c.child; Ce !== null; ) {
								for (De = We = Ce; We !== null; ) {
									switch (((xe = We), ($e = xe.child), xe.tag)) {
										case 0:
										case 11:
										case 14:
										case 15:
											Hh(4, xe, xe.return)
											break
										case 1:
											lf(xe, xe.return)
											var Ye = xe.stateNode
											if (typeof Ye.componentWillUnmount == "function") {
												;(w = xe), (g = xe.return)
												try {
													;(f = w),
														(Ye.props = f.memoizedProps),
														(Ye.state = f.memoizedState),
														Ye.componentWillUnmount()
												} catch (Ke) {
													$n(w, g, Ke)
												}
											}
											break
										case 5:
											lf(xe, xe.return)
											break
										case 22:
											if (xe.memoizedState !== null) {
												wI(De)
												continue
											}
									}
									$e !== null ? (($e.return = xe), (We = $e)) : wI(De)
								}
								Ce = Ce.sibling
							}
						e: for (Ce = null, De = c; ; ) {
							if (De.tag === 5) {
								if (Ce === null) {
									Ce = De
									try {
										;(S = De.stateNode),
											fe
												? ((M = S.style),
												  typeof M.setProperty == "function"
														? M.setProperty("display", "none", "important")
														: (M.display = "none"))
												: ((G = De.stateNode),
												  (Z = De.memoizedProps.style),
												  (j = Z != null && Z.hasOwnProperty("display") ? Z.display : null),
												  (G.style.display = Wn("display", j)))
									} catch (Ke) {
										$n(c, c.return, Ke)
									}
								}
							} else if (De.tag === 6) {
								if (Ce === null)
									try {
										De.stateNode.nodeValue = fe ? "" : De.memoizedProps
									} catch (Ke) {
										$n(c, c.return, Ke)
									}
							} else if (
								((De.tag !== 22 && De.tag !== 23) || De.memoizedState === null || De === c) &&
								De.child !== null
							) {
								;(De.child.return = De), (De = De.child)
								continue
							}
							if (De === c) break e
							for (; De.sibling === null; ) {
								if (De.return === null || De.return === c) break e
								Ce === De && (Ce = null), (De = De.return)
							}
							Ce === De && (Ce = null), (De.sibling.return = De.return), (De = De.sibling)
						}
					}
					break
				case 19:
					so(f, c), Bo(c), w & 4 && gI(c)
					break
				case 21:
					break
				default:
					so(f, c), Bo(c)
			}
		}
		function Bo(c) {
			var f = c.flags
			if (f & 2) {
				try {
					e: {
						for (var g = c.return; g !== null; ) {
							if (hI(g)) {
								var w = g
								break e
							}
							g = g.return
						}
						throw Error(n(160))
					}
					switch (w.tag) {
						case 5:
							var S = w.stateNode
							w.flags & 32 && (ct(S, ""), (w.flags &= -33))
							var M = mI(c)
							aC(c, M, S)
							break
						case 3:
						case 4:
							var j = w.stateNode.containerInfo,
								G = mI(c)
							iC(c, G, j)
							break
						default:
							throw Error(n(161))
					}
				} catch (Z) {
					$n(c, c.return, Z)
				}
				c.flags &= -3
			}
			f & 4096 && (c.flags &= -4097)
		}
		function hQ(c, f, g) {
			;(We = c), bI(c)
		}
		function bI(c, f, g) {
			for (var w = (c.mode & 1) !== 0; We !== null; ) {
				var S = We,
					M = S.child
				if (S.tag === 22 && w) {
					var j = S.memoizedState !== null || g0
					if (!j) {
						var G = S.alternate,
							Z = (G !== null && G.memoizedState !== null) || Qr
						G = g0
						var fe = Qr
						if (((g0 = j), (Qr = Z) && !fe))
							for (We = S; We !== null; )
								(j = We),
									(Z = j.child),
									j.tag === 22 && j.memoizedState !== null
										? EI(S)
										: Z !== null
										? ((Z.return = j), (We = Z))
										: EI(S)
						for (; M !== null; ) (We = M), bI(M), (M = M.sibling)
						;(We = S), (g0 = G), (Qr = fe)
					}
					xI(c)
				} else S.subtreeFlags & 8772 && M !== null ? ((M.return = S), (We = M)) : xI(c)
			}
		}
		function xI(c) {
			for (; We !== null; ) {
				var f = We
				if (f.flags & 8772) {
					var g = f.alternate
					try {
						if (f.flags & 8772)
							switch (f.tag) {
								case 0:
								case 11:
								case 15:
									Qr || y0(5, f)
									break
								case 1:
									var w = f.stateNode
									if (f.flags & 4 && !Qr)
										if (g === null) w.componentDidMount()
										else {
											var S =
												f.elementType === f.type ? g.memoizedProps : ao(f.type, g.memoizedProps)
											w.componentDidUpdate(
												S,
												g.memoizedState,
												w.__reactInternalSnapshotBeforeUpdate,
											)
										}
									var M = f.updateQueue
									M !== null && wM(f, M, w)
									break
								case 3:
									var j = f.updateQueue
									if (j !== null) {
										if (((g = null), f.child !== null))
											switch (f.child.tag) {
												case 5:
													g = f.child.stateNode
													break
												case 1:
													g = f.child.stateNode
											}
										wM(f, j, g)
									}
									break
								case 5:
									var G = f.stateNode
									if (g === null && f.flags & 4) {
										g = G
										var Z = f.memoizedProps
										switch (f.type) {
											case "button":
											case "input":
											case "select":
											case "textarea":
												Z.autoFocus && g.focus()
												break
											case "img":
												Z.src && (g.src = Z.src)
										}
									}
									break
								case 6:
									break
								case 4:
									break
								case 12:
									break
								case 13:
									if (f.memoizedState === null) {
										var fe = f.alternate
										if (fe !== null) {
											var Ce = fe.memoizedState
											if (Ce !== null) {
												var De = Ce.dehydrated
												De !== null && yh(De)
											}
										}
									}
									break
								case 19:
								case 17:
								case 21:
								case 22:
								case 23:
								case 25:
									break
								default:
									throw Error(n(163))
							}
						Qr || (f.flags & 512 && rC(f))
					} catch (xe) {
						$n(f, f.return, xe)
					}
				}
				if (f === c) {
					We = null
					break
				}
				if (((g = f.sibling), g !== null)) {
					;(g.return = f.return), (We = g)
					break
				}
				We = f.return
			}
		}
		function wI(c) {
			for (; We !== null; ) {
				var f = We
				if (f === c) {
					We = null
					break
				}
				var g = f.sibling
				if (g !== null) {
					;(g.return = f.return), (We = g)
					break
				}
				We = f.return
			}
		}
		function EI(c) {
			for (; We !== null; ) {
				var f = We
				try {
					switch (f.tag) {
						case 0:
						case 11:
						case 15:
							var g = f.return
							try {
								y0(4, f)
							} catch (Z) {
								$n(f, g, Z)
							}
							break
						case 1:
							var w = f.stateNode
							if (typeof w.componentDidMount == "function") {
								var S = f.return
								try {
									w.componentDidMount()
								} catch (Z) {
									$n(f, S, Z)
								}
							}
							var M = f.return
							try {
								rC(f)
							} catch (Z) {
								$n(f, M, Z)
							}
							break
						case 5:
							var j = f.return
							try {
								rC(f)
							} catch (Z) {
								$n(f, j, Z)
							}
					}
				} catch (Z) {
					$n(f, f.return, Z)
				}
				if (f === c) {
					We = null
					break
				}
				var G = f.sibling
				if (G !== null) {
					;(G.return = f.return), (We = G)
					break
				}
				We = f.return
			}
		}
		var mQ = Math.ceil,
			b0 = D.ReactCurrentDispatcher,
			oC = D.ReactCurrentOwner,
			Na = D.ReactCurrentBatchConfig,
			It = 0,
			Er = null,
			nr = null,
			Lr = 0,
			Zi = 0,
			uf = ql(0),
			pr = 0,
			$h = null,
			mc = 0,
			x0 = 0,
			sC = 0,
			Uh = null,
			Oi = null,
			lC = 0,
			cf = 1 / 0,
			Us = null,
			w0 = !1,
			uC = null,
			Ql = null,
			E0 = !1,
			Xl = null,
			C0 = 0,
			zh = 0,
			cC = null,
			T0 = -1,
			k0 = 0
		function di() {
			return It & 6 ? Gn() : T0 !== -1 ? T0 : (T0 = Gn())
		}
		function Jl(c) {
			return c.mode & 1
				? It & 2 && Lr !== 0
					? Lr & -Lr
					: JK.transition !== null
					? (k0 === 0 && (k0 = mN()), k0)
					: ((c = Zt), c !== 0 || ((c = window.event), (c = c === void 0 ? 16 : TN(c.type))), c)
				: 1
		}
		function lo(c, f, g, w) {
			if (50 < zh) throw ((zh = 0), (cC = null), Error(n(185)))
			ph(c, g, w),
				(!(It & 2) || c !== Er) &&
					(c === Er && (!(It & 2) && (x0 |= g), pr === 4 && Zl(c, Lr)),
					Ai(c, w),
					g === 1 && It === 0 && !(f.mode & 1) && ((cf = Gn() + 500), Zg && Wl()))
		}
		function Ai(c, f) {
			var g = c.callbackNode
			JG(c, f)
			var w = Rg(c, c === Er ? Lr : 0)
			if (w === 0) g !== null && Og(g), (c.callbackNode = null), (c.callbackPriority = 0)
			else if (((f = w & -w), c.callbackPriority !== f)) {
				if ((g != null && Og(g), f === 1))
					c.tag === 0 ? XK(TI.bind(null, c)) : uM(TI.bind(null, c)),
						YK(function () {
							!(It & 6) && Wl()
						}),
						(g = null)
				else {
					switch (vN(w)) {
						case 1:
							g = zw
							break
						case 4:
							g = pN
							break
						case 16:
							g = Ag
							break
						case 536870912:
							g = hN
							break
						default:
							g = Ag
					}
					g = MI(g, CI.bind(null, c))
				}
				;(c.callbackPriority = f), (c.callbackNode = g)
			}
		}
		function CI(c, f) {
			if (((T0 = -1), (k0 = 0), It & 6)) throw Error(n(327))
			var g = c.callbackNode
			if (df() && c.callbackNode !== g) return null
			var w = Rg(c, c === Er ? Lr : 0)
			if (w === 0) return null
			if (w & 30 || w & c.expiredLanes || f) f = S0(c, w)
			else {
				f = w
				var S = It
				It |= 2
				var M = SI()
				;(Er !== c || Lr !== f) && ((Us = null), (cf = Gn() + 500), gc(c, f))
				do
					try {
						yQ()
						break
					} catch (G) {
						kI(c, G)
					}
				while (!0)
				_E(), (b0.current = M), (It = S), nr !== null ? (f = 0) : ((Er = null), (Lr = 0), (f = pr))
			}
			if (f !== 0) {
				if ((f === 2 && ((S = qw(c)), S !== 0 && ((w = S), (f = dC(c, S)))), f === 1))
					throw ((g = $h), gc(c, 0), Zl(c, w), Ai(c, Gn()), g)
				if (f === 6) Zl(c, w)
				else {
					if (
						((S = c.current.alternate),
						!(w & 30) &&
							!vQ(S) &&
							((f = S0(c, w)),
							f === 2 && ((M = qw(c)), M !== 0 && ((w = M), (f = dC(c, M)))),
							f === 1))
					)
						throw ((g = $h), gc(c, 0), Zl(c, w), Ai(c, Gn()), g)
					switch (((c.finishedWork = S), (c.finishedLanes = w), f)) {
						case 0:
						case 1:
							throw Error(n(345))
						case 2:
							yc(c, Oi, Us)
							break
						case 3:
							if ((Zl(c, w), (w & 130023424) === w && ((f = lC + 500 - Gn()), 10 < f))) {
								if (Rg(c, 0) !== 0) break
								if (((S = c.suspendedLanes), (S & w) !== w)) {
									di(), (c.pingedLanes |= c.suspendedLanes & S)
									break
								}
								c.timeoutHandle = gE(yc.bind(null, c, Oi, Us), f)
								break
							}
							yc(c, Oi, Us)
							break
						case 4:
							if ((Zl(c, w), (w & 4194240) === w)) break
							for (f = c.eventTimes, S = -1; 0 < w; ) {
								var j = 31 - no(w)
								;(M = 1 << j), (j = f[j]), j > S && (S = j), (w &= ~M)
							}
							if (
								((w = S),
								(w = Gn() - w),
								(w =
									(120 > w
										? 120
										: 480 > w
										? 480
										: 1080 > w
										? 1080
										: 1920 > w
										? 1920
										: 3e3 > w
										? 3e3
										: 4320 > w
										? 4320
										: 1960 * mQ(w / 1960)) - w),
								10 < w)
							) {
								c.timeoutHandle = gE(yc.bind(null, c, Oi, Us), w)
								break
							}
							yc(c, Oi, Us)
							break
						case 5:
							yc(c, Oi, Us)
							break
						default:
							throw Error(n(329))
					}
				}
			}
			return Ai(c, Gn()), c.callbackNode === g ? CI.bind(null, c) : null
		}
		function dC(c, f) {
			var g = Uh
			return (
				c.current.memoizedState.isDehydrated && (gc(c, f).flags |= 256),
				(c = S0(c, f)),
				c !== 2 && ((f = Oi), (Oi = g), f !== null && fC(f)),
				c
			)
		}
		function fC(c) {
			Oi === null ? (Oi = c) : Oi.push.apply(Oi, c)
		}
		function vQ(c) {
			for (var f = c; ; ) {
				if (f.flags & 16384) {
					var g = f.updateQueue
					if (g !== null && ((g = g.stores), g !== null))
						for (var w = 0; w < g.length; w++) {
							var S = g[w],
								M = S.getSnapshot
							S = S.value
							try {
								if (!ro(M(), S)) return !1
							} catch {
								return !1
							}
						}
				}
				if (((g = f.child), f.subtreeFlags & 16384 && g !== null)) (g.return = f), (f = g)
				else {
					if (f === c) break
					for (; f.sibling === null; ) {
						if (f.return === null || f.return === c) return !0
						f = f.return
					}
					;(f.sibling.return = f.return), (f = f.sibling)
				}
			}
			return !0
		}
		function Zl(c, f) {
			for (
				f &= ~sC, f &= ~x0, c.suspendedLanes |= f, c.pingedLanes &= ~f, c = c.expirationTimes;
				0 < f;

			) {
				var g = 31 - no(f),
					w = 1 << g
				;(c[g] = -1), (f &= ~w)
			}
		}
		function TI(c) {
			if (It & 6) throw Error(n(327))
			df()
			var f = Rg(c, 0)
			if (!(f & 1)) return Ai(c, Gn()), null
			var g = S0(c, f)
			if (c.tag !== 0 && g === 2) {
				var w = qw(c)
				w !== 0 && ((f = w), (g = dC(c, w)))
			}
			if (g === 1) throw ((g = $h), gc(c, 0), Zl(c, f), Ai(c, Gn()), g)
			if (g === 6) throw Error(n(345))
			return (
				(c.finishedWork = c.current.alternate),
				(c.finishedLanes = f),
				yc(c, Oi, Us),
				Ai(c, Gn()),
				null
			)
		}
		function pC(c, f) {
			var g = It
			It |= 1
			try {
				return c(f)
			} finally {
				;(It = g), It === 0 && ((cf = Gn() + 500), Zg && Wl())
			}
		}
		function vc(c) {
			Xl !== null && Xl.tag === 0 && !(It & 6) && df()
			var f = It
			It |= 1
			var g = Na.transition,
				w = Zt
			try {
				if (((Na.transition = null), (Zt = 1), c)) return c()
			} finally {
				;(Zt = w), (Na.transition = g), (It = f), !(It & 6) && Wl()
			}
		}
		function hC() {
			;(Zi = uf.current), gn(uf)
		}
		function gc(c, f) {
			;(c.finishedWork = null), (c.finishedLanes = 0)
			var g = c.timeoutHandle
			if ((g !== -1 && ((c.timeoutHandle = -1), WK(g)), nr !== null))
				for (g = nr.return; g !== null; ) {
					var w = g
					switch ((CE(w), w.tag)) {
						case 1:
							;(w = w.type.childContextTypes), w != null && Xg()
							break
						case 3:
							of(), gn(Si), gn(Yr), PE()
							break
						case 5:
							RE(w)
							break
						case 4:
							of()
							break
						case 13:
							gn(Mn)
							break
						case 19:
							gn(Mn)
							break
						case 10:
							OE(w.type._context)
							break
						case 22:
						case 23:
							hC()
					}
					g = g.return
				}
			if (
				((Er = c),
				(nr = c = eu(c.current, null)),
				(Lr = Zi = f),
				(pr = 0),
				($h = null),
				(sC = x0 = mc = 0),
				(Oi = Uh = null),
				fc !== null)
			) {
				for (f = 0; f < fc.length; f++)
					if (((g = fc[f]), (w = g.interleaved), w !== null)) {
						g.interleaved = null
						var S = w.next,
							M = g.pending
						if (M !== null) {
							var j = M.next
							;(M.next = S), (w.next = j)
						}
						g.pending = w
					}
				fc = null
			}
			return c
		}
		function kI(c, f) {
			do {
				var g = nr
				try {
					if ((_E(), (u0.current = p0), c0)) {
						for (var w = In.memoizedState; w !== null; ) {
							var S = w.queue
							S !== null && (S.pending = null), (w = w.next)
						}
						c0 = !1
					}
					if (
						((hc = 0),
						(wr = fr = In = null),
						(Lh = !1),
						(Ph = 0),
						(oC.current = null),
						g === null || g.return === null)
					) {
						;(pr = 1), ($h = f), (nr = null)
						break
					}
					e: {
						var M = c,
							j = g.return,
							G = g,
							Z = f
						if (
							((f = Lr),
							(G.flags |= 32768),
							Z !== null && typeof Z == "object" && typeof Z.then == "function")
						) {
							var fe = Z,
								Ce = G,
								De = Ce.tag
							if (!(Ce.mode & 1) && (De === 0 || De === 11 || De === 15)) {
								var xe = Ce.alternate
								xe
									? ((Ce.updateQueue = xe.updateQueue),
									  (Ce.memoizedState = xe.memoizedState),
									  (Ce.lanes = xe.lanes))
									: ((Ce.updateQueue = null), (Ce.memoizedState = null))
							}
							var $e = QM(j)
							if ($e !== null) {
								;($e.flags &= -257),
									XM($e, j, G, M, f),
									$e.mode & 1 && KM(M, fe, f),
									(f = $e),
									(Z = fe)
								var Ye = f.updateQueue
								if (Ye === null) {
									var Ke = new Set()
									Ke.add(Z), (f.updateQueue = Ke)
								} else Ye.add(Z)
								break e
							} else {
								if (!(f & 1)) {
									KM(M, fe, f), mC()
									break e
								}
								Z = Error(n(426))
							}
						} else if (kn && G.mode & 1) {
							var Kn = QM(j)
							if (Kn !== null) {
								!(Kn.flags & 65536) && (Kn.flags |= 256), XM(Kn, j, G, M, f), SE(sf(Z, G))
								break e
							}
						}
						;(M = Z = sf(Z, G)),
							pr !== 4 && (pr = 2),
							Uh === null ? (Uh = [M]) : Uh.push(M),
							(M = j)
						do {
							switch (M.tag) {
								case 3:
									;(M.flags |= 65536), (f &= -f), (M.lanes |= f)
									var ae = YM(M, Z, f)
									xM(M, ae)
									break e
								case 1:
									G = Z
									var te = M.type,
										ce = M.stateNode
									if (
										!(M.flags & 128) &&
										(typeof te.getDerivedStateFromError == "function" ||
											(ce !== null &&
												typeof ce.componentDidCatch == "function" &&
												(Ql === null || !Ql.has(ce))))
									) {
										;(M.flags |= 65536), (f &= -f), (M.lanes |= f)
										var Ie = GM(M, G, f)
										xM(M, Ie)
										break e
									}
							}
							M = M.return
						} while (M !== null)
					}
					_I(g)
				} catch (Je) {
					;(f = Je), nr === g && g !== null && (nr = g = g.return)
					continue
				}
				break
			} while (!0)
		}
		function SI() {
			var c = b0.current
			return (b0.current = p0), c === null ? p0 : c
		}
		function mC() {
			;(pr === 0 || pr === 3 || pr === 2) && (pr = 4),
				Er === null || (!(mc & 268435455) && !(x0 & 268435455)) || Zl(Er, Lr)
		}
		function S0(c, f) {
			var g = It
			It |= 2
			var w = SI()
			;(Er !== c || Lr !== f) && ((Us = null), gc(c, f))
			do
				try {
					gQ()
					break
				} catch (S) {
					kI(c, S)
				}
			while (!0)
			if ((_E(), (It = g), (b0.current = w), nr !== null)) throw Error(n(261))
			return (Er = null), (Lr = 0), pr
		}
		function gQ() {
			for (; nr !== null; ) DI(nr)
		}
		function yQ() {
			for (; nr !== null && !fN(); ) DI(nr)
		}
		function DI(c) {
			var f = NI(c.alternate, c, Zi)
			;(c.memoizedProps = c.pendingProps), f === null ? _I(c) : (nr = f), (oC.current = null)
		}
		function _I(c) {
			var f = c
			do {
				var g = f.alternate
				if (((c = f.return), f.flags & 32768)) {
					if (((g = dQ(g, f)), g !== null)) {
						;(g.flags &= 32767), (nr = g)
						return
					}
					if (c !== null) (c.flags |= 32768), (c.subtreeFlags = 0), (c.deletions = null)
					else {
						;(pr = 6), (nr = null)
						return
					}
				} else if (((g = cQ(g, f, Zi)), g !== null)) {
					nr = g
					return
				}
				if (((f = f.sibling), f !== null)) {
					nr = f
					return
				}
				nr = f = c
			} while (f !== null)
			pr === 0 && (pr = 5)
		}
		function yc(c, f, g) {
			var w = Zt,
				S = Na.transition
			try {
				;(Na.transition = null), (Zt = 1), bQ(c, f, g, w)
			} finally {
				;(Na.transition = S), (Zt = w)
			}
			return null
		}
		function bQ(c, f, g, w) {
			do df()
			while (Xl !== null)
			if (It & 6) throw Error(n(327))
			g = c.finishedWork
			var S = c.finishedLanes
			if (g === null) return null
			if (((c.finishedWork = null), (c.finishedLanes = 0), g === c.current)) throw Error(n(177))
			;(c.callbackNode = null), (c.callbackPriority = 0)
			var M = g.lanes | g.childLanes
			if (
				(ZG(c, M),
				c === Er && ((nr = Er = null), (Lr = 0)),
				(!(g.subtreeFlags & 2064) && !(g.flags & 2064)) ||
					E0 ||
					((E0 = !0),
					MI(Ag, function () {
						return df(), null
					})),
				(M = (g.flags & 15990) !== 0),
				g.subtreeFlags & 15990 || M)
			) {
				;(M = Na.transition), (Na.transition = null)
				var j = Zt
				Zt = 1
				var G = It
				;(It |= 4),
					(oC.current = null),
					pQ(c, g),
					yI(g, c),
					BK(mE),
					(jg = !!hE),
					(mE = hE = null),
					(c.current = g),
					hQ(g),
					qG(),
					(It = G),
					(Zt = j),
					(Na.transition = M)
			} else c.current = g
			if (
				(E0 && ((E0 = !1), (Xl = c), (C0 = S)),
				(M = c.pendingLanes),
				M === 0 && (Ql = null),
				YG(g.stateNode),
				Ai(c, Gn()),
				f !== null)
			)
				for (w = c.onRecoverableError, g = 0; g < f.length; g++)
					(S = f[g]), w(S.value, { componentStack: S.stack, digest: S.digest })
			if (w0) throw ((w0 = !1), (c = uC), (uC = null), c)
			return (
				C0 & 1 && c.tag !== 0 && df(),
				(M = c.pendingLanes),
				M & 1 ? (c === cC ? zh++ : ((zh = 0), (cC = c))) : (zh = 0),
				Wl(),
				null
			)
		}
		function df() {
			if (Xl !== null) {
				var c = vN(C0),
					f = Na.transition,
					g = Zt
				try {
					if (((Na.transition = null), (Zt = 16 > c ? 16 : c), Xl === null)) var w = !1
					else {
						if (((c = Xl), (Xl = null), (C0 = 0), It & 6)) throw Error(n(331))
						var S = It
						for (It |= 4, We = c.current; We !== null; ) {
							var M = We,
								j = M.child
							if (We.flags & 16) {
								var G = M.deletions
								if (G !== null) {
									for (var Z = 0; Z < G.length; Z++) {
										var fe = G[Z]
										for (We = fe; We !== null; ) {
											var Ce = We
											switch (Ce.tag) {
												case 0:
												case 11:
												case 15:
													Hh(8, Ce, M)
											}
											var De = Ce.child
											if (De !== null) (De.return = Ce), (We = De)
											else
												for (; We !== null; ) {
													Ce = We
													var xe = Ce.sibling,
														$e = Ce.return
													if ((pI(Ce), Ce === fe)) {
														We = null
														break
													}
													if (xe !== null) {
														;(xe.return = $e), (We = xe)
														break
													}
													We = $e
												}
										}
									}
									var Ye = M.alternate
									if (Ye !== null) {
										var Ke = Ye.child
										if (Ke !== null) {
											Ye.child = null
											do {
												var Kn = Ke.sibling
												;(Ke.sibling = null), (Ke = Kn)
											} while (Ke !== null)
										}
									}
									We = M
								}
							}
							if (M.subtreeFlags & 2064 && j !== null) (j.return = M), (We = j)
							else
								e: for (; We !== null; ) {
									if (((M = We), M.flags & 2048))
										switch (M.tag) {
											case 0:
											case 11:
											case 15:
												Hh(9, M, M.return)
										}
									var ae = M.sibling
									if (ae !== null) {
										;(ae.return = M.return), (We = ae)
										break e
									}
									We = M.return
								}
						}
						var te = c.current
						for (We = te; We !== null; ) {
							j = We
							var ce = j.child
							if (j.subtreeFlags & 2064 && ce !== null) (ce.return = j), (We = ce)
							else
								e: for (j = te; We !== null; ) {
									if (((G = We), G.flags & 2048))
										try {
											switch (G.tag) {
												case 0:
												case 11:
												case 15:
													y0(9, G)
											}
										} catch (Je) {
											$n(G, G.return, Je)
										}
									if (G === j) {
										We = null
										break e
									}
									var Ie = G.sibling
									if (Ie !== null) {
										;(Ie.return = G.return), (We = Ie)
										break e
									}
									We = G.return
								}
						}
						if (((It = S), Wl(), Lo && typeof Lo.onPostCommitFiberRoot == "function"))
							try {
								Lo.onPostCommitFiberRoot(Ng, c)
							} catch {}
						w = !0
					}
					return w
				} finally {
					;(Zt = g), (Na.transition = f)
				}
			}
			return !1
		}
		function OI(c, f, g) {
			;(f = sf(g, f)),
				(f = YM(c, f, 1)),
				(c = Gl(c, f, 1)),
				(f = di()),
				c !== null && (ph(c, 1, f), Ai(c, f))
		}
		function $n(c, f, g) {
			if (c.tag === 3) OI(c, c, g)
			else
				for (; f !== null; ) {
					if (f.tag === 3) {
						OI(f, c, g)
						break
					} else if (f.tag === 1) {
						var w = f.stateNode
						if (
							typeof f.type.getDerivedStateFromError == "function" ||
							(typeof w.componentDidCatch == "function" && (Ql === null || !Ql.has(w)))
						) {
							;(c = sf(g, c)),
								(c = GM(f, c, 1)),
								(f = Gl(f, c, 1)),
								(c = di()),
								f !== null && (ph(f, 1, c), Ai(f, c))
							break
						}
					}
					f = f.return
				}
		}
		function xQ(c, f, g) {
			var w = c.pingCache
			w !== null && w.delete(f),
				(f = di()),
				(c.pingedLanes |= c.suspendedLanes & g),
				Er === c &&
					(Lr & g) === g &&
					(pr === 4 || (pr === 3 && (Lr & 130023424) === Lr && 500 > Gn() - lC)
						? gc(c, 0)
						: (sC |= g)),
				Ai(c, f)
		}
		function AI(c, f) {
			f === 0 &&
				(c.mode & 1 ? ((f = Ig), (Ig <<= 1), !(Ig & 130023424) && (Ig = 4194304)) : (f = 1))
			var g = di()
			;(c = Bs(c, f)), c !== null && (ph(c, f, g), Ai(c, g))
		}
		function wQ(c) {
			var f = c.memoizedState,
				g = 0
			f !== null && (g = f.retryLane), AI(c, g)
		}
		function EQ(c, f) {
			var g = 0
			switch (c.tag) {
				case 13:
					var w = c.stateNode,
						S = c.memoizedState
					S !== null && (g = S.retryLane)
					break
				case 19:
					w = c.stateNode
					break
				default:
					throw Error(n(314))
			}
			w !== null && w.delete(f), AI(c, g)
		}
		var NI
		NI = function (c, f, g) {
			if (c !== null)
				if (c.memoizedProps !== f.pendingProps || Si.current) _i = !0
				else {
					if (!(c.lanes & g) && !(f.flags & 128)) return (_i = !1), uQ(c, f, g)
					_i = !!(c.flags & 131072)
				}
			else (_i = !1), kn && f.flags & 1048576 && cM(f, t0, f.index)
			switch (((f.lanes = 0), f.tag)) {
				case 2:
					var w = f.type
					v0(c, f), (c = f.pendingProps)
					var S = Jd(f, Yr.current)
					af(f, g), (S = BE(null, f, w, c, S, g))
					var M = HE()
					return (
						(f.flags |= 1),
						typeof S == "object" &&
						S !== null &&
						typeof S.render == "function" &&
						S.$$typeof === void 0
							? ((f.tag = 1),
							  (f.memoizedState = null),
							  (f.updateQueue = null),
							  Di(w) ? ((M = !0), Jg(f)) : (M = !1),
							  (f.memoizedState = S.state !== null && S.state !== void 0 ? S.state : null),
							  ME(f),
							  (S.updater = h0),
							  (f.stateNode = S),
							  (S._reactInternals = f),
							  WE(f, w, c, g),
							  (f = QE(null, f, w, !0, M, g)))
							: ((f.tag = 0), kn && M && EE(f), ci(null, f, S, g), (f = f.child)),
						f
					)
				case 16:
					w = f.elementType
					e: {
						switch (
							(v0(c, f),
							(c = f.pendingProps),
							(S = w._init),
							(w = S(w._payload)),
							(f.type = w),
							(S = f.tag = TQ(w)),
							(c = ao(w, c)),
							S)
						) {
							case 0:
								f = KE(null, f, w, c, g)
								break e
							case 1:
								f = rI(null, f, w, c, g)
								break e
							case 11:
								f = JM(null, f, w, c, g)
								break e
							case 14:
								f = ZM(null, f, w, ao(w.type, c), g)
								break e
						}
						throw Error(n(306, w, ""))
					}
					return f
				case 0:
					return (
						(w = f.type),
						(S = f.pendingProps),
						(S = f.elementType === w ? S : ao(w, S)),
						KE(c, f, w, S, g)
					)
				case 1:
					return (
						(w = f.type),
						(S = f.pendingProps),
						(S = f.elementType === w ? S : ao(w, S)),
						rI(c, f, w, S, g)
					)
				case 3:
					e: {
						if ((iI(f), c === null)) throw Error(n(387))
						;(w = f.pendingProps),
							(M = f.memoizedState),
							(S = M.element),
							bM(c, f),
							s0(f, w, null, g)
						var j = f.memoizedState
						if (((w = j.element), M.isDehydrated))
							if (
								((M = {
									element: w,
									isDehydrated: !1,
									cache: j.cache,
									pendingSuspenseBoundaries: j.pendingSuspenseBoundaries,
									transitions: j.transitions,
								}),
								(f.updateQueue.baseState = M),
								(f.memoizedState = M),
								f.flags & 256)
							) {
								;(S = sf(Error(n(423)), f)), (f = aI(c, f, w, g, S))
								break e
							} else if (w !== S) {
								;(S = sf(Error(n(424)), f)), (f = aI(c, f, w, g, S))
								break e
							} else
								for (
									Ji = zl(f.stateNode.containerInfo.firstChild),
										Xi = f,
										kn = !0,
										io = null,
										g = gM(f, null, w, g),
										f.child = g;
									g;

								)
									(g.flags = (g.flags & -3) | 4096), (g = g.sibling)
						else {
							if ((tf(), w === S)) {
								f = $s(c, f, g)
								break e
							}
							ci(c, f, w, g)
						}
						f = f.child
					}
					return f
				case 5:
					return (
						EM(f),
						c === null && kE(f),
						(w = f.type),
						(S = f.pendingProps),
						(M = c !== null ? c.memoizedProps : null),
						(j = S.children),
						vE(w, S) ? (j = null) : M !== null && vE(w, M) && (f.flags |= 32),
						nI(c, f),
						ci(c, f, j, g),
						f.child
					)
				case 6:
					return c === null && kE(f), null
				case 13:
					return oI(c, f, g)
				case 4:
					return (
						IE(f, f.stateNode.containerInfo),
						(w = f.pendingProps),
						c === null ? (f.child = nf(f, null, w, g)) : ci(c, f, w, g),
						f.child
					)
				case 11:
					return (
						(w = f.type),
						(S = f.pendingProps),
						(S = f.elementType === w ? S : ao(w, S)),
						JM(c, f, w, S, g)
					)
				case 7:
					return ci(c, f, f.pendingProps, g), f.child
				case 8:
					return ci(c, f, f.pendingProps.children, g), f.child
				case 12:
					return ci(c, f, f.pendingProps.children, g), f.child
				case 10:
					e: {
						if (
							((w = f.type._context),
							(S = f.pendingProps),
							(M = f.memoizedProps),
							(j = S.value),
							dn(i0, w._currentValue),
							(w._currentValue = j),
							M !== null)
						)
							if (ro(M.value, j)) {
								if (M.children === S.children && !Si.current) {
									f = $s(c, f, g)
									break e
								}
							} else
								for (M = f.child, M !== null && (M.return = f); M !== null; ) {
									var G = M.dependencies
									if (G !== null) {
										j = M.child
										for (var Z = G.firstContext; Z !== null; ) {
											if (Z.context === w) {
												if (M.tag === 1) {
													;(Z = Hs(-1, g & -g)), (Z.tag = 2)
													var fe = M.updateQueue
													if (fe !== null) {
														fe = fe.shared
														var Ce = fe.pending
														Ce === null ? (Z.next = Z) : ((Z.next = Ce.next), (Ce.next = Z)),
															(fe.pending = Z)
													}
												}
												;(M.lanes |= g),
													(Z = M.alternate),
													Z !== null && (Z.lanes |= g),
													AE(M.return, g, f),
													(G.lanes |= g)
												break
											}
											Z = Z.next
										}
									} else if (M.tag === 10) j = M.type === f.type ? null : M.child
									else if (M.tag === 18) {
										if (((j = M.return), j === null)) throw Error(n(341))
										;(j.lanes |= g),
											(G = j.alternate),
											G !== null && (G.lanes |= g),
											AE(j, g, f),
											(j = M.sibling)
									} else j = M.child
									if (j !== null) j.return = M
									else
										for (j = M; j !== null; ) {
											if (j === f) {
												j = null
												break
											}
											if (((M = j.sibling), M !== null)) {
												;(M.return = j.return), (j = M)
												break
											}
											j = j.return
										}
									M = j
								}
						ci(c, f, S.children, g), (f = f.child)
					}
					return f
				case 9:
					return (
						(S = f.type),
						(w = f.pendingProps.children),
						af(f, g),
						(S = Oa(S)),
						(w = w(S)),
						(f.flags |= 1),
						ci(c, f, w, g),
						f.child
					)
				case 14:
					return (w = f.type), (S = ao(w, f.pendingProps)), (S = ao(w.type, S)), ZM(c, f, w, S, g)
				case 15:
					return eI(c, f, f.type, f.pendingProps, g)
				case 17:
					return (
						(w = f.type),
						(S = f.pendingProps),
						(S = f.elementType === w ? S : ao(w, S)),
						v0(c, f),
						(f.tag = 1),
						Di(w) ? ((c = !0), Jg(f)) : (c = !1),
						af(f, g),
						VM(f, w, S),
						WE(f, w, S, g),
						QE(null, f, w, !0, c, g)
					)
				case 19:
					return lI(c, f, g)
				case 22:
					return tI(c, f, g)
			}
			throw Error(n(156, f.tag))
		}
		function MI(c, f) {
			return dh(c, f)
		}
		function CQ(c, f, g, w) {
			;(this.tag = c),
				(this.key = g),
				(this.sibling =
					this.child =
					this.return =
					this.stateNode =
					this.type =
					this.elementType =
						null),
				(this.index = 0),
				(this.ref = null),
				(this.pendingProps = f),
				(this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null),
				(this.mode = w),
				(this.subtreeFlags = this.flags = 0),
				(this.deletions = null),
				(this.childLanes = this.lanes = 0),
				(this.alternate = null)
		}
		function Ma(c, f, g, w) {
			return new CQ(c, f, g, w)
		}
		function vC(c) {
			return (c = c.prototype), !(!c || !c.isReactComponent)
		}
		function TQ(c) {
			if (typeof c == "function") return vC(c) ? 1 : 0
			if (c != null) {
				if (((c = c.$$typeof), c === z)) return 11
				if (c === ne) return 14
			}
			return 2
		}
		function eu(c, f) {
			var g = c.alternate
			return (
				g === null
					? ((g = Ma(c.tag, f, c.key, c.mode)),
					  (g.elementType = c.elementType),
					  (g.type = c.type),
					  (g.stateNode = c.stateNode),
					  (g.alternate = c),
					  (c.alternate = g))
					: ((g.pendingProps = f),
					  (g.type = c.type),
					  (g.flags = 0),
					  (g.subtreeFlags = 0),
					  (g.deletions = null)),
				(g.flags = c.flags & 14680064),
				(g.childLanes = c.childLanes),
				(g.lanes = c.lanes),
				(g.child = c.child),
				(g.memoizedProps = c.memoizedProps),
				(g.memoizedState = c.memoizedState),
				(g.updateQueue = c.updateQueue),
				(f = c.dependencies),
				(g.dependencies = f === null ? null : { lanes: f.lanes, firstContext: f.firstContext }),
				(g.sibling = c.sibling),
				(g.index = c.index),
				(g.ref = c.ref),
				g
			)
		}
		function D0(c, f, g, w, S, M) {
			var j = 2
			if (((w = c), typeof c == "function")) vC(c) && (j = 1)
			else if (typeof c == "string") j = 5
			else
				e: switch (c) {
					case N:
						return bc(g.children, S, M, f)
					case I:
						;(j = 8), (S |= 8)
						break
					case P:
						return (c = Ma(12, g, f, S | 2)), (c.elementType = P), (c.lanes = M), c
					case V:
						return (c = Ma(13, g, f, S)), (c.elementType = V), (c.lanes = M), c
					case K:
						return (c = Ma(19, g, f, S)), (c.elementType = K), (c.lanes = M), c
					case ie:
						return _0(g, S, M, f)
					default:
						if (typeof c == "object" && c !== null)
							switch (c.$$typeof) {
								case L:
									j = 10
									break e
								case B:
									j = 9
									break e
								case z:
									j = 11
									break e
								case ne:
									j = 14
									break e
								case re:
									;(j = 16), (w = null)
									break e
							}
						throw Error(n(130, c == null ? c : typeof c, ""))
				}
			return (f = Ma(j, g, f, S)), (f.elementType = c), (f.type = w), (f.lanes = M), f
		}
		function bc(c, f, g, w) {
			return (c = Ma(7, c, w, f)), (c.lanes = g), c
		}
		function _0(c, f, g, w) {
			return (
				(c = Ma(22, c, w, f)),
				(c.elementType = ie),
				(c.lanes = g),
				(c.stateNode = { isHidden: !1 }),
				c
			)
		}
		function gC(c, f, g) {
			return (c = Ma(6, c, null, f)), (c.lanes = g), c
		}
		function yC(c, f, g) {
			return (
				(f = Ma(4, c.children !== null ? c.children : [], c.key, f)),
				(f.lanes = g),
				(f.stateNode = {
					containerInfo: c.containerInfo,
					pendingChildren: null,
					implementation: c.implementation,
				}),
				f
			)
		}
		function kQ(c, f, g, w, S) {
			;(this.tag = f),
				(this.containerInfo = c),
				(this.finishedWork = this.pingCache = this.current = this.pendingChildren = null),
				(this.timeoutHandle = -1),
				(this.callbackNode = this.pendingContext = this.context = null),
				(this.callbackPriority = 0),
				(this.eventTimes = Vw(0)),
				(this.expirationTimes = Vw(-1)),
				(this.entangledLanes =
					this.finishedLanes =
					this.mutableReadLanes =
					this.expiredLanes =
					this.pingedLanes =
					this.suspendedLanes =
					this.pendingLanes =
						0),
				(this.entanglements = Vw(0)),
				(this.identifierPrefix = w),
				(this.onRecoverableError = S),
				(this.mutableSourceEagerHydrationData = null)
		}
		function bC(c, f, g, w, S, M, j, G, Z) {
			return (
				(c = new kQ(c, f, g, G, Z)),
				f === 1 ? ((f = 1), M === !0 && (f |= 8)) : (f = 0),
				(M = Ma(3, null, null, f)),
				(c.current = M),
				(M.stateNode = c),
				(M.memoizedState = {
					element: w,
					isDehydrated: g,
					cache: null,
					transitions: null,
					pendingSuspenseBoundaries: null,
				}),
				ME(M),
				c
			)
		}
		function SQ(c, f, g) {
			var w = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null
			return {
				$$typeof: A,
				key: w == null ? null : "" + w,
				children: c,
				containerInfo: f,
				implementation: g,
			}
		}
		function II(c) {
			if (!c) return Vl
			c = c._reactInternals
			e: {
				if (St(c) !== c || c.tag !== 1) throw Error(n(170))
				var f = c
				do {
					switch (f.tag) {
						case 3:
							f = f.stateNode.context
							break e
						case 1:
							if (Di(f.type)) {
								f = f.stateNode.__reactInternalMemoizedMergedChildContext
								break e
							}
					}
					f = f.return
				} while (f !== null)
				throw Error(n(171))
			}
			if (c.tag === 1) {
				var g = c.type
				if (Di(g)) return sM(c, g, f)
			}
			return f
		}
		function RI(c, f, g, w, S, M, j, G, Z) {
			return (
				(c = bC(g, w, !0, c, S, M, j, G, Z)),
				(c.context = II(null)),
				(g = c.current),
				(w = di()),
				(S = Jl(g)),
				(M = Hs(w, S)),
				(M.callback = f ?? null),
				Gl(g, M, S),
				(c.current.lanes = S),
				ph(c, S, w),
				Ai(c, w),
				c
			)
		}
		function O0(c, f, g, w) {
			var S = f.current,
				M = di(),
				j = Jl(S)
			return (
				(g = II(g)),
				f.context === null ? (f.context = g) : (f.pendingContext = g),
				(f = Hs(M, j)),
				(f.payload = { element: c }),
				(w = w === void 0 ? null : w),
				w !== null && (f.callback = w),
				(c = Gl(S, f, j)),
				c !== null && (lo(c, S, j, M), o0(c, S, j)),
				j
			)
		}
		function A0(c) {
			if (((c = c.current), !c.child)) return null
			switch (c.child.tag) {
				case 5:
					return c.child.stateNode
				default:
					return c.child.stateNode
			}
		}
		function LI(c, f) {
			if (((c = c.memoizedState), c !== null && c.dehydrated !== null)) {
				var g = c.retryLane
				c.retryLane = g !== 0 && g < f ? g : f
			}
		}
		function xC(c, f) {
			LI(c, f), (c = c.alternate) && LI(c, f)
		}
		function DQ() {
			return null
		}
		var PI =
			typeof reportError == "function"
				? reportError
				: function (c) {
						console.error(c)
				  }
		function wC(c) {
			this._internalRoot = c
		}
		;(N0.prototype.render = wC.prototype.render =
			function (c) {
				var f = this._internalRoot
				if (f === null) throw Error(n(409))
				O0(c, f, null, null)
			}),
			(N0.prototype.unmount = wC.prototype.unmount =
				function () {
					var c = this._internalRoot
					if (c !== null) {
						this._internalRoot = null
						var f = c.containerInfo
						vc(function () {
							O0(null, c, null, null)
						}),
							(f[Ls] = null)
					}
				})
		function N0(c) {
			this._internalRoot = c
		}
		N0.prototype.unstable_scheduleHydration = function (c) {
			if (c) {
				var f = bN()
				c = { blockedOn: null, target: c, priority: f }
				for (var g = 0; g < Hl.length && f !== 0 && f < Hl[g].priority; g++);
				Hl.splice(g, 0, c), g === 0 && EN(c)
			}
		}
		function EC(c) {
			return !(!c || (c.nodeType !== 1 && c.nodeType !== 9 && c.nodeType !== 11))
		}
		function M0(c) {
			return !(
				!c ||
				(c.nodeType !== 1 &&
					c.nodeType !== 9 &&
					c.nodeType !== 11 &&
					(c.nodeType !== 8 || c.nodeValue !== " react-mount-point-unstable "))
			)
		}
		function jI() {}
		function _Q(c, f, g, w, S) {
			if (S) {
				if (typeof w == "function") {
					var M = w
					w = function () {
						var fe = A0(j)
						M.call(fe)
					}
				}
				var j = RI(f, w, c, 0, null, !1, !1, "", jI)
				return (
					(c._reactRootContainer = j),
					(c[Ls] = j.current),
					Dh(c.nodeType === 8 ? c.parentNode : c),
					vc(),
					j
				)
			}
			for (; (S = c.lastChild); ) c.removeChild(S)
			if (typeof w == "function") {
				var G = w
				w = function () {
					var fe = A0(Z)
					G.call(fe)
				}
			}
			var Z = bC(c, 0, !1, null, null, !1, !1, "", jI)
			return (
				(c._reactRootContainer = Z),
				(c[Ls] = Z.current),
				Dh(c.nodeType === 8 ? c.parentNode : c),
				vc(function () {
					O0(f, Z, g, w)
				}),
				Z
			)
		}
		function I0(c, f, g, w, S) {
			var M = g._reactRootContainer
			if (M) {
				var j = M
				if (typeof S == "function") {
					var G = S
					S = function () {
						var Z = A0(j)
						G.call(Z)
					}
				}
				O0(f, j, c, S)
			} else j = _Q(g, f, c, S, w)
			return A0(j)
		}
		;(gN = function (c) {
			switch (c.tag) {
				case 3:
					var f = c.stateNode
					if (f.current.memoizedState.isDehydrated) {
						var g = fh(f.pendingLanes)
						g !== 0 && (Ww(f, g | 1), Ai(f, Gn()), !(It & 6) && ((cf = Gn() + 500), Wl()))
					}
					break
				case 13:
					vc(function () {
						var w = Bs(c, 1)
						if (w !== null) {
							var S = di()
							lo(w, c, 1, S)
						}
					}),
						xC(c, 1)
			}
		}),
			(Yw = function (c) {
				if (c.tag === 13) {
					var f = Bs(c, 134217728)
					if (f !== null) {
						var g = di()
						lo(f, c, 134217728, g)
					}
					xC(c, 134217728)
				}
			}),
			(yN = function (c) {
				if (c.tag === 13) {
					var f = Jl(c),
						g = Bs(c, f)
					if (g !== null) {
						var w = di()
						lo(g, c, f, w)
					}
					xC(c, f)
				}
			}),
			(bN = function () {
				return Zt
			}),
			(xN = function (c, f) {
				var g = Zt
				try {
					return (Zt = c), f()
				} finally {
					Zt = g
				}
			}),
			(ic = function (c, f, g) {
				switch (f) {
					case "input":
						if ((sn(c, g), (f = g.name), g.type === "radio" && f != null)) {
							for (g = c; g.parentNode; ) g = g.parentNode
							for (
								g = g.querySelectorAll("input[name=" + JSON.stringify("" + f) + '][type="radio"]'),
									f = 0;
								f < g.length;
								f++
							) {
								var w = g[f]
								if (w !== c && w.form === c.form) {
									var S = Qg(w)
									if (!S) throw Error(n(90))
									mt(w), sn(w, S)
								}
							}
						}
						break
					case "textarea":
						pe(c, g)
						break
					case "select":
						;(f = g.value), f != null && mn(c, !!g.multiple, f, !1)
				}
			}),
			(ka = pC),
			(uh = vc)
		var OQ = { usingClientEntryPoint: !1, Events: [Ah, Qd, Qg, Hd, Dg, pC] },
			qh = {
				findFiberByHostInstance: lc,
				bundleType: 0,
				version: "18.3.1",
				rendererPackageName: "react-dom",
			},
			AQ = {
				bundleType: qh.bundleType,
				version: qh.version,
				rendererPackageName: qh.rendererPackageName,
				rendererConfig: qh.rendererConfig,
				overrideHookState: null,
				overrideHookStateDeletePath: null,
				overrideHookStateRenamePath: null,
				overrideProps: null,
				overridePropsDeletePath: null,
				overridePropsRenamePath: null,
				setErrorHandler: null,
				setSuspenseHandler: null,
				scheduleUpdate: null,
				currentDispatcherRef: D.ReactCurrentDispatcher,
				findHostInstanceByFiber: function (c) {
					return (c = Sa(c)), c === null ? null : c.stateNode
				},
				findFiberByHostInstance: qh.findFiberByHostInstance || DQ,
				findHostInstancesForRefresh: null,
				scheduleRefresh: null,
				scheduleRoot: null,
				setRefreshHandler: null,
				getCurrentFiber: null,
				reconcilerVersion: "18.3.1-next-f1338f8080-20240426",
			}
		if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
			var R0 = __REACT_DEVTOOLS_GLOBAL_HOOK__
			if (!R0.isDisabled && R0.supportsFiber)
				try {
					;(Ng = R0.inject(AQ)), (Lo = R0)
				} catch {}
		}
		return (
			(Ni.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = OQ),
			(Ni.createPortal = function (c, f) {
				var g = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null
				if (!EC(f)) throw Error(n(200))
				return SQ(c, f, null, g)
			}),
			(Ni.createRoot = function (c, f) {
				if (!EC(c)) throw Error(n(299))
				var g = !1,
					w = "",
					S = PI
				return (
					f != null &&
						(f.unstable_strictMode === !0 && (g = !0),
						f.identifierPrefix !== void 0 && (w = f.identifierPrefix),
						f.onRecoverableError !== void 0 && (S = f.onRecoverableError)),
					(f = bC(c, 1, !1, null, null, g, !1, w, S)),
					(c[Ls] = f.current),
					Dh(c.nodeType === 8 ? c.parentNode : c),
					new wC(f)
				)
			}),
			(Ni.findDOMNode = function (c) {
				if (c == null) return null
				if (c.nodeType === 1) return c
				var f = c._reactInternals
				if (f === void 0)
					throw typeof c.render == "function"
						? Error(n(188))
						: ((c = Object.keys(c).join(",")), Error(n(268, c)))
				return (c = Sa(f)), (c = c === null ? null : c.stateNode), c
			}),
			(Ni.flushSync = function (c) {
				return vc(c)
			}),
			(Ni.hydrate = function (c, f, g) {
				if (!M0(f)) throw Error(n(200))
				return I0(null, c, f, !0, g)
			}),
			(Ni.hydrateRoot = function (c, f, g) {
				if (!EC(c)) throw Error(n(405))
				var w = (g != null && g.hydratedSources) || null,
					S = !1,
					M = "",
					j = PI
				if (
					(g != null &&
						(g.unstable_strictMode === !0 && (S = !0),
						g.identifierPrefix !== void 0 && (M = g.identifierPrefix),
						g.onRecoverableError !== void 0 && (j = g.onRecoverableError)),
					(f = RI(f, null, c, 1, g ?? null, S, !1, M, j)),
					(c[Ls] = f.current),
					Dh(c),
					w)
				)
					for (c = 0; c < w.length; c++)
						(g = w[c]),
							(S = g._getVersion),
							(S = S(g._source)),
							f.mutableSourceEagerHydrationData == null
								? (f.mutableSourceEagerHydrationData = [g, S])
								: f.mutableSourceEagerHydrationData.push(g, S)
				return new N0(f)
			}),
			(Ni.render = function (c, f, g) {
				if (!M0(f)) throw Error(n(200))
				return I0(null, c, f, !1, g)
			}),
			(Ni.unmountComponentAtNode = function (c) {
				if (!M0(c)) throw Error(n(40))
				return c._reactRootContainer
					? (vc(function () {
							I0(null, null, c, !1, function () {
								;(c._reactRootContainer = null), (c[Ls] = null)
							})
					  }),
					  !0)
					: !1
			}),
			(Ni.unstable_batchedUpdates = pC),
			(Ni.unstable_renderSubtreeIntoContainer = function (c, f, g, w) {
				if (!M0(g)) throw Error(n(200))
				if (c == null || c._reactInternals === void 0) throw Error(n(38))
				return I0(c, f, g, !1, w)
			}),
			(Ni.version = "18.3.1-next-f1338f8080-20240426"),
			Ni
		)
	}
	var nR
	function dX() {
		if (nR) return _C.exports
		nR = 1
		function e() {
			if (
				!(
					typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" ||
					typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function"
				)
			)
				try {
					__REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(e)
				} catch (t) {
					console.error(t)
				}
		}
		return e(), (_C.exports = cX()), _C.exports
	}
	var $D = dX()
	const nl = Ti($D)
	var NC = { exports: {} },
		MC = {}
	/**
	 * @license React
	 * use-sync-external-store-with-selector.production.min.js
	 *
	 * Copyright (c) Facebook, Inc. and its affiliates.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */ var rR
	function fX() {
		if (rR) return MC
		rR = 1
		var e = sx()
		function t(l, u) {
			return (l === u && (l !== 0 || 1 / l === 1 / u)) || (l !== l && u !== u)
		}
		var n = typeof Object.is == "function" ? Object.is : t,
			r = e.useSyncExternalStore,
			i = e.useRef,
			a = e.useEffect,
			o = e.useMemo,
			s = e.useDebugValue
		return (
			(MC.useSyncExternalStoreWithSelector = function (l, u, d, p, m) {
				var v = i(null)
				if (v.current === null) {
					var y = { hasValue: !1, value: null }
					v.current = y
				} else y = v.current
				v = o(
					function () {
						function x(O) {
							if (!E) {
								if (((E = !0), (T = O), (O = p(O)), m !== void 0 && y.hasValue)) {
									var A = y.value
									if (m(A, O)) return (C = A)
								}
								return (C = O)
							}
							if (((A = C), n(T, O))) return A
							var N = p(O)
							return m !== void 0 && m(A, N) ? A : ((T = O), (C = N))
						}
						var E = !1,
							T,
							C,
							D = d === void 0 ? null : d
						return [
							function () {
								return x(u())
							},
							D === null
								? void 0
								: function () {
										return x(D())
								  },
						]
					},
					[u, d, p, m],
				)
				var b = r(l, v[0], v[1])
				return (
					a(
						function () {
							;(y.hasValue = !0), (y.value = b)
						},
						[b],
					),
					s(b),
					b
				)
			}),
			MC
		)
	}
	var iR
	function pX() {
		return iR || ((iR = 1), (NC.exports = fX())), NC.exports
	}
	var hX = pX(),
		ua = "default" in CS ? H : CS,
		aR = Symbol.for("react-redux-context"),
		oR = typeof globalThis < "u" ? globalThis : {}
	function mX() {
		if (!ua.createContext) return {}
		const e = oR[aR] ?? (oR[aR] = new Map())
		let t = e.get(ua.createContext)
		return t || ((t = ua.createContext(null)), e.set(ua.createContext, t)), t
	}
	var Mu = mX(),
		vX = () => {
			throw new Error("uSES not initialized!")
		}
	function UD(e = Mu) {
		return function () {
			return ua.useContext(e)
		}
	}
	var m8 = UD(),
		v8 = vX,
		gX = (e) => {
			v8 = e
		},
		yX = (e, t) => e === t
	function bX(e = Mu) {
		const t = e === Mu ? m8 : UD(e),
			n = (r, i = {}) => {
				const { equalityFn: a = yX, devModeChecks: o = {} } =
						typeof i == "function" ? { equalityFn: i } : i,
					{
						store: s,
						subscription: l,
						getServerState: u,
						stabilityCheck: d,
						identityFunctionCheck: p,
					} = t()
				ua.useRef(!0)
				const m = ua.useCallback(
						{
							[r.name](y) {
								return r(y)
							},
						}[r.name],
						[r, d, o.stabilityCheck],
					),
					v = v8(l.addNestedSub, s.getState, u || s.getState, m, a)
				return ua.useDebugValue(v), v
			}
		return Object.assign(n, { withTypes: () => n }), n
	}
	var Up = bX()
	function g8(e) {
		e()
	}
	function xX() {
		let e = null,
			t = null
		return {
			clear() {
				;(e = null), (t = null)
			},
			notify() {
				g8(() => {
					let n = e
					for (; n; ) n.callback(), (n = n.next)
				})
			},
			get() {
				const n = []
				let r = e
				for (; r; ) n.push(r), (r = r.next)
				return n
			},
			subscribe(n) {
				let r = !0
				const i = (t = { callback: n, next: null, prev: t })
				return (
					i.prev ? (i.prev.next = i) : (e = i),
					function () {
						!r ||
							e === null ||
							((r = !1),
							i.next ? (i.next.prev = i.prev) : (t = i.prev),
							i.prev ? (i.prev.next = i.next) : (e = i.next))
					}
				)
			},
		}
	}
	var sR = { notify() {}, get: () => [] }
	function wX(e, t) {
		let n,
			r = sR,
			i = 0,
			a = !1
		function o(b) {
			d()
			const x = r.subscribe(b)
			let E = !1
			return () => {
				E || ((E = !0), x(), p())
			}
		}
		function s() {
			r.notify()
		}
		function l() {
			y.onStateChange && y.onStateChange()
		}
		function u() {
			return a
		}
		function d() {
			i++, n || ((n = e.subscribe(l)), (r = xX()))
		}
		function p() {
			i--, n && i === 0 && (n(), (n = void 0), r.clear(), (r = sR))
		}
		function m() {
			a || ((a = !0), d())
		}
		function v() {
			a && ((a = !1), p())
		}
		const y = {
			addNestedSub: o,
			notifyNestedSubs: s,
			handleChangeWrapper: l,
			isSubscribed: u,
			trySubscribe: m,
			tryUnsubscribe: v,
			getListeners: () => r,
		}
		return y
	}
	var EX =
			typeof window < "u" &&
			typeof window.document < "u" &&
			typeof window.document.createElement < "u",
		CX = typeof navigator < "u" && navigator.product === "ReactNative",
		TX = EX || CX ? ua.useLayoutEffect : ua.useEffect
	function lR(e, t) {
		return e === t ? e !== 0 || t !== 0 || 1 / e === 1 / t : e !== e && t !== t
	}
	function Om(e, t) {
		if (lR(e, t)) return !0
		if (typeof e != "object" || e === null || typeof t != "object" || t === null) return !1
		const n = Object.keys(e),
			r = Object.keys(t)
		if (n.length !== r.length) return !1
		for (let i = 0; i < n.length; i++)
			if (!Object.prototype.hasOwnProperty.call(t, n[i]) || !lR(e[n[i]], t[n[i]])) return !1
		return !0
	}
	function kX({
		store: e,
		context: t,
		children: n,
		serverState: r,
		stabilityCheck: i = "once",
		identityFunctionCheck: a = "once",
	}) {
		const o = ua.useMemo(() => {
				const u = wX(e)
				return {
					store: e,
					subscription: u,
					getServerState: r ? () => r : void 0,
					stabilityCheck: i,
					identityFunctionCheck: a,
				}
			}, [e, r, i, a]),
			s = ua.useMemo(() => e.getState(), [e])
		TX(() => {
			const { subscription: u } = o
			return (
				(u.onStateChange = u.notifyNestedSubs),
				u.trySubscribe(),
				s !== e.getState() && u.notifyNestedSubs(),
				() => {
					u.tryUnsubscribe(), (u.onStateChange = void 0)
				}
			)
		}, [o, s])
		const l = t || Mu
		return ua.createElement(l.Provider, { value: o }, n)
	}
	var SX = kX
	function y8(e = Mu) {
		const t = e === Mu ? m8 : UD(e),
			n = () => {
				const { store: r } = t()
				return r
			}
		return Object.assign(n, { withTypes: () => n }), n
	}
	var b8 = y8()
	function DX(e = Mu) {
		const t = e === Mu ? b8 : y8(e),
			n = () => t().dispatch
		return Object.assign(n, { withTypes: () => n }), n
	}
	var zD = DX(),
		_X = g8
	gX(hX.useSyncExternalStoreWithSelector)
	var Wh = {},
		uR
	function OX() {
		if (uR) return Wh
		;(uR = 1),
			Object.defineProperty(Wh, "__esModule", { value: !0 }),
			(Wh.parse = o),
			(Wh.serialize = u)
		const e = /^[\u0021-\u003A\u003C\u003E-\u007E]+$/,
			t = /^[\u0021-\u003A\u003C-\u007E]*$/,
			n = /^([.]?[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)([.][a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)*$/i,
			r = /^[\u0020-\u003A\u003D-\u007E]*$/,
			i = Object.prototype.toString,
			a = (() => {
				const m = function () {}
				return (m.prototype = Object.create(null)), m
			})()
		function o(m, v) {
			const y = new a(),
				b = m.length
			if (b < 2) return y
			const x = (v == null ? void 0 : v.decode) || d
			let E = 0
			do {
				const T = m.indexOf("=", E)
				if (T === -1) break
				const C = m.indexOf(";", E),
					D = C === -1 ? b : C
				if (T > D) {
					E = m.lastIndexOf(";", T - 1) + 1
					continue
				}
				const O = s(m, E, T),
					A = l(m, T, O),
					N = m.slice(O, A)
				if (y[N] === void 0) {
					let I = s(m, T + 1, D),
						P = l(m, D, I)
					const L = x(m.slice(I, P))
					y[N] = L
				}
				E = D + 1
			} while (E < b)
			return y
		}
		function s(m, v, y) {
			do {
				const b = m.charCodeAt(v)
				if (b !== 32 && b !== 9) return v
			} while (++v < y)
			return y
		}
		function l(m, v, y) {
			for (; v > y; ) {
				const b = m.charCodeAt(--v)
				if (b !== 32 && b !== 9) return v + 1
			}
			return y
		}
		function u(m, v, y) {
			const b = (y == null ? void 0 : y.encode) || encodeURIComponent
			if (!e.test(m)) throw new TypeError(`argument name is invalid: ${m}`)
			const x = b(v)
			if (!t.test(x)) throw new TypeError(`argument val is invalid: ${v}`)
			let E = m + "=" + x
			if (!y) return E
			if (y.maxAge !== void 0) {
				if (!Number.isInteger(y.maxAge))
					throw new TypeError(`option maxAge is invalid: ${y.maxAge}`)
				E += "; Max-Age=" + y.maxAge
			}
			if (y.domain) {
				if (!n.test(y.domain)) throw new TypeError(`option domain is invalid: ${y.domain}`)
				E += "; Domain=" + y.domain
			}
			if (y.path) {
				if (!r.test(y.path)) throw new TypeError(`option path is invalid: ${y.path}`)
				E += "; Path=" + y.path
			}
			if (y.expires) {
				if (!p(y.expires) || !Number.isFinite(y.expires.valueOf()))
					throw new TypeError(`option expires is invalid: ${y.expires}`)
				E += "; Expires=" + y.expires.toUTCString()
			}
			if (
				(y.httpOnly && (E += "; HttpOnly"),
				y.secure && (E += "; Secure"),
				y.partitioned && (E += "; Partitioned"),
				y.priority)
			)
				switch (typeof y.priority == "string" ? y.priority.toLowerCase() : void 0) {
					case "low":
						E += "; Priority=Low"
						break
					case "medium":
						E += "; Priority=Medium"
						break
					case "high":
						E += "; Priority=High"
						break
					default:
						throw new TypeError(`option priority is invalid: ${y.priority}`)
				}
			if (y.sameSite)
				switch (typeof y.sameSite == "string" ? y.sameSite.toLowerCase() : y.sameSite) {
					case !0:
					case "strict":
						E += "; SameSite=Strict"
						break
					case "lax":
						E += "; SameSite=Lax"
						break
					case "none":
						E += "; SameSite=None"
						break
					default:
						throw new TypeError(`option sameSite is invalid: ${y.sameSite}`)
				}
			return E
		}
		function d(m) {
			if (m.indexOf("%") === -1) return m
			try {
				return decodeURIComponent(m)
			} catch {
				return m
			}
		}
		function p(m) {
			return i.call(m) === "[object Date]"
		}
		return Wh
	}
	OX()
	/**
	 * react-router v7.0.1
	 *
	 * Copyright (c) Remix Software Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE.md file in the root directory of this source tree.
	 *
	 * @license MIT
	 */ var cR = "popstate"
	function AX(e = {}) {
		function t(r, i) {
			let { pathname: a, search: o, hash: s } = r.location
			return kS(
				"",
				{ pathname: a, search: o, hash: s },
				(i.state && i.state.usr) || null,
				(i.state && i.state.key) || "default",
			)
		}
		function n(r, i) {
			return typeof i == "string" ? i : ev(i)
		}
		return MX(t, n, null, e)
	}
	function jn(e, t) {
		if (e === !1 || e === null || typeof e > "u") throw new Error(t)
	}
	function Yu(e, t) {
		if (!e) {
			typeof console < "u" && console.warn(t)
			try {
				throw new Error(t)
			} catch {}
		}
	}
	function NX() {
		return Math.random().toString(36).substring(2, 10)
	}
	function dR(e, t) {
		return { usr: e.state, key: e.key, idx: t }
	}
	function kS(e, t, n = null, r) {
		return {
			pathname: typeof e == "string" ? e : e.pathname,
			search: "",
			hash: "",
			...(typeof t == "string" ? zp(t) : t),
			state: n,
			key: (t && t.key) || r || NX(),
		}
	}
	function ev({ pathname: e = "/", search: t = "", hash: n = "" }) {
		return (
			t && t !== "?" && (e += t.charAt(0) === "?" ? t : "?" + t),
			n && n !== "#" && (e += n.charAt(0) === "#" ? n : "#" + n),
			e
		)
	}
	function zp(e) {
		let t = {}
		if (e) {
			let n = e.indexOf("#")
			n >= 0 && ((t.hash = e.substring(n)), (e = e.substring(0, n)))
			let r = e.indexOf("?")
			r >= 0 && ((t.search = e.substring(r)), (e = e.substring(0, r))), e && (t.pathname = e)
		}
		return t
	}
	function MX(e, t, n, r = {}) {
		let { window: i = document.defaultView, v5Compat: a = !1 } = r,
			o = i.history,
			s = "POP",
			l = null,
			u = d()
		u == null && ((u = 0), o.replaceState({ ...o.state, idx: u }, ""))
		function d() {
			return (o.state || { idx: null }).idx
		}
		function p() {
			s = "POP"
			let x = d(),
				E = x == null ? null : x - u
			;(u = x), l && l({ action: s, location: b.location, delta: E })
		}
		function m(x, E) {
			s = "PUSH"
			let T = kS(b.location, x, E)
			u = d() + 1
			let C = dR(T, u),
				D = b.createHref(T)
			try {
				o.pushState(C, "", D)
			} catch (O) {
				if (O instanceof DOMException && O.name === "DataCloneError") throw O
				i.location.assign(D)
			}
			a && l && l({ action: s, location: b.location, delta: 1 })
		}
		function v(x, E) {
			s = "REPLACE"
			let T = kS(b.location, x, E)
			u = d()
			let C = dR(T, u),
				D = b.createHref(T)
			o.replaceState(C, "", D), a && l && l({ action: s, location: b.location, delta: 0 })
		}
		function y(x) {
			let E = i.location.origin !== "null" ? i.location.origin : i.location.href,
				T = typeof x == "string" ? x : ev(x)
			return (
				(T = T.replace(/ $/, "%20")),
				jn(E, `No window.location.(origin|href) available to create URL for href: ${T}`),
				new URL(T, E)
			)
		}
		let b = {
			get action() {
				return s
			},
			get location() {
				return e(i, o)
			},
			listen(x) {
				if (l) throw new Error("A history only accepts one active listener")
				return (
					i.addEventListener(cR, p),
					(l = x),
					() => {
						i.removeEventListener(cR, p), (l = null)
					}
				)
			},
			createHref(x) {
				return t(i, x)
			},
			createURL: y,
			encodeLocation(x) {
				let E = y(x)
				return { pathname: E.pathname, search: E.search, hash: E.hash }
			},
			push: m,
			replace: v,
			go(x) {
				return o.go(x)
			},
		}
		return b
	}
	function x8(e, t, n = "/") {
		return IX(e, t, n, !1)
	}
	function IX(e, t, n, r) {
		let i = typeof t == "string" ? zp(t) : t,
			a = Iu(i.pathname || "/", n)
		if (a == null) return null
		let o = w8(e)
		RX(o)
		let s = null
		for (let l = 0; s == null && l < o.length; ++l) {
			let u = VX(a)
			s = zX(o[l], u, r)
		}
		return s
	}
	function w8(e, t = [], n = [], r = "") {
		let i = (a, o, s) => {
			let l = {
				relativePath: s === void 0 ? a.path || "" : s,
				caseSensitive: a.caseSensitive === !0,
				childrenIndex: o,
				route: a,
			}
			l.relativePath.startsWith("/") &&
				(jn(
					l.relativePath.startsWith(r),
					`Absolute route path "${l.relativePath}" nested under path "${r}" is not valid. An absolute child route path must start with the combined path of all its parent routes.`,
				),
				(l.relativePath = l.relativePath.slice(r.length)))
			let u = sl([r, l.relativePath]),
				d = n.concat(l)
			a.children &&
				a.children.length > 0 &&
				(jn(
					a.index !== !0,
					`Index routes must not have child routes. Please remove all child routes from route path "${u}".`,
				),
				w8(a.children, t, d, u)),
				!(a.path == null && !a.index) && t.push({ path: u, score: $X(u, a.index), routesMeta: d })
		}
		return (
			e.forEach((a, o) => {
				var s
				if (a.path === "" || !((s = a.path) != null && s.includes("?"))) i(a, o)
				else for (let l of E8(a.path)) i(a, o, l)
			}),
			t
		)
	}
	function E8(e) {
		let t = e.split("/")
		if (t.length === 0) return []
		let [n, ...r] = t,
			i = n.endsWith("?"),
			a = n.replace(/\?$/, "")
		if (r.length === 0) return i ? [a, ""] : [a]
		let o = E8(r.join("/")),
			s = []
		return (
			s.push(...o.map((l) => (l === "" ? a : [a, l].join("/")))),
			i && s.push(...o),
			s.map((l) => (e.startsWith("/") && l === "" ? "/" : l))
		)
	}
	function RX(e) {
		e.sort((t, n) =>
			t.score !== n.score
				? n.score - t.score
				: UX(
						t.routesMeta.map((r) => r.childrenIndex),
						n.routesMeta.map((r) => r.childrenIndex),
				  ),
		)
	}
	var LX = /^:[\w-]+$/,
		PX = 3,
		jX = 2,
		FX = 1,
		BX = 10,
		HX = -2,
		fR = (e) => e === "*"
	function $X(e, t) {
		let n = e.split("/"),
			r = n.length
		return (
			n.some(fR) && (r += HX),
			t && (r += jX),
			n.filter((i) => !fR(i)).reduce((i, a) => i + (LX.test(a) ? PX : a === "" ? FX : BX), r)
		)
	}
	function UX(e, t) {
		return e.length === t.length && e.slice(0, -1).every((r, i) => r === t[i])
			? e[e.length - 1] - t[t.length - 1]
			: 0
	}
	function zX(e, t, n = !1) {
		let { routesMeta: r } = e,
			i = {},
			a = "/",
			o = []
		for (let s = 0; s < r.length; ++s) {
			let l = r[s],
				u = s === r.length - 1,
				d = a === "/" ? t : t.slice(a.length) || "/",
				p = A1({ path: l.relativePath, caseSensitive: l.caseSensitive, end: u }, d),
				m = l.route
			if (
				(!p &&
					u &&
					n &&
					!r[r.length - 1].route.index &&
					(p = A1({ path: l.relativePath, caseSensitive: l.caseSensitive, end: !1 }, d)),
				!p)
			)
				return null
			Object.assign(i, p.params),
				o.push({
					params: i,
					pathname: sl([a, p.pathname]),
					pathnameBase: KX(sl([a, p.pathnameBase])),
					route: m,
				}),
				p.pathnameBase !== "/" && (a = sl([a, p.pathnameBase]))
		}
		return o
	}
	function A1(e, t) {
		typeof e == "string" && (e = { path: e, caseSensitive: !1, end: !0 })
		let [n, r] = qX(e.path, e.caseSensitive, e.end),
			i = t.match(n)
		if (!i) return null
		let a = i[0],
			o = a.replace(/(.)\/+$/, "$1"),
			s = i.slice(1)
		return {
			params: r.reduce((u, { paramName: d, isOptional: p }, m) => {
				if (d === "*") {
					let y = s[m] || ""
					o = a.slice(0, a.length - y.length).replace(/(.)\/+$/, "$1")
				}
				const v = s[m]
				return p && !v ? (u[d] = void 0) : (u[d] = (v || "").replace(/%2F/g, "/")), u
			}, {}),
			pathname: a,
			pathnameBase: o,
			pattern: e,
		}
	}
	function qX(e, t = !1, n = !0) {
		Yu(
			e === "*" || !e.endsWith("*") || e.endsWith("/*"),
			`Route path "${e}" will be treated as if it were "${e.replace(
				/\*$/,
				"/*",
			)}" because the \`*\` character must always follow a \`/\` in the pattern. To get rid of this warning, please change the route path to "${e.replace(
				/\*$/,
				"/*",
			)}".`,
		)
		let r = [],
			i =
				"^" +
				e
					.replace(/\/*\*?$/, "")
					.replace(/^\/*/, "/")
					.replace(/[\\.*+^${}|()[\]]/g, "\\$&")
					.replace(
						/\/:([\w-]+)(\?)?/g,
						(o, s, l) => (
							r.push({ paramName: s, isOptional: l != null }), l ? "/?([^\\/]+)?" : "/([^\\/]+)"
						),
					)
		return (
			e.endsWith("*")
				? (r.push({ paramName: "*" }),
				  (i += e === "*" || e === "/*" ? "(.*)$" : "(?:\\/(.+)|\\/*)$"))
				: n
				? (i += "\\/*$")
				: e !== "" && e !== "/" && (i += "(?:(?=\\/|$))"),
			[new RegExp(i, t ? void 0 : "i"), r]
		)
	}
	function VX(e) {
		try {
			return e
				.split("/")
				.map((t) => decodeURIComponent(t).replace(/\//g, "%2F"))
				.join("/")
		} catch (t) {
			return (
				Yu(
					!1,
					`The URL path "${e}" could not be decoded because it is is a malformed URL segment. This is probably due to a bad percent encoding (${t}).`,
				),
				e
			)
		}
	}
	function Iu(e, t) {
		if (t === "/") return e
		if (!e.toLowerCase().startsWith(t.toLowerCase())) return null
		let n = t.endsWith("/") ? t.length - 1 : t.length,
			r = e.charAt(n)
		return r && r !== "/" ? null : e.slice(n) || "/"
	}
	function WX(e, t = "/") {
		let { pathname: n, search: r = "", hash: i = "" } = typeof e == "string" ? zp(e) : e
		return { pathname: n ? (n.startsWith("/") ? n : YX(n, t)) : t, search: QX(r), hash: XX(i) }
	}
	function YX(e, t) {
		let n = t.replace(/\/+$/, "").split("/")
		return (
			e.split("/").forEach((i) => {
				i === ".." ? n.length > 1 && n.pop() : i !== "." && n.push(i)
			}),
			n.length > 1 ? n.join("/") : "/"
		)
	}
	function IC(e, t, n, r) {
		return `Cannot include a '${e}' character in a manually specified \`to.${t}\` field [${JSON.stringify(
			r,
		)}].  Please separate it out to the \`to.${n}\` field. Alternatively you may provide the full path as a string in <Link to="..."> and the router will parse it for you.`
	}
	function GX(e) {
		return e.filter((t, n) => n === 0 || (t.route.path && t.route.path.length > 0))
	}
	function C8(e) {
		let t = GX(e)
		return t.map((n, r) => (r === t.length - 1 ? n.pathname : n.pathnameBase))
	}
	function T8(e, t, n, r = !1) {
		let i
		typeof e == "string"
			? (i = zp(e))
			: ((i = { ...e }),
			  jn(!i.pathname || !i.pathname.includes("?"), IC("?", "pathname", "search", i)),
			  jn(!i.pathname || !i.pathname.includes("#"), IC("#", "pathname", "hash", i)),
			  jn(!i.search || !i.search.includes("#"), IC("#", "search", "hash", i)))
		let a = e === "" || i.pathname === "",
			o = a ? "/" : i.pathname,
			s
		if (o == null) s = n
		else {
			let p = t.length - 1
			if (!r && o.startsWith("..")) {
				let m = o.split("/")
				for (; m[0] === ".."; ) m.shift(), (p -= 1)
				i.pathname = m.join("/")
			}
			s = p >= 0 ? t[p] : "/"
		}
		let l = WX(i, s),
			u = o && o !== "/" && o.endsWith("/"),
			d = (a || o === ".") && n.endsWith("/")
		return !l.pathname.endsWith("/") && (u || d) && (l.pathname += "/"), l
	}
	var sl = (e) => e.join("/").replace(/\/\/+/g, "/"),
		KX = (e) => e.replace(/\/+$/, "").replace(/^\/*/, "/"),
		QX = (e) => (!e || e === "?" ? "" : e.startsWith("?") ? e : "?" + e),
		XX = (e) => (!e || e === "#" ? "" : e.startsWith("#") ? e : "#" + e)
	function JX(e) {
		return (
			e != null &&
			typeof e.status == "number" &&
			typeof e.statusText == "string" &&
			typeof e.internal == "boolean" &&
			"data" in e
		)
	}
	var k8 = ["POST", "PUT", "PATCH", "DELETE"]
	new Set(k8)
	var ZX = ["GET", ...k8]
	new Set(ZX)
	var qp = _.createContext(null)
	qp.displayName = "DataRouter"
	var lx = _.createContext(null)
	lx.displayName = "DataRouterState"
	var S8 = _.createContext({ isTransitioning: !1 })
	S8.displayName = "ViewTransition"
	var eJ = _.createContext(new Map())
	eJ.displayName = "Fetchers"
	var tJ = _.createContext(null)
	tJ.displayName = "Await"
	var xs = _.createContext(null)
	xs.displayName = "Navigation"
	var zv = _.createContext(null)
	zv.displayName = "Location"
	var Mo = _.createContext({ outlet: null, matches: [], isDataRoute: !1 })
	Mo.displayName = "Route"
	var qD = _.createContext(null)
	qD.displayName = "RouteError"
	function nJ(e, { relative: t } = {}) {
		jn(qv(), "useHref() may be used only in the context of a <Router> component.")
		let { basename: n, navigator: r } = _.useContext(xs),
			{ hash: i, pathname: a, search: o } = Vv(e, { relative: t }),
			s = a
		return (
			n !== "/" && (s = a === "/" ? n : sl([n, a])),
			r.createHref({ pathname: s, search: o, hash: i })
		)
	}
	function qv() {
		return _.useContext(zv) != null
	}
	function Ea() {
		return (
			jn(qv(), "useLocation() may be used only in the context of a <Router> component."),
			_.useContext(zv).location
		)
	}
	var D8 =
		"You should call navigate() in a React.useEffect(), not when your component is first rendered."
	function _8(e) {
		_.useContext(xs).static || _.useLayoutEffect(e)
	}
	function Xa() {
		let { isDataRoute: e } = _.useContext(Mo)
		return e ? gJ() : rJ()
	}
	function rJ() {
		jn(qv(), "useNavigate() may be used only in the context of a <Router> component.")
		let e = _.useContext(qp),
			{ basename: t, navigator: n } = _.useContext(xs),
			{ matches: r } = _.useContext(Mo),
			{ pathname: i } = Ea(),
			a = JSON.stringify(C8(r)),
			o = _.useRef(!1)
		return (
			_8(() => {
				o.current = !0
			}),
			_.useCallback(
				(l, u = {}) => {
					if ((Yu(o.current, D8), !o.current)) return
					if (typeof l == "number") {
						n.go(l)
						return
					}
					let d = T8(l, JSON.parse(a), i, u.relative === "path")
					e == null && t !== "/" && (d.pathname = d.pathname === "/" ? t : sl([t, d.pathname])),
						(u.replace ? n.replace : n.push)(d, u.state, u)
				},
				[t, n, a, i, e],
			)
		)
	}
	var iJ = _.createContext(null)
	function aJ(e) {
		let t = _.useContext(Mo).outlet
		return t && _.createElement(iJ.Provider, { value: e }, t)
	}
	function Sl() {
		let { matches: e } = _.useContext(Mo),
			t = e[e.length - 1]
		return t ? t.params : {}
	}
	function Vv(e, { relative: t } = {}) {
		let { matches: n } = _.useContext(Mo),
			{ pathname: r } = Ea(),
			i = JSON.stringify(C8(n))
		return _.useMemo(() => T8(e, JSON.parse(i), r, t === "path"), [e, i, r, t])
	}
	function oJ(e, t) {
		return O8(e, t)
	}
	function O8(e, t, n, r) {
		var b
		jn(qv(), "useRoutes() may be used only in the context of a <Router> component.")
		let { navigator: i } = _.useContext(xs),
			{ matches: a } = _.useContext(Mo),
			o = a[a.length - 1],
			s = o ? o.params : {}
		o && o.pathname
		let l = o ? o.pathnameBase : "/"
		o && o.route
		let u = Ea(),
			d
		if (t) {
			let x = typeof t == "string" ? zp(t) : t
			jn(
				l === "/" || ((b = x.pathname) == null ? void 0 : b.startsWith(l)),
				`When overriding the location using \`<Routes location>\` or \`useRoutes(routes, location)\`, the location pathname must begin with the portion of the URL pathname that was matched by all parent routes. The current pathname base is "${l}" but pathname "${x.pathname}" was given in the \`location\` prop.`,
			),
				(d = x)
		} else d = u
		let p = d.pathname || "/",
			m = p
		if (l !== "/") {
			let x = l.replace(/^\//, "").split("/")
			m = "/" + p.replace(/^\//, "").split("/").slice(x.length).join("/")
		}
		let v = x8(e, { pathname: m }),
			y = dJ(
				v &&
					v.map((x) =>
						Object.assign({}, x, {
							params: Object.assign({}, s, x.params),
							pathname: sl([
								l,
								i.encodeLocation ? i.encodeLocation(x.pathname).pathname : x.pathname,
							]),
							pathnameBase:
								x.pathnameBase === "/"
									? l
									: sl([
											l,
											i.encodeLocation ? i.encodeLocation(x.pathnameBase).pathname : x.pathnameBase,
									  ]),
						}),
					),
				a,
				n,
				r,
			)
		return t && y
			? _.createElement(
					zv.Provider,
					{
						value: {
							location: { pathname: "/", search: "", hash: "", state: null, key: "default", ...d },
							navigationType: "POP",
						},
					},
					y,
			  )
			: y
	}
	function sJ() {
		let e = vJ(),
			t = JX(e)
				? `${e.status} ${e.statusText}`
				: e instanceof Error
				? e.message
				: JSON.stringify(e),
			n = e instanceof Error ? e.stack : null,
			i = { padding: "0.5rem", backgroundColor: "rgba(200,200,200, 0.5)" }
		return _.createElement(
			_.Fragment,
			null,
			_.createElement("h2", null, "Unexpected Application Error!"),
			_.createElement("h3", { style: { fontStyle: "italic" } }, t),
			n ? _.createElement("pre", { style: i }, n) : null,
			null,
		)
	}
	var lJ = _.createElement(sJ, null),
		uJ = class extends _.Component {
			constructor(e) {
				super(e),
					(this.state = { location: e.location, revalidation: e.revalidation, error: e.error })
			}
			static getDerivedStateFromError(e) {
				return { error: e }
			}
			static getDerivedStateFromProps(e, t) {
				return t.location !== e.location || (t.revalidation !== "idle" && e.revalidation === "idle")
					? { error: e.error, location: e.location, revalidation: e.revalidation }
					: {
							error: e.error !== void 0 ? e.error : t.error,
							location: t.location,
							revalidation: e.revalidation || t.revalidation,
					  }
			}
			componentDidCatch(e, t) {
				console.error("React Router caught the following error during render", e, t)
			}
			render() {
				return this.state.error !== void 0
					? _.createElement(
							Mo.Provider,
							{ value: this.props.routeContext },
							_.createElement(qD.Provider, {
								value: this.state.error,
								children: this.props.component,
							}),
					  )
					: this.props.children
			}
		}
	function cJ({ routeContext: e, match: t, children: n }) {
		let r = _.useContext(qp)
		return (
			r &&
				r.static &&
				r.staticContext &&
				(t.route.errorElement || t.route.ErrorBoundary) &&
				(r.staticContext._deepestRenderedBoundaryId = t.route.id),
			_.createElement(Mo.Provider, { value: e }, n)
		)
	}
	function dJ(e, t = [], n = null, r = null) {
		if (e == null) {
			if (!n) return null
			if (n.errors) e = n.matches
			else if (t.length === 0 && !n.initialized && n.matches.length > 0) e = n.matches
			else return null
		}
		let i = e,
			a = n == null ? void 0 : n.errors
		if (a != null) {
			let l = i.findIndex((u) => u.route.id && (a == null ? void 0 : a[u.route.id]) !== void 0)
			jn(
				l >= 0,
				`Could not find a matching route for errors on route IDs: ${Object.keys(a).join(",")}`,
			),
				(i = i.slice(0, Math.min(i.length, l + 1)))
		}
		let o = !1,
			s = -1
		if (n)
			for (let l = 0; l < i.length; l++) {
				let u = i[l]
				if (((u.route.HydrateFallback || u.route.hydrateFallbackElement) && (s = l), u.route.id)) {
					let { loaderData: d, errors: p } = n,
						m = u.route.loader && !d.hasOwnProperty(u.route.id) && (!p || p[u.route.id] === void 0)
					if (u.route.lazy || m) {
						;(o = !0), s >= 0 ? (i = i.slice(0, s + 1)) : (i = [i[0]])
						break
					}
				}
			}
		return i.reduceRight((l, u, d) => {
			let p,
				m = !1,
				v = null,
				y = null
			n &&
				((p = a && u.route.id ? a[u.route.id] : void 0),
				(v = u.route.errorElement || lJ),
				o &&
					(s < 0 && d === 0
						? (yJ(
								"route-fallback",
								!1,
								"No `HydrateFallback` element provided to render during initial hydration",
						  ),
						  (m = !0),
						  (y = null))
						: s === d && ((m = !0), (y = u.route.hydrateFallbackElement || null))))
			let b = t.concat(i.slice(0, d + 1)),
				x = () => {
					let E
					return (
						p
							? (E = v)
							: m
							? (E = y)
							: u.route.Component
							? (E = _.createElement(u.route.Component, null))
							: u.route.element
							? (E = u.route.element)
							: (E = l),
						_.createElement(cJ, {
							match: u,
							routeContext: { outlet: l, matches: b, isDataRoute: n != null },
							children: E,
						})
					)
				}
			return n && (u.route.ErrorBoundary || u.route.errorElement || d === 0)
				? _.createElement(uJ, {
						location: n.location,
						revalidation: n.revalidation,
						component: v,
						error: p,
						children: x(),
						routeContext: { outlet: null, matches: b, isDataRoute: !0 },
				  })
				: x()
		}, null)
	}
	function VD(e) {
		return `${e} must be used within a data router.  See https://reactrouter.com/en/main/routers/picking-a-router.`
	}
	function fJ(e) {
		let t = _.useContext(qp)
		return jn(t, VD(e)), t
	}
	function pJ(e) {
		let t = _.useContext(lx)
		return jn(t, VD(e)), t
	}
	function hJ(e) {
		let t = _.useContext(Mo)
		return jn(t, VD(e)), t
	}
	function WD(e) {
		let t = hJ(e),
			n = t.matches[t.matches.length - 1]
		return jn(n.route.id, `${e} can only be used on routes that contain a unique "id"`), n.route.id
	}
	function mJ() {
		return WD("useRouteId")
	}
	function vJ() {
		var r
		let e = _.useContext(qD),
			t = pJ("useRouteError"),
			n = WD("useRouteError")
		return e !== void 0 ? e : (r = t.errors) == null ? void 0 : r[n]
	}
	function gJ() {
		let { router: e } = fJ("useNavigate"),
			t = WD("useNavigate"),
			n = _.useRef(!1)
		return (
			_8(() => {
				n.current = !0
			}),
			_.useCallback(
				async (i, a = {}) => {
					Yu(n.current, D8),
						n.current &&
							(typeof i == "number" ? e.navigate(i) : await e.navigate(i, { fromRouteId: t, ...a }))
				},
				[e, t],
			)
		)
	}
	var pR = {}
	function yJ(e, t, n) {
		pR[e] || ((pR[e] = !0), Yu(!1, n))
	}
	_.memo(bJ)
	function bJ({ routes: e, future: t, state: n }) {
		return O8(e, void 0, n, t)
	}
	function A8(e) {
		return aJ(e.context)
	}
	function $t(e) {
		jn(
			!1,
			"A <Route> is only ever to be used as the child of <Routes> element, never rendered directly. Please wrap your <Route> in a <Routes>.",
		)
	}
	function xJ({
		basename: e = "/",
		children: t = null,
		location: n,
		navigationType: r = "POP",
		navigator: i,
		static: a = !1,
	}) {
		jn(
			!qv(),
			"You cannot render a <Router> inside another <Router>. You should never have more than one in your app.",
		)
		let o = e.replace(/^\/*/, "/"),
			s = _.useMemo(() => ({ basename: o, navigator: i, static: a, future: {} }), [o, i, a])
		typeof n == "string" && (n = zp(n))
		let {
				pathname: l = "/",
				search: u = "",
				hash: d = "",
				state: p = null,
				key: m = "default",
			} = n,
			v = _.useMemo(() => {
				let y = Iu(l, o)
				return y == null
					? null
					: { location: { pathname: y, search: u, hash: d, state: p, key: m }, navigationType: r }
			}, [o, l, u, d, p, m, r])
		return (
			Yu(
				v != null,
				`<Router basename="${o}"> is not able to match the URL "${l}${u}${d}" because it does not start with the basename, so the <Router> won't render anything.`,
			),
			v == null
				? null
				: _.createElement(
						xs.Provider,
						{ value: s },
						_.createElement(zv.Provider, { children: t, value: v }),
				  )
		)
	}
	function wJ({ children: e, location: t }) {
		return oJ(SS(e), t)
	}
	function SS(e, t = []) {
		let n = []
		return (
			_.Children.forEach(e, (r, i) => {
				if (!_.isValidElement(r)) return
				let a = [...t, i]
				if (r.type === _.Fragment) {
					n.push.apply(n, SS(r.props.children, a))
					return
				}
				jn(
					r.type === $t,
					`[${
						typeof r.type == "string" ? r.type : r.type.name
					}] is not a <Route> component. All component children of <Routes> must be a <Route> or <React.Fragment>`,
				),
					jn(!r.props.index || !r.props.children, "An index route cannot have child routes.")
				let o = {
					id: r.props.id || a.join("-"),
					caseSensitive: r.props.caseSensitive,
					element: r.props.element,
					Component: r.props.Component,
					index: r.props.index,
					path: r.props.path,
					loader: r.props.loader,
					action: r.props.action,
					hydrateFallbackElement: r.props.hydrateFallbackElement,
					HydrateFallback: r.props.HydrateFallback,
					errorElement: r.props.errorElement,
					ErrorBoundary: r.props.ErrorBoundary,
					hasErrorBoundary:
						r.props.hasErrorBoundary === !0 ||
						r.props.ErrorBoundary != null ||
						r.props.errorElement != null,
					shouldRevalidate: r.props.shouldRevalidate,
					handle: r.props.handle,
					lazy: r.props.lazy,
				}
				r.props.children && (o.children = SS(r.props.children, a)), n.push(o)
			}),
			n
		)
	}
	var By = "get",
		Hy = "application/x-www-form-urlencoded"
	function ux(e) {
		return e != null && typeof e.tagName == "string"
	}
	function EJ(e) {
		return ux(e) && e.tagName.toLowerCase() === "button"
	}
	function CJ(e) {
		return ux(e) && e.tagName.toLowerCase() === "form"
	}
	function TJ(e) {
		return ux(e) && e.tagName.toLowerCase() === "input"
	}
	function kJ(e) {
		return !!(e.metaKey || e.altKey || e.ctrlKey || e.shiftKey)
	}
	function SJ(e, t) {
		return e.button === 0 && (!t || t === "_self") && !kJ(e)
	}
	var j0 = null
	function DJ() {
		if (j0 === null)
			try {
				new FormData(document.createElement("form"), 0), (j0 = !1)
			} catch {
				j0 = !0
			}
		return j0
	}
	var _J = new Set(["application/x-www-form-urlencoded", "multipart/form-data", "text/plain"])
	function RC(e) {
		return e != null && !_J.has(e)
			? (Yu(
					!1,
					`"${e}" is not a valid \`encType\` for \`<Form>\`/\`<fetcher.Form>\` and will default to "${Hy}"`,
			  ),
			  null)
			: e
	}
	function OJ(e, t) {
		let n, r, i, a, o
		if (CJ(e)) {
			let s = e.getAttribute("action")
			;(r = s ? Iu(s, t) : null),
				(n = e.getAttribute("method") || By),
				(i = RC(e.getAttribute("enctype")) || Hy),
				(a = new FormData(e))
		} else if (EJ(e) || (TJ(e) && (e.type === "submit" || e.type === "image"))) {
			let s = e.form
			if (s == null)
				throw new Error('Cannot submit a <button> or <input type="submit"> without a <form>')
			let l = e.getAttribute("formaction") || s.getAttribute("action")
			if (
				((r = l ? Iu(l, t) : null),
				(n = e.getAttribute("formmethod") || s.getAttribute("method") || By),
				(i = RC(e.getAttribute("formenctype")) || RC(s.getAttribute("enctype")) || Hy),
				(a = new FormData(s, e)),
				!DJ())
			) {
				let { name: u, type: d, value: p } = e
				if (d === "image") {
					let m = u ? `${u}.` : ""
					a.append(`${m}x`, "0"), a.append(`${m}y`, "0")
				} else u && a.append(u, p)
			}
		} else {
			if (ux(e))
				throw new Error(
					'Cannot submit element that is not <form>, <button>, or <input type="submit|image">',
				)
			;(n = By), (r = null), (i = Hy), (o = e)
		}
		return (
			a && i === "text/plain" && ((o = a), (a = void 0)),
			{ action: r, method: n.toLowerCase(), encType: i, formData: a, body: o }
		)
	}
	function YD(e, t) {
		if (e === !1 || e === null || typeof e > "u") throw new Error(t)
	}
	async function AJ(e, t) {
		if (e.id in t) return t[e.id]
		try {
			let n = await import(e.module)
			return (t[e.id] = n), n
		} catch (n) {
			return (
				console.error(`Error loading route module \`${e.module}\`, reloading page...`),
				console.error(n),
				window.__reactRouterContext && window.__reactRouterContext.isSpaMode,
				window.location.reload(),
				new Promise(() => {})
			)
		}
	}
	function NJ(e) {
		return e == null
			? !1
			: e.href == null
			? e.rel === "preload" && typeof e.imageSrcSet == "string" && typeof e.imageSizes == "string"
			: typeof e.rel == "string" && typeof e.href == "string"
	}
	async function MJ(e, t, n) {
		let r = await Promise.all(
			e.map(async (i) => {
				let a = t.routes[i.route.id]
				if (a) {
					let o = await AJ(a, n)
					return o.links ? o.links() : []
				}
				return []
			}),
		)
		return PJ(
			r
				.flat(1)
				.filter(NJ)
				.filter((i) => i.rel === "stylesheet" || i.rel === "preload")
				.map((i) =>
					i.rel === "stylesheet"
						? { ...i, rel: "prefetch", as: "style" }
						: { ...i, rel: "prefetch" },
				),
		)
	}
	function hR(e, t, n, r, i, a) {
		let o = (l, u) => (n[u] ? l.route.id !== n[u].route.id : !0),
			s = (l, u) => {
				var d
				return (
					n[u].pathname !== l.pathname ||
					(((d = n[u].route.path) == null ? void 0 : d.endsWith("*")) &&
						n[u].params["*"] !== l.params["*"])
				)
			}
		return a === "assets"
			? t.filter((l, u) => o(l, u) || s(l, u))
			: a === "data"
			? t.filter((l, u) => {
					var p
					let d = r.routes[l.route.id]
					if (!d || !d.hasLoader) return !1
					if (o(l, u) || s(l, u)) return !0
					if (l.route.shouldRevalidate) {
						let m = l.route.shouldRevalidate({
							currentUrl: new URL(i.pathname + i.search + i.hash, window.origin),
							currentParams: ((p = n[0]) == null ? void 0 : p.params) || {},
							nextUrl: new URL(e, window.origin),
							nextParams: l.params,
							defaultShouldRevalidate: !0,
						})
						if (typeof m == "boolean") return m
					}
					return !0
			  })
			: []
	}
	function IJ(e, t) {
		return RJ(
			e
				.map((n) => {
					let r = t.routes[n.route.id]
					if (!r) return []
					let i = [r.module]
					return r.imports && (i = i.concat(r.imports)), i
				})
				.flat(1),
		)
	}
	function RJ(e) {
		return [...new Set(e)]
	}
	function LJ(e) {
		let t = {},
			n = Object.keys(e).sort()
		for (let r of n) t[r] = e[r]
		return t
	}
	function PJ(e, t) {
		let n = new Set()
		return (
			new Set(t),
			e.reduce((r, i) => {
				let a = JSON.stringify(LJ(i))
				return n.has(a) || (n.add(a), r.push({ key: a, link: i })), r
			}, [])
		)
	}
	function jJ(e) {
		let t =
			typeof e == "string"
				? new URL(e, typeof window > "u" ? "server://singlefetch/" : window.location.origin)
				: e
		return (
			t.pathname === "/"
				? (t.pathname = "_root.data")
				: (t.pathname = `${t.pathname.replace(/\/$/, "")}.data`),
			t
		)
	}
	function FJ() {
		let e = _.useContext(qp)
		return YD(e, "You must render this element inside a <DataRouterContext.Provider> element"), e
	}
	function BJ() {
		let e = _.useContext(lx)
		return (
			YD(e, "You must render this element inside a <DataRouterStateContext.Provider> element"), e
		)
	}
	var GD = _.createContext(void 0)
	GD.displayName = "FrameworkContext"
	function N8() {
		let e = _.useContext(GD)
		return YD(e, "You must render this element inside a <HydratedRouter> element"), e
	}
	function HJ(e, t) {
		let n = _.useContext(GD),
			[r, i] = _.useState(!1),
			[a, o] = _.useState(!1),
			{ onFocus: s, onBlur: l, onMouseEnter: u, onMouseLeave: d, onTouchStart: p } = t,
			m = _.useRef(null)
		_.useEffect(() => {
			if ((e === "render" && o(!0), e === "viewport")) {
				let b = (E) => {
						E.forEach((T) => {
							o(T.isIntersecting)
						})
					},
					x = new IntersectionObserver(b, { threshold: 0.5 })
				return (
					m.current && x.observe(m.current),
					() => {
						x.disconnect()
					}
				)
			}
		}, [e]),
			_.useEffect(() => {
				if (r) {
					let b = setTimeout(() => {
						o(!0)
					}, 100)
					return () => {
						clearTimeout(b)
					}
				}
			}, [r])
		let v = () => {
				i(!0)
			},
			y = () => {
				i(!1), o(!1)
			}
		return n
			? e !== "intent"
				? [a, m, {}]
				: [
						a,
						m,
						{
							onFocus: Yh(s, v),
							onBlur: Yh(l, y),
							onMouseEnter: Yh(u, v),
							onMouseLeave: Yh(d, y),
							onTouchStart: Yh(p, v),
						},
				  ]
			: [!1, m, {}]
	}
	function Yh(e, t) {
		return (n) => {
			e && e(n), n.defaultPrevented || t(n)
		}
	}
	function $J({ page: e, ...t }) {
		let { router: n } = FJ(),
			r = _.useMemo(() => x8(n.routes, e, n.basename), [n.routes, e, n.basename])
		return r
			? _.createElement(zJ, { page: e, matches: r, ...t })
			: (console.warn(`Tried to prefetch ${e} but no routes matched.`), null)
	}
	function UJ(e) {
		let { manifest: t, routeModules: n } = N8(),
			[r, i] = _.useState([])
		return (
			_.useEffect(() => {
				let a = !1
				return (
					MJ(e, t, n).then((o) => {
						a || i(o)
					}),
					() => {
						a = !0
					}
				)
			}, [e, t, n]),
			r
		)
	}
	function zJ({ page: e, matches: t, ...n }) {
		let r = Ea(),
			{ manifest: i, routeModules: a } = N8(),
			{ loaderData: o, matches: s } = BJ(),
			l = _.useMemo(() => hR(e, t, s, i, r, "data"), [e, t, s, i, r]),
			u = _.useMemo(() => hR(e, t, s, i, r, "assets"), [e, t, s, i, r]),
			d = _.useMemo(() => {
				if (e === r.pathname + r.search + r.hash) return []
				let v = new Set(),
					y = !1
				if (
					(t.forEach((x) => {
						var T
						let E = i.routes[x.route.id]
						!E ||
							!E.hasLoader ||
							((!l.some((C) => C.route.id === x.route.id) &&
								x.route.id in o &&
								(T = a[x.route.id]) != null &&
								T.shouldRevalidate) ||
							E.hasClientLoader
								? (y = !0)
								: v.add(x.route.id))
					}),
					v.size === 0)
				)
					return []
				let b = jJ(e)
				return (
					y &&
						v.size > 0 &&
						b.searchParams.set(
							"_routes",
							t
								.filter((x) => v.has(x.route.id))
								.map((x) => x.route.id)
								.join(","),
						),
					[b.pathname + b.search]
				)
			}, [o, r, i, l, t, e, a]),
			p = _.useMemo(() => IJ(u, i), [u, i]),
			m = UJ(u)
		return _.createElement(
			_.Fragment,
			null,
			d.map((v) =>
				_.createElement("link", { key: v, rel: "prefetch", as: "fetch", href: v, ...n }),
			),
			p.map((v) => _.createElement("link", { key: v, rel: "modulepreload", href: v, ...n })),
			m.map(({ key: v, link: y }) => _.createElement("link", { key: v, ...y })),
		)
	}
	function qJ(...e) {
		return (t) => {
			e.forEach((n) => {
				typeof n == "function" ? n(t) : n != null && (n.current = t)
			})
		}
	}
	var M8 =
		typeof window < "u" &&
		typeof window.document < "u" &&
		typeof window.document.createElement < "u"
	try {
		M8 && (window.__reactRouterVersion = "7.0.1")
	} catch {}
	function VJ({ basename: e, children: t, window: n }) {
		let r = _.useRef()
		r.current == null && (r.current = AX({ window: n, v5Compat: !0 }))
		let i = r.current,
			[a, o] = _.useState({ action: i.action, location: i.location }),
			s = _.useCallback(
				(l) => {
					_.startTransition(() => o(l))
				},
				[o],
			)
		return (
			_.useLayoutEffect(() => i.listen(s), [i, s]),
			_.createElement(xJ, {
				basename: e,
				children: t,
				location: a.location,
				navigationType: a.action,
				navigator: i,
			})
		)
	}
	var I8 = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i,
		R8 = _.forwardRef(function (
			{
				onClick: t,
				discover: n = "render",
				prefetch: r = "none",
				relative: i,
				reloadDocument: a,
				replace: o,
				state: s,
				target: l,
				to: u,
				preventScrollReset: d,
				viewTransition: p,
				...m
			},
			v,
		) {
			let { basename: y } = _.useContext(xs),
				b = typeof u == "string" && I8.test(u),
				x,
				E = !1
			if (typeof u == "string" && b && ((x = u), M8))
				try {
					let P = new URL(window.location.href),
						L = u.startsWith("//") ? new URL(P.protocol + u) : new URL(u),
						B = Iu(L.pathname, y)
					L.origin === P.origin && B != null ? (u = B + L.search + L.hash) : (E = !0)
				} catch {
					Yu(
						!1,
						`<Link to="${u}"> contains an invalid URL which will probably break when clicked - please update to a valid URL path.`,
					)
				}
			let T = nJ(u, { relative: i }),
				[C, D, O] = HJ(r, m),
				A = GJ(u, {
					replace: o,
					state: s,
					target: l,
					preventScrollReset: d,
					relative: i,
					viewTransition: p,
				})
			function N(P) {
				t && t(P), P.defaultPrevented || A(P)
			}
			let I = _.createElement("a", {
				...m,
				...O,
				href: x || T,
				onClick: E || a ? t : N,
				ref: qJ(v, D),
				target: l,
				"data-discover": !b && n === "render" ? "true" : void 0,
			})
			return C && !b ? _.createElement(_.Fragment, null, I, _.createElement($J, { page: T })) : I
		})
	R8.displayName = "Link"
	var Un = _.forwardRef(function (
		{
			"aria-current": t = "page",
			caseSensitive: n = !1,
			className: r = "",
			end: i = !1,
			style: a,
			to: o,
			viewTransition: s,
			children: l,
			...u
		},
		d,
	) {
		let p = Vv(o, { relative: u.relative }),
			m = Ea(),
			v = _.useContext(lx),
			{ navigator: y, basename: b } = _.useContext(xs),
			x = v != null && ZJ(p) && s === !0,
			E = y.encodeLocation ? y.encodeLocation(p).pathname : p.pathname,
			T = m.pathname,
			C = v && v.navigation && v.navigation.location ? v.navigation.location.pathname : null
		n || ((T = T.toLowerCase()), (C = C ? C.toLowerCase() : null), (E = E.toLowerCase())),
			C && b && (C = Iu(C, b) || C)
		const D = E !== "/" && E.endsWith("/") ? E.length - 1 : E.length
		let O = T === E || (!i && T.startsWith(E) && T.charAt(D) === "/"),
			A = C != null && (C === E || (!i && C.startsWith(E) && C.charAt(E.length) === "/")),
			N = { isActive: O, isPending: A, isTransitioning: x },
			I = O ? t : void 0,
			P
		typeof r == "function"
			? (P = r(N))
			: (P = [r, O ? "active" : null, A ? "pending" : null, x ? "transitioning" : null]
					.filter(Boolean)
					.join(" "))
		let L = typeof a == "function" ? a(N) : a
		return _.createElement(
			R8,
			{ ...u, "aria-current": I, className: P, ref: d, style: L, to: o, viewTransition: s },
			typeof l == "function" ? l(N) : l,
		)
	})
	Un.displayName = "NavLink"
	var WJ = _.forwardRef(
		(
			{
				discover: e = "render",
				fetcherKey: t,
				navigate: n,
				reloadDocument: r,
				replace: i,
				state: a,
				method: o = By,
				action: s,
				onSubmit: l,
				relative: u,
				preventScrollReset: d,
				viewTransition: p,
				...m
			},
			v,
		) => {
			let y = XJ(),
				b = JJ(s, { relative: u }),
				x = o.toLowerCase() === "get" ? "get" : "post",
				E = typeof s == "string" && I8.test(s),
				T = (C) => {
					if ((l && l(C), C.defaultPrevented)) return
					C.preventDefault()
					let D = C.nativeEvent.submitter,
						O = (D == null ? void 0 : D.getAttribute("formmethod")) || o
					y(D || C.currentTarget, {
						fetcherKey: t,
						method: O,
						navigate: n,
						replace: i,
						state: a,
						relative: u,
						preventScrollReset: d,
						viewTransition: p,
					})
				}
			return _.createElement("form", {
				ref: v,
				method: x,
				action: b,
				onSubmit: r ? l : T,
				...m,
				"data-discover": !E && e === "render" ? "true" : void 0,
			})
		},
	)
	WJ.displayName = "Form"
	function YJ(e) {
		return `${e} must be used within a data router.  See https://reactrouter.com/en/main/routers/picking-a-router.`
	}
	function L8(e) {
		let t = _.useContext(qp)
		return jn(t, YJ(e)), t
	}
	function GJ(
		e,
		{ target: t, replace: n, state: r, preventScrollReset: i, relative: a, viewTransition: o } = {},
	) {
		let s = Xa(),
			l = Ea(),
			u = Vv(e, { relative: a })
		return _.useCallback(
			(d) => {
				if (SJ(d, t)) {
					d.preventDefault()
					let p = n !== void 0 ? n : ev(l) === ev(u)
					s(e, { replace: p, state: r, preventScrollReset: i, relative: a, viewTransition: o })
				}
			},
			[l, s, u, n, r, t, e, i, a, o],
		)
	}
	var KJ = 0,
		QJ = () => `__${String(++KJ)}__`
	function XJ() {
		let { router: e } = L8("useSubmit"),
			{ basename: t } = _.useContext(xs),
			n = mJ()
		return _.useCallback(
			async (r, i = {}) => {
				let { action: a, method: o, encType: s, formData: l, body: u } = OJ(r, t)
				if (i.navigate === !1) {
					let d = i.fetcherKey || QJ()
					await e.fetch(d, n, i.action || a, {
						preventScrollReset: i.preventScrollReset,
						formData: l,
						body: u,
						formMethod: i.method || o,
						formEncType: i.encType || s,
						flushSync: i.flushSync,
					})
				} else
					await e.navigate(i.action || a, {
						preventScrollReset: i.preventScrollReset,
						formData: l,
						body: u,
						formMethod: i.method || o,
						formEncType: i.encType || s,
						replace: i.replace,
						state: i.state,
						fromRouteId: n,
						flushSync: i.flushSync,
						viewTransition: i.viewTransition,
					})
			},
			[e, t, n],
		)
	}
	function JJ(e, { relative: t } = {}) {
		let { basename: n } = _.useContext(xs),
			r = _.useContext(Mo)
		jn(r, "useFormAction must be used inside a RouteContext")
		let [i] = r.matches.slice(-1),
			a = { ...Vv(e || ".", { relative: t }) },
			o = Ea()
		if (e == null) {
			a.search = o.search
			let s = new URLSearchParams(a.search),
				l = s.getAll("index")
			if (l.some((d) => d === "")) {
				s.delete("index"), l.filter((p) => p).forEach((p) => s.append("index", p))
				let d = s.toString()
				a.search = d ? `?${d}` : ""
			}
		}
		return (
			(!e || e === ".") &&
				i.route.index &&
				(a.search = a.search ? a.search.replace(/^\?/, "?index&") : "?index"),
			n !== "/" && (a.pathname = a.pathname === "/" ? n : sl([n, a.pathname])),
			ev(a)
		)
	}
	function ZJ(e, t = {}) {
		let n = _.useContext(S8)
		jn(
			n != null,
			"`useViewTransitionState` must be used within `react-router-dom`'s `RouterProvider`.  Did you accidentally import `RouterProvider` from `react-router`?",
		)
		let { basename: r } = L8("useViewTransitionState"),
			i = Vv(e, { relative: t.relative })
		if (!n.isTransitioning) return !1
		let a = Iu(n.currentLocation.pathname, r) || n.currentLocation.pathname,
			o = Iu(n.nextLocation.pathname, r) || n.nextLocation.pathname
		return A1(i.pathname, o) != null || A1(i.pathname, a) != null
	}
	new TextEncoder()
	class Pi {}
	q(Pi, "LocalRule", "LR"),
		q(Pi, "CodeOfConduct", "CC"),
		q(Pi, "AboutUs", "AU"),
		q(Pi, "SeniorMatchPlay", "SP"),
		q(Pi, "MatchPlay", "MP"),
		q(Pi, "Tournament", "TN"),
		q(Pi, "TournamentPlayerInformation", "TP"),
		q(Pi, "PaceOfPlay", "PP"),
		q(Pi, "Other", "OX")
	class Rn {}
	q(Rn, "Home", "H"),
		q(Rn, "TournamentBids", "B"),
		q(Rn, "AboutTheMPGA", "A"),
		q(Rn, "MatchPlay", "M"),
		q(Rn, "MemberClubs", "C"),
		q(Rn, "ClubEditing", "E"),
		q(Rn, "ClubRegistration", "R"),
		q(Rn, "IndividualRegistration", "I"),
		q(Rn, "CodeOfConduct", "CC"),
		q(Rn, "OurMission", "OM"),
		q(Rn, "ExecutiveCommittee", "EC"),
		q(Rn, "MatchPlaySignup", "MP"),
		q(Rn, "FAQ", "FQ"),
		q(Rn, "PastPresidents", "PP")
	class lt {}
	q(lt, "ServerUrl", "https://data.mpga.net"),
		q(lt, "ApiUrl", "https://data.mpga.net/api"),
		q(lt, "AuthUrl", "https://data.mpga.net/auth"),
		q(lt, "AdminUrl", "https://data.mpga.net/admin"),
		q(lt, "EventCalendarYear", 2025),
		q(lt, "MatchPlayYear", 2024),
		q(lt, "MemberClubYear", 2024),
		q(lt, "MembershipDues", 100),
		q(lt, "StripePublicKey", "pk_live_OIaQLnjulh71VsO2Ct0w5BQU"),
		q(lt, "Mode", "Live"),
		q(lt, "BearerTokenName", "mpga-token"),
		q(lt, "CrsfCookieName", "crsftoken")
	function Pr(e) {
		return `Minified Redux error #${e}; visit https://redux.js.org/Errors?code=${e} for the full message or use the non-minified dev environment for full errors. `
	}
	var eZ = (typeof Symbol == "function" && Symbol.observable) || "@@observable",
		mR = eZ,
		LC = () => Math.random().toString(36).substring(7).split("").join("."),
		tZ = {
			INIT: `@@redux/INIT${LC()}`,
			REPLACE: `@@redux/REPLACE${LC()}`,
			PROBE_UNKNOWN_ACTION: () => `@@redux/PROBE_UNKNOWN_ACTION${LC()}`,
		},
		N1 = tZ
	function Ru(e) {
		if (typeof e != "object" || e === null) return !1
		let t = e
		for (; Object.getPrototypeOf(t) !== null; ) t = Object.getPrototypeOf(t)
		return Object.getPrototypeOf(e) === t || Object.getPrototypeOf(e) === null
	}
	function P8(e, t, n) {
		if (typeof e != "function") throw new Error(Pr(2))
		if (
			(typeof t == "function" && typeof n == "function") ||
			(typeof n == "function" && typeof arguments[3] == "function")
		)
			throw new Error(Pr(0))
		if ((typeof t == "function" && typeof n > "u" && ((n = t), (t = void 0)), typeof n < "u")) {
			if (typeof n != "function") throw new Error(Pr(1))
			return n(P8)(e, t)
		}
		let r = e,
			i = t,
			a = new Map(),
			o = a,
			s = 0,
			l = !1
		function u() {
			o === a &&
				((o = new Map()),
				a.forEach((x, E) => {
					o.set(E, x)
				}))
		}
		function d() {
			if (l) throw new Error(Pr(3))
			return i
		}
		function p(x) {
			if (typeof x != "function") throw new Error(Pr(4))
			if (l) throw new Error(Pr(5))
			let E = !0
			u()
			const T = s++
			return (
				o.set(T, x),
				function () {
					if (E) {
						if (l) throw new Error(Pr(6))
						;(E = !1), u(), o.delete(T), (a = null)
					}
				}
			)
		}
		function m(x) {
			if (!Ru(x)) throw new Error(Pr(7))
			if (typeof x.type > "u") throw new Error(Pr(8))
			if (typeof x.type != "string") throw new Error(Pr(17))
			if (l) throw new Error(Pr(9))
			try {
				;(l = !0), (i = r(i, x))
			} finally {
				l = !1
			}
			return (
				(a = o).forEach((T) => {
					T()
				}),
				x
			)
		}
		function v(x) {
			if (typeof x != "function") throw new Error(Pr(10))
			;(r = x), m({ type: N1.REPLACE })
		}
		function y() {
			const x = p
			return {
				subscribe(E) {
					if (typeof E != "object" || E === null) throw new Error(Pr(11))
					function T() {
						const D = E
						D.next && D.next(d())
					}
					return T(), { unsubscribe: x(T) }
				},
				[mR]() {
					return this
				},
			}
		}
		return (
			m({ type: N1.INIT }), { dispatch: m, subscribe: p, getState: d, replaceReducer: v, [mR]: y }
		)
	}
	function nZ(e) {
		Object.keys(e).forEach((t) => {
			const n = e[t]
			if (typeof n(void 0, { type: N1.INIT }) > "u") throw new Error(Pr(12))
			if (typeof n(void 0, { type: N1.PROBE_UNKNOWN_ACTION() }) > "u") throw new Error(Pr(13))
		})
	}
	function j8(e) {
		const t = Object.keys(e),
			n = {}
		for (let a = 0; a < t.length; a++) {
			const o = t[a]
			typeof e[o] == "function" && (n[o] = e[o])
		}
		const r = Object.keys(n)
		let i
		try {
			nZ(n)
		} catch (a) {
			i = a
		}
		return function (o = {}, s) {
			if (i) throw i
			let l = !1
			const u = {}
			for (let d = 0; d < r.length; d++) {
				const p = r[d],
					m = n[p],
					v = o[p],
					y = m(v, s)
				if (typeof y > "u") throw (s && s.type, new Error(Pr(14)))
				;(u[p] = y), (l = l || y !== v)
			}
			return (l = l || r.length !== Object.keys(o).length), l ? u : o
		}
	}
	function M1(...e) {
		return e.length === 0
			? (t) => t
			: e.length === 1
			? e[0]
			: e.reduce(
					(t, n) =>
						(...r) =>
							t(n(...r)),
			  )
	}
	function rZ(...e) {
		return (t) => (n, r) => {
			const i = t(n, r)
			let a = () => {
				throw new Error(Pr(15))
			}
			const o = { getState: i.getState, dispatch: (l, ...u) => a(l, ...u) },
				s = e.map((l) => l(o))
			return (a = M1(...s)(i.dispatch)), { ...i, dispatch: a }
		}
	}
	function F8(e) {
		return Ru(e) && "type" in e && typeof e.type == "string"
	}
	var KD = Symbol.for("immer-nothing"),
		Am = Symbol.for("immer-draftable"),
		Vi = Symbol.for("immer-state")
	function $r(e, ...t) {
		throw new Error(`[Immer] minified error nr: ${e}. Full error at: https://bit.ly/3cXEKWf`)
	}
	var sd = Object.getPrototypeOf
	function fs(e) {
		return !!e && !!e[Vi]
	}
	function So(e) {
		var t
		return e
			? B8(e) ||
					Array.isArray(e) ||
					!!e[Am] ||
					!!((t = e.constructor) != null && t[Am]) ||
					Wv(e) ||
					Yv(e)
			: !1
	}
	var iZ = Object.prototype.constructor.toString()
	function B8(e) {
		if (!e || typeof e != "object") return !1
		const t = sd(e)
		if (t === null) return !0
		const n = Object.hasOwnProperty.call(t, "constructor") && t.constructor
		return n === Object ? !0 : typeof n == "function" && Function.toString.call(n) === iZ
	}
	function aZ(e) {
		return fs(e) || $r(15, e), e[Vi].base_
	}
	function tv(e, t) {
		ld(e) === 0
			? Reflect.ownKeys(e).forEach((n) => {
					t(n, e[n], e)
			  })
			: e.forEach((n, r) => t(r, n, e))
	}
	function ld(e) {
		const t = e[Vi]
		return t ? t.type_ : Array.isArray(e) ? 1 : Wv(e) ? 2 : Yv(e) ? 3 : 0
	}
	function nv(e, t) {
		return ld(e) === 2 ? e.has(t) : Object.prototype.hasOwnProperty.call(e, t)
	}
	function PC(e, t) {
		return ld(e) === 2 ? e.get(t) : e[t]
	}
	function H8(e, t, n) {
		const r = ld(e)
		r === 2 ? e.set(t, n) : r === 3 ? e.add(n) : (e[t] = n)
	}
	function oZ(e, t) {
		return e === t ? e !== 0 || 1 / e === 1 / t : e !== e && t !== t
	}
	function Wv(e) {
		return e instanceof Map
	}
	function Yv(e) {
		return e instanceof Set
	}
	function Dc(e) {
		return e.copy_ || e.base_
	}
	function DS(e, t) {
		if (Wv(e)) return new Map(e)
		if (Yv(e)) return new Set(e)
		if (Array.isArray(e)) return Array.prototype.slice.call(e)
		const n = B8(e)
		if (t === !0 || (t === "class_only" && !n)) {
			const r = Object.getOwnPropertyDescriptors(e)
			delete r[Vi]
			let i = Reflect.ownKeys(r)
			for (let a = 0; a < i.length; a++) {
				const o = i[a],
					s = r[o]
				s.writable === !1 && ((s.writable = !0), (s.configurable = !0)),
					(s.get || s.set) &&
						(r[o] = { configurable: !0, writable: !0, enumerable: s.enumerable, value: e[o] })
			}
			return Object.create(sd(e), r)
		} else {
			const r = sd(e)
			if (r !== null && n) return { ...e }
			const i = Object.create(r)
			return Object.assign(i, e)
		}
	}
	function QD(e, t = !1) {
		return (
			cx(e) ||
				fs(e) ||
				!So(e) ||
				(ld(e) > 1 && (e.set = e.add = e.clear = e.delete = sZ),
				Object.freeze(e),
				t && Object.entries(e).forEach(([n, r]) => QD(r, !0))),
			e
		)
	}
	function sZ() {
		$r(2)
	}
	function cx(e) {
		return Object.isFrozen(e)
	}
	var _S = {}
	function ud(e) {
		const t = _S[e]
		return t || $r(0, e), t
	}
	function lZ(e, t) {
		_S[e] || (_S[e] = t)
	}
	var rv
	function $8() {
		return rv
	}
	function uZ(e, t) {
		return { drafts_: [], parent_: e, immer_: t, canAutoFreeze_: !0, unfinalizedDrafts_: 0 }
	}
	function vR(e, t) {
		t && (ud("Patches"), (e.patches_ = []), (e.inversePatches_ = []), (e.patchListener_ = t))
	}
	function OS(e) {
		AS(e), e.drafts_.forEach(cZ), (e.drafts_ = null)
	}
	function AS(e) {
		e === rv && (rv = e.parent_)
	}
	function gR(e) {
		return (rv = uZ(rv, e))
	}
	function cZ(e) {
		const t = e[Vi]
		t.type_ === 0 || t.type_ === 1 ? t.revoke_() : (t.revoked_ = !0)
	}
	function yR(e, t) {
		t.unfinalizedDrafts_ = t.drafts_.length
		const n = t.drafts_[0]
		return (
			e !== void 0 && e !== n
				? (n[Vi].modified_ && (OS(t), $r(4)),
				  So(e) && ((e = I1(t, e)), t.parent_ || R1(t, e)),
				  t.patches_ &&
						ud("Patches").generateReplacementPatches_(
							n[Vi].base_,
							e,
							t.patches_,
							t.inversePatches_,
						))
				: (e = I1(t, n, [])),
			OS(t),
			t.patches_ && t.patchListener_(t.patches_, t.inversePatches_),
			e !== KD ? e : void 0
		)
	}
	function I1(e, t, n) {
		if (cx(t)) return t
		const r = t[Vi]
		if (!r) return tv(t, (i, a) => bR(e, r, t, i, a, n)), t
		if (r.scope_ !== e) return t
		if (!r.modified_) return R1(e, r.base_, !0), r.base_
		if (!r.finalized_) {
			;(r.finalized_ = !0), r.scope_.unfinalizedDrafts_--
			const i = r.copy_
			let a = i,
				o = !1
			r.type_ === 3 && ((a = new Set(i)), i.clear(), (o = !0)),
				tv(a, (s, l) => bR(e, r, i, s, l, n, o)),
				R1(e, i, !1),
				n && e.patches_ && ud("Patches").generatePatches_(r, n, e.patches_, e.inversePatches_)
		}
		return r.copy_
	}
	function bR(e, t, n, r, i, a, o) {
		if (fs(i)) {
			const s = a && t && t.type_ !== 3 && !nv(t.assigned_, r) ? a.concat(r) : void 0,
				l = I1(e, i, s)
			if ((H8(n, r, l), fs(l))) e.canAutoFreeze_ = !1
			else return
		} else o && n.add(i)
		if (So(i) && !cx(i)) {
			if (!e.immer_.autoFreeze_ && e.unfinalizedDrafts_ < 1) return
			I1(e, i),
				(!t || !t.scope_.parent_) &&
					typeof r != "symbol" &&
					Object.prototype.propertyIsEnumerable.call(n, r) &&
					R1(e, i)
		}
	}
	function R1(e, t, n = !1) {
		!e.parent_ && e.immer_.autoFreeze_ && e.canAutoFreeze_ && QD(t, n)
	}
	function dZ(e, t) {
		const n = Array.isArray(e),
			r = {
				type_: n ? 1 : 0,
				scope_: t ? t.scope_ : $8(),
				modified_: !1,
				finalized_: !1,
				assigned_: {},
				parent_: t,
				base_: e,
				draft_: null,
				copy_: null,
				revoke_: null,
				isManual_: !1,
			}
		let i = r,
			a = XD
		n && ((i = [r]), (a = iv))
		const { revoke: o, proxy: s } = Proxy.revocable(i, a)
		return (r.draft_ = s), (r.revoke_ = o), s
	}
	var XD = {
			get(e, t) {
				if (t === Vi) return e
				const n = Dc(e)
				if (!nv(n, t)) return fZ(e, n, t)
				const r = n[t]
				return e.finalized_ || !So(r)
					? r
					: r === jC(e.base_, t)
					? (FC(e), (e.copy_[t] = MS(r, e)))
					: r
			},
			has(e, t) {
				return t in Dc(e)
			},
			ownKeys(e) {
				return Reflect.ownKeys(Dc(e))
			},
			set(e, t, n) {
				const r = U8(Dc(e), t)
				if (r != null && r.set) return r.set.call(e.draft_, n), !0
				if (!e.modified_) {
					const i = jC(Dc(e), t),
						a = i == null ? void 0 : i[Vi]
					if (a && a.base_ === n) return (e.copy_[t] = n), (e.assigned_[t] = !1), !0
					if (oZ(n, i) && (n !== void 0 || nv(e.base_, t))) return !0
					FC(e), NS(e)
				}
				return (
					(e.copy_[t] === n && (n !== void 0 || t in e.copy_)) ||
						(Number.isNaN(n) && Number.isNaN(e.copy_[t])) ||
						((e.copy_[t] = n), (e.assigned_[t] = !0)),
					!0
				)
			},
			deleteProperty(e, t) {
				return (
					jC(e.base_, t) !== void 0 || t in e.base_
						? ((e.assigned_[t] = !1), FC(e), NS(e))
						: delete e.assigned_[t],
					e.copy_ && delete e.copy_[t],
					!0
				)
			},
			getOwnPropertyDescriptor(e, t) {
				const n = Dc(e),
					r = Reflect.getOwnPropertyDescriptor(n, t)
				return (
					r && {
						writable: !0,
						configurable: e.type_ !== 1 || t !== "length",
						enumerable: r.enumerable,
						value: n[t],
					}
				)
			},
			defineProperty() {
				$r(11)
			},
			getPrototypeOf(e) {
				return sd(e.base_)
			},
			setPrototypeOf() {
				$r(12)
			},
		},
		iv = {}
	tv(XD, (e, t) => {
		iv[e] = function () {
			return (arguments[0] = arguments[0][0]), t.apply(this, arguments)
		}
	})
	iv.deleteProperty = function (e, t) {
		return iv.set.call(this, e, t, void 0)
	}
	iv.set = function (e, t, n) {
		return XD.set.call(this, e[0], t, n, e[0])
	}
	function jC(e, t) {
		const n = e[Vi]
		return (n ? Dc(n) : e)[t]
	}
	function fZ(e, t, n) {
		var i
		const r = U8(t, n)
		return r ? ("value" in r ? r.value : (i = r.get) == null ? void 0 : i.call(e.draft_)) : void 0
	}
	function U8(e, t) {
		if (!(t in e)) return
		let n = sd(e)
		for (; n; ) {
			const r = Object.getOwnPropertyDescriptor(n, t)
			if (r) return r
			n = sd(n)
		}
	}
	function NS(e) {
		e.modified_ || ((e.modified_ = !0), e.parent_ && NS(e.parent_))
	}
	function FC(e) {
		e.copy_ || (e.copy_ = DS(e.base_, e.scope_.immer_.useStrictShallowCopy_))
	}
	var pZ = class {
		constructor(e) {
			;(this.autoFreeze_ = !0),
				(this.useStrictShallowCopy_ = !1),
				(this.produce = (t, n, r) => {
					if (typeof t == "function" && typeof n != "function") {
						const a = n
						n = t
						const o = this
						return function (l = a, ...u) {
							return o.produce(l, (d) => n.call(this, d, ...u))
						}
					}
					typeof n != "function" && $r(6), r !== void 0 && typeof r != "function" && $r(7)
					let i
					if (So(t)) {
						const a = gR(this),
							o = MS(t, void 0)
						let s = !0
						try {
							;(i = n(o)), (s = !1)
						} finally {
							s ? OS(a) : AS(a)
						}
						return vR(a, r), yR(i, a)
					} else if (!t || typeof t != "object") {
						if (
							((i = n(t)),
							i === void 0 && (i = t),
							i === KD && (i = void 0),
							this.autoFreeze_ && QD(i, !0),
							r)
						) {
							const a = [],
								o = []
							ud("Patches").generateReplacementPatches_(t, i, a, o), r(a, o)
						}
						return i
					} else $r(1, t)
				}),
				(this.produceWithPatches = (t, n) => {
					if (typeof t == "function")
						return (o, ...s) => this.produceWithPatches(o, (l) => t(l, ...s))
					let r, i
					return [
						this.produce(t, n, (o, s) => {
							;(r = o), (i = s)
						}),
						r,
						i,
					]
				}),
				typeof (e == null ? void 0 : e.autoFreeze) == "boolean" && this.setAutoFreeze(e.autoFreeze),
				typeof (e == null ? void 0 : e.useStrictShallowCopy) == "boolean" &&
					this.setUseStrictShallowCopy(e.useStrictShallowCopy)
		}
		createDraft(e) {
			So(e) || $r(8), fs(e) && (e = hZ(e))
			const t = gR(this),
				n = MS(e, void 0)
			return (n[Vi].isManual_ = !0), AS(t), n
		}
		finishDraft(e, t) {
			const n = e && e[Vi]
			;(!n || !n.isManual_) && $r(9)
			const { scope_: r } = n
			return vR(r, t), yR(void 0, r)
		}
		setAutoFreeze(e) {
			this.autoFreeze_ = e
		}
		setUseStrictShallowCopy(e) {
			this.useStrictShallowCopy_ = e
		}
		applyPatches(e, t) {
			let n
			for (n = t.length - 1; n >= 0; n--) {
				const i = t[n]
				if (i.path.length === 0 && i.op === "replace") {
					e = i.value
					break
				}
			}
			n > -1 && (t = t.slice(n + 1))
			const r = ud("Patches").applyPatches_
			return fs(e) ? r(e, t) : this.produce(e, (i) => r(i, t))
		}
	}
	function MS(e, t) {
		const n = Wv(e) ? ud("MapSet").proxyMap_(e, t) : Yv(e) ? ud("MapSet").proxySet_(e, t) : dZ(e, t)
		return (t ? t.scope_ : $8()).drafts_.push(n), n
	}
	function hZ(e) {
		return fs(e) || $r(10, e), z8(e)
	}
	function z8(e) {
		if (!So(e) || cx(e)) return e
		const t = e[Vi]
		let n
		if (t) {
			if (!t.modified_) return t.base_
			;(t.finalized_ = !0), (n = DS(e, t.scope_.immer_.useStrictShallowCopy_))
		} else n = DS(e, !0)
		return (
			tv(n, (r, i) => {
				H8(n, r, z8(i))
			}),
			t && (t.finalized_ = !1),
			n
		)
	}
	function mZ() {
		const t = "replace",
			n = "add",
			r = "remove"
		function i(m, v, y, b) {
			switch (m.type_) {
				case 0:
				case 2:
					return o(m, v, y, b)
				case 1:
					return a(m, v, y, b)
				case 3:
					return s(m, v, y, b)
			}
		}
		function a(m, v, y, b) {
			let { base_: x, assigned_: E } = m,
				T = m.copy_
			T.length < x.length && (([x, T] = [T, x]), ([y, b] = [b, y]))
			for (let C = 0; C < x.length; C++)
				if (E[C] && T[C] !== x[C]) {
					const D = v.concat([C])
					y.push({ op: t, path: D, value: p(T[C]) }), b.push({ op: t, path: D, value: p(x[C]) })
				}
			for (let C = x.length; C < T.length; C++) {
				const D = v.concat([C])
				y.push({ op: n, path: D, value: p(T[C]) })
			}
			for (let C = T.length - 1; x.length <= C; --C) {
				const D = v.concat([C])
				b.push({ op: r, path: D })
			}
		}
		function o(m, v, y, b) {
			const { base_: x, copy_: E } = m
			tv(m.assigned_, (T, C) => {
				const D = PC(x, T),
					O = PC(E, T),
					A = C ? (nv(x, T) ? t : n) : r
				if (D === O && A === t) return
				const N = v.concat(T)
				y.push(A === r ? { op: A, path: N } : { op: A, path: N, value: O }),
					b.push(
						A === n
							? { op: r, path: N }
							: A === r
							? { op: n, path: N, value: p(D) }
							: { op: t, path: N, value: p(D) },
					)
			})
		}
		function s(m, v, y, b) {
			let { base_: x, copy_: E } = m,
				T = 0
			x.forEach((C) => {
				if (!E.has(C)) {
					const D = v.concat([T])
					y.push({ op: r, path: D, value: C }), b.unshift({ op: n, path: D, value: C })
				}
				T++
			}),
				(T = 0),
				E.forEach((C) => {
					if (!x.has(C)) {
						const D = v.concat([T])
						y.push({ op: n, path: D, value: C }), b.unshift({ op: r, path: D, value: C })
					}
					T++
				})
		}
		function l(m, v, y, b) {
			y.push({ op: t, path: [], value: v === KD ? void 0 : v }),
				b.push({ op: t, path: [], value: m })
		}
		function u(m, v) {
			return (
				v.forEach((y) => {
					const { path: b, op: x } = y
					let E = m
					for (let O = 0; O < b.length - 1; O++) {
						const A = ld(E)
						let N = b[O]
						typeof N != "string" && typeof N != "number" && (N = "" + N),
							(A === 0 || A === 1) && (N === "__proto__" || N === "constructor") && $r(19),
							typeof E == "function" && N === "prototype" && $r(19),
							(E = PC(E, N)),
							typeof E != "object" && $r(18, b.join("/"))
					}
					const T = ld(E),
						C = d(y.value),
						D = b[b.length - 1]
					switch (x) {
						case t:
							switch (T) {
								case 2:
									return E.set(D, C)
								case 3:
									$r(16)
								default:
									return (E[D] = C)
							}
						case n:
							switch (T) {
								case 1:
									return D === "-" ? E.push(C) : E.splice(D, 0, C)
								case 2:
									return E.set(D, C)
								case 3:
									return E.add(C)
								default:
									return (E[D] = C)
							}
						case r:
							switch (T) {
								case 1:
									return E.splice(D, 1)
								case 2:
									return E.delete(D)
								case 3:
									return E.delete(y.value)
								default:
									return delete E[D]
							}
						default:
							$r(17, x)
					}
				}),
				m
			)
		}
		function d(m) {
			if (!So(m)) return m
			if (Array.isArray(m)) return m.map(d)
			if (Wv(m)) return new Map(Array.from(m.entries()).map(([y, b]) => [y, d(b)]))
			if (Yv(m)) return new Set(Array.from(m).map(d))
			const v = Object.create(sd(m))
			for (const y in m) v[y] = d(m[y])
			return nv(m, Am) && (v[Am] = m[Am]), v
		}
		function p(m) {
			return fs(m) ? d(m) : m
		}
		lZ("Patches", { applyPatches_: u, generatePatches_: i, generateReplacementPatches_: l })
	}
	var ya = new pZ(),
		Gv = ya.produce,
		q8 = ya.produceWithPatches.bind(ya)
	ya.setAutoFreeze.bind(ya)
	ya.setUseStrictShallowCopy.bind(ya)
	var xR = ya.applyPatches.bind(ya)
	ya.createDraft.bind(ya)
	ya.finishDraft.bind(ya)
	function vZ(e, t = `expected a function, instead received ${typeof e}`) {
		if (typeof e != "function") throw new TypeError(t)
	}
	function gZ(e, t = `expected an object, instead received ${typeof e}`) {
		if (typeof e != "object") throw new TypeError(t)
	}
	function yZ(e, t = "expected all items to be functions, instead received the following types: ") {
		if (!e.every((n) => typeof n == "function")) {
			const n = e
				.map((r) => (typeof r == "function" ? `function ${r.name || "unnamed"}()` : typeof r))
				.join(", ")
			throw new TypeError(`${t}[${n}]`)
		}
	}
	var wR = (e) => (Array.isArray(e) ? e : [e])
	function bZ(e) {
		const t = Array.isArray(e[0]) ? e[0] : e
		return (
			yZ(
				t,
				"createSelector expects all input-selectors to be functions, but received the following types: ",
			),
			t
		)
	}
	function xZ(e, t) {
		const n = [],
			{ length: r } = e
		for (let i = 0; i < r; i++) n.push(e[i].apply(null, t))
		return n
	}
	var wZ = class {
			constructor(e) {
				this.value = e
			}
			deref() {
				return this.value
			}
		},
		EZ = typeof WeakRef < "u" ? WeakRef : wZ,
		CZ = 0,
		ER = 1
	function F0() {
		return { s: CZ, v: void 0, o: null, p: null }
	}
	function L1(e, t = {}) {
		let n = F0()
		const { resultEqualityCheck: r } = t
		let i,
			a = 0
		function o() {
			var p
			let s = n
			const { length: l } = arguments
			for (let m = 0, v = l; m < v; m++) {
				const y = arguments[m]
				if (typeof y == "function" || (typeof y == "object" && y !== null)) {
					let b = s.o
					b === null && (s.o = b = new WeakMap())
					const x = b.get(y)
					x === void 0 ? ((s = F0()), b.set(y, s)) : (s = x)
				} else {
					let b = s.p
					b === null && (s.p = b = new Map())
					const x = b.get(y)
					x === void 0 ? ((s = F0()), b.set(y, s)) : (s = x)
				}
			}
			const u = s
			let d
			if (s.s === ER) d = s.v
			else if (((d = e.apply(null, arguments)), a++, r)) {
				const m = ((p = i == null ? void 0 : i.deref) == null ? void 0 : p.call(i)) ?? i
				m != null && r(m, d) && ((d = m), a !== 0 && a--),
					(i = (typeof d == "object" && d !== null) || typeof d == "function" ? new EZ(d) : d)
			}
			return (u.s = ER), (u.v = d), d
		}
		return (
			(o.clearCache = () => {
				;(n = F0()), o.resetResultsCount()
			}),
			(o.resultsCount = () => a),
			(o.resetResultsCount = () => {
				a = 0
			}),
			o
		)
	}
	function TZ(e, ...t) {
		const n = typeof e == "function" ? { memoize: e, memoizeOptions: t } : e,
			r = (...i) => {
				let a = 0,
					o = 0,
					s,
					l = {},
					u = i.pop()
				typeof u == "object" && ((l = u), (u = i.pop())),
					vZ(
						u,
						`createSelector expects an output function after the inputs, but received: [${typeof u}]`,
					)
				const d = { ...n, ...l },
					{
						memoize: p,
						memoizeOptions: m = [],
						argsMemoize: v = L1,
						argsMemoizeOptions: y = [],
						devModeChecks: b = {},
					} = d,
					x = wR(m),
					E = wR(y),
					T = bZ(i),
					C = p(function () {
						return a++, u.apply(null, arguments)
					}, ...x),
					D = v(function () {
						o++
						const A = xZ(T, arguments)
						return (s = C.apply(null, A)), s
					}, ...E)
				return Object.assign(D, {
					resultFunc: u,
					memoizedResultFunc: C,
					dependencies: T,
					dependencyRecomputations: () => o,
					resetDependencyRecomputations: () => {
						o = 0
					},
					lastResult: () => s,
					recomputations: () => a,
					resetRecomputations: () => {
						a = 0
					},
					memoize: p,
					argsMemoize: v,
				})
			}
		return Object.assign(r, { withTypes: () => r }), r
	}
	var dx = TZ(L1),
		kZ = Object.assign(
			(e, t = dx) => {
				gZ(
					e,
					`createStructuredSelector expects first argument to be an object where each property is a selector, instead received a ${typeof e}`,
				)
				const n = Object.keys(e),
					r = n.map((a) => e[a])
				return t(r, (...a) => a.reduce((o, s, l) => ((o[n[l]] = s), o), {}))
			},
			{ withTypes: () => kZ },
		)
	function V8(e) {
		return ({ dispatch: n, getState: r }) =>
			(i) =>
			(a) =>
				typeof a == "function" ? a(n, r, e) : i(a)
	}
	var SZ = V8(),
		DZ = V8,
		_Z =
			typeof window < "u" && window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__
				? window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__
				: function () {
						if (arguments.length !== 0)
							return typeof arguments[0] == "object" ? M1 : M1.apply(null, arguments)
				  },
		OZ = (e) => e && typeof e.match == "function"
	function yo(e, t) {
		function n(...r) {
			if (t) {
				let i = t(...r)
				if (!i) throw new Error(bo(0))
				return {
					type: e,
					payload: i.payload,
					...("meta" in i && { meta: i.meta }),
					...("error" in i && { error: i.error }),
				}
			}
			return { type: e, payload: r[0] }
		}
		return (n.toString = () => `${e}`), (n.type = e), (n.match = (r) => F8(r) && r.type === e), n
	}
	var W8 = class gm extends Array {
		constructor(...t) {
			super(...t), Object.setPrototypeOf(this, gm.prototype)
		}
		static get [Symbol.species]() {
			return gm
		}
		concat(...t) {
			return super.concat.apply(this, t)
		}
		prepend(...t) {
			return t.length === 1 && Array.isArray(t[0])
				? new gm(...t[0].concat(this))
				: new gm(...t.concat(this))
		}
	}
	function CR(e) {
		return So(e) ? Gv(e, () => {}) : e
	}
	function TR(e, t, n) {
		return e.has(t) ? e.get(t) : e.set(t, n(t)).get(t)
	}
	function AZ(e) {
		return typeof e == "boolean"
	}
	var NZ = () =>
			function (t) {
				const {
					thunk: n = !0,
					immutableCheck: r = !0,
					serializableCheck: i = !0,
					actionCreatorCheck: a = !0,
				} = t ?? {}
				let o = new W8()
				return n && (AZ(n) ? o.push(SZ) : o.push(DZ(n.extraArgument))), o
			},
		Lc = "RTK_autoBatch",
		Gh = () => (e) => ({ payload: e, meta: { [Lc]: !0 } }),
		kR = (e) => (t) => {
			setTimeout(t, e)
		},
		MZ =
			(e = { type: "raf" }) =>
			(t) =>
			(...n) => {
				const r = t(...n)
				let i = !0,
					a = !1,
					o = !1
				const s = new Set(),
					l =
						e.type === "tick"
							? queueMicrotask
							: e.type === "raf"
							? typeof window < "u" && window.requestAnimationFrame
								? window.requestAnimationFrame
								: kR(10)
							: e.type === "callback"
							? e.queueNotification
							: kR(e.timeout),
					u = () => {
						;(o = !1), a && ((a = !1), s.forEach((d) => d()))
					}
				return Object.assign({}, r, {
					subscribe(d) {
						const p = () => i && d(),
							m = r.subscribe(p)
						return (
							s.add(d),
							() => {
								m(), s.delete(d)
							}
						)
					},
					dispatch(d) {
						var p
						try {
							return (
								(i = !((p = d == null ? void 0 : d.meta) != null && p[Lc])),
								(a = !i),
								a && (o || ((o = !0), l(u))),
								r.dispatch(d)
							)
						} finally {
							i = !0
						}
					},
				})
			},
		IZ = (e) =>
			function (n) {
				const { autoBatch: r = !0 } = n ?? {}
				let i = new W8(e)
				return r && i.push(MZ(typeof r == "object" ? r : void 0)), i
			}
	function RZ(e) {
		const t = NZ(),
			{
				reducer: n = void 0,
				middleware: r,
				devTools: i = !0,
				preloadedState: a = void 0,
				enhancers: o = void 0,
			} = e || {}
		let s
		if (typeof n == "function") s = n
		else if (Ru(n)) s = j8(n)
		else throw new Error(bo(1))
		let l
		typeof r == "function" ? (l = r(t)) : (l = t())
		let u = M1
		i && (u = _Z({ trace: !1, ...(typeof i == "object" && i) }))
		const d = rZ(...l),
			p = IZ(d)
		let m = typeof o == "function" ? o(p) : p()
		const v = u(...m)
		return P8(s, a, v)
	}
	function Y8(e) {
		const t = {},
			n = []
		let r
		const i = {
			addCase(a, o) {
				const s = typeof a == "string" ? a : a.type
				if (!s) throw new Error(bo(28))
				if (s in t) throw new Error(bo(29))
				return (t[s] = o), i
			},
			addMatcher(a, o) {
				return n.push({ matcher: a, reducer: o }), i
			},
			addDefaultCase(a) {
				return (r = a), i
			},
		}
		return e(i), [t, n, r]
	}
	function LZ(e) {
		return typeof e == "function"
	}
	function PZ(e, t) {
		let [n, r, i] = Y8(t),
			a
		if (LZ(e)) a = () => CR(e())
		else {
			const s = CR(e)
			a = () => s
		}
		function o(s = a(), l) {
			let u = [n[l.type], ...r.filter(({ matcher: d }) => d(l)).map(({ reducer: d }) => d)]
			return (
				u.filter((d) => !!d).length === 0 && (u = [i]),
				u.reduce((d, p) => {
					if (p)
						if (fs(d)) {
							const v = p(d, l)
							return v === void 0 ? d : v
						} else {
							if (So(d)) return Gv(d, (m) => p(m, l))
							{
								const m = p(d, l)
								if (m === void 0) {
									if (d === null) return d
									throw Error("A case reducer on a non-draftable value must not return undefined")
								}
								return m
							}
						}
					return d
				}, s)
			)
		}
		return (o.getInitialState = a), o
	}
	var G8 = (e, t) => (OZ(e) ? e.match(t) : e(t))
	function yl(...e) {
		return (t) => e.some((n) => G8(n, t))
	}
	function Nm(...e) {
		return (t) => e.every((n) => G8(n, t))
	}
	function fx(e, t) {
		if (!e || !e.meta) return !1
		const n = typeof e.meta.requestId == "string",
			r = t.indexOf(e.meta.requestStatus) > -1
		return n && r
	}
	function Kv(e) {
		return (
			typeof e[0] == "function" && "pending" in e[0] && "fulfilled" in e[0] && "rejected" in e[0]
		)
	}
	function JD(...e) {
		return e.length === 0
			? (t) => fx(t, ["pending"])
			: Kv(e)
			? yl(...e.map((t) => t.pending))
			: JD()(e[0])
	}
	function ep(...e) {
		return e.length === 0
			? (t) => fx(t, ["rejected"])
			: Kv(e)
			? yl(...e.map((t) => t.rejected))
			: ep()(e[0])
	}
	function px(...e) {
		const t = (n) => n && n.meta && n.meta.rejectedWithValue
		return e.length === 0 ? Nm(ep(...e), t) : Kv(e) ? Nm(ep(...e), t) : px()(e[0])
	}
	function Lu(...e) {
		return e.length === 0
			? (t) => fx(t, ["fulfilled"])
			: Kv(e)
			? yl(...e.map((t) => t.fulfilled))
			: Lu()(e[0])
	}
	function IS(...e) {
		return e.length === 0
			? (t) => fx(t, ["pending", "fulfilled", "rejected"])
			: Kv(e)
			? yl(...e.flatMap((t) => [t.pending, t.rejected, t.fulfilled]))
			: IS()(e[0])
	}
	var jZ = "ModuleSymbhasOwnPr-0123456789ABCDEFGHNRVfgctiUvz_KqYTJkLxpZXIjQW",
		ZD = (e = 21) => {
			let t = "",
				n = e
			for (; n--; ) t += jZ[(Math.random() * 64) | 0]
			return t
		},
		FZ = ["name", "message", "stack", "code"],
		BC = class {
			constructor(e, t) {
				q(this, "_type")
				;(this.payload = e), (this.meta = t)
			}
		},
		SR = class {
			constructor(e, t) {
				q(this, "_type")
				;(this.payload = e), (this.meta = t)
			}
		},
		BZ = (e) => {
			if (typeof e == "object" && e !== null) {
				const t = {}
				for (const n of FZ) typeof e[n] == "string" && (t[n] = e[n])
				return t
			}
			return { message: String(e) }
		},
		qr = (() => {
			function e(t, n, r) {
				const i = yo(t + "/fulfilled", (l, u, d, p) => ({
						payload: l,
						meta: { ...(p || {}), arg: d, requestId: u, requestStatus: "fulfilled" },
					})),
					a = yo(t + "/pending", (l, u, d) => ({
						payload: void 0,
						meta: { ...(d || {}), arg: u, requestId: l, requestStatus: "pending" },
					})),
					o = yo(t + "/rejected", (l, u, d, p, m) => ({
						payload: p,
						error: ((r && r.serializeError) || BZ)(l || "Rejected"),
						meta: {
							...(m || {}),
							arg: d,
							requestId: u,
							rejectedWithValue: !!p,
							requestStatus: "rejected",
							aborted: (l == null ? void 0 : l.name) === "AbortError",
							condition: (l == null ? void 0 : l.name) === "ConditionError",
						},
					}))
				function s(l) {
					return (u, d, p) => {
						const m = r != null && r.idGenerator ? r.idGenerator(l) : ZD(),
							v = new AbortController()
						let y, b
						function x(T) {
							;(b = T), v.abort()
						}
						const E = (async function () {
							var D, O
							let T
							try {
								let A =
									(D = r == null ? void 0 : r.condition) == null
										? void 0
										: D.call(r, l, { getState: d, extra: p })
								if (($Z(A) && (A = await A), A === !1 || v.signal.aborted))
									throw {
										name: "ConditionError",
										message: "Aborted due to condition callback returning false.",
									}
								const N = new Promise((I, P) => {
									;(y = () => {
										P({ name: "AbortError", message: b || "Aborted" })
									}),
										v.signal.addEventListener("abort", y)
								})
								u(
									a(
										m,
										l,
										(O = r == null ? void 0 : r.getPendingMeta) == null
											? void 0
											: O.call(r, { requestId: m, arg: l }, { getState: d, extra: p }),
									),
								),
									(T = await Promise.race([
										N,
										Promise.resolve(
											n(l, {
												dispatch: u,
												getState: d,
												extra: p,
												requestId: m,
												signal: v.signal,
												abort: x,
												rejectWithValue: (I, P) => new BC(I, P),
												fulfillWithValue: (I, P) => new SR(I, P),
											}),
										).then((I) => {
											if (I instanceof BC) throw I
											return I instanceof SR ? i(I.payload, m, l, I.meta) : i(I, m, l)
										}),
									]))
							} catch (A) {
								T = A instanceof BC ? o(null, m, l, A.payload, A.meta) : o(A, m, l)
							} finally {
								y && v.signal.removeEventListener("abort", y)
							}
							return (
								(r && !r.dispatchConditionRejection && o.match(T) && T.meta.condition) || u(T), T
							)
						})()
						return Object.assign(E, {
							abort: x,
							requestId: m,
							arg: l,
							unwrap() {
								return E.then(HZ)
							},
						})
					}
				}
				return Object.assign(s, {
					pending: a,
					rejected: o,
					fulfilled: i,
					settled: yl(o, i),
					typePrefix: t,
				})
			}
			return (e.withTypes = () => e), e
		})()
	function HZ(e) {
		if (e.meta && e.meta.rejectedWithValue) throw e.payload
		if (e.error) throw e.error
		return e.payload
	}
	function $Z(e) {
		return e !== null && typeof e == "object" && typeof e.then == "function"
	}
	var UZ = Symbol.for("rtk-slice-createasyncthunk")
	function zZ(e, t) {
		return `${e}/${t}`
	}
	function qZ({ creators: e } = {}) {
		var n
		const t = (n = e == null ? void 0 : e.asyncThunk) == null ? void 0 : n[UZ]
		return function (i) {
			const { name: a, reducerPath: o = a } = i
			if (!a) throw new Error(bo(11))
			typeof process < "u"
			const s = (typeof i.reducers == "function" ? i.reducers(WZ()) : i.reducers) || {},
				l = Object.keys(s),
				u = {
					sliceCaseReducersByName: {},
					sliceCaseReducersByType: {},
					actionCreators: {},
					sliceMatchers: [],
				},
				d = {
					addCase(C, D) {
						const O = typeof C == "string" ? C : C.type
						if (!O) throw new Error(bo(12))
						if (O in u.sliceCaseReducersByType) throw new Error(bo(13))
						return (u.sliceCaseReducersByType[O] = D), d
					},
					addMatcher(C, D) {
						return u.sliceMatchers.push({ matcher: C, reducer: D }), d
					},
					exposeAction(C, D) {
						return (u.actionCreators[C] = D), d
					},
					exposeCaseReducer(C, D) {
						return (u.sliceCaseReducersByName[C] = D), d
					},
				}
			l.forEach((C) => {
				const D = s[C],
					O = { reducerName: C, type: zZ(a, C), createNotation: typeof i.reducers == "function" }
				GZ(D) ? QZ(O, D, d, t) : YZ(O, D, d)
			})
			function p() {
				const [C = {}, D = [], O = void 0] =
						typeof i.extraReducers == "function" ? Y8(i.extraReducers) : [i.extraReducers],
					A = { ...C, ...u.sliceCaseReducersByType }
				return PZ(i.initialState, (N) => {
					for (let I in A) N.addCase(I, A[I])
					for (let I of u.sliceMatchers) N.addMatcher(I.matcher, I.reducer)
					for (let I of D) N.addMatcher(I.matcher, I.reducer)
					O && N.addDefaultCase(O)
				})
			}
			const m = (C) => C,
				v = new Map()
			let y
			function b(C, D) {
				return y || (y = p()), y(C, D)
			}
			function x() {
				return y || (y = p()), y.getInitialState()
			}
			function E(C, D = !1) {
				function O(N) {
					let I = N[C]
					return typeof I > "u" && D && (I = x()), I
				}
				function A(N = m) {
					const I = TR(v, D, () => new WeakMap())
					return TR(I, N, () => {
						const P = {}
						for (const [L, B] of Object.entries(i.selectors ?? {})) P[L] = VZ(B, N, x, D)
						return P
					})
				}
				return {
					reducerPath: C,
					getSelectors: A,
					get selectors() {
						return A(O)
					},
					selectSlice: O,
				}
			}
			const T = {
				name: a,
				reducer: b,
				actions: u.actionCreators,
				caseReducers: u.sliceCaseReducersByName,
				getInitialState: x,
				...E(o),
				injectInto(C, { reducerPath: D, ...O } = {}) {
					const A = D ?? o
					return C.inject({ reducerPath: A, reducer: b }, O), { ...T, ...E(A, !0) }
				},
			}
			return T
		}
	}
	function VZ(e, t, n, r) {
		function i(a, ...o) {
			let s = t(a)
			return typeof s > "u" && r && (s = n()), e(s, ...o)
		}
		return (i.unwrapped = e), i
	}
	var co = qZ()
	function WZ() {
		function e(t, n) {
			return { _reducerDefinitionType: "asyncThunk", payloadCreator: t, ...n }
		}
		return (
			(e.withTypes = () => e),
			{
				reducer(t) {
					return Object.assign(
						{
							[t.name](...n) {
								return t(...n)
							},
						}[t.name],
						{ _reducerDefinitionType: "reducer" },
					)
				},
				preparedReducer(t, n) {
					return { _reducerDefinitionType: "reducerWithPrepare", prepare: t, reducer: n }
				},
				asyncThunk: e,
			}
		)
	}
	function YZ({ type: e, reducerName: t, createNotation: n }, r, i) {
		let a, o
		if ("reducer" in r) {
			if (n && !KZ(r)) throw new Error(bo(17))
			;(a = r.reducer), (o = r.prepare)
		} else a = r
		i.addCase(e, a)
			.exposeCaseReducer(t, a)
			.exposeAction(t, o ? yo(e, o) : yo(e))
	}
	function GZ(e) {
		return e._reducerDefinitionType === "asyncThunk"
	}
	function KZ(e) {
		return e._reducerDefinitionType === "reducerWithPrepare"
	}
	function QZ({ type: e, reducerName: t }, n, r, i) {
		if (!i) throw new Error(bo(18))
		const { payloadCreator: a, fulfilled: o, pending: s, rejected: l, settled: u, options: d } = n,
			p = i(e, a, d)
		r.exposeAction(t, p),
			o && r.addCase(p.fulfilled, o),
			s && r.addCase(p.pending, s),
			l && r.addCase(p.rejected, l),
			u && r.addMatcher(p.settled, u),
			r.exposeCaseReducer(t, {
				fulfilled: o || B0,
				pending: s || B0,
				rejected: l || B0,
				settled: u || B0,
			})
	}
	function B0() {}
	function bo(e) {
		return `Minified Redux Toolkit error #${e}; visit https://redux-toolkit.js.org/Errors?code=${e} for the full message or use the non-minified dev environment for full errors. `
	}
	var K8 = ((e) => (
		(e.uninitialized = "uninitialized"),
		(e.pending = "pending"),
		(e.fulfilled = "fulfilled"),
		(e.rejected = "rejected"),
		e
	))(K8 || {})
	function XZ(e) {
		return {
			status: e,
			isUninitialized: e === "uninitialized",
			isLoading: e === "pending",
			isSuccess: e === "fulfilled",
			isError: e === "rejected",
		}
	}
	var DR = Ru
	function Q8(e, t) {
		if (e === t || !((DR(e) && DR(t)) || (Array.isArray(e) && Array.isArray(t)))) return t
		const n = Object.keys(t),
			r = Object.keys(e)
		let i = n.length === r.length
		const a = Array.isArray(t) ? [] : {}
		for (const o of n) (a[o] = Q8(e[o], t[o])), i && (i = e[o] === a[o])
		return i ? e : a
	}
	function Uf(e) {
		let t = 0
		for (const n in e) t++
		return t
	}
	var _R = (e) => [].concat(...e)
	function JZ() {
		return typeof document > "u" ? !0 : document.visibilityState !== "hidden"
	}
	function P1(e) {
		return e != null
	}
	function ZZ() {
		return typeof navigator > "u" || navigator.onLine === void 0 ? !0 : navigator.onLine
	}
	function eee(e, t, n) {
		return e.has(t) ? e.get(t) : e.set(t, n).get(t)
	}
	var OR = class {
			constructor(e, t = void 0) {
				;(this.value = e), (this.meta = t)
			}
		},
		e_ = yo("__rtkq/focused"),
		X8 = yo("__rtkq/unfocused"),
		t_ = yo("__rtkq/online"),
		J8 = yo("__rtkq/offline")
	function Z8(e) {
		return e.type === "query"
	}
	function tee(e) {
		return e.type === "mutation"
	}
	function n_(e, t, n, r, i, a) {
		return nee(e)
			? e(t, n, r, i).filter(P1).map(RS).map(a)
			: Array.isArray(e)
			? e.map(RS).map(a)
			: []
	}
	function nee(e) {
		return typeof e == "function"
	}
	function RS(e) {
		return typeof e == "string" ? { type: e } : e
	}
	function ree(e, t) {
		return e.catch(t)
	}
	var av = Symbol("forceQueryFn"),
		LS = (e) => typeof e[av] == "function"
	function iee({ serializeQueryArgs: e, queryThunk: t, mutationThunk: n, api: r, context: i }) {
		const a = new Map(),
			o = new Map(),
			{
				unsubscribeQueryResult: s,
				removeMutationResult: l,
				updateSubscriptionOptions: u,
			} = r.internalActions
		return {
			buildInitiateQuery: y,
			buildInitiateMutation: b,
			getRunningQueryThunk: d,
			getRunningMutationThunk: p,
			getRunningQueriesThunk: m,
			getRunningMutationsThunk: v,
		}
		function d(x, E) {
			return (T) => {
				var O
				const C = i.endpointDefinitions[x],
					D = e({ queryArgs: E, endpointDefinition: C, endpointName: x })
				return (O = a.get(T)) == null ? void 0 : O[D]
			}
		}
		function p(x, E) {
			return (T) => {
				var C
				return (C = o.get(T)) == null ? void 0 : C[E]
			}
		}
		function m() {
			return (x) => Object.values(a.get(x) || {}).filter(P1)
		}
		function v() {
			return (x) => Object.values(o.get(x) || {}).filter(P1)
		}
		function y(x, E) {
			const T =
				(C, { subscribe: D = !0, forceRefetch: O, subscriptionOptions: A, [av]: N, ...I } = {}) =>
				(P, L) => {
					var ee
					const B = e({ queryArgs: C, endpointDefinition: E, endpointName: x }),
						z = t({
							...I,
							type: "query",
							subscribe: D,
							forceRefetch: O,
							subscriptionOptions: A,
							endpointName: x,
							originalArgs: C,
							queryCacheKey: B,
							[av]: N,
						}),
						V = r.endpoints[x].select(C),
						K = P(z),
						ne = V(L()),
						{ requestId: re, abort: ie } = K,
						J = ne.requestId !== re,
						le = (ee = a.get(P)) == null ? void 0 : ee[B],
						F = () => V(L()),
						Y = Object.assign(
							N ? K.then(F) : J && !le ? Promise.resolve(ne) : Promise.all([le, K]).then(F),
							{
								arg: C,
								requestId: re,
								subscriptionOptions: A,
								queryCacheKey: B,
								abort: ie,
								async unwrap() {
									const $ = await Y
									if ($.isError) throw $.error
									return $.data
								},
								refetch: () => P(T(C, { subscribe: !1, forceRefetch: !0 })),
								unsubscribe() {
									D && P(s({ queryCacheKey: B, requestId: re }))
								},
								updateSubscriptionOptions($) {
									;(Y.subscriptionOptions = $),
										P(u({ endpointName: x, requestId: re, queryCacheKey: B, options: $ }))
								},
							},
						)
					if (!le && !J && !N) {
						const $ = eee(a, P, {})
						;($[B] = Y),
							Y.then(() => {
								delete $[B], Uf($) || a.delete(P)
							})
					}
					return Y
				}
			return T
		}
		function b(x) {
			return (E, { track: T = !0, fixedCacheKey: C } = {}) =>
				(D, O) => {
					const A = n({
							type: "mutation",
							endpointName: x,
							originalArgs: E,
							track: T,
							fixedCacheKey: C,
						}),
						N = D(A),
						{ requestId: I, abort: P, unwrap: L } = N,
						B = ree(
							N.unwrap().then((ne) => ({ data: ne })),
							(ne) => ({ error: ne }),
						),
						z = () => {
							D(l({ requestId: I, fixedCacheKey: C }))
						},
						V = Object.assign(B, { arg: N.arg, requestId: I, abort: P, unwrap: L, reset: z }),
						K = o.get(D) || {}
					return (
						o.set(D, K),
						(K[I] = V),
						V.then(() => {
							delete K[I], Uf(K) || o.delete(D)
						}),
						C &&
							((K[C] = V),
							V.then(() => {
								K[C] === V && (delete K[C], Uf(K) || o.delete(D))
							})),
						V
					)
				}
		}
	}
	function AR(e) {
		return e
	}
	function aee({
		reducerPath: e,
		baseQuery: t,
		context: { endpointDefinitions: n },
		serializeQueryArgs: r,
		api: i,
		assertTagType: a,
	}) {
		const o = (T, C, D, O) => (A, N) => {
				const I = n[T],
					P = r({ queryArgs: C, endpointDefinition: I, endpointName: T })
				if ((A(i.internalActions.queryResultPatched({ queryCacheKey: P, patches: D })), !O)) return
				const L = i.endpoints[T].select(C)(N()),
					B = n_(I.providesTags, L.data, void 0, C, {}, a)
				A(i.internalActions.updateProvidedBy({ queryCacheKey: P, providedTags: B }))
			},
			s =
				(T, C, D, O = !0) =>
				(A, N) => {
					const P = i.endpoints[T].select(C)(N()),
						L = {
							patches: [],
							inversePatches: [],
							undo: () => A(i.util.patchQueryData(T, C, L.inversePatches, O)),
						}
					if (P.status === "uninitialized") return L
					let B
					if ("data" in P)
						if (So(P.data)) {
							const [z, V, K] = q8(P.data, D)
							L.patches.push(...V), L.inversePatches.push(...K), (B = z)
						} else
							(B = D(P.data)),
								L.patches.push({ op: "replace", path: [], value: B }),
								L.inversePatches.push({ op: "replace", path: [], value: P.data })
					return L.patches.length === 0 || A(i.util.patchQueryData(T, C, L.patches, O)), L
				},
			l = (T, C, D) => (O) =>
				O(
					i.endpoints[T].initiate(C, {
						subscribe: !1,
						forceRefetch: !0,
						[av]: () => ({ data: D }),
					}),
				),
			u = async (
				T,
				{
					signal: C,
					abort: D,
					rejectWithValue: O,
					fulfillWithValue: A,
					dispatch: N,
					getState: I,
					extra: P,
				},
			) => {
				const L = n[T.endpointName]
				try {
					let B = AR,
						z
					const V = {
							signal: C,
							abort: D,
							dispatch: N,
							getState: I,
							extra: P,
							endpoint: T.endpointName,
							type: T.type,
							forced: T.type === "query" ? d(T, I()) : void 0,
							queryCacheKey: T.type === "query" ? T.queryCacheKey : void 0,
						},
						K = T.type === "query" ? T[av] : void 0
					if (
						(K
							? (z = K())
							: L.query
							? ((z = await t(L.query(T.originalArgs), V, L.extraOptions)),
							  L.transformResponse && (B = L.transformResponse))
							: (z = await L.queryFn(T.originalArgs, V, L.extraOptions, (ne) =>
									t(ne, V, L.extraOptions),
							  )),
						typeof process < "u",
						z.error)
					)
						throw new OR(z.error, z.meta)
					return A(await B(z.data, z.meta, T.originalArgs), {
						fulfilledTimeStamp: Date.now(),
						baseQueryMeta: z.meta,
						[Lc]: !0,
					})
				} catch (B) {
					let z = B
					if (z instanceof OR) {
						let V = AR
						L.query && L.transformErrorResponse && (V = L.transformErrorResponse)
						try {
							return O(await V(z.value, z.meta, T.originalArgs), {
								baseQueryMeta: z.meta,
								[Lc]: !0,
							})
						} catch (K) {
							z = K
						}
					}
					throw (typeof process < "u", console.error(z), z)
				}
			}
		function d(T, C) {
			var I, P, L
			const D = (P = (I = C[e]) == null ? void 0 : I.queries) == null ? void 0 : P[T.queryCacheKey],
				O = (L = C[e]) == null ? void 0 : L.config.refetchOnMountOrArgChange,
				A = D == null ? void 0 : D.fulfilledTimeStamp,
				N = T.forceRefetch ?? (T.subscribe && O)
			return N ? N === !0 || (Number(new Date()) - Number(A)) / 1e3 >= N : !1
		}
		const p = qr(`${e}/executeQuery`, u, {
				getPendingMeta() {
					return { startedTimeStamp: Date.now(), [Lc]: !0 }
				},
				condition(T, { getState: C }) {
					var L, B, z
					const D = C(),
						O = (B = (L = D[e]) == null ? void 0 : L.queries) == null ? void 0 : B[T.queryCacheKey],
						A = O == null ? void 0 : O.fulfilledTimeStamp,
						N = T.originalArgs,
						I = O == null ? void 0 : O.originalArgs,
						P = n[T.endpointName]
					return LS(T)
						? !0
						: (O == null ? void 0 : O.status) === "pending"
						? !1
						: d(T, D) ||
						  (Z8(P) &&
								(z = P == null ? void 0 : P.forceRefetch) != null &&
								z.call(P, { currentArg: N, previousArg: I, endpointState: O, state: D }))
						? !0
						: !A
				},
				dispatchConditionRejection: !0,
			}),
			m = qr(`${e}/executeMutation`, u, {
				getPendingMeta() {
					return { startedTimeStamp: Date.now(), [Lc]: !0 }
				},
			}),
			v = (T) => "force" in T,
			y = (T) => "ifOlderThan" in T,
			b = (T, C, D) => (O, A) => {
				const N = v(D) && D.force,
					I = y(D) && D.ifOlderThan,
					P = (B = !0) => {
						const z = { forceRefetch: B, isPrefetch: !0 }
						return i.endpoints[T].initiate(C, z)
					},
					L = i.endpoints[T].select(C)(A())
				if (N) O(P())
				else if (I) {
					const B = L == null ? void 0 : L.fulfilledTimeStamp
					if (!B) {
						O(P())
						return
					}
					;(Number(new Date()) - Number(new Date(B))) / 1e3 >= I && O(P())
				} else O(P(!1))
			}
		function x(T) {
			return (C) => {
				var D, O
				return (
					((O = (D = C == null ? void 0 : C.meta) == null ? void 0 : D.arg) == null
						? void 0
						: O.endpointName) === T
				)
			}
		}
		function E(T, C) {
			return {
				matchPending: Nm(JD(T), x(C)),
				matchFulfilled: Nm(Lu(T), x(C)),
				matchRejected: Nm(ep(T), x(C)),
			}
		}
		return {
			queryThunk: p,
			mutationThunk: m,
			prefetch: b,
			updateQueryData: s,
			upsertQueryData: l,
			patchQueryData: o,
			buildMatchThunkActions: E,
		}
	}
	function eB(e, t, n, r) {
		return n_(
			n[e.meta.arg.endpointName][t],
			Lu(e) ? e.payload : void 0,
			px(e) ? e.payload : void 0,
			e.meta.arg.originalArgs,
			"baseQueryMeta" in e.meta ? e.meta.baseQueryMeta : void 0,
			r,
		)
	}
	function H0(e, t, n) {
		const r = e[t]
		r && n(r)
	}
	function ov(e) {
		return ("arg" in e ? e.arg.fixedCacheKey : e.fixedCacheKey) ?? e.requestId
	}
	function NR(e, t, n) {
		const r = e[ov(t)]
		r && n(r)
	}
	var Kh = {}
	function oee({
		reducerPath: e,
		queryThunk: t,
		mutationThunk: n,
		serializeQueryArgs: r,
		context: {
			endpointDefinitions: i,
			apiUid: a,
			extractRehydrationInfo: o,
			hasRehydrationInfo: s,
		},
		assertTagType: l,
		config: u,
	}) {
		const d = yo(`${e}/resetApiState`)
		function p(A, N, I, P) {
			var L
			A[(L = N.queryCacheKey)] ??
				(A[L] = { status: "uninitialized", endpointName: N.endpointName }),
				H0(A, N.queryCacheKey, (B) => {
					;(B.status = "pending"),
						(B.requestId = I && B.requestId ? B.requestId : P.requestId),
						N.originalArgs !== void 0 && (B.originalArgs = N.originalArgs),
						(B.startedTimeStamp = P.startedTimeStamp)
				})
		}
		function m(A, N, I) {
			H0(A, N.arg.queryCacheKey, (P) => {
				if (P.requestId !== N.requestId && !LS(N.arg)) return
				const { merge: L } = i[N.arg.endpointName]
				if (((P.status = "fulfilled"), L))
					if (P.data !== void 0) {
						const { fulfilledTimeStamp: B, arg: z, baseQueryMeta: V, requestId: K } = N
						let ne = Gv(P.data, (re) =>
							L(re, I, {
								arg: z.originalArgs,
								baseQueryMeta: V,
								fulfilledTimeStamp: B,
								requestId: K,
							}),
						)
						P.data = ne
					} else P.data = I
				else
					P.data =
						i[N.arg.endpointName].structuralSharing ?? !0
							? Q8(fs(P.data) ? aZ(P.data) : P.data, I)
							: I
				delete P.error, (P.fulfilledTimeStamp = N.fulfilledTimeStamp)
			})
		}
		const v = co({
				name: `${e}/queries`,
				initialState: Kh,
				reducers: {
					removeQueryResult: {
						reducer(A, { payload: { queryCacheKey: N } }) {
							delete A[N]
						},
						prepare: Gh(),
					},
					cacheEntriesUpserted: {
						reducer(A, N) {
							for (const I of N.payload) {
								const { queryDescription: P, value: L } = I
								p(A, P, !0, {
									arg: P,
									requestId: N.meta.requestId,
									startedTimeStamp: N.meta.timestamp,
								}),
									m(
										A,
										{
											arg: P,
											requestId: N.meta.requestId,
											fulfilledTimeStamp: N.meta.timestamp,
											baseQueryMeta: {},
										},
										L,
									)
							}
						},
						prepare: (A) => ({
							payload: A.map((P) => {
								const { endpointName: L, arg: B, value: z } = P,
									V = i[L]
								return {
									queryDescription: {
										type: "query",
										endpointName: L,
										originalArgs: P.arg,
										queryCacheKey: r({ queryArgs: B, endpointDefinition: V, endpointName: L }),
									},
									value: z,
								}
							}),
							meta: { [Lc]: !0, requestId: ZD(), timestamp: Date.now() },
						}),
					},
					queryResultPatched: {
						reducer(A, { payload: { queryCacheKey: N, patches: I } }) {
							H0(A, N, (P) => {
								P.data = xR(P.data, I.concat())
							})
						},
						prepare: Gh(),
					},
				},
				extraReducers(A) {
					A.addCase(t.pending, (N, { meta: I, meta: { arg: P } }) => {
						const L = LS(P)
						p(N, P, L, I)
					})
						.addCase(t.fulfilled, (N, { meta: I, payload: P }) => {
							m(N, I, P)
						})
						.addCase(
							t.rejected,
							(N, { meta: { condition: I, arg: P, requestId: L }, error: B, payload: z }) => {
								H0(N, P.queryCacheKey, (V) => {
									if (!I) {
										if (V.requestId !== L) return
										;(V.status = "rejected"), (V.error = z ?? B)
									}
								})
							},
						)
						.addMatcher(s, (N, I) => {
							const { queries: P } = o(I)
							for (const [L, B] of Object.entries(P))
								((B == null ? void 0 : B.status) === "fulfilled" ||
									(B == null ? void 0 : B.status) === "rejected") &&
									(N[L] = B)
						})
				},
			}),
			y = co({
				name: `${e}/mutations`,
				initialState: Kh,
				reducers: {
					removeMutationResult: {
						reducer(A, { payload: N }) {
							const I = ov(N)
							I in A && delete A[I]
						},
						prepare: Gh(),
					},
				},
				extraReducers(A) {
					A.addCase(
						n.pending,
						(N, { meta: I, meta: { requestId: P, arg: L, startedTimeStamp: B } }) => {
							L.track &&
								(N[ov(I)] = {
									requestId: P,
									status: "pending",
									endpointName: L.endpointName,
									startedTimeStamp: B,
								})
						},
					)
						.addCase(n.fulfilled, (N, { payload: I, meta: P }) => {
							P.arg.track &&
								NR(N, P, (L) => {
									L.requestId === P.requestId &&
										((L.status = "fulfilled"),
										(L.data = I),
										(L.fulfilledTimeStamp = P.fulfilledTimeStamp))
								})
						})
						.addCase(n.rejected, (N, { payload: I, error: P, meta: L }) => {
							L.arg.track &&
								NR(N, L, (B) => {
									B.requestId === L.requestId && ((B.status = "rejected"), (B.error = I ?? P))
								})
						})
						.addMatcher(s, (N, I) => {
							const { mutations: P } = o(I)
							for (const [L, B] of Object.entries(P))
								((B == null ? void 0 : B.status) === "fulfilled" ||
									(B == null ? void 0 : B.status) === "rejected") &&
									L !== (B == null ? void 0 : B.requestId) &&
									(N[L] = B)
						})
				},
			}),
			b = co({
				name: `${e}/invalidation`,
				initialState: Kh,
				reducers: {
					updateProvidedBy: {
						reducer(A, N) {
							var L, B
							const { queryCacheKey: I, providedTags: P } = N.payload
							for (const z of Object.values(A))
								for (const V of Object.values(z)) {
									const K = V.indexOf(I)
									K !== -1 && V.splice(K, 1)
								}
							for (const { type: z, id: V } of P) {
								const K =
									(L = A[z] ?? (A[z] = {}))[(B = V || "__internal_without_id")] ?? (L[B] = [])
								K.includes(I) || K.push(I)
							}
						},
						prepare: Gh(),
					},
				},
				extraReducers(A) {
					A.addCase(v.actions.removeQueryResult, (N, { payload: { queryCacheKey: I } }) => {
						for (const P of Object.values(N))
							for (const L of Object.values(P)) {
								const B = L.indexOf(I)
								B !== -1 && L.splice(B, 1)
							}
					})
						.addMatcher(s, (N, I) => {
							var L, B
							const { provided: P } = o(I)
							for (const [z, V] of Object.entries(P))
								for (const [K, ne] of Object.entries(V)) {
									const re =
										(L = N[z] ?? (N[z] = {}))[(B = K || "__internal_without_id")] ?? (L[B] = [])
									for (const ie of ne) re.includes(ie) || re.push(ie)
								}
						})
						.addMatcher(yl(Lu(t), px(t)), (N, I) => {
							const P = eB(I, "providesTags", i, l),
								{ queryCacheKey: L } = I.meta.arg
							b.caseReducers.updateProvidedBy(
								N,
								b.actions.updateProvidedBy({ queryCacheKey: L, providedTags: P }),
							)
						})
				},
			}),
			x = co({
				name: `${e}/subscriptions`,
				initialState: Kh,
				reducers: {
					updateSubscriptionOptions(A, N) {},
					unsubscribeQueryResult(A, N) {},
					internal_getRTKQSubscriptions() {},
				},
			}),
			E = co({
				name: `${e}/internalSubscriptions`,
				initialState: Kh,
				reducers: {
					subscriptionsUpdated: {
						reducer(A, N) {
							return xR(A, N.payload)
						},
						prepare: Gh(),
					},
				},
			}),
			T = co({
				name: `${e}/config`,
				initialState: { online: ZZ(), focused: JZ(), middlewareRegistered: !1, ...u },
				reducers: {
					middlewareRegistered(A, { payload: N }) {
						A.middlewareRegistered =
							A.middlewareRegistered === "conflict" || a !== N ? "conflict" : !0
					},
				},
				extraReducers: (A) => {
					A.addCase(t_, (N) => {
						N.online = !0
					})
						.addCase(J8, (N) => {
							N.online = !1
						})
						.addCase(e_, (N) => {
							N.focused = !0
						})
						.addCase(X8, (N) => {
							N.focused = !1
						})
						.addMatcher(s, (N) => ({ ...N }))
				},
			}),
			C = j8({
				queries: v.reducer,
				mutations: y.reducer,
				provided: b.reducer,
				subscriptions: E.reducer,
				config: T.reducer,
			}),
			D = (A, N) => C(d.match(N) ? void 0 : A, N),
			O = {
				...T.actions,
				...v.actions,
				...x.actions,
				...E.actions,
				...y.actions,
				...b.actions,
				resetApiState: d,
			}
		return { reducer: D, actions: O }
	}
	var ho = Symbol.for("RTKQ/skipToken"),
		tB = { status: "uninitialized" },
		MR = Gv(tB, () => {}),
		IR = Gv(tB, () => {})
	function see({ serializeQueryArgs: e, reducerPath: t, createSelector: n }) {
		const r = (p) => MR,
			i = (p) => IR
		return {
			buildQuerySelector: s,
			buildMutationSelector: l,
			selectInvalidatedBy: u,
			selectCachedArgsForQuery: d,
		}
		function a(p) {
			return { ...p, ...XZ(p.status) }
		}
		function o(p) {
			return p[t]
		}
		function s(p, m) {
			return (v) => {
				if (v === ho) return n(r, a)
				const y = e({ queryArgs: v, endpointDefinition: m, endpointName: p })
				return n((x) => {
					var E, T
					return ((T = (E = o(x)) == null ? void 0 : E.queries) == null ? void 0 : T[y]) ?? MR
				}, a)
			}
		}
		function l() {
			return (p) => {
				let m
				return (
					typeof p == "object" ? (m = ov(p) ?? ho) : (m = p),
					n(
						m === ho
							? i
							: (b) => {
									var x, E
									return (
										((E = (x = o(b)) == null ? void 0 : x.mutations) == null ? void 0 : E[m]) ?? IR
									)
							  },
						a,
					)
				)
			}
		}
		function u(p, m) {
			const v = p[t],
				y = new Set()
			for (const b of m.filter(P1).map(RS)) {
				const x = v.provided[b.type]
				if (!x) continue
				let E = (b.id !== void 0 ? x[b.id] : _R(Object.values(x))) ?? []
				for (const T of E) y.add(T)
			}
			return _R(
				Array.from(y.values()).map((b) => {
					const x = v.queries[b]
					return x
						? [{ queryCacheKey: b, endpointName: x.endpointName, originalArgs: x.originalArgs }]
						: []
				}),
			)
		}
		function d(p, m) {
			return Object.values(p[t].queries)
				.filter((v) => (v == null ? void 0 : v.endpointName) === m && v.status !== "uninitialized")
				.map((v) => v.originalArgs)
		}
	}
	var ff = WeakMap ? new WeakMap() : void 0,
		RR = ({ endpointName: e, queryArgs: t }) => {
			let n = ""
			const r = ff == null ? void 0 : ff.get(t)
			if (typeof r == "string") n = r
			else {
				const i = JSON.stringify(
					t,
					(a, o) => (
						(o = typeof o == "bigint" ? { $bigint: o.toString() } : o),
						(o = Ru(o)
							? Object.keys(o)
									.sort()
									.reduce((s, l) => ((s[l] = o[l]), s), {})
							: o),
						o
					),
				)
				Ru(t) && (ff == null || ff.set(t, i)), (n = i)
			}
			return `${e}(${n})`
		}
	function lee(...e) {
		return function (n) {
			const r = L1((u) => {
					var d
					return (d = n.extractRehydrationInfo) == null
						? void 0
						: d.call(n, u, { reducerPath: n.reducerPath ?? "api" })
				}),
				i = {
					reducerPath: "api",
					keepUnusedDataFor: 60,
					refetchOnMountOrArgChange: !1,
					refetchOnFocus: !1,
					refetchOnReconnect: !1,
					invalidationBehavior: "delayed",
					...n,
					extractRehydrationInfo: r,
					serializeQueryArgs(u) {
						let d = RR
						if ("serializeQueryArgs" in u.endpointDefinition) {
							const p = u.endpointDefinition.serializeQueryArgs
							d = (m) => {
								const v = p(m)
								return typeof v == "string" ? v : RR({ ...m, queryArgs: v })
							}
						} else n.serializeQueryArgs && (d = n.serializeQueryArgs)
						return d(u)
					},
					tagTypes: [...(n.tagTypes || [])],
				},
				a = {
					endpointDefinitions: {},
					batch(u) {
						u()
					},
					apiUid: ZD(),
					extractRehydrationInfo: r,
					hasRehydrationInfo: L1((u) => r(u) != null),
				},
				o = {
					injectEndpoints: l,
					enhanceEndpoints({ addTagTypes: u, endpoints: d }) {
						if (u) for (const p of u) i.tagTypes.includes(p) || i.tagTypes.push(p)
						if (d)
							for (const [p, m] of Object.entries(d))
								typeof m == "function"
									? m(a.endpointDefinitions[p])
									: Object.assign(a.endpointDefinitions[p] || {}, m)
						return o
					},
				},
				s = e.map((u) => u.init(o, i, a))
			function l(u) {
				const d = u.endpoints({
					query: (p) => ({ ...p, type: "query" }),
					mutation: (p) => ({ ...p, type: "mutation" }),
				})
				for (const [p, m] of Object.entries(d)) {
					if (u.overrideExisting !== !0 && p in a.endpointDefinitions) {
						if (u.overrideExisting === "throw") throw new Error(bo(39))
						typeof process < "u"
						continue
					}
					a.endpointDefinitions[p] = m
					for (const v of s) v.injectEndpoint(p, m)
				}
				return o
			}
			return o.injectEndpoints({ endpoints: n.endpoints })
		}
	}
	function nu(e, ...t) {
		return Object.assign(e, ...t)
	}
	var uee = ({ api: e, queryThunk: t, internalState: n }) => {
		const r = `${e.reducerPath}/subscriptions`
		let i = null,
			a = null
		const { updateSubscriptionOptions: o, unsubscribeQueryResult: s } = e.internalActions,
			l = (v, y) => {
				var x, E, T
				if (o.match(y)) {
					const { queryCacheKey: C, requestId: D, options: O } = y.payload
					return (x = v == null ? void 0 : v[C]) != null && x[D] && (v[C][D] = O), !0
				}
				if (s.match(y)) {
					const { queryCacheKey: C, requestId: D } = y.payload
					return v[C] && delete v[C][D], !0
				}
				if (e.internalActions.removeQueryResult.match(y))
					return delete v[y.payload.queryCacheKey], !0
				if (t.pending.match(y)) {
					const {
							meta: { arg: C, requestId: D },
						} = y,
						O = v[(E = C.queryCacheKey)] ?? (v[E] = {})
					return (
						(O[`${D}_running`] = {}),
						C.subscribe && (O[D] = C.subscriptionOptions ?? O[D] ?? {}),
						!0
					)
				}
				let b = !1
				if (t.fulfilled.match(y) || t.rejected.match(y)) {
					const C = v[y.meta.arg.queryCacheKey] || {},
						D = `${y.meta.requestId}_running`
					b || (b = !!C[D]), delete C[D]
				}
				if (t.rejected.match(y)) {
					const {
						meta: { condition: C, arg: D, requestId: O },
					} = y
					if (C && D.subscribe) {
						const A = v[(T = D.queryCacheKey)] ?? (v[T] = {})
						;(A[O] = D.subscriptionOptions ?? A[O] ?? {}), (b = !0)
					}
				}
				return b
			},
			u = () => n.currentSubscriptions,
			m = {
				getSubscriptions: u,
				getSubscriptionCount: (v) => {
					const b = u()[v] ?? {}
					return Uf(b)
				},
				isRequestSubscribed: (v, y) => {
					var x
					const b = u()
					return !!((x = b == null ? void 0 : b[v]) != null && x[y])
				},
			}
		return (v, y) => {
			if (
				(i || (i = JSON.parse(JSON.stringify(n.currentSubscriptions))),
				e.util.resetApiState.match(v))
			)
				return (i = n.currentSubscriptions = {}), (a = null), [!0, !1]
			if (e.internalActions.internal_getRTKQSubscriptions.match(v)) return [!1, m]
			const b = l(n.currentSubscriptions, v)
			let x = !0
			if (b) {
				a ||
					(a = setTimeout(() => {
						const C = JSON.parse(JSON.stringify(n.currentSubscriptions)),
							[, D] = q8(i, () => C)
						y.next(e.internalActions.subscriptionsUpdated(D)), (i = C), (a = null)
					}, 500))
				const E = typeof v.type == "string" && !!v.type.startsWith(r),
					T = t.rejected.match(v) && v.meta.condition && !!v.meta.arg.subscribe
				x = !E && !T
			}
			return [x, !1]
		}
	}
	function cee(e) {
		for (const t in e) return !1
		return !0
	}
	var dee = 2147483647 / 1e3 - 1,
		fee = ({ reducerPath: e, api: t, queryThunk: n, context: r, internalState: i }) => {
			const {
					removeQueryResult: a,
					unsubscribeQueryResult: o,
					cacheEntriesUpserted: s,
				} = t.internalActions,
				l = yl(o.match, n.fulfilled, n.rejected, s.match)
			function u(v) {
				const y = i.currentSubscriptions[v]
				return !!y && !cee(y)
			}
			const d = {},
				p = (v, y, b) => {
					var x
					if (l(v)) {
						const E = y.getState()[e]
						let T
						if (s.match(v)) T = v.payload.map((C) => C.queryDescription.queryCacheKey)
						else {
							const { queryCacheKey: C } = o.match(v) ? v.payload : v.meta.arg
							T = [C]
						}
						for (const C of T)
							m(C, (x = E.queries[C]) == null ? void 0 : x.endpointName, y, E.config)
					}
					if (t.util.resetApiState.match(v))
						for (const [E, T] of Object.entries(d)) T && clearTimeout(T), delete d[E]
					if (r.hasRehydrationInfo(v)) {
						const E = y.getState()[e],
							{ queries: T } = r.extractRehydrationInfo(v)
						for (const [C, D] of Object.entries(T))
							m(C, D == null ? void 0 : D.endpointName, y, E.config)
					}
				}
			function m(v, y, b, x) {
				const E = r.endpointDefinitions[y],
					T = (E == null ? void 0 : E.keepUnusedDataFor) ?? x.keepUnusedDataFor
				if (T === 1 / 0) return
				const C = Math.max(0, Math.min(T, dee))
				if (!u(v)) {
					const D = d[v]
					D && clearTimeout(D),
						(d[v] = setTimeout(() => {
							u(v) || b.dispatch(a({ queryCacheKey: v })), delete d[v]
						}, C * 1e3))
				}
			}
			return p
		},
		LR = new Error("Promise never resolved before cacheEntryRemoved."),
		pee = ({
			api: e,
			reducerPath: t,
			context: n,
			queryThunk: r,
			mutationThunk: i,
			internalState: a,
		}) => {
			const o = IS(r),
				s = IS(i),
				l = Lu(r, i),
				u = {}
			function d(b, x, E) {
				const T = u[b]
				T != null &&
					T.valueResolved &&
					(T.valueResolved({ data: x, meta: E }), delete T.valueResolved)
			}
			function p(b) {
				const x = u[b]
				x && (delete u[b], x.cacheEntryRemoved())
			}
			const m = (b, x, E) => {
				const T = v(b)
				function C(D, O, A, N) {
					const I = E[t].queries[O],
						P = x.getState()[t].queries[O]
					!I && P && y(D, N, O, x, A)
				}
				if (r.pending.match(b))
					C(b.meta.arg.endpointName, T, b.meta.requestId, b.meta.arg.originalArgs)
				else if (e.internalActions.cacheEntriesUpserted.match(b))
					for (const { queryDescription: D, value: O } of b.payload) {
						const { endpointName: A, originalArgs: N, queryCacheKey: I } = D
						C(A, I, b.meta.requestId, N), d(I, O, {})
					}
				else if (i.pending.match(b))
					x.getState()[t].mutations[T] &&
						y(b.meta.arg.endpointName, b.meta.arg.originalArgs, T, x, b.meta.requestId)
				else if (l(b)) d(T, b.payload, b.meta.baseQueryMeta)
				else if (
					e.internalActions.removeQueryResult.match(b) ||
					e.internalActions.removeMutationResult.match(b)
				)
					p(T)
				else if (e.util.resetApiState.match(b)) for (const D of Object.keys(u)) p(D)
			}
			function v(b) {
				return o(b)
					? b.meta.arg.queryCacheKey
					: s(b)
					? b.meta.arg.fixedCacheKey ?? b.meta.requestId
					: e.internalActions.removeQueryResult.match(b)
					? b.payload.queryCacheKey
					: e.internalActions.removeMutationResult.match(b)
					? ov(b.payload)
					: ""
			}
			function y(b, x, E, T, C) {
				const D = n.endpointDefinitions[b],
					O = D == null ? void 0 : D.onCacheEntryAdded
				if (!O) return
				const A = {},
					N = new Promise((V) => {
						A.cacheEntryRemoved = V
					}),
					I = Promise.race([
						new Promise((V) => {
							A.valueResolved = V
						}),
						N.then(() => {
							throw LR
						}),
					])
				I.catch(() => {}), (u[E] = A)
				const P = e.endpoints[b].select(D.type === "query" ? x : E),
					L = T.dispatch((V, K, ne) => ne),
					B = {
						...T,
						getCacheEntry: () => P(T.getState()),
						requestId: C,
						extra: L,
						updateCachedData:
							D.type === "query" ? (V) => T.dispatch(e.util.updateQueryData(b, x, V)) : void 0,
						cacheDataLoaded: I,
						cacheEntryRemoved: N,
					},
					z = O(x, B)
				Promise.resolve(z).catch((V) => {
					if (V !== LR) throw V
				})
			}
			return m
		},
		hee =
			({ api: e, context: { apiUid: t }, reducerPath: n }) =>
			(r, i) => {
				e.util.resetApiState.match(r) && i.dispatch(e.internalActions.middlewareRegistered(t)),
					typeof process < "u"
			},
		mee = ({
			reducerPath: e,
			context: t,
			context: { endpointDefinitions: n },
			mutationThunk: r,
			queryThunk: i,
			api: a,
			assertTagType: o,
			refetchQuery: s,
			internalState: l,
		}) => {
			const { removeQueryResult: u } = a.internalActions,
				d = yl(Lu(r), px(r)),
				p = yl(Lu(r, i), ep(r, i))
			let m = []
			const v = (x, E) => {
				d(x)
					? b(eB(x, "invalidatesTags", n, o), E)
					: p(x)
					? b([], E)
					: a.util.invalidateTags.match(x) && b(n_(x.payload, void 0, void 0, void 0, void 0, o), E)
			}
			function y(x) {
				var E, T
				for (const C in x.queries)
					if (((E = x.queries[C]) == null ? void 0 : E.status) === "pending") return !0
				for (const C in x.mutations)
					if (((T = x.mutations[C]) == null ? void 0 : T.status) === "pending") return !0
				return !1
			}
			function b(x, E) {
				const T = E.getState(),
					C = T[e]
				if ((m.push(...x), C.config.invalidationBehavior === "delayed" && y(C))) return
				const D = m
				if (((m = []), D.length === 0)) return
				const O = a.util.selectInvalidatedBy(T, D)
				t.batch(() => {
					const A = Array.from(O.values())
					for (const { queryCacheKey: N } of A) {
						const I = C.queries[N],
							P = l.currentSubscriptions[N] ?? {}
						I &&
							(Uf(P) === 0
								? E.dispatch(u({ queryCacheKey: N }))
								: I.status !== "uninitialized" && E.dispatch(s(I)))
					}
				})
			}
			return v
		},
		vee = ({ reducerPath: e, queryThunk: t, api: n, refetchQuery: r, internalState: i }) => {
			const a = {},
				o = (m, v) => {
					;(n.internalActions.updateSubscriptionOptions.match(m) ||
						n.internalActions.unsubscribeQueryResult.match(m)) &&
						l(m.payload, v),
						(t.pending.match(m) || (t.rejected.match(m) && m.meta.condition)) && l(m.meta.arg, v),
						(t.fulfilled.match(m) || (t.rejected.match(m) && !m.meta.condition)) &&
							s(m.meta.arg, v),
						n.util.resetApiState.match(m) && d()
				}
			function s({ queryCacheKey: m }, v) {
				const y = v.getState()[e],
					b = y.queries[m],
					x = i.currentSubscriptions[m]
				if (!b || b.status === "uninitialized") return
				const { lowestPollingInterval: E, skipPollingIfUnfocused: T } = p(x)
				if (!Number.isFinite(E)) return
				const C = a[m]
				C != null && C.timeout && (clearTimeout(C.timeout), (C.timeout = void 0))
				const D = Date.now() + E
				a[m] = {
					nextPollTimestamp: D,
					pollingInterval: E,
					timeout: setTimeout(() => {
						;(y.config.focused || !T) && v.dispatch(r(b)), s({ queryCacheKey: m }, v)
					}, E),
				}
			}
			function l({ queryCacheKey: m }, v) {
				const b = v.getState()[e].queries[m],
					x = i.currentSubscriptions[m]
				if (!b || b.status === "uninitialized") return
				const { lowestPollingInterval: E } = p(x)
				if (!Number.isFinite(E)) {
					u(m)
					return
				}
				const T = a[m],
					C = Date.now() + E
				;(!T || C < T.nextPollTimestamp) && s({ queryCacheKey: m }, v)
			}
			function u(m) {
				const v = a[m]
				v != null && v.timeout && clearTimeout(v.timeout), delete a[m]
			}
			function d() {
				for (const m of Object.keys(a)) u(m)
			}
			function p(m = {}) {
				let v = !1,
					y = Number.POSITIVE_INFINITY
				for (let b in m)
					m[b].pollingInterval &&
						((y = Math.min(m[b].pollingInterval, y)), (v = m[b].skipPollingIfUnfocused || v))
				return { lowestPollingInterval: y, skipPollingIfUnfocused: v }
			}
			return o
		},
		gee = ({ api: e, context: t, queryThunk: n, mutationThunk: r }) => {
			const i = JD(n, r),
				a = ep(n, r),
				o = Lu(n, r),
				s = {}
			return (u, d) => {
				var p, m
				if (i(u)) {
					const {
							requestId: v,
							arg: { endpointName: y, originalArgs: b },
						} = u.meta,
						x = t.endpointDefinitions[y],
						E = x == null ? void 0 : x.onQueryStarted
					if (E) {
						const T = {},
							C = new Promise((N, I) => {
								;(T.resolve = N), (T.reject = I)
							})
						C.catch(() => {}), (s[v] = T)
						const D = e.endpoints[y].select(x.type === "query" ? b : v),
							O = d.dispatch((N, I, P) => P),
							A = {
								...d,
								getCacheEntry: () => D(d.getState()),
								requestId: v,
								extra: O,
								updateCachedData:
									x.type === "query" ? (N) => d.dispatch(e.util.updateQueryData(y, b, N)) : void 0,
								queryFulfilled: C,
							}
						E(b, A)
					}
				} else if (o(u)) {
					const { requestId: v, baseQueryMeta: y } = u.meta
					;(p = s[v]) == null || p.resolve({ data: u.payload, meta: y }), delete s[v]
				} else if (a(u)) {
					const { requestId: v, rejectedWithValue: y, baseQueryMeta: b } = u.meta
					;(m = s[v]) == null ||
						m.reject({ error: u.payload ?? u.error, isUnhandledError: !y, meta: b }),
						delete s[v]
				}
			}
		},
		yee = ({ reducerPath: e, context: t, api: n, refetchQuery: r, internalState: i }) => {
			const { removeQueryResult: a } = n.internalActions,
				o = (l, u) => {
					e_.match(l) && s(u, "refetchOnFocus"), t_.match(l) && s(u, "refetchOnReconnect")
				}
			function s(l, u) {
				const d = l.getState()[e],
					p = d.queries,
					m = i.currentSubscriptions
				t.batch(() => {
					for (const v of Object.keys(m)) {
						const y = p[v],
							b = m[v]
						if (!b || !y) continue
						;(Object.values(b).some((E) => E[u] === !0) ||
							(Object.values(b).every((E) => E[u] === void 0) && d.config[u])) &&
							(Uf(b) === 0
								? l.dispatch(a({ queryCacheKey: v }))
								: y.status !== "uninitialized" && l.dispatch(r(y)))
					}
				})
			}
			return o
		}
	function bee(e) {
		const { reducerPath: t, queryThunk: n, api: r, context: i } = e,
			{ apiUid: a } = i,
			o = { invalidateTags: yo(`${t}/invalidateTags`) },
			s = (p) => p.type.startsWith(`${t}/`),
			l = [hee, fee, mee, vee, pee, gee]
		return {
			middleware: (p) => {
				let m = !1
				const y = {
						...e,
						internalState: { currentSubscriptions: {} },
						refetchQuery: d,
						isThisApiSliceAction: s,
					},
					b = l.map((T) => T(y)),
					x = uee(y),
					E = yee(y)
				return (T) => (C) => {
					if (!F8(C)) return T(C)
					m || ((m = !0), p.dispatch(r.internalActions.middlewareRegistered(a)))
					const D = { ...p, next: T },
						O = p.getState(),
						[A, N] = x(C, D, O)
					let I
					if (
						(A ? (I = T(C)) : (I = N),
						p.getState()[t] && (E(C, D, O), s(C) || i.hasRehydrationInfo(C)))
					)
						for (const P of b) P(C, D, O)
					return I
				}
			},
			actions: o,
		}
		function d(p) {
			return e.api.endpoints[p.endpointName].initiate(p.originalArgs, {
				subscribe: !1,
				forceRefetch: !0,
			})
		}
	}
	var PR = Symbol(),
		xee = ({ createSelector: e = dx } = {}) => ({
			name: PR,
			init(
				t,
				{
					baseQuery: n,
					tagTypes: r,
					reducerPath: i,
					serializeQueryArgs: a,
					keepUnusedDataFor: o,
					refetchOnMountOrArgChange: s,
					refetchOnFocus: l,
					refetchOnReconnect: u,
					invalidationBehavior: d,
				},
				p,
			) {
				mZ()
				const m = (J) => (typeof process < "u", J)
				Object.assign(t, {
					reducerPath: i,
					endpoints: {},
					internalActions: { onOnline: t_, onOffline: J8, onFocus: e_, onFocusLost: X8 },
					util: {},
				})
				const {
						queryThunk: v,
						mutationThunk: y,
						patchQueryData: b,
						updateQueryData: x,
						upsertQueryData: E,
						prefetch: T,
						buildMatchThunkActions: C,
					} = aee({
						baseQuery: n,
						reducerPath: i,
						context: p,
						api: t,
						serializeQueryArgs: a,
						assertTagType: m,
					}),
					{ reducer: D, actions: O } = oee({
						context: p,
						queryThunk: v,
						mutationThunk: y,
						serializeQueryArgs: a,
						reducerPath: i,
						assertTagType: m,
						config: {
							refetchOnFocus: l,
							refetchOnReconnect: u,
							refetchOnMountOrArgChange: s,
							keepUnusedDataFor: o,
							reducerPath: i,
							invalidationBehavior: d,
						},
					})
				nu(t.util, {
					patchQueryData: b,
					updateQueryData: x,
					upsertQueryData: E,
					prefetch: T,
					resetApiState: O.resetApiState,
					upsertQueryEntries: O.cacheEntriesUpserted,
				}),
					nu(t.internalActions, O)
				const { middleware: A, actions: N } = bee({
					reducerPath: i,
					context: p,
					queryThunk: v,
					mutationThunk: y,
					api: t,
					assertTagType: m,
				})
				nu(t.util, N), nu(t, { reducer: D, middleware: A })
				const {
					buildQuerySelector: I,
					buildMutationSelector: P,
					selectInvalidatedBy: L,
					selectCachedArgsForQuery: B,
				} = see({ serializeQueryArgs: a, reducerPath: i, createSelector: e })
				nu(t.util, { selectInvalidatedBy: L, selectCachedArgsForQuery: B })
				const {
					buildInitiateQuery: z,
					buildInitiateMutation: V,
					getRunningMutationThunk: K,
					getRunningMutationsThunk: ne,
					getRunningQueriesThunk: re,
					getRunningQueryThunk: ie,
				} = iee({ queryThunk: v, mutationThunk: y, api: t, serializeQueryArgs: a, context: p })
				return (
					nu(t.util, {
						getRunningMutationThunk: K,
						getRunningMutationsThunk: ne,
						getRunningQueryThunk: ie,
						getRunningQueriesThunk: re,
					}),
					{
						name: PR,
						injectEndpoint(J, le) {
							var Y
							const F = t
							;(Y = F.endpoints)[J] ?? (Y[J] = {}),
								Z8(le)
									? nu(F.endpoints[J], { name: J, select: I(J, le), initiate: z(J, le) }, C(v, J))
									: tee(le) && nu(F.endpoints[J], { name: J, select: P(), initiate: V(J) }, C(y, J))
						},
					}
				)
			},
		})
	function HC(e) {
		return e.replace(e[0], e[0].toUpperCase())
	}
	function wee(e) {
		return e.type === "query"
	}
	function Eee(e) {
		return e.type === "mutation"
	}
	function $0(e, ...t) {
		return Object.assign(e, ...t)
	}
	var pf = WeakMap ? new WeakMap() : void 0,
		Cee = ({ endpointName: e, queryArgs: t }) => {
			let n = ""
			const r = pf == null ? void 0 : pf.get(t)
			if (typeof r == "string") n = r
			else {
				const i = JSON.stringify(
					t,
					(a, o) => (
						(o = typeof o == "bigint" ? { $bigint: o.toString() } : o),
						(o = Ru(o)
							? Object.keys(o)
									.sort()
									.reduce((s, l) => ((s[l] = o[l]), s), {})
							: o),
						o
					),
				)
				Ru(t) && (pf == null || pf.set(t, i)), (n = i)
			}
			return `${e}(${n})`
		},
		$C = Symbol()
	function jR(e, t, n, r) {
		const i = _.useMemo(
				() => ({
					queryArgs: e,
					serialized:
						typeof e == "object" ? t({ queryArgs: e, endpointDefinition: n, endpointName: r }) : e,
				}),
				[e, t, n, r],
			),
			a = _.useRef(i)
		return (
			_.useEffect(() => {
				a.current.serialized !== i.serialized && (a.current = i)
			}, [i]),
			a.current.serialized === i.serialized ? a.current.queryArgs : e
		)
	}
	function UC(e) {
		const t = _.useRef(e)
		return (
			_.useEffect(() => {
				Om(t.current, e) || (t.current = e)
			}, [e]),
			Om(t.current, e) ? t.current : e
		)
	}
	var Tee = () =>
			typeof window < "u" &&
			typeof window.document < "u" &&
			typeof window.document.createElement < "u",
		kee = Tee(),
		See = () => typeof navigator < "u" && navigator.product === "ReactNative",
		Dee = See(),
		_ee = () => (kee || Dee ? _.useLayoutEffect : _.useEffect),
		Oee = _ee(),
		Aee = (e) =>
			e.isUninitialized
				? {
						...e,
						isUninitialized: !1,
						isFetching: !0,
						isLoading: e.data === void 0,
						status: K8.pending,
				  }
				: e
	function Nee({
		api: e,
		moduleOptions: {
			batch: t,
			hooks: { useDispatch: n, useSelector: r, useStore: i },
			unstable__sideEffectsInRender: a,
			createSelector: o,
		},
		serializeQueryArgs: s,
		context: l,
	}) {
		const u = a ? (y) => y() : _.useEffect
		return { buildQueryHooks: m, buildMutationHook: v, usePrefetch: p }
		function d(y, b, x) {
			if (b != null && b.endpointName && y.isUninitialized) {
				const { endpointName: A } = b,
					N = l.endpointDefinitions[A]
				s({ queryArgs: b.originalArgs, endpointDefinition: N, endpointName: A }) ===
					s({ queryArgs: x, endpointDefinition: N, endpointName: A }) && (b = void 0)
			}
			let E = y.isSuccess ? y.data : b == null ? void 0 : b.data
			E === void 0 && (E = y.data)
			const T = E !== void 0,
				C = y.isLoading,
				D = (!b || b.isLoading || b.isUninitialized) && !T && C,
				O = y.isSuccess || (T && ((C && !(b != null && b.isError)) || y.isUninitialized))
			return { ...y, data: E, currentData: y.data, isFetching: C, isLoading: D, isSuccess: O }
		}
		function p(y, b) {
			const x = n(),
				E = UC(b)
			return _.useCallback((T, C) => x(e.util.prefetch(y, T, { ...E, ...C })), [y, x, E])
		}
		function m(y) {
			const b = (
					T,
					{
						refetchOnReconnect: C,
						refetchOnFocus: D,
						refetchOnMountOrArgChange: O,
						skip: A = !1,
						pollingInterval: N = 0,
						skipPollingIfUnfocused: I = !1,
					} = {},
				) => {
					const { initiate: P } = e.endpoints[y],
						L = n(),
						B = _.useRef(void 0)
					if (!B.current) {
						const F = L(e.internalActions.internal_getRTKQSubscriptions())
						B.current = F
					}
					const z = jR(A ? ho : T, Cee, l.endpointDefinitions[y], y),
						V = UC({
							refetchOnReconnect: C,
							refetchOnFocus: D,
							pollingInterval: N,
							skipPollingIfUnfocused: I,
						}),
						K = _.useRef(!1),
						ne = _.useRef(void 0)
					let { queryCacheKey: re, requestId: ie } = ne.current || {},
						J = !1
					re && ie && (J = B.current.isRequestSubscribed(re, ie))
					const le = !J && K.current
					return (
						u(() => {
							K.current = J
						}),
						u(() => {
							le && (ne.current = void 0)
						}, [le]),
						u(() => {
							var ee
							const F = ne.current
							if ((typeof process < "u", z === ho)) {
								F == null || F.unsubscribe(), (ne.current = void 0)
								return
							}
							const Y = (ee = ne.current) == null ? void 0 : ee.subscriptionOptions
							if (!F || F.arg !== z) {
								F == null || F.unsubscribe()
								const $ = L(P(z, { subscriptionOptions: V, forceRefetch: O }))
								ne.current = $
							} else V !== Y && F.updateSubscriptionOptions(V)
						}, [L, P, O, z, V, le]),
						_.useEffect(
							() => () => {
								var F
								;(F = ne.current) == null || F.unsubscribe(), (ne.current = void 0)
							},
							[],
						),
						_.useMemo(
							() => ({
								refetch: () => {
									var F
									if (!ne.current) throw new Error(bo(38))
									return (F = ne.current) == null ? void 0 : F.refetch()
								},
							}),
							[],
						)
					)
				},
				x = ({
					refetchOnReconnect: T,
					refetchOnFocus: C,
					pollingInterval: D = 0,
					skipPollingIfUnfocused: O = !1,
				} = {}) => {
					const { initiate: A } = e.endpoints[y],
						N = n(),
						[I, P] = _.useState($C),
						L = _.useRef(void 0),
						B = UC({
							refetchOnReconnect: T,
							refetchOnFocus: C,
							pollingInterval: D,
							skipPollingIfUnfocused: O,
						})
					u(() => {
						var re, ie
						const ne = (re = L.current) == null ? void 0 : re.subscriptionOptions
						B !== ne && ((ie = L.current) == null || ie.updateSubscriptionOptions(B))
					}, [B])
					const z = _.useRef(B)
					u(() => {
						z.current = B
					}, [B])
					const V = _.useCallback(
							function (ne, re = !1) {
								let ie
								return (
									t(() => {
										var J
										;(J = L.current) == null || J.unsubscribe(),
											(L.current = ie =
												N(A(ne, { subscriptionOptions: z.current, forceRefetch: !re }))),
											P(ne)
									}),
									ie
								)
							},
							[N, A],
						),
						K = _.useCallback(() => {
							var ne, re
							;(ne = L.current) != null &&
								ne.queryCacheKey &&
								N(
									e.internalActions.removeQueryResult({
										queryCacheKey: (re = L.current) == null ? void 0 : re.queryCacheKey,
									}),
								)
						}, [N])
					return (
						_.useEffect(
							() => () => {
								var ne
								;(ne = L == null ? void 0 : L.current) == null || ne.unsubscribe()
							},
							[],
						),
						_.useEffect(() => {
							I !== $C && !L.current && V(I, !0)
						}, [I, V]),
						_.useMemo(() => [V, I, { reset: K }], [V, I, K])
					)
				},
				E = (T, { skip: C = !1, selectFromResult: D } = {}) => {
					const { select: O } = e.endpoints[y],
						A = jR(C ? ho : T, s, l.endpointDefinitions[y], y),
						N = _.useRef(void 0),
						I = _.useMemo(
							() =>
								o([O(A), (V, K) => K, (V) => A], d, {
									memoizeOptions: { resultEqualityCheck: Om },
								}),
							[O, A],
						),
						P = _.useMemo(
							() => (D ? o([I], D, { devModeChecks: { identityFunctionCheck: "never" } }) : I),
							[I, D],
						),
						L = r((V) => P(V, N.current), Om),
						B = i(),
						z = I(B.getState(), N.current)
					return (
						Oee(() => {
							N.current = z
						}, [z]),
						L
					)
				}
			return {
				useQueryState: E,
				useQuerySubscription: b,
				useLazyQuerySubscription: x,
				useLazyQuery(T) {
					const [C, D, { reset: O }] = x(T),
						A = E(D, { ...T, skip: D === $C }),
						N = _.useMemo(() => ({ lastArg: D }), [D])
					return _.useMemo(() => [C, { ...A, reset: O }, N], [C, A, O, N])
				},
				useQuery(T, C) {
					const D = b(T, C),
						O = E(T, { selectFromResult: T === ho || (C != null && C.skip) ? void 0 : Aee, ...C }),
						{ data: A, status: N, isLoading: I, isSuccess: P, isError: L, error: B } = O
					return (
						_.useDebugValue({
							data: A,
							status: N,
							isLoading: I,
							isSuccess: P,
							isError: L,
							error: B,
						}),
						_.useMemo(() => ({ ...O, ...D }), [O, D])
					)
				},
			}
		}
		function v(y) {
			return ({ selectFromResult: b, fixedCacheKey: x } = {}) => {
				const { select: E, initiate: T } = e.endpoints[y],
					C = n(),
					[D, O] = _.useState()
				_.useEffect(
					() => () => {
						;(D != null && D.arg.fixedCacheKey) || D == null || D.reset()
					},
					[D],
				)
				const A = _.useCallback(
						function (Y) {
							const ee = C(T(Y, { fixedCacheKey: x }))
							return O(ee), ee
						},
						[C, T, x],
					),
					{ requestId: N } = D || {},
					I = _.useMemo(
						() => E({ fixedCacheKey: x, requestId: D == null ? void 0 : D.requestId }),
						[x, D, E],
					),
					P = _.useMemo(() => (b ? o([I], b) : I), [b, I]),
					L = r(P, Om),
					B = x == null ? (D == null ? void 0 : D.arg.originalArgs) : void 0,
					z = _.useCallback(() => {
						t(() => {
							D && O(void 0),
								x && C(e.internalActions.removeMutationResult({ requestId: N, fixedCacheKey: x }))
						})
					}, [C, x, D, N]),
					{
						endpointName: V,
						data: K,
						status: ne,
						isLoading: re,
						isSuccess: ie,
						isError: J,
						error: le,
					} = L
				_.useDebugValue({
					endpointName: V,
					data: K,
					status: ne,
					isLoading: re,
					isSuccess: ie,
					isError: J,
					error: le,
				})
				const F = _.useMemo(() => ({ ...L, originalArgs: B, reset: z }), [L, B, z])
				return _.useMemo(() => [A, F], [A, F])
			}
		}
	}
	var Mee = Symbol(),
		Iee = ({
			batch: e = _X,
			hooks: t = { useDispatch: zD, useSelector: Up, useStore: b8 },
			createSelector: n = dx,
			unstable__sideEffectsInRender: r = !1,
			...i
		} = {}) => ({
			name: Mee,
			init(a, { serializeQueryArgs: o }, s) {
				const l = a,
					{
						buildQueryHooks: u,
						buildMutationHook: d,
						usePrefetch: p,
					} = Nee({
						api: a,
						moduleOptions: {
							batch: e,
							hooks: t,
							unstable__sideEffectsInRender: r,
							createSelector: n,
						},
						serializeQueryArgs: o,
						context: s,
					})
				return (
					$0(l, { usePrefetch: p }),
					$0(s, { batch: e }),
					{
						injectEndpoint(m, v) {
							if (wee(v)) {
								const {
									useQuery: y,
									useLazyQuery: b,
									useLazyQuerySubscription: x,
									useQueryState: E,
									useQuerySubscription: T,
								} = u(m)
								$0(l.endpoints[m], {
									useQuery: y,
									useLazyQuery: b,
									useLazyQuerySubscription: x,
									useQueryState: E,
									useQuerySubscription: T,
								}),
									(a[`use${HC(m)}Query`] = y),
									(a[`useLazy${HC(m)}Query`] = b)
							} else if (Eee(v)) {
								const y = d(m)
								$0(l.endpoints[m], { useMutation: y }), (a[`use${HC(m)}Mutation`] = y)
							}
						},
					}
				)
			},
		}),
		Ree = lee(xee(), Iee()),
		U0 = { exports: {} },
		zC,
		FR
	function nB() {
		return (
			FR ||
				((FR = 1),
				(zC = function (t, n) {
					return function () {
						for (var i = new Array(arguments.length), a = 0; a < i.length; a++) i[a] = arguments[a]
						return t.apply(n, i)
					}
				})),
			zC
		)
	}
	var qC, BR
	function Ca() {
		if (BR) return qC
		BR = 1
		var e = nB(),
			t = Object.prototype.toString
		function n(I) {
			return t.call(I) === "[object Array]"
		}
		function r(I) {
			return typeof I > "u"
		}
		function i(I) {
			return (
				I !== null &&
				!r(I) &&
				I.constructor !== null &&
				!r(I.constructor) &&
				typeof I.constructor.isBuffer == "function" &&
				I.constructor.isBuffer(I)
			)
		}
		function a(I) {
			return t.call(I) === "[object ArrayBuffer]"
		}
		function o(I) {
			return typeof FormData < "u" && I instanceof FormData
		}
		function s(I) {
			var P
			return (
				typeof ArrayBuffer < "u" && ArrayBuffer.isView
					? (P = ArrayBuffer.isView(I))
					: (P = I && I.buffer && I.buffer instanceof ArrayBuffer),
				P
			)
		}
		function l(I) {
			return typeof I == "string"
		}
		function u(I) {
			return typeof I == "number"
		}
		function d(I) {
			return I !== null && typeof I == "object"
		}
		function p(I) {
			if (t.call(I) !== "[object Object]") return !1
			var P = Object.getPrototypeOf(I)
			return P === null || P === Object.prototype
		}
		function m(I) {
			return t.call(I) === "[object Date]"
		}
		function v(I) {
			return t.call(I) === "[object File]"
		}
		function y(I) {
			return t.call(I) === "[object Blob]"
		}
		function b(I) {
			return t.call(I) === "[object Function]"
		}
		function x(I) {
			return d(I) && b(I.pipe)
		}
		function E(I) {
			return typeof URLSearchParams < "u" && I instanceof URLSearchParams
		}
		function T(I) {
			return I.trim ? I.trim() : I.replace(/^\s+|\s+$/g, "")
		}
		function C() {
			return typeof navigator < "u" &&
				(navigator.product === "ReactNative" ||
					navigator.product === "NativeScript" ||
					navigator.product === "NS")
				? !1
				: typeof window < "u" && typeof document < "u"
		}
		function D(I, P) {
			if (!(I === null || typeof I > "u"))
				if ((typeof I != "object" && (I = [I]), n(I)))
					for (var L = 0, B = I.length; L < B; L++) P.call(null, I[L], L, I)
				else for (var z in I) Object.prototype.hasOwnProperty.call(I, z) && P.call(null, I[z], z, I)
		}
		function O() {
			var I = {}
			function P(z, V) {
				p(I[V]) && p(z)
					? (I[V] = O(I[V], z))
					: p(z)
					? (I[V] = O({}, z))
					: n(z)
					? (I[V] = z.slice())
					: (I[V] = z)
			}
			for (var L = 0, B = arguments.length; L < B; L++) D(arguments[L], P)
			return I
		}
		function A(I, P, L) {
			return (
				D(P, function (z, V) {
					L && typeof z == "function" ? (I[V] = e(z, L)) : (I[V] = z)
				}),
				I
			)
		}
		function N(I) {
			return I.charCodeAt(0) === 65279 && (I = I.slice(1)), I
		}
		return (
			(qC = {
				isArray: n,
				isArrayBuffer: a,
				isBuffer: i,
				isFormData: o,
				isArrayBufferView: s,
				isString: l,
				isNumber: u,
				isObject: d,
				isPlainObject: p,
				isUndefined: r,
				isDate: m,
				isFile: v,
				isBlob: y,
				isFunction: b,
				isStream: x,
				isURLSearchParams: E,
				isStandardBrowserEnv: C,
				forEach: D,
				merge: O,
				extend: A,
				trim: T,
				stripBOM: N,
			}),
			qC
		)
	}
	var VC, HR
	function rB() {
		if (HR) return VC
		HR = 1
		var e = Ca()
		function t(n) {
			return encodeURIComponent(n)
				.replace(/%3A/gi, ":")
				.replace(/%24/g, "$")
				.replace(/%2C/gi, ",")
				.replace(/%20/g, "+")
				.replace(/%5B/gi, "[")
				.replace(/%5D/gi, "]")
		}
		return (
			(VC = function (r, i, a) {
				if (!i) return r
				var o
				if (a) o = a(i)
				else if (e.isURLSearchParams(i)) o = i.toString()
				else {
					var s = []
					e.forEach(i, function (d, p) {
						d === null ||
							typeof d > "u" ||
							(e.isArray(d) ? (p = p + "[]") : (d = [d]),
							e.forEach(d, function (v) {
								e.isDate(v) ? (v = v.toISOString()) : e.isObject(v) && (v = JSON.stringify(v)),
									s.push(t(p) + "=" + t(v))
							}))
					}),
						(o = s.join("&"))
				}
				if (o) {
					var l = r.indexOf("#")
					l !== -1 && (r = r.slice(0, l)), (r += (r.indexOf("?") === -1 ? "?" : "&") + o)
				}
				return r
			}),
			VC
		)
	}
	var WC, $R
	function Lee() {
		if ($R) return WC
		$R = 1
		var e = Ca()
		function t() {
			this.handlers = []
		}
		return (
			(t.prototype.use = function (r, i, a) {
				return (
					this.handlers.push({
						fulfilled: r,
						rejected: i,
						synchronous: a ? a.synchronous : !1,
						runWhen: a ? a.runWhen : null,
					}),
					this.handlers.length - 1
				)
			}),
			(t.prototype.eject = function (r) {
				this.handlers[r] && (this.handlers[r] = null)
			}),
			(t.prototype.forEach = function (r) {
				e.forEach(this.handlers, function (a) {
					a !== null && r(a)
				})
			}),
			(WC = t),
			WC
		)
	}
	var YC, UR
	function Pee() {
		if (UR) return YC
		UR = 1
		var e = Ca()
		return (
			(YC = function (n, r) {
				e.forEach(n, function (a, o) {
					o !== r && o.toUpperCase() === r.toUpperCase() && ((n[r] = a), delete n[o])
				})
			}),
			YC
		)
	}
	var GC, zR
	function iB() {
		return (
			zR ||
				((zR = 1),
				(GC = function (t, n, r, i, a) {
					return (
						(t.config = n),
						r && (t.code = r),
						(t.request = i),
						(t.response = a),
						(t.isAxiosError = !0),
						(t.toJSON = function () {
							return {
								message: this.message,
								name: this.name,
								description: this.description,
								number: this.number,
								fileName: this.fileName,
								lineNumber: this.lineNumber,
								columnNumber: this.columnNumber,
								stack: this.stack,
								config: this.config,
								code: this.code,
								status: this.response && this.response.status ? this.response.status : null,
							}
						}),
						t
					)
				})),
			GC
		)
	}
	var KC, qR
	function aB() {
		if (qR) return KC
		qR = 1
		var e = iB()
		return (
			(KC = function (n, r, i, a, o) {
				var s = new Error(n)
				return e(s, r, i, a, o)
			}),
			KC
		)
	}
	var QC, VR
	function jee() {
		if (VR) return QC
		VR = 1
		var e = aB()
		return (
			(QC = function (n, r, i) {
				var a = i.config.validateStatus
				!i.status || !a || a(i.status)
					? n(i)
					: r(e("Request failed with status code " + i.status, i.config, null, i.request, i))
			}),
			QC
		)
	}
	var XC, WR
	function Fee() {
		if (WR) return XC
		WR = 1
		var e = Ca()
		return (
			(XC = e.isStandardBrowserEnv()
				? (function () {
						return {
							write: function (r, i, a, o, s, l) {
								var u = []
								u.push(r + "=" + encodeURIComponent(i)),
									e.isNumber(a) && u.push("expires=" + new Date(a).toGMTString()),
									e.isString(o) && u.push("path=" + o),
									e.isString(s) && u.push("domain=" + s),
									l === !0 && u.push("secure"),
									(document.cookie = u.join("; "))
							},
							read: function (r) {
								var i = document.cookie.match(new RegExp("(^|;\\s*)(" + r + ")=([^;]*)"))
								return i ? decodeURIComponent(i[3]) : null
							},
							remove: function (r) {
								this.write(r, "", Date.now() - 864e5)
							},
						}
				  })()
				: (function () {
						return {
							write: function () {},
							read: function () {
								return null
							},
							remove: function () {},
						}
				  })()),
			XC
		)
	}
	var JC, YR
	function Bee() {
		return (
			YR ||
				((YR = 1),
				(JC = function (t) {
					return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(t)
				})),
			JC
		)
	}
	var ZC, GR
	function Hee() {
		return (
			GR ||
				((GR = 1),
				(ZC = function (t, n) {
					return n ? t.replace(/\/+$/, "") + "/" + n.replace(/^\/+/, "") : t
				})),
			ZC
		)
	}
	var eT, KR
	function $ee() {
		if (KR) return eT
		KR = 1
		var e = Bee(),
			t = Hee()
		return (
			(eT = function (r, i) {
				return r && !e(i) ? t(r, i) : i
			}),
			eT
		)
	}
	var tT, QR
	function Uee() {
		if (QR) return tT
		QR = 1
		var e = Ca(),
			t = [
				"age",
				"authorization",
				"content-length",
				"content-type",
				"etag",
				"expires",
				"from",
				"host",
				"if-modified-since",
				"if-unmodified-since",
				"last-modified",
				"location",
				"max-forwards",
				"proxy-authorization",
				"referer",
				"retry-after",
				"user-agent",
			]
		return (
			(tT = function (r) {
				var i = {},
					a,
					o,
					s
				return (
					r &&
						e.forEach(
							r.split(`
`),
							function (u) {
								if (
									((s = u.indexOf(":")),
									(a = e.trim(u.substr(0, s)).toLowerCase()),
									(o = e.trim(u.substr(s + 1))),
									a)
								) {
									if (i[a] && t.indexOf(a) >= 0) return
									a === "set-cookie"
										? (i[a] = (i[a] ? i[a] : []).concat([o]))
										: (i[a] = i[a] ? i[a] + ", " + o : o)
								}
							},
						),
					i
				)
			}),
			tT
		)
	}
	var nT, XR
	function zee() {
		if (XR) return nT
		XR = 1
		var e = Ca()
		return (
			(nT = e.isStandardBrowserEnv()
				? (function () {
						var n = /(msie|trident)/i.test(navigator.userAgent),
							r = document.createElement("a"),
							i
						function a(o) {
							var s = o
							return (
								n && (r.setAttribute("href", s), (s = r.href)),
								r.setAttribute("href", s),
								{
									href: r.href,
									protocol: r.protocol ? r.protocol.replace(/:$/, "") : "",
									host: r.host,
									search: r.search ? r.search.replace(/^\?/, "") : "",
									hash: r.hash ? r.hash.replace(/^#/, "") : "",
									hostname: r.hostname,
									port: r.port,
									pathname: r.pathname.charAt(0) === "/" ? r.pathname : "/" + r.pathname,
								}
							)
						}
						return (
							(i = a(window.location.href)),
							function (s) {
								var l = e.isString(s) ? a(s) : s
								return l.protocol === i.protocol && l.host === i.host
							}
						)
				  })()
				: (function () {
						return function () {
							return !0
						}
				  })()),
			nT
		)
	}
	var rT, JR
	function hx() {
		if (JR) return rT
		JR = 1
		function e(t) {
			this.message = t
		}
		return (
			(e.prototype.toString = function () {
				return "Cancel" + (this.message ? ": " + this.message : "")
			}),
			(e.prototype.__CANCEL__ = !0),
			(rT = e),
			rT
		)
	}
	var iT, ZR
	function eL() {
		if (ZR) return iT
		ZR = 1
		var e = Ca(),
			t = jee(),
			n = Fee(),
			r = rB(),
			i = $ee(),
			a = Uee(),
			o = zee(),
			s = aB(),
			l = mx(),
			u = hx()
		return (
			(iT = function (p) {
				return new Promise(function (v, y) {
					var b = p.data,
						x = p.headers,
						E = p.responseType,
						T
					function C() {
						p.cancelToken && p.cancelToken.unsubscribe(T),
							p.signal && p.signal.removeEventListener("abort", T)
					}
					e.isFormData(b) && delete x["Content-Type"]
					var D = new XMLHttpRequest()
					if (p.auth) {
						var O = p.auth.username || "",
							A = p.auth.password ? unescape(encodeURIComponent(p.auth.password)) : ""
						x.Authorization = "Basic " + btoa(O + ":" + A)
					}
					var N = i(p.baseURL, p.url)
					D.open(p.method.toUpperCase(), r(N, p.params, p.paramsSerializer), !0),
						(D.timeout = p.timeout)
					function I() {
						if (D) {
							var L = "getAllResponseHeaders" in D ? a(D.getAllResponseHeaders()) : null,
								B = !E || E === "text" || E === "json" ? D.responseText : D.response,
								z = {
									data: B,
									status: D.status,
									statusText: D.statusText,
									headers: L,
									config: p,
									request: D,
								}
							t(
								function (K) {
									v(K), C()
								},
								function (K) {
									y(K), C()
								},
								z,
							),
								(D = null)
						}
					}
					if (
						("onloadend" in D
							? (D.onloadend = I)
							: (D.onreadystatechange = function () {
									!D ||
										D.readyState !== 4 ||
										(D.status === 0 && !(D.responseURL && D.responseURL.indexOf("file:") === 0)) ||
										setTimeout(I)
							  }),
						(D.onabort = function () {
							D && (y(s("Request aborted", p, "ECONNABORTED", D)), (D = null))
						}),
						(D.onerror = function () {
							y(s("Network Error", p, null, D)), (D = null)
						}),
						(D.ontimeout = function () {
							var B = p.timeout ? "timeout of " + p.timeout + "ms exceeded" : "timeout exceeded",
								z = p.transitional || l.transitional
							p.timeoutErrorMessage && (B = p.timeoutErrorMessage),
								y(s(B, p, z.clarifyTimeoutError ? "ETIMEDOUT" : "ECONNABORTED", D)),
								(D = null)
						}),
						e.isStandardBrowserEnv())
					) {
						var P =
							(p.withCredentials || o(N)) && p.xsrfCookieName ? n.read(p.xsrfCookieName) : void 0
						P && (x[p.xsrfHeaderName] = P)
					}
					"setRequestHeader" in D &&
						e.forEach(x, function (B, z) {
							typeof b > "u" && z.toLowerCase() === "content-type"
								? delete x[z]
								: D.setRequestHeader(z, B)
						}),
						e.isUndefined(p.withCredentials) || (D.withCredentials = !!p.withCredentials),
						E && E !== "json" && (D.responseType = p.responseType),
						typeof p.onDownloadProgress == "function" &&
							D.addEventListener("progress", p.onDownloadProgress),
						typeof p.onUploadProgress == "function" &&
							D.upload &&
							D.upload.addEventListener("progress", p.onUploadProgress),
						(p.cancelToken || p.signal) &&
							((T = function (L) {
								D && (y(!L || (L && L.type) ? new u("canceled") : L), D.abort(), (D = null))
							}),
							p.cancelToken && p.cancelToken.subscribe(T),
							p.signal && (p.signal.aborted ? T() : p.signal.addEventListener("abort", T))),
						b || (b = null),
						D.send(b)
				})
			}),
			iT
		)
	}
	var aT, tL
	function mx() {
		if (tL) return aT
		tL = 1
		var e = Ca(),
			t = Pee(),
			n = iB(),
			r = { "Content-Type": "application/x-www-form-urlencoded" }
		function i(l, u) {
			!e.isUndefined(l) && e.isUndefined(l["Content-Type"]) && (l["Content-Type"] = u)
		}
		function a() {
			var l
			return (
				(typeof XMLHttpRequest < "u" ||
					(typeof process < "u" &&
						Object.prototype.toString.call(process) === "[object process]")) &&
					(l = eL()),
				l
			)
		}
		function o(l, u, d) {
			if (e.isString(l))
				try {
					return (u || JSON.parse)(l), e.trim(l)
				} catch (p) {
					if (p.name !== "SyntaxError") throw p
				}
			return (0, JSON.stringify)(l)
		}
		var s = {
			transitional: { silentJSONParsing: !0, forcedJSONParsing: !0, clarifyTimeoutError: !1 },
			adapter: a(),
			transformRequest: [
				function (u, d) {
					return (
						t(d, "Accept"),
						t(d, "Content-Type"),
						e.isFormData(u) ||
						e.isArrayBuffer(u) ||
						e.isBuffer(u) ||
						e.isStream(u) ||
						e.isFile(u) ||
						e.isBlob(u)
							? u
							: e.isArrayBufferView(u)
							? u.buffer
							: e.isURLSearchParams(u)
							? (i(d, "application/x-www-form-urlencoded;charset=utf-8"), u.toString())
							: e.isObject(u) || (d && d["Content-Type"] === "application/json")
							? (i(d, "application/json"), o(u))
							: u
					)
				},
			],
			transformResponse: [
				function (u) {
					var d = this.transitional || s.transitional,
						p = d && d.silentJSONParsing,
						m = d && d.forcedJSONParsing,
						v = !p && this.responseType === "json"
					if (v || (m && e.isString(u) && u.length))
						try {
							return JSON.parse(u)
						} catch (y) {
							if (v) throw y.name === "SyntaxError" ? n(y, this, "E_JSON_PARSE") : y
						}
					return u
				},
			],
			timeout: 0,
			xsrfCookieName: "XSRF-TOKEN",
			xsrfHeaderName: "X-XSRF-TOKEN",
			maxContentLength: -1,
			maxBodyLength: -1,
			validateStatus: function (u) {
				return u >= 200 && u < 300
			},
			headers: { common: { Accept: "application/json, text/plain, */*" } },
		}
		return (
			e.forEach(["delete", "get", "head"], function (u) {
				s.headers[u] = {}
			}),
			e.forEach(["post", "put", "patch"], function (u) {
				s.headers[u] = e.merge(r)
			}),
			(aT = s),
			aT
		)
	}
	var oT, nL
	function qee() {
		if (nL) return oT
		nL = 1
		var e = Ca(),
			t = mx()
		return (
			(oT = function (r, i, a) {
				var o = this || t
				return (
					e.forEach(a, function (l) {
						r = l.call(o, r, i)
					}),
					r
				)
			}),
			oT
		)
	}
	var sT, rL
	function oB() {
		return (
			rL ||
				((rL = 1),
				(sT = function (t) {
					return !!(t && t.__CANCEL__)
				})),
			sT
		)
	}
	var lT, iL
	function Vee() {
		if (iL) return lT
		iL = 1
		var e = Ca(),
			t = qee(),
			n = oB(),
			r = mx(),
			i = hx()
		function a(o) {
			if ((o.cancelToken && o.cancelToken.throwIfRequested(), o.signal && o.signal.aborted))
				throw new i("canceled")
		}
		return (
			(lT = function (s) {
				a(s),
					(s.headers = s.headers || {}),
					(s.data = t.call(s, s.data, s.headers, s.transformRequest)),
					(s.headers = e.merge(s.headers.common || {}, s.headers[s.method] || {}, s.headers)),
					e.forEach(["delete", "get", "head", "post", "put", "patch", "common"], function (d) {
						delete s.headers[d]
					})
				var l = s.adapter || r.adapter
				return l(s).then(
					function (d) {
						return a(s), (d.data = t.call(s, d.data, d.headers, s.transformResponse)), d
					},
					function (d) {
						return (
							n(d) ||
								(a(s),
								d &&
									d.response &&
									(d.response.data = t.call(
										s,
										d.response.data,
										d.response.headers,
										s.transformResponse,
									))),
							Promise.reject(d)
						)
					},
				)
			}),
			lT
		)
	}
	var uT, aL
	function sB() {
		if (aL) return uT
		aL = 1
		var e = Ca()
		return (
			(uT = function (n, r) {
				r = r || {}
				var i = {}
				function a(p, m) {
					return e.isPlainObject(p) && e.isPlainObject(m)
						? e.merge(p, m)
						: e.isPlainObject(m)
						? e.merge({}, m)
						: e.isArray(m)
						? m.slice()
						: m
				}
				function o(p) {
					if (e.isUndefined(r[p])) {
						if (!e.isUndefined(n[p])) return a(void 0, n[p])
					} else return a(n[p], r[p])
				}
				function s(p) {
					if (!e.isUndefined(r[p])) return a(void 0, r[p])
				}
				function l(p) {
					if (e.isUndefined(r[p])) {
						if (!e.isUndefined(n[p])) return a(void 0, n[p])
					} else return a(void 0, r[p])
				}
				function u(p) {
					if (p in r) return a(n[p], r[p])
					if (p in n) return a(void 0, n[p])
				}
				var d = {
					url: s,
					method: s,
					data: s,
					baseURL: l,
					transformRequest: l,
					transformResponse: l,
					paramsSerializer: l,
					timeout: l,
					timeoutMessage: l,
					withCredentials: l,
					adapter: l,
					responseType: l,
					xsrfCookieName: l,
					xsrfHeaderName: l,
					onUploadProgress: l,
					onDownloadProgress: l,
					decompress: l,
					maxContentLength: l,
					maxBodyLength: l,
					transport: l,
					httpAgent: l,
					httpsAgent: l,
					cancelToken: l,
					socketPath: l,
					responseEncoding: l,
					validateStatus: u,
				}
				return (
					e.forEach(Object.keys(n).concat(Object.keys(r)), function (m) {
						var v = d[m] || o,
							y = v(m)
						;(e.isUndefined(y) && v !== u) || (i[m] = y)
					}),
					i
				)
			}),
			uT
		)
	}
	var cT, oL
	function lB() {
		return oL || ((oL = 1), (cT = { version: "0.24.0" })), cT
	}
	var dT, sL
	function Wee() {
		if (sL) return dT
		sL = 1
		var e = lB().version,
			t = {}
		;["object", "boolean", "number", "function", "string", "symbol"].forEach(function (i, a) {
			t[i] = function (s) {
				return typeof s === i || "a" + (a < 1 ? "n " : " ") + i
			}
		})
		var n = {}
		t.transitional = function (a, o, s) {
			function l(u, d) {
				return "[Axios v" + e + "] Transitional option '" + u + "'" + d + (s ? ". " + s : "")
			}
			return function (u, d, p) {
				if (a === !1) throw new Error(l(d, " has been removed" + (o ? " in " + o : "")))
				return (
					o &&
						!n[d] &&
						((n[d] = !0),
						console.warn(
							l(d, " has been deprecated since v" + o + " and will be removed in the near future"),
						)),
					a ? a(u, d, p) : !0
				)
			}
		}
		function r(i, a, o) {
			if (typeof i != "object") throw new TypeError("options must be an object")
			for (var s = Object.keys(i), l = s.length; l-- > 0; ) {
				var u = s[l],
					d = a[u]
				if (d) {
					var p = i[u],
						m = p === void 0 || d(p, u, i)
					if (m !== !0) throw new TypeError("option " + u + " must be " + m)
					continue
				}
				if (o !== !0) throw Error("Unknown option " + u)
			}
		}
		return (dT = { assertOptions: r, validators: t }), dT
	}
	var fT, lL
	function Yee() {
		if (lL) return fT
		lL = 1
		var e = Ca(),
			t = rB(),
			n = Lee(),
			r = Vee(),
			i = sB(),
			a = Wee(),
			o = a.validators
		function s(l) {
			;(this.defaults = l), (this.interceptors = { request: new n(), response: new n() })
		}
		return (
			(s.prototype.request = function (u) {
				typeof u == "string" ? ((u = arguments[1] || {}), (u.url = arguments[0])) : (u = u || {}),
					(u = i(this.defaults, u)),
					u.method
						? (u.method = u.method.toLowerCase())
						: this.defaults.method
						? (u.method = this.defaults.method.toLowerCase())
						: (u.method = "get")
				var d = u.transitional
				d !== void 0 &&
					a.assertOptions(
						d,
						{
							silentJSONParsing: o.transitional(o.boolean),
							forcedJSONParsing: o.transitional(o.boolean),
							clarifyTimeoutError: o.transitional(o.boolean),
						},
						!1,
					)
				var p = [],
					m = !0
				this.interceptors.request.forEach(function (D) {
					;(typeof D.runWhen == "function" && D.runWhen(u) === !1) ||
						((m = m && D.synchronous), p.unshift(D.fulfilled, D.rejected))
				})
				var v = []
				this.interceptors.response.forEach(function (D) {
					v.push(D.fulfilled, D.rejected)
				})
				var y
				if (!m) {
					var b = [r, void 0]
					for (
						Array.prototype.unshift.apply(b, p), b = b.concat(v), y = Promise.resolve(u);
						b.length;

					)
						y = y.then(b.shift(), b.shift())
					return y
				}
				for (var x = u; p.length; ) {
					var E = p.shift(),
						T = p.shift()
					try {
						x = E(x)
					} catch (C) {
						T(C)
						break
					}
				}
				try {
					y = r(x)
				} catch (C) {
					return Promise.reject(C)
				}
				for (; v.length; ) y = y.then(v.shift(), v.shift())
				return y
			}),
			(s.prototype.getUri = function (u) {
				return (u = i(this.defaults, u)), t(u.url, u.params, u.paramsSerializer).replace(/^\?/, "")
			}),
			e.forEach(["delete", "get", "head", "options"], function (u) {
				s.prototype[u] = function (d, p) {
					return this.request(i(p || {}, { method: u, url: d, data: (p || {}).data }))
				}
			}),
			e.forEach(["post", "put", "patch"], function (u) {
				s.prototype[u] = function (d, p, m) {
					return this.request(i(m || {}, { method: u, url: d, data: p }))
				}
			}),
			(fT = s),
			fT
		)
	}
	var pT, uL
	function Gee() {
		if (uL) return pT
		uL = 1
		var e = hx()
		function t(n) {
			if (typeof n != "function") throw new TypeError("executor must be a function.")
			var r
			this.promise = new Promise(function (o) {
				r = o
			})
			var i = this
			this.promise.then(function (a) {
				if (i._listeners) {
					var o,
						s = i._listeners.length
					for (o = 0; o < s; o++) i._listeners[o](a)
					i._listeners = null
				}
			}),
				(this.promise.then = function (a) {
					var o,
						s = new Promise(function (l) {
							i.subscribe(l), (o = l)
						}).then(a)
					return (
						(s.cancel = function () {
							i.unsubscribe(o)
						}),
						s
					)
				}),
				n(function (o) {
					i.reason || ((i.reason = new e(o)), r(i.reason))
				})
		}
		return (
			(t.prototype.throwIfRequested = function () {
				if (this.reason) throw this.reason
			}),
			(t.prototype.subscribe = function (r) {
				if (this.reason) {
					r(this.reason)
					return
				}
				this._listeners ? this._listeners.push(r) : (this._listeners = [r])
			}),
			(t.prototype.unsubscribe = function (r) {
				if (this._listeners) {
					var i = this._listeners.indexOf(r)
					i !== -1 && this._listeners.splice(i, 1)
				}
			}),
			(t.source = function () {
				var r,
					i = new t(function (o) {
						r = o
					})
				return { token: i, cancel: r }
			}),
			(pT = t),
			pT
		)
	}
	var hT, cL
	function Kee() {
		return (
			cL ||
				((cL = 1),
				(hT = function (t) {
					return function (r) {
						return t.apply(null, r)
					}
				})),
			hT
		)
	}
	var mT, dL
	function Qee() {
		return (
			dL ||
				((dL = 1),
				(mT = function (t) {
					return typeof t == "object" && t.isAxiosError === !0
				})),
			mT
		)
	}
	var fL
	function Xee() {
		if (fL) return U0.exports
		fL = 1
		var e = Ca(),
			t = nB(),
			n = Yee(),
			r = sB(),
			i = mx()
		function a(s) {
			var l = new n(s),
				u = t(n.prototype.request, l)
			return (
				e.extend(u, n.prototype, l),
				e.extend(u, l),
				(u.create = function (p) {
					return a(r(s, p))
				}),
				u
			)
		}
		var o = a(i)
		return (
			(o.Axios = n),
			(o.Cancel = hx()),
			(o.CancelToken = Gee()),
			(o.isCancel = oB()),
			(o.VERSION = lB().version),
			(o.all = function (l) {
				return Promise.all(l)
			}),
			(o.spread = Kee()),
			(o.isAxiosError = Qee()),
			(U0.exports = o),
			(U0.exports.default = o),
			U0.exports
		)
	}
	var vT, pL
	function Jee() {
		return pL || ((pL = 1), (vT = Xee())), vT
	}
	var Zee = Jee()
	const vx = Ti(Zee),
		ws = vx.create({ baseURL: lt.ApiUrl, xsrfCookieName: lt.CrsfCookieName }),
		Es = vx.create({ baseURL: lt.AuthUrl, xsrfCookieName: lt.CrsfCookieName })
	ws.interceptors.request.use((e) => {
		const t = uB()
		return t && (e.headers.Authorization = "Token " + t), e
	})
	Es.interceptors.request.use((e) => {
		const t = uB()
		return t && (e.headers.Authorization = "Token " + t), e
	})
	const uB = () => {
			let e = localStorage.getItem(lt.BearerTokenName)
			return e || (e = sessionStorage.getItem(lt.BearerTokenName)), e
		},
		ete =
			({ baseUrl: e } = { baseUrl: "" }) =>
			async ({ url: t, method: n, data: r }) => {
				try {
					return { data: (await ws({ url: e + t, method: n, data: r })).data }
				} catch (i) {
					const a = i
					return a ? { error: JSON.stringify(a.response.data) } : { error: JSON.stringify(i) }
				}
			},
		Ui = Ree({
			reducerPath: "mpga-api",
			baseQuery: ete({ baseUrl: "" }),
			tagTypes: [
				"Announcements",
				"Awards",
				"Clubs",
				"ClubContacts",
				"Committee",
				"Contacts",
				"Documents",
				"Events",
				"MatchPlayResults",
				"Memberships",
				"Pages",
				"Photos",
				"Policies",
				"Tournaments",
				"Tournament-Winners",
			],
			keepUnusedDataFor: 150,
			endpoints: () => ({}),
		}),
		tte = {
			config: {
				eventCalendarYear: 0,
				matchPlayYear: 0,
				memberClubYear: 0,
				membershipDues: 0,
				stripePublicKey: "",
			},
			isBusy: !1,
			editMode: !1,
			closedForms: [],
		},
		gT = qr("app/getConfig", async () => (await vx.get("/settings/")).data),
		cB = co({
			name: "app",
			initialState: tte,
			reducers: {
				isBusy: (e) => {
					e.isBusy = !0
				},
				isNotBusy: (e) => {
					e.isBusy = !1
				},
				saveLocation: (e, t) => {
					e.location = t.payload
				},
				toggleEditMode: (e) => {
					e.editMode = !e.editMode
				},
				closeOpenForms: (e, t) => {
					e.closedForms.push(t.payload)
				},
			},
			extraReducers: (e) => {
				e.addCase(gT.pending, (t) => {
					t.isBusy = !0
				}),
					e.addCase(gT.fulfilled, (t, n) => {
						;(t.isBusy = !1), (t.config = n.payload)
					}),
					e.addCase(gT.rejected, (t) => {
						t.isBusy = !1
					})
			},
		}),
		{
			isBusy: GSt,
			isNotBusy: KSt,
			saveLocation: dB,
			toggleEditMode: nte,
			closeOpenForms: QSt,
		} = cB.actions,
		rte = cB.reducer,
		ite = { subMenu: "home", segments: [] },
		fB = co({
			name: "layout",
			initialState: ite,
			reducers: {
				routeChanged(e, t) {
					var n = t.payload.split("/"),
						r = n[1].length > 0 ? n[1] : "home"
					;(e.subMenu = r), (e.segments = n.slice(1))
				},
			},
		}),
		{ routeChanged: ate } = fB.actions,
		ote = fB.reducer,
		ste = { sending: !1, failed: !1 },
		$y = qr("messages/sendMessage", async (e) => (await ws.post("/messages/", e)).data),
		lte = co({
			name: "messages",
			initialState: ste,
			reducers: {},
			extraReducers: (e) => {
				e.addCase($y.pending, (t) => {
					t.sending = !0
				}),
					e.addCase($y.fulfilled, (t, n) => {
						;(t.sending = !1), (t.sent = n.payload)
					}),
					e.addCase($y.rejected, (t) => {
						;(t.sending = !1), (t.failed = !0)
					})
			},
		}),
		ute = lte.reducer,
		cte = { paymentProcessing: !1, hasError: !1 },
		Uy = qr("payments/payClubDues", async (e) => {
			const n = (await ws.get(`/club-dues/${e.club.id}/`)).data
			return await e.stripe.confirmCardPayment(n, { payment_method: e.method.id })
		}),
		dte = co({
			name: "payments",
			initialState: cte,
			reducers: {},
			extraReducers: (e) => {
				e.addCase(Uy.pending, (t) => {
					t.paymentProcessing = !0
				}),
					e.addCase(Uy.fulfilled, (t, n) => {
						;(t.paymentProcessing = !1),
							n.payload.error
								? (t.paymentError = n.payload.error.message)
								: n.payload.paymentIntent
								? (t.paymentConfirmationId = n.payload.paymentIntent.id)
								: (t.paymentError = "Unexpected result from the payment processor.")
					}),
					e.addCase(Uy.rejected, (t) => {
						;(t.paymentProcessing = !1),
							(t.paymentError = "An error occurred while processing the payment.")
					})
			},
		}),
		fte = dte.reducer,
		_c = {
			errorMessage: "",
			isBusy: !1,
			hasError: !1,
			pendingPasswordReset: !1,
			passwordResetConfirmed: !1,
			accountExists: !1,
			accountActivated: !1,
			accountCreated: !1,
		},
		hL = { user: { is_authenticated: !1 }, flags: _c },
		zy = qr("users/getUser", async () => (await Es.get("/users/me/")).data),
		pte = qr(
			"users/getContactRoles",
			async (e) => (await ws.get("/contact-roles/?email=" + e)).data,
		),
		qy = qr(
			"users/login",
			async (e) =>
				(
					await Es.post("/token/login/", {
						username: e.email,
						email: e.email,
						password: e.password,
					})
				).data,
		),
		hte = qr("users/logout", async () => {
			await Es.post("/token/logout/", {})
		}),
		Vy = qr("users/createAccount", async (e) => {
			const t = {
				email: e.email,
				first_name: e.firstName,
				last_name: e.lastName,
				password: e.password,
				re_password: e.confirmPassword,
			}
			return (await Es.post("/users/", t)).data
		}),
		pB = qr("users/updateAccount", async (e) => (await Es.patch("/users/me/", e)).data),
		Wy = qr("users/getContact", async (e) => (await ws.get(`/contacts/?email=${e}`)).data[0]),
		Yy = qr("users/saveContact", async (e) => (await ws.patch(`/contacts/${e.id}/`, e)).data),
		PS = qr(
			"users/resetPassword",
			async (e) => (await Es.post("/users/reset-password/", { email: e })).data,
		),
		Gy = qr(
			"users/confirmPasswordReset",
			async (e) => (await Es.post("/users/reset-password-confirm/", e)).data,
		),
		Ky = qr(
			"users/changePassword",
			async (e) => (await Es.post("/users/change-password/", e)).data,
		),
		Qy = qr("users/activateAccount", async (e) => (await Es.post("/users/activation/", e)).data),
		hB = co({
			name: "user",
			initialState: hL,
			reducers: {
				resetUser: (e) => {
					;(e.user = hL.user), (e.flags = _c)
				},
			},
			extraReducers: (e) => {
				e.addCase(zy.pending, (t) => {
					t.flags.isBusy = !0
				})
					.addCase(zy.fulfilled, (t, n) => {
						;(t.user = n.payload), (t.flags = _c)
					})
					.addCase(zy.rejected, (t) => {
						t.flags.hasError = !0
					})
					.addCase(pte.fulfilled, (t, n) => {
						var a, o
						const r = (a = n.payload.committee[0]) == null ? void 0 : a.id,
							i = (o = n.payload.club[0]) == null ? void 0 : o.club__system_name
						;(t.clubId = i), (t.committeeId = r)
					})
					.addCase(qy.pending, (t) => {
						t.flags.isBusy = !0
					})
					.addCase(qy.fulfilled, (t) => {
						t.flags = _c
					})
					.addCase(qy.rejected, (t, n) => {
						;(t.flags.hasError = !0), (t.flags.errorMessage = n.error.message)
					})
					.addCase(Vy.pending, (t, n) => {
						;(t.accountRequest = n.meta.arg), (t.flags.isBusy = !0)
					})
					.addCase(Vy.fulfilled, (t) => {
						t.flags.accountCreated = !0
					})
					.addCase(Vy.rejected, (t, n) => {
						let r = !1
						n.error.message === "user already exists" && (r = !0),
							(t.flags.accountExists = r),
							(t.flags.hasError = !0),
							(t.flags.errorMessage = r ? "We already have an account for you." : n.error.message)
					})
					.addCase(Wy.pending, (t) => {
						t.flags.isBusy = !0
					})
					.addCase(Wy.fulfilled, (t, n) => {
						;(t.contact = n.payload), (t.flags = _c)
					})
					.addCase(Wy.rejected, (t, n) => {
						;(t.flags.hasError = !0), (t.flags.errorMessage = n.error.message)
					})
					.addCase(Yy.pending, (t) => {
						t.flags.isBusy = !0
					})
					.addCase(Yy.fulfilled, (t) => {
						t.flags = _c
					})
					.addCase(Yy.rejected, (t, n) => {
						;(t.flags.hasError = !0), (t.flags.errorMessage = n.error.message)
					})
					.addCase(PS.pending, (t) => {
						t.flags.isBusy = !0
					})
					.addCase(PS.fulfilled, (t) => {
						t.flags.pendingPasswordReset = !0
					})
					.addCase(Gy.pending, (t) => {
						t.flags.isBusy = !0
					})
					.addCase(Gy.fulfilled, (t) => {
						t.flags.passwordResetConfirmed = !0
					})
					.addCase(Gy.rejected, (t, n) => {
						;(t.flags.hasError = !0), (t.flags.errorMessage = n.error.message)
					})
					.addCase(Qy.pending, (t) => {
						t.flags.isBusy = !0
					})
					.addCase(Qy.fulfilled, (t) => {
						t.flags.accountActivated = !0
					})
					.addCase(Qy.rejected, (t, n) => {
						;(t.flags.hasError = !0), (t.flags.errorMessage = n.error.message)
					})
					.addCase(Ky.pending, (t) => {
						t.flags.isBusy = !0
					})
					.addCase(Ky.fulfilled, (t) => {
						t.flags = _c
					})
					.addCase(Ky.rejected, (t, n) => {
						;(t.flags.hasError = !0), (t.flags.errorMessage = n.error.message)
					})
			},
		}),
		{ resetUser: mte } = hB.actions,
		vte = hB.reducer,
		gte = { app: rte, layout: ote, messaging: ute, payments: fte, session: vte },
		mB = RZ({
			middleware: (e) => e().concat(Ui.middleware),
			reducer: { ...gte, [Ui.reducerPath]: Ui.reducer },
		}),
		ki = () => zD(),
		Nr = Up
	var yT, mL
	function yte() {
		if (mL) return yT
		mL = 1
		var e = "Expected a function",
			t = NaN,
			n = "[object Symbol]",
			r = /^\s+|\s+$/g,
			i = /^[-+]0x[0-9a-f]+$/i,
			a = /^0b[01]+$/i,
			o = /^0o[0-7]+$/i,
			s = parseInt,
			l = typeof L0 == "object" && L0 && L0.Object === Object && L0,
			u = typeof self == "object" && self && self.Object === Object && self,
			d = l || u || Function("return this")(),
			p = Object.prototype,
			m = p.toString,
			v = Math.max,
			y = Math.min,
			b = function () {
				return d.Date.now()
			}
		function x(O, A, N) {
			var I,
				P,
				L,
				B,
				z,
				V,
				K = 0,
				ne = !1,
				re = !1,
				ie = !0
			if (typeof O != "function") throw new TypeError(e)
			;(A = D(A) || 0),
				E(N) &&
					((ne = !!N.leading),
					(re = "maxWait" in N),
					(L = re ? v(D(N.maxWait) || 0, A) : L),
					(ie = "trailing" in N ? !!N.trailing : ie))
			function J(be) {
				var Le = I,
					Be = P
				return (I = P = void 0), (K = be), (B = O.apply(Be, Le)), B
			}
			function le(be) {
				return (K = be), (z = setTimeout(ee, A)), ne ? J(be) : B
			}
			function F(be) {
				var Le = be - V,
					Be = be - K,
					et = A - Le
				return re ? y(et, L - Be) : et
			}
			function Y(be) {
				var Le = be - V,
					Be = be - K
				return V === void 0 || Le >= A || Le < 0 || (re && Be >= L)
			}
			function ee() {
				var be = b()
				if (Y(be)) return $(be)
				z = setTimeout(ee, F(be))
			}
			function $(be) {
				return (z = void 0), ie && I ? J(be) : ((I = P = void 0), B)
			}
			function ge() {
				z !== void 0 && clearTimeout(z), (K = 0), (I = V = P = z = void 0)
			}
			function Se() {
				return z === void 0 ? B : $(b())
			}
			function Ee() {
				var be = b(),
					Le = Y(be)
				if (((I = arguments), (P = this), (V = be), Le)) {
					if (z === void 0) return le(V)
					if (re) return (z = setTimeout(ee, A)), J(V)
				}
				return z === void 0 && (z = setTimeout(ee, A)), B
			}
			return (Ee.cancel = ge), (Ee.flush = Se), Ee
		}
		function E(O) {
			var A = typeof O
			return !!O && (A == "object" || A == "function")
		}
		function T(O) {
			return !!O && typeof O == "object"
		}
		function C(O) {
			return typeof O == "symbol" || (T(O) && m.call(O) == n)
		}
		function D(O) {
			if (typeof O == "number") return O
			if (C(O)) return t
			if (E(O)) {
				var A = typeof O.valueOf == "function" ? O.valueOf() : O
				O = E(A) ? A + "" : A
			}
			if (typeof O != "string") return O === 0 ? O : +O
			O = O.replace(r, "")
			var N = a.test(O)
			return N || o.test(O) ? s(O.slice(2), N ? 2 : 8) : i.test(O) ? t : +O
		}
		return (yT = x), yT
	}
	var bte = yte()
	const vL = Ti(bte)
	var vB = typeof window < "u" ? _.useLayoutEffect : _.useEffect
	function gB(e, t, n, r) {
		const i = _.useRef(t)
		vB(() => {
			i.current = t
		}, [t]),
			_.useEffect(() => {
				const a = window
				if (!(a && a.addEventListener)) return
				const o = (s) => {
					i.current(s)
				}
				return (
					a.addEventListener(e, o, r),
					() => {
						a.removeEventListener(e, o, r)
					}
				)
			}, [e, n, r])
	}
	function xte(e) {
		const t = _.useRef(e)
		;(t.current = e),
			_.useEffect(
				() => () => {
					t.current()
				},
				[],
			)
	}
	function wte(e, t = 500, n) {
		const r = _.useRef()
		xte(() => {
			r.current && r.current.cancel()
		})
		const i = _.useMemo(() => {
			const a = vL(e, t, n),
				o = (...s) => a(...s)
			return (
				(o.cancel = () => {
					a.cancel()
				}),
				(o.isPending = () => !!r.current),
				(o.flush = () => a.flush()),
				o
			)
		}, [e, t, n])
		return (
			_.useEffect(() => {
				r.current = vL(e, t, n)
			}, [e, t, n]),
			i
		)
	}
	var gL = typeof window > "u"
	function Ete(e = {}) {
		let { initializeWithValue: t = !0 } = e
		gL && (t = !1)
		const n = () => {
				if (!gL) return window.screen
			},
			[r, i] = _.useState(() => {
				if (t) return n()
			}),
			a = wte(i, e.debounceDelay)
		function o() {
			const s = n(),
				l = e.debounceDelay ? a : i
			if (s) {
				const {
					width: u,
					height: d,
					availHeight: p,
					availWidth: m,
					colorDepth: v,
					orientation: y,
					pixelDepth: b,
				} = s
				l({
					width: u,
					height: d,
					availHeight: p,
					availWidth: m,
					colorDepth: v,
					orientation: y,
					pixelDepth: b,
				})
			}
		}
		return (
			gB("resize", o),
			vB(() => {
				o()
			}, []),
			r
		)
	}
	const r_ = H.createContext({ sidebarOpen: !1 })
	r_.displayName = "LayoutContext"
	function Cte(e) {
		const t = Ete(),
			[n, r] = H.useState(t.width >= 1200),
			i = H.useCallback((u) => {
				const d = u.target
				;(d == null ? void 0 : d.innerWidth) >= 1200 && r(!0)
			}, [])
		gB("resize", i)
		const l = {
			sidebarOpen: n,
			closeSidebar: () => {
				t.width < 1200 && r(!1)
			},
			openSidebar: () => {
				r(!0)
			},
			toggleSidebar: () => {
				r(!n)
			},
		}
		return h.jsx(r_.Provider, { value: l, ...e })
	}
	var bT = { exports: {} }
	/*!
	Copyright (c) 2018 Jed Watson.
	Licensed under the MIT License (MIT), see
	http://jedwatson.github.io/classnames
*/ var yL
	function Tte() {
		return (
			yL ||
				((yL = 1),
				(function (e) {
					;(function () {
						var t = {}.hasOwnProperty
						function n() {
							for (var a = "", o = 0; o < arguments.length; o++) {
								var s = arguments[o]
								s && (a = i(a, r(s)))
							}
							return a
						}
						function r(a) {
							if (typeof a == "string" || typeof a == "number") return a
							if (typeof a != "object") return ""
							if (Array.isArray(a)) return n.apply(null, a)
							if (
								a.toString !== Object.prototype.toString &&
								!a.toString.toString().includes("[native code]")
							)
								return a.toString()
							var o = ""
							for (var s in a) t.call(a, s) && a[s] && (o = i(o, s))
							return o
						}
						function i(a, o) {
							return o ? (a ? a + " " + o : a + o) : a
						}
						e.exports ? ((n.default = n), (e.exports = n)) : (window.classNames = n)
					})()
				})(bT)),
			bT.exports
		)
	}
	var kte = Tte()
	const Fe = Ti(kte),
		Ste = ["xxl", "xl", "lg", "md", "sm", "xs"],
		Dte = "xs",
		gx = _.createContext({ prefixes: {}, breakpoints: Ste, minBreakpoint: Dte })
	function nt(e, t) {
		const { prefixes: n } = _.useContext(gx)
		return e || n[t] || t
	}
	function yB() {
		const { breakpoints: e } = _.useContext(gx)
		return e
	}
	function bB() {
		const { minBreakpoint: e } = _.useContext(gx)
		return e
	}
	function xB() {
		const { dir: e } = _.useContext(gx)
		return e === "rtl"
	}
	function _te({ as: e, bsPrefix: t, className: n, ...r }) {
		t = nt(t, "col")
		const i = yB(),
			a = bB(),
			o = [],
			s = []
		return (
			i.forEach((l) => {
				const u = r[l]
				delete r[l]
				let d, p, m
				typeof u == "object" && u != null ? ({ span: d, offset: p, order: m } = u) : (d = u)
				const v = l !== a ? `-${l}` : ""
				d && o.push(d === !0 ? `${t}${v}` : `${t}${v}-${d}`),
					m != null && s.push(`order${v}-${m}`),
					p != null && s.push(`offset${v}-${p}`)
			}),
			[
				{ ...r, className: Fe(n, ...o, ...s) },
				{ as: e, bsPrefix: t, spans: o },
			]
		)
	}
	const it = _.forwardRef((e, t) => {
		const [{ className: n, ...r }, { as: i = "div", bsPrefix: a, spans: o }] = _te(e)
		return h.jsx(i, { ...r, ref: t, className: Fe(n, !o.length && a) })
	})
	it.displayName = "Col"
	const ln = _.forwardRef(({ bsPrefix: e, className: t, as: n = "div", ...r }, i) => {
		const a = nt(e, "row"),
			o = yB(),
			s = bB(),
			l = `${a}-cols`,
			u = []
		return (
			o.forEach((d) => {
				const p = r[d]
				delete r[d]
				let m
				p != null && typeof p == "object" ? ({ cols: m } = p) : (m = p)
				const v = d !== s ? `-${d}` : ""
				m != null && u.push(`${l}${v}-${m}`)
			}),
			h.jsx(n, { ref: i, ...r, className: Fe(t, a, ...u) })
		)
	})
	ln.displayName = "Row"
	function Ote() {
		return h.jsx(ln, {
			children: h.jsx(it, {
				xs: { span: 12 },
				sm: { span: 10, offset: 1 },
				md: { span: 8, offset: 2 },
				lg: { span: 4, offset: 4 },
				children: h.jsx(A8, {}),
			}),
		})
	}
	const Qv = _.forwardRef(
		(
			{
				bsPrefix: e,
				variant: t,
				animation: n = "border",
				size: r,
				as: i = "div",
				className: a,
				...o
			},
			s,
		) => {
			e = nt(e, "spinner")
			const l = `${e}-${n}`
			return h.jsx(i, { ref: s, ...o, className: Fe(a, l, r && `${l}-${r}`, t && `text-${t}`) })
		},
	)
	Qv.displayName = "Spinner"
	const Vp = () =>
		h.jsx(Qv, {
			animation: "grow",
			variant: "secondary",
			role: "status",
			children: h.jsx("span", { className: "visually-hidden", children: "Loading..." }),
		}) //! moment.js
	//! version : 2.30.1
	//! authors : Tim Wood, Iskren Chernev, Moment.js contributors
	//! license : MIT
	//! momentjs.com
	var wB
	function Te() {
		return wB.apply(null, arguments)
	}
	function Ate(e) {
		wB = e
	}
	function Do(e) {
		return e instanceof Array || Object.prototype.toString.call(e) === "[object Array]"
	}
	function qc(e) {
		return e != null && Object.prototype.toString.call(e) === "[object Object]"
	}
	function zt(e, t) {
		return Object.prototype.hasOwnProperty.call(e, t)
	}
	function i_(e) {
		if (Object.getOwnPropertyNames) return Object.getOwnPropertyNames(e).length === 0
		var t
		for (t in e) if (zt(e, t)) return !1
		return !0
	}
	function Li(e) {
		return e === void 0
	}
	function bl(e) {
		return typeof e == "number" || Object.prototype.toString.call(e) === "[object Number]"
	}
	function Xv(e) {
		return e instanceof Date || Object.prototype.toString.call(e) === "[object Date]"
	}
	function EB(e, t) {
		var n = [],
			r,
			i = e.length
		for (r = 0; r < i; ++r) n.push(t(e[r], r))
		return n
	}
	function gu(e, t) {
		for (var n in t) zt(t, n) && (e[n] = t[n])
		return (
			zt(t, "toString") && (e.toString = t.toString), zt(t, "valueOf") && (e.valueOf = t.valueOf), e
		)
	}
	function Cs(e, t, n, r) {
		return VB(e, t, n, r, !0).utc()
	}
	function Nte() {
		return {
			empty: !1,
			unusedTokens: [],
			unusedInput: [],
			overflow: -2,
			charsLeftOver: 0,
			nullInput: !1,
			invalidEra: null,
			invalidMonth: null,
			invalidFormat: !1,
			userInvalidated: !1,
			iso: !1,
			parsedDateParts: [],
			era: null,
			meridiem: null,
			rfc2822: !1,
			weekdayMismatch: !1,
		}
	}
	function bt(e) {
		return e._pf == null && (e._pf = Nte()), e._pf
	}
	var jS
	Array.prototype.some
		? (jS = Array.prototype.some)
		: (jS = function (e) {
				var t = Object(this),
					n = t.length >>> 0,
					r
				for (r = 0; r < n; r++) if (r in t && e.call(this, t[r], r, t)) return !0
				return !1
		  })
	function a_(e) {
		var t = null,
			n = !1,
			r = e._d && !isNaN(e._d.getTime())
		if (
			(r &&
				((t = bt(e)),
				(n = jS.call(t.parsedDateParts, function (i) {
					return i != null
				})),
				(r =
					t.overflow < 0 &&
					!t.empty &&
					!t.invalidEra &&
					!t.invalidMonth &&
					!t.invalidWeekday &&
					!t.weekdayMismatch &&
					!t.nullInput &&
					!t.invalidFormat &&
					!t.userInvalidated &&
					(!t.meridiem || (t.meridiem && n))),
				e._strict &&
					(r = r && t.charsLeftOver === 0 && t.unusedTokens.length === 0 && t.bigHour === void 0)),
			Object.isFrozen == null || !Object.isFrozen(e))
		)
			e._isValid = r
		else return r
		return e._isValid
	}
	function yx(e) {
		var t = Cs(NaN)
		return e != null ? gu(bt(t), e) : (bt(t).userInvalidated = !0), t
	}
	var bL = (Te.momentProperties = []),
		xT = !1
	function o_(e, t) {
		var n,
			r,
			i,
			a = bL.length
		if (
			(Li(t._isAMomentObject) || (e._isAMomentObject = t._isAMomentObject),
			Li(t._i) || (e._i = t._i),
			Li(t._f) || (e._f = t._f),
			Li(t._l) || (e._l = t._l),
			Li(t._strict) || (e._strict = t._strict),
			Li(t._tzm) || (e._tzm = t._tzm),
			Li(t._isUTC) || (e._isUTC = t._isUTC),
			Li(t._offset) || (e._offset = t._offset),
			Li(t._pf) || (e._pf = bt(t)),
			Li(t._locale) || (e._locale = t._locale),
			a > 0)
		)
			for (n = 0; n < a; n++) (r = bL[n]), (i = t[r]), Li(i) || (e[r] = i)
		return e
	}
	function Jv(e) {
		o_(this, e),
			(this._d = new Date(e._d != null ? e._d.getTime() : NaN)),
			this.isValid() || (this._d = new Date(NaN)),
			xT === !1 && ((xT = !0), Te.updateOffset(this), (xT = !1))
	}
	function _o(e) {
		return e instanceof Jv || (e != null && e._isAMomentObject != null)
	}
	function CB(e) {
		Te.suppressDeprecationWarnings === !1 &&
			typeof console < "u" &&
			console.warn &&
			console.warn("Deprecation warning: " + e)
	}
	function Ja(e, t) {
		var n = !0
		return gu(function () {
			if ((Te.deprecationHandler != null && Te.deprecationHandler(null, e), n)) {
				var r = [],
					i,
					a,
					o,
					s = arguments.length
				for (a = 0; a < s; a++) {
					if (((i = ""), typeof arguments[a] == "object")) {
						i +=
							`
[` +
							a +
							"] "
						for (o in arguments[0]) zt(arguments[0], o) && (i += o + ": " + arguments[0][o] + ", ")
						i = i.slice(0, -2)
					} else i = arguments[a]
					r.push(i)
				}
				CB(
					e +
						`
Arguments: ` +
						Array.prototype.slice.call(r).join("") +
						`
` +
						new Error().stack,
				),
					(n = !1)
			}
			return t.apply(this, arguments)
		}, t)
	}
	var xL = {}
	function TB(e, t) {
		Te.deprecationHandler != null && Te.deprecationHandler(e, t), xL[e] || (CB(t), (xL[e] = !0))
	}
	Te.suppressDeprecationWarnings = !1
	Te.deprecationHandler = null
	function Ts(e) {
		return (
			(typeof Function < "u" && e instanceof Function) ||
			Object.prototype.toString.call(e) === "[object Function]"
		)
	}
	function Mte(e) {
		var t, n
		for (n in e) zt(e, n) && ((t = e[n]), Ts(t) ? (this[n] = t) : (this["_" + n] = t))
		;(this._config = e),
			(this._dayOfMonthOrdinalParseLenient = new RegExp(
				(this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) + "|" + /\d{1,2}/.source,
			))
	}
	function FS(e, t) {
		var n = gu({}, e),
			r
		for (r in t)
			zt(t, r) &&
				(qc(e[r]) && qc(t[r])
					? ((n[r] = {}), gu(n[r], e[r]), gu(n[r], t[r]))
					: t[r] != null
					? (n[r] = t[r])
					: delete n[r])
		for (r in e) zt(e, r) && !zt(t, r) && qc(e[r]) && (n[r] = gu({}, n[r]))
		return n
	}
	function s_(e) {
		e != null && this.set(e)
	}
	var BS
	Object.keys
		? (BS = Object.keys)
		: (BS = function (e) {
				var t,
					n = []
				for (t in e) zt(e, t) && n.push(t)
				return n
		  })
	var Ite = {
		sameDay: "[Today at] LT",
		nextDay: "[Tomorrow at] LT",
		nextWeek: "dddd [at] LT",
		lastDay: "[Yesterday at] LT",
		lastWeek: "[Last] dddd [at] LT",
		sameElse: "L",
	}
	function Rte(e, t, n) {
		var r = this._calendar[e] || this._calendar.sameElse
		return Ts(r) ? r.call(t, n) : r
	}
	function ps(e, t, n) {
		var r = "" + Math.abs(e),
			i = t - r.length,
			a = e >= 0
		return (a ? (n ? "+" : "") : "-") + Math.pow(10, Math.max(0, i)).toString().substr(1) + r
	}
	var l_ =
			/(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|N{1,5}|YYYYYY|YYYYY|YYYY|YY|y{2,4}|yo?|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g,
		z0 = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g,
		wT = {},
		zf = {}
	function rt(e, t, n, r) {
		var i = r
		typeof r == "string" &&
			(i = function () {
				return this[r]()
			}),
			e && (zf[e] = i),
			t &&
				(zf[t[0]] = function () {
					return ps(i.apply(this, arguments), t[1], t[2])
				}),
			n &&
				(zf[n] = function () {
					return this.localeData().ordinal(i.apply(this, arguments), e)
				})
	}
	function Lte(e) {
		return e.match(/\[[\s\S]/) ? e.replace(/^\[|\]$/g, "") : e.replace(/\\/g, "")
	}
	function Pte(e) {
		var t = e.match(l_),
			n,
			r
		for (n = 0, r = t.length; n < r; n++) zf[t[n]] ? (t[n] = zf[t[n]]) : (t[n] = Lte(t[n]))
		return function (i) {
			var a = "",
				o
			for (o = 0; o < r; o++) a += Ts(t[o]) ? t[o].call(i, e) : t[o]
			return a
		}
	}
	function Xy(e, t) {
		return e.isValid()
			? ((t = kB(t, e.localeData())), (wT[t] = wT[t] || Pte(t)), wT[t](e))
			: e.localeData().invalidDate()
	}
	function kB(e, t) {
		var n = 5
		function r(i) {
			return t.longDateFormat(i) || i
		}
		for (z0.lastIndex = 0; n >= 0 && z0.test(e); )
			(e = e.replace(z0, r)), (z0.lastIndex = 0), (n -= 1)
		return e
	}
	var jte = {
		LTS: "h:mm:ss A",
		LT: "h:mm A",
		L: "MM/DD/YYYY",
		LL: "MMMM D, YYYY",
		LLL: "MMMM D, YYYY h:mm A",
		LLLL: "dddd, MMMM D, YYYY h:mm A",
	}
	function Fte(e) {
		var t = this._longDateFormat[e],
			n = this._longDateFormat[e.toUpperCase()]
		return t || !n
			? t
			: ((this._longDateFormat[e] = n
					.match(l_)
					.map(function (r) {
						return r === "MMMM" || r === "MM" || r === "DD" || r === "dddd" ? r.slice(1) : r
					})
					.join("")),
			  this._longDateFormat[e])
	}
	var Bte = "Invalid date"
	function Hte() {
		return this._invalidDate
	}
	var $te = "%d",
		Ute = /\d{1,2}/
	function zte(e) {
		return this._ordinal.replace("%d", e)
	}
	var qte = {
		future: "in %s",
		past: "%s ago",
		s: "a few seconds",
		ss: "%d seconds",
		m: "a minute",
		mm: "%d minutes",
		h: "an hour",
		hh: "%d hours",
		d: "a day",
		dd: "%d days",
		w: "a week",
		ww: "%d weeks",
		M: "a month",
		MM: "%d months",
		y: "a year",
		yy: "%d years",
	}
	function Vte(e, t, n, r) {
		var i = this._relativeTime[n]
		return Ts(i) ? i(e, t, n, r) : i.replace(/%d/i, e)
	}
	function Wte(e, t) {
		var n = this._relativeTime[e > 0 ? "future" : "past"]
		return Ts(n) ? n(t) : n.replace(/%s/i, t)
	}
	var wL = {
		D: "date",
		dates: "date",
		date: "date",
		d: "day",
		days: "day",
		day: "day",
		e: "weekday",
		weekdays: "weekday",
		weekday: "weekday",
		E: "isoWeekday",
		isoweekdays: "isoWeekday",
		isoweekday: "isoWeekday",
		DDD: "dayOfYear",
		dayofyears: "dayOfYear",
		dayofyear: "dayOfYear",
		h: "hour",
		hours: "hour",
		hour: "hour",
		ms: "millisecond",
		milliseconds: "millisecond",
		millisecond: "millisecond",
		m: "minute",
		minutes: "minute",
		minute: "minute",
		M: "month",
		months: "month",
		month: "month",
		Q: "quarter",
		quarters: "quarter",
		quarter: "quarter",
		s: "second",
		seconds: "second",
		second: "second",
		gg: "weekYear",
		weekyears: "weekYear",
		weekyear: "weekYear",
		GG: "isoWeekYear",
		isoweekyears: "isoWeekYear",
		isoweekyear: "isoWeekYear",
		w: "week",
		weeks: "week",
		week: "week",
		W: "isoWeek",
		isoweeks: "isoWeek",
		isoweek: "isoWeek",
		y: "year",
		years: "year",
		year: "year",
	}
	function Za(e) {
		return typeof e == "string" ? wL[e] || wL[e.toLowerCase()] : void 0
	}
	function u_(e) {
		var t = {},
			n,
			r
		for (r in e) zt(e, r) && ((n = Za(r)), n && (t[n] = e[r]))
		return t
	}
	var Yte = {
		date: 9,
		day: 11,
		weekday: 11,
		isoWeekday: 11,
		dayOfYear: 4,
		hour: 13,
		millisecond: 16,
		minute: 14,
		month: 8,
		quarter: 7,
		second: 15,
		weekYear: 1,
		isoWeekYear: 1,
		week: 5,
		isoWeek: 5,
		year: 1,
	}
	function Gte(e) {
		var t = [],
			n
		for (n in e) zt(e, n) && t.push({ unit: n, priority: Yte[n] })
		return (
			t.sort(function (r, i) {
				return r.priority - i.priority
			}),
			t
		)
	}
	var SB = /\d/,
		Ta = /\d\d/,
		DB = /\d{3}/,
		c_ = /\d{4}/,
		bx = /[+-]?\d{6}/,
		Cn = /\d\d?/,
		_B = /\d\d\d\d?/,
		OB = /\d\d\d\d\d\d?/,
		xx = /\d{1,3}/,
		d_ = /\d{1,4}/,
		wx = /[+-]?\d{1,6}/,
		Wp = /\d+/,
		Ex = /[+-]?\d+/,
		Kte = /Z|[+-]\d\d:?\d\d/gi,
		Cx = /Z|[+-]\d\d(?::?\d\d)?/gi,
		Qte = /[+-]?\d+(\.\d{1,3})?/,
		Zv =
			/[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i,
		Yp = /^[1-9]\d?/,
		f_ = /^([1-9]\d|\d)/,
		j1
	j1 = {}
	function qe(e, t, n) {
		j1[e] = Ts(t)
			? t
			: function (r, i) {
					return r && n ? n : t
			  }
	}
	function Xte(e, t) {
		return zt(j1, e) ? j1[e](t._strict, t._locale) : new RegExp(Jte(e))
	}
	function Jte(e) {
		return ll(
			e.replace("\\", "").replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (t, n, r, i, a) {
				return n || r || i || a
			}),
		)
	}
	function ll(e) {
		return e.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&")
	}
	function ja(e) {
		return e < 0 ? Math.ceil(e) || 0 : Math.floor(e)
	}
	function Dt(e) {
		var t = +e,
			n = 0
		return t !== 0 && isFinite(t) && (n = ja(t)), n
	}
	var HS = {}
	function an(e, t) {
		var n,
			r = t,
			i
		for (
			typeof e == "string" && (e = [e]),
				bl(t) &&
					(r = function (a, o) {
						o[t] = Dt(a)
					}),
				i = e.length,
				n = 0;
			n < i;
			n++
		)
			HS[e[n]] = r
	}
	function eg(e, t) {
		an(e, function (n, r, i, a) {
			;(i._w = i._w || {}), t(n, i._w, i, a)
		})
	}
	function Zte(e, t, n) {
		t != null && zt(HS, e) && HS[e](t, n._a, n, e)
	}
	function Tx(e) {
		return (e % 4 === 0 && e % 100 !== 0) || e % 400 === 0
	}
	var ti = 0,
		rl = 1,
		Jo = 2,
		gr = 3,
		mo = 4,
		il = 5,
		Pc = 6,
		ene = 7,
		tne = 8
	rt("Y", 0, 0, function () {
		var e = this.year()
		return e <= 9999 ? ps(e, 4) : "+" + e
	})
	rt(0, ["YY", 2], 0, function () {
		return this.year() % 100
	})
	rt(0, ["YYYY", 4], 0, "year")
	rt(0, ["YYYYY", 5], 0, "year")
	rt(0, ["YYYYYY", 6, !0], 0, "year")
	qe("Y", Ex)
	qe("YY", Cn, Ta)
	qe("YYYY", d_, c_)
	qe("YYYYY", wx, bx)
	qe("YYYYYY", wx, bx)
	an(["YYYYY", "YYYYYY"], ti)
	an("YYYY", function (e, t) {
		t[ti] = e.length === 2 ? Te.parseTwoDigitYear(e) : Dt(e)
	})
	an("YY", function (e, t) {
		t[ti] = Te.parseTwoDigitYear(e)
	})
	an("Y", function (e, t) {
		t[ti] = parseInt(e, 10)
	})
	function Mm(e) {
		return Tx(e) ? 366 : 365
	}
	Te.parseTwoDigitYear = function (e) {
		return Dt(e) + (Dt(e) > 68 ? 1900 : 2e3)
	}
	var AB = Gp("FullYear", !0)
	function nne() {
		return Tx(this.year())
	}
	function Gp(e, t) {
		return function (n) {
			return n != null ? (NB(this, e, n), Te.updateOffset(this, t), this) : sv(this, e)
		}
	}
	function sv(e, t) {
		if (!e.isValid()) return NaN
		var n = e._d,
			r = e._isUTC
		switch (t) {
			case "Milliseconds":
				return r ? n.getUTCMilliseconds() : n.getMilliseconds()
			case "Seconds":
				return r ? n.getUTCSeconds() : n.getSeconds()
			case "Minutes":
				return r ? n.getUTCMinutes() : n.getMinutes()
			case "Hours":
				return r ? n.getUTCHours() : n.getHours()
			case "Date":
				return r ? n.getUTCDate() : n.getDate()
			case "Day":
				return r ? n.getUTCDay() : n.getDay()
			case "Month":
				return r ? n.getUTCMonth() : n.getMonth()
			case "FullYear":
				return r ? n.getUTCFullYear() : n.getFullYear()
			default:
				return NaN
		}
	}
	function NB(e, t, n) {
		var r, i, a, o, s
		if (!(!e.isValid() || isNaN(n))) {
			switch (((r = e._d), (i = e._isUTC), t)) {
				case "Milliseconds":
					return void (i ? r.setUTCMilliseconds(n) : r.setMilliseconds(n))
				case "Seconds":
					return void (i ? r.setUTCSeconds(n) : r.setSeconds(n))
				case "Minutes":
					return void (i ? r.setUTCMinutes(n) : r.setMinutes(n))
				case "Hours":
					return void (i ? r.setUTCHours(n) : r.setHours(n))
				case "Date":
					return void (i ? r.setUTCDate(n) : r.setDate(n))
				case "FullYear":
					break
				default:
					return
			}
			;(a = n),
				(o = e.month()),
				(s = e.date()),
				(s = s === 29 && o === 1 && !Tx(a) ? 28 : s),
				i ? r.setUTCFullYear(a, o, s) : r.setFullYear(a, o, s)
		}
	}
	function rne(e) {
		return (e = Za(e)), Ts(this[e]) ? this[e]() : this
	}
	function ine(e, t) {
		if (typeof e == "object") {
			e = u_(e)
			var n = Gte(e),
				r,
				i = n.length
			for (r = 0; r < i; r++) this[n[r].unit](e[n[r].unit])
		} else if (((e = Za(e)), Ts(this[e]))) return this[e](t)
		return this
	}
	function ane(e, t) {
		return ((e % t) + t) % t
	}
	var Qn
	Array.prototype.indexOf
		? (Qn = Array.prototype.indexOf)
		: (Qn = function (e) {
				var t
				for (t = 0; t < this.length; ++t) if (this[t] === e) return t
				return -1
		  })
	function p_(e, t) {
		if (isNaN(e) || isNaN(t)) return NaN
		var n = ane(t, 12)
		return (e += (t - n) / 12), n === 1 ? (Tx(e) ? 29 : 28) : 31 - ((n % 7) % 2)
	}
	rt("M", ["MM", 2], "Mo", function () {
		return this.month() + 1
	})
	rt("MMM", 0, 0, function (e) {
		return this.localeData().monthsShort(this, e)
	})
	rt("MMMM", 0, 0, function (e) {
		return this.localeData().months(this, e)
	})
	qe("M", Cn, Yp)
	qe("MM", Cn, Ta)
	qe("MMM", function (e, t) {
		return t.monthsShortRegex(e)
	})
	qe("MMMM", function (e, t) {
		return t.monthsRegex(e)
	})
	an(["M", "MM"], function (e, t) {
		t[rl] = Dt(e) - 1
	})
	an(["MMM", "MMMM"], function (e, t, n, r) {
		var i = n._locale.monthsParse(e, r, n._strict)
		i != null ? (t[rl] = i) : (bt(n).invalidMonth = e)
	})
	var one =
			"January_February_March_April_May_June_July_August_September_October_November_December".split(
				"_",
			),
		MB = "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),
		IB = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/,
		sne = Zv,
		lne = Zv
	function une(e, t) {
		return e
			? Do(this._months)
				? this._months[e.month()]
				: this._months[(this._months.isFormat || IB).test(t) ? "format" : "standalone"][e.month()]
			: Do(this._months)
			? this._months
			: this._months.standalone
	}
	function cne(e, t) {
		return e
			? Do(this._monthsShort)
				? this._monthsShort[e.month()]
				: this._monthsShort[IB.test(t) ? "format" : "standalone"][e.month()]
			: Do(this._monthsShort)
			? this._monthsShort
			: this._monthsShort.standalone
	}
	function dne(e, t, n) {
		var r,
			i,
			a,
			o = e.toLocaleLowerCase()
		if (!this._monthsParse)
			for (
				this._monthsParse = [], this._longMonthsParse = [], this._shortMonthsParse = [], r = 0;
				r < 12;
				++r
			)
				(a = Cs([2e3, r])),
					(this._shortMonthsParse[r] = this.monthsShort(a, "").toLocaleLowerCase()),
					(this._longMonthsParse[r] = this.months(a, "").toLocaleLowerCase())
		return n
			? t === "MMM"
				? ((i = Qn.call(this._shortMonthsParse, o)), i !== -1 ? i : null)
				: ((i = Qn.call(this._longMonthsParse, o)), i !== -1 ? i : null)
			: t === "MMM"
			? ((i = Qn.call(this._shortMonthsParse, o)),
			  i !== -1 ? i : ((i = Qn.call(this._longMonthsParse, o)), i !== -1 ? i : null))
			: ((i = Qn.call(this._longMonthsParse, o)),
			  i !== -1 ? i : ((i = Qn.call(this._shortMonthsParse, o)), i !== -1 ? i : null))
	}
	function fne(e, t, n) {
		var r, i, a
		if (this._monthsParseExact) return dne.call(this, e, t, n)
		for (
			this._monthsParse ||
				((this._monthsParse = []), (this._longMonthsParse = []), (this._shortMonthsParse = [])),
				r = 0;
			r < 12;
			r++
		) {
			if (
				((i = Cs([2e3, r])),
				n &&
					!this._longMonthsParse[r] &&
					((this._longMonthsParse[r] = new RegExp(
						"^" + this.months(i, "").replace(".", "") + "$",
						"i",
					)),
					(this._shortMonthsParse[r] = new RegExp(
						"^" + this.monthsShort(i, "").replace(".", "") + "$",
						"i",
					))),
				!n &&
					!this._monthsParse[r] &&
					((a = "^" + this.months(i, "") + "|^" + this.monthsShort(i, "")),
					(this._monthsParse[r] = new RegExp(a.replace(".", ""), "i"))),
				n && t === "MMMM" && this._longMonthsParse[r].test(e))
			)
				return r
			if (n && t === "MMM" && this._shortMonthsParse[r].test(e)) return r
			if (!n && this._monthsParse[r].test(e)) return r
		}
	}
	function RB(e, t) {
		if (!e.isValid()) return e
		if (typeof t == "string") {
			if (/^\d+$/.test(t)) t = Dt(t)
			else if (((t = e.localeData().monthsParse(t)), !bl(t))) return e
		}
		var n = t,
			r = e.date()
		return (
			(r = r < 29 ? r : Math.min(r, p_(e.year(), n))),
			e._isUTC ? e._d.setUTCMonth(n, r) : e._d.setMonth(n, r),
			e
		)
	}
	function LB(e) {
		return e != null ? (RB(this, e), Te.updateOffset(this, !0), this) : sv(this, "Month")
	}
	function pne() {
		return p_(this.year(), this.month())
	}
	function hne(e) {
		return this._monthsParseExact
			? (zt(this, "_monthsRegex") || PB.call(this),
			  e ? this._monthsShortStrictRegex : this._monthsShortRegex)
			: (zt(this, "_monthsShortRegex") || (this._monthsShortRegex = sne),
			  this._monthsShortStrictRegex && e ? this._monthsShortStrictRegex : this._monthsShortRegex)
	}
	function mne(e) {
		return this._monthsParseExact
			? (zt(this, "_monthsRegex") || PB.call(this), e ? this._monthsStrictRegex : this._monthsRegex)
			: (zt(this, "_monthsRegex") || (this._monthsRegex = lne),
			  this._monthsStrictRegex && e ? this._monthsStrictRegex : this._monthsRegex)
	}
	function PB() {
		function e(l, u) {
			return u.length - l.length
		}
		var t = [],
			n = [],
			r = [],
			i,
			a,
			o,
			s
		for (i = 0; i < 12; i++)
			(a = Cs([2e3, i])),
				(o = ll(this.monthsShort(a, ""))),
				(s = ll(this.months(a, ""))),
				t.push(o),
				n.push(s),
				r.push(s),
				r.push(o)
		t.sort(e),
			n.sort(e),
			r.sort(e),
			(this._monthsRegex = new RegExp("^(" + r.join("|") + ")", "i")),
			(this._monthsShortRegex = this._monthsRegex),
			(this._monthsStrictRegex = new RegExp("^(" + n.join("|") + ")", "i")),
			(this._monthsShortStrictRegex = new RegExp("^(" + t.join("|") + ")", "i"))
	}
	function vne(e, t, n, r, i, a, o) {
		var s
		return (
			e < 100 && e >= 0
				? ((s = new Date(e + 400, t, n, r, i, a, o)), isFinite(s.getFullYear()) && s.setFullYear(e))
				: (s = new Date(e, t, n, r, i, a, o)),
			s
		)
	}
	function lv(e) {
		var t, n
		return (
			e < 100 && e >= 0
				? ((n = Array.prototype.slice.call(arguments)),
				  (n[0] = e + 400),
				  (t = new Date(Date.UTC.apply(null, n))),
				  isFinite(t.getUTCFullYear()) && t.setUTCFullYear(e))
				: (t = new Date(Date.UTC.apply(null, arguments))),
			t
		)
	}
	function F1(e, t, n) {
		var r = 7 + t - n,
			i = (7 + lv(e, 0, r).getUTCDay() - t) % 7
		return -i + r - 1
	}
	function jB(e, t, n, r, i) {
		var a = (7 + n - r) % 7,
			o = F1(e, r, i),
			s = 1 + 7 * (t - 1) + a + o,
			l,
			u
		return (
			s <= 0
				? ((l = e - 1), (u = Mm(l) + s))
				: s > Mm(e)
				? ((l = e + 1), (u = s - Mm(e)))
				: ((l = e), (u = s)),
			{ year: l, dayOfYear: u }
		)
	}
	function uv(e, t, n) {
		var r = F1(e.year(), t, n),
			i = Math.floor((e.dayOfYear() - r - 1) / 7) + 1,
			a,
			o
		return (
			i < 1
				? ((o = e.year() - 1), (a = i + ul(o, t, n)))
				: i > ul(e.year(), t, n)
				? ((a = i - ul(e.year(), t, n)), (o = e.year() + 1))
				: ((o = e.year()), (a = i)),
			{ week: a, year: o }
		)
	}
	function ul(e, t, n) {
		var r = F1(e, t, n),
			i = F1(e + 1, t, n)
		return (Mm(e) - r + i) / 7
	}
	rt("w", ["ww", 2], "wo", "week")
	rt("W", ["WW", 2], "Wo", "isoWeek")
	qe("w", Cn, Yp)
	qe("ww", Cn, Ta)
	qe("W", Cn, Yp)
	qe("WW", Cn, Ta)
	eg(["w", "ww", "W", "WW"], function (e, t, n, r) {
		t[r.substr(0, 1)] = Dt(e)
	})
	function gne(e) {
		return uv(e, this._week.dow, this._week.doy).week
	}
	var yne = { dow: 0, doy: 6 }
	function bne() {
		return this._week.dow
	}
	function xne() {
		return this._week.doy
	}
	function wne(e) {
		var t = this.localeData().week(this)
		return e == null ? t : this.add((e - t) * 7, "d")
	}
	function Ene(e) {
		var t = uv(this, 1, 4).week
		return e == null ? t : this.add((e - t) * 7, "d")
	}
	rt("d", 0, "do", "day")
	rt("dd", 0, 0, function (e) {
		return this.localeData().weekdaysMin(this, e)
	})
	rt("ddd", 0, 0, function (e) {
		return this.localeData().weekdaysShort(this, e)
	})
	rt("dddd", 0, 0, function (e) {
		return this.localeData().weekdays(this, e)
	})
	rt("e", 0, 0, "weekday")
	rt("E", 0, 0, "isoWeekday")
	qe("d", Cn)
	qe("e", Cn)
	qe("E", Cn)
	qe("dd", function (e, t) {
		return t.weekdaysMinRegex(e)
	})
	qe("ddd", function (e, t) {
		return t.weekdaysShortRegex(e)
	})
	qe("dddd", function (e, t) {
		return t.weekdaysRegex(e)
	})
	eg(["dd", "ddd", "dddd"], function (e, t, n, r) {
		var i = n._locale.weekdaysParse(e, r, n._strict)
		i != null ? (t.d = i) : (bt(n).invalidWeekday = e)
	})
	eg(["d", "e", "E"], function (e, t, n, r) {
		t[r] = Dt(e)
	})
	function Cne(e, t) {
		return typeof e != "string"
			? e
			: isNaN(e)
			? ((e = t.weekdaysParse(e)), typeof e == "number" ? e : null)
			: parseInt(e, 10)
	}
	function Tne(e, t) {
		return typeof e == "string" ? t.weekdaysParse(e) % 7 || 7 : isNaN(e) ? null : e
	}
	function h_(e, t) {
		return e.slice(t, 7).concat(e.slice(0, t))
	}
	var kne = "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
		FB = "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),
		Sne = "Su_Mo_Tu_We_Th_Fr_Sa".split("_"),
		Dne = Zv,
		_ne = Zv,
		One = Zv
	function Ane(e, t) {
		var n = Do(this._weekdays)
			? this._weekdays
			: this._weekdays[e && e !== !0 && this._weekdays.isFormat.test(t) ? "format" : "standalone"]
		return e === !0 ? h_(n, this._week.dow) : e ? n[e.day()] : n
	}
	function Nne(e) {
		return e === !0
			? h_(this._weekdaysShort, this._week.dow)
			: e
			? this._weekdaysShort[e.day()]
			: this._weekdaysShort
	}
	function Mne(e) {
		return e === !0
			? h_(this._weekdaysMin, this._week.dow)
			: e
			? this._weekdaysMin[e.day()]
			: this._weekdaysMin
	}
	function Ine(e, t, n) {
		var r,
			i,
			a,
			o = e.toLocaleLowerCase()
		if (!this._weekdaysParse)
			for (
				this._weekdaysParse = [], this._shortWeekdaysParse = [], this._minWeekdaysParse = [], r = 0;
				r < 7;
				++r
			)
				(a = Cs([2e3, 1]).day(r)),
					(this._minWeekdaysParse[r] = this.weekdaysMin(a, "").toLocaleLowerCase()),
					(this._shortWeekdaysParse[r] = this.weekdaysShort(a, "").toLocaleLowerCase()),
					(this._weekdaysParse[r] = this.weekdays(a, "").toLocaleLowerCase())
		return n
			? t === "dddd"
				? ((i = Qn.call(this._weekdaysParse, o)), i !== -1 ? i : null)
				: t === "ddd"
				? ((i = Qn.call(this._shortWeekdaysParse, o)), i !== -1 ? i : null)
				: ((i = Qn.call(this._minWeekdaysParse, o)), i !== -1 ? i : null)
			: t === "dddd"
			? ((i = Qn.call(this._weekdaysParse, o)),
			  i !== -1 || ((i = Qn.call(this._shortWeekdaysParse, o)), i !== -1)
					? i
					: ((i = Qn.call(this._minWeekdaysParse, o)), i !== -1 ? i : null))
			: t === "ddd"
			? ((i = Qn.call(this._shortWeekdaysParse, o)),
			  i !== -1 || ((i = Qn.call(this._weekdaysParse, o)), i !== -1)
					? i
					: ((i = Qn.call(this._minWeekdaysParse, o)), i !== -1 ? i : null))
			: ((i = Qn.call(this._minWeekdaysParse, o)),
			  i !== -1 || ((i = Qn.call(this._weekdaysParse, o)), i !== -1)
					? i
					: ((i = Qn.call(this._shortWeekdaysParse, o)), i !== -1 ? i : null))
	}
	function Rne(e, t, n) {
		var r, i, a
		if (this._weekdaysParseExact) return Ine.call(this, e, t, n)
		for (
			this._weekdaysParse ||
				((this._weekdaysParse = []),
				(this._minWeekdaysParse = []),
				(this._shortWeekdaysParse = []),
				(this._fullWeekdaysParse = [])),
				r = 0;
			r < 7;
			r++
		) {
			if (
				((i = Cs([2e3, 1]).day(r)),
				n &&
					!this._fullWeekdaysParse[r] &&
					((this._fullWeekdaysParse[r] = new RegExp(
						"^" + this.weekdays(i, "").replace(".", "\\.?") + "$",
						"i",
					)),
					(this._shortWeekdaysParse[r] = new RegExp(
						"^" + this.weekdaysShort(i, "").replace(".", "\\.?") + "$",
						"i",
					)),
					(this._minWeekdaysParse[r] = new RegExp(
						"^" + this.weekdaysMin(i, "").replace(".", "\\.?") + "$",
						"i",
					))),
				this._weekdaysParse[r] ||
					((a =
						"^" +
						this.weekdays(i, "") +
						"|^" +
						this.weekdaysShort(i, "") +
						"|^" +
						this.weekdaysMin(i, "")),
					(this._weekdaysParse[r] = new RegExp(a.replace(".", ""), "i"))),
				n && t === "dddd" && this._fullWeekdaysParse[r].test(e))
			)
				return r
			if (n && t === "ddd" && this._shortWeekdaysParse[r].test(e)) return r
			if (n && t === "dd" && this._minWeekdaysParse[r].test(e)) return r
			if (!n && this._weekdaysParse[r].test(e)) return r
		}
	}
	function Lne(e) {
		if (!this.isValid()) return e != null ? this : NaN
		var t = sv(this, "Day")
		return e != null ? ((e = Cne(e, this.localeData())), this.add(e - t, "d")) : t
	}
	function Pne(e) {
		if (!this.isValid()) return e != null ? this : NaN
		var t = (this.day() + 7 - this.localeData()._week.dow) % 7
		return e == null ? t : this.add(e - t, "d")
	}
	function jne(e) {
		if (!this.isValid()) return e != null ? this : NaN
		if (e != null) {
			var t = Tne(e, this.localeData())
			return this.day(this.day() % 7 ? t : t - 7)
		} else return this.day() || 7
	}
	function Fne(e) {
		return this._weekdaysParseExact
			? (zt(this, "_weekdaysRegex") || m_.call(this),
			  e ? this._weekdaysStrictRegex : this._weekdaysRegex)
			: (zt(this, "_weekdaysRegex") || (this._weekdaysRegex = Dne),
			  this._weekdaysStrictRegex && e ? this._weekdaysStrictRegex : this._weekdaysRegex)
	}
	function Bne(e) {
		return this._weekdaysParseExact
			? (zt(this, "_weekdaysRegex") || m_.call(this),
			  e ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex)
			: (zt(this, "_weekdaysShortRegex") || (this._weekdaysShortRegex = _ne),
			  this._weekdaysShortStrictRegex && e
					? this._weekdaysShortStrictRegex
					: this._weekdaysShortRegex)
	}
	function Hne(e) {
		return this._weekdaysParseExact
			? (zt(this, "_weekdaysRegex") || m_.call(this),
			  e ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex)
			: (zt(this, "_weekdaysMinRegex") || (this._weekdaysMinRegex = One),
			  this._weekdaysMinStrictRegex && e ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex)
	}
	function m_() {
		function e(d, p) {
			return p.length - d.length
		}
		var t = [],
			n = [],
			r = [],
			i = [],
			a,
			o,
			s,
			l,
			u
		for (a = 0; a < 7; a++)
			(o = Cs([2e3, 1]).day(a)),
				(s = ll(this.weekdaysMin(o, ""))),
				(l = ll(this.weekdaysShort(o, ""))),
				(u = ll(this.weekdays(o, ""))),
				t.push(s),
				n.push(l),
				r.push(u),
				i.push(s),
				i.push(l),
				i.push(u)
		t.sort(e),
			n.sort(e),
			r.sort(e),
			i.sort(e),
			(this._weekdaysRegex = new RegExp("^(" + i.join("|") + ")", "i")),
			(this._weekdaysShortRegex = this._weekdaysRegex),
			(this._weekdaysMinRegex = this._weekdaysRegex),
			(this._weekdaysStrictRegex = new RegExp("^(" + r.join("|") + ")", "i")),
			(this._weekdaysShortStrictRegex = new RegExp("^(" + n.join("|") + ")", "i")),
			(this._weekdaysMinStrictRegex = new RegExp("^(" + t.join("|") + ")", "i"))
	}
	function v_() {
		return this.hours() % 12 || 12
	}
	function $ne() {
		return this.hours() || 24
	}
	rt("H", ["HH", 2], 0, "hour")
	rt("h", ["hh", 2], 0, v_)
	rt("k", ["kk", 2], 0, $ne)
	rt("hmm", 0, 0, function () {
		return "" + v_.apply(this) + ps(this.minutes(), 2)
	})
	rt("hmmss", 0, 0, function () {
		return "" + v_.apply(this) + ps(this.minutes(), 2) + ps(this.seconds(), 2)
	})
	rt("Hmm", 0, 0, function () {
		return "" + this.hours() + ps(this.minutes(), 2)
	})
	rt("Hmmss", 0, 0, function () {
		return "" + this.hours() + ps(this.minutes(), 2) + ps(this.seconds(), 2)
	})
	function BB(e, t) {
		rt(e, 0, 0, function () {
			return this.localeData().meridiem(this.hours(), this.minutes(), t)
		})
	}
	BB("a", !0)
	BB("A", !1)
	function HB(e, t) {
		return t._meridiemParse
	}
	qe("a", HB)
	qe("A", HB)
	qe("H", Cn, f_)
	qe("h", Cn, Yp)
	qe("k", Cn, Yp)
	qe("HH", Cn, Ta)
	qe("hh", Cn, Ta)
	qe("kk", Cn, Ta)
	qe("hmm", _B)
	qe("hmmss", OB)
	qe("Hmm", _B)
	qe("Hmmss", OB)
	an(["H", "HH"], gr)
	an(["k", "kk"], function (e, t, n) {
		var r = Dt(e)
		t[gr] = r === 24 ? 0 : r
	})
	an(["a", "A"], function (e, t, n) {
		;(n._isPm = n._locale.isPM(e)), (n._meridiem = e)
	})
	an(["h", "hh"], function (e, t, n) {
		;(t[gr] = Dt(e)), (bt(n).bigHour = !0)
	})
	an("hmm", function (e, t, n) {
		var r = e.length - 2
		;(t[gr] = Dt(e.substr(0, r))), (t[mo] = Dt(e.substr(r))), (bt(n).bigHour = !0)
	})
	an("hmmss", function (e, t, n) {
		var r = e.length - 4,
			i = e.length - 2
		;(t[gr] = Dt(e.substr(0, r))),
			(t[mo] = Dt(e.substr(r, 2))),
			(t[il] = Dt(e.substr(i))),
			(bt(n).bigHour = !0)
	})
	an("Hmm", function (e, t, n) {
		var r = e.length - 2
		;(t[gr] = Dt(e.substr(0, r))), (t[mo] = Dt(e.substr(r)))
	})
	an("Hmmss", function (e, t, n) {
		var r = e.length - 4,
			i = e.length - 2
		;(t[gr] = Dt(e.substr(0, r))), (t[mo] = Dt(e.substr(r, 2))), (t[il] = Dt(e.substr(i)))
	})
	function Une(e) {
		return (e + "").toLowerCase().charAt(0) === "p"
	}
	var zne = /[ap]\.?m?\.?/i,
		qne = Gp("Hours", !0)
	function Vne(e, t, n) {
		return e > 11 ? (n ? "pm" : "PM") : n ? "am" : "AM"
	}
	var $B = {
			calendar: Ite,
			longDateFormat: jte,
			invalidDate: Bte,
			ordinal: $te,
			dayOfMonthOrdinalParse: Ute,
			relativeTime: qte,
			months: one,
			monthsShort: MB,
			week: yne,
			weekdays: kne,
			weekdaysMin: Sne,
			weekdaysShort: FB,
			meridiemParse: zne,
		},
		Dn = {},
		Qh = {},
		cv
	function Wne(e, t) {
		var n,
			r = Math.min(e.length, t.length)
		for (n = 0; n < r; n += 1) if (e[n] !== t[n]) return n
		return r
	}
	function EL(e) {
		return e && e.toLowerCase().replace("_", "-")
	}
	function Yne(e) {
		for (var t = 0, n, r, i, a; t < e.length; ) {
			for (
				a = EL(e[t]).split("-"), n = a.length, r = EL(e[t + 1]), r = r ? r.split("-") : null;
				n > 0;

			) {
				if (((i = kx(a.slice(0, n).join("-"))), i)) return i
				if (r && r.length >= n && Wne(a, r) >= n - 1) break
				n--
			}
			t++
		}
		return cv
	}
	function Gne(e) {
		return !!(e && e.match("^[^/\\\\]*$"))
	}
	function kx(e) {
		var t = null,
			n
		if (Dn[e] === void 0 && typeof ei < "u" && ei && ei.exports && Gne(e))
			try {
				;(t = cv._abbr), (n = require), n("./locale/" + e), Eu(t)
			} catch {
				Dn[e] = null
			}
		return Dn[e]
	}
	function Eu(e, t) {
		var n
		return (
			e &&
				(Li(t) ? (n = Dl(e)) : (n = g_(e, t)),
				n
					? (cv = n)
					: typeof console < "u" &&
					  console.warn &&
					  console.warn("Locale " + e + " not found. Did you forget to load it?")),
			cv._abbr
		)
	}
	function g_(e, t) {
		if (t !== null) {
			var n,
				r = $B
			if (((t.abbr = e), Dn[e] != null))
				TB(
					"defineLocaleOverride",
					"use moment.updateLocale(localeName, config) to change an existing locale. moment.defineLocale(localeName, config) should only be used for creating a new locale See http://momentjs.com/guides/#/warnings/define-locale/ for more info.",
				),
					(r = Dn[e]._config)
			else if (t.parentLocale != null)
				if (Dn[t.parentLocale] != null) r = Dn[t.parentLocale]._config
				else if (((n = kx(t.parentLocale)), n != null)) r = n._config
				else
					return (
						Qh[t.parentLocale] || (Qh[t.parentLocale] = []),
						Qh[t.parentLocale].push({ name: e, config: t }),
						null
					)
			return (
				(Dn[e] = new s_(FS(r, t))),
				Qh[e] &&
					Qh[e].forEach(function (i) {
						g_(i.name, i.config)
					}),
				Eu(e),
				Dn[e]
			)
		} else return delete Dn[e], null
	}
	function Kne(e, t) {
		if (t != null) {
			var n,
				r,
				i = $B
			Dn[e] != null && Dn[e].parentLocale != null
				? Dn[e].set(FS(Dn[e]._config, t))
				: ((r = kx(e)),
				  r != null && (i = r._config),
				  (t = FS(i, t)),
				  r == null && (t.abbr = e),
				  (n = new s_(t)),
				  (n.parentLocale = Dn[e]),
				  (Dn[e] = n)),
				Eu(e)
		} else
			Dn[e] != null &&
				(Dn[e].parentLocale != null
					? ((Dn[e] = Dn[e].parentLocale), e === Eu() && Eu(e))
					: Dn[e] != null && delete Dn[e])
		return Dn[e]
	}
	function Dl(e) {
		var t
		if ((e && e._locale && e._locale._abbr && (e = e._locale._abbr), !e)) return cv
		if (!Do(e)) {
			if (((t = kx(e)), t)) return t
			e = [e]
		}
		return Yne(e)
	}
	function Qne() {
		return BS(Dn)
	}
	function y_(e) {
		var t,
			n = e._a
		return (
			n &&
				bt(e).overflow === -2 &&
				((t =
					n[rl] < 0 || n[rl] > 11
						? rl
						: n[Jo] < 1 || n[Jo] > p_(n[ti], n[rl])
						? Jo
						: n[gr] < 0 ||
						  n[gr] > 24 ||
						  (n[gr] === 24 && (n[mo] !== 0 || n[il] !== 0 || n[Pc] !== 0))
						? gr
						: n[mo] < 0 || n[mo] > 59
						? mo
						: n[il] < 0 || n[il] > 59
						? il
						: n[Pc] < 0 || n[Pc] > 999
						? Pc
						: -1),
				bt(e)._overflowDayOfYear && (t < ti || t > Jo) && (t = Jo),
				bt(e)._overflowWeeks && t === -1 && (t = ene),
				bt(e)._overflowWeekday && t === -1 && (t = tne),
				(bt(e).overflow = t)),
			e
		)
	}
	var Xne =
			/^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/,
		Jne =
			/^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d|))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/,
		Zne = /Z|[+-]\d\d(?::?\d\d)?/,
		q0 = [
			["YYYYYY-MM-DD", /[+-]\d{6}-\d\d-\d\d/],
			["YYYY-MM-DD", /\d{4}-\d\d-\d\d/],
			["GGGG-[W]WW-E", /\d{4}-W\d\d-\d/],
			["GGGG-[W]WW", /\d{4}-W\d\d/, !1],
			["YYYY-DDD", /\d{4}-\d{3}/],
			["YYYY-MM", /\d{4}-\d\d/, !1],
			["YYYYYYMMDD", /[+-]\d{10}/],
			["YYYYMMDD", /\d{8}/],
			["GGGG[W]WWE", /\d{4}W\d{3}/],
			["GGGG[W]WW", /\d{4}W\d{2}/, !1],
			["YYYYDDD", /\d{7}/],
			["YYYYMM", /\d{6}/, !1],
			["YYYY", /\d{4}/, !1],
		],
		ET = [
			["HH:mm:ss.SSSS", /\d\d:\d\d:\d\d\.\d+/],
			["HH:mm:ss,SSSS", /\d\d:\d\d:\d\d,\d+/],
			["HH:mm:ss", /\d\d:\d\d:\d\d/],
			["HH:mm", /\d\d:\d\d/],
			["HHmmss.SSSS", /\d\d\d\d\d\d\.\d+/],
			["HHmmss,SSSS", /\d\d\d\d\d\d,\d+/],
			["HHmmss", /\d\d\d\d\d\d/],
			["HHmm", /\d\d\d\d/],
			["HH", /\d\d/],
		],
		ere = /^\/?Date\((-?\d+)/i,
		tre =
			/^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/,
		nre = {
			UT: 0,
			GMT: 0,
			EDT: -4 * 60,
			EST: -5 * 60,
			CDT: -5 * 60,
			CST: -6 * 60,
			MDT: -6 * 60,
			MST: -7 * 60,
			PDT: -7 * 60,
			PST: -8 * 60,
		}
	function UB(e) {
		var t,
			n,
			r = e._i,
			i = Xne.exec(r) || Jne.exec(r),
			a,
			o,
			s,
			l,
			u = q0.length,
			d = ET.length
		if (i) {
			for (bt(e).iso = !0, t = 0, n = u; t < n; t++)
				if (q0[t][1].exec(i[1])) {
					;(o = q0[t][0]), (a = q0[t][2] !== !1)
					break
				}
			if (o == null) {
				e._isValid = !1
				return
			}
			if (i[3]) {
				for (t = 0, n = d; t < n; t++)
					if (ET[t][1].exec(i[3])) {
						s = (i[2] || " ") + ET[t][0]
						break
					}
				if (s == null) {
					e._isValid = !1
					return
				}
			}
			if (!a && s != null) {
				e._isValid = !1
				return
			}
			if (i[4])
				if (Zne.exec(i[4])) l = "Z"
				else {
					e._isValid = !1
					return
				}
			;(e._f = o + (s || "") + (l || "")), x_(e)
		} else e._isValid = !1
	}
	function rre(e, t, n, r, i, a) {
		var o = [ire(e), MB.indexOf(t), parseInt(n, 10), parseInt(r, 10), parseInt(i, 10)]
		return a && o.push(parseInt(a, 10)), o
	}
	function ire(e) {
		var t = parseInt(e, 10)
		return t <= 49 ? 2e3 + t : t <= 999 ? 1900 + t : t
	}
	function are(e) {
		return e
			.replace(/\([^()]*\)|[\n\t]/g, " ")
			.replace(/(\s\s+)/g, " ")
			.replace(/^\s\s*/, "")
			.replace(/\s\s*$/, "")
	}
	function ore(e, t, n) {
		if (e) {
			var r = FB.indexOf(e),
				i = new Date(t[0], t[1], t[2]).getDay()
			if (r !== i) return (bt(n).weekdayMismatch = !0), (n._isValid = !1), !1
		}
		return !0
	}
	function sre(e, t, n) {
		if (e) return nre[e]
		if (t) return 0
		var r = parseInt(n, 10),
			i = r % 100,
			a = (r - i) / 100
		return a * 60 + i
	}
	function zB(e) {
		var t = tre.exec(are(e._i)),
			n
		if (t) {
			if (((n = rre(t[4], t[3], t[2], t[5], t[6], t[7])), !ore(t[1], n, e))) return
			;(e._a = n),
				(e._tzm = sre(t[8], t[9], t[10])),
				(e._d = lv.apply(null, e._a)),
				e._d.setUTCMinutes(e._d.getUTCMinutes() - e._tzm),
				(bt(e).rfc2822 = !0)
		} else e._isValid = !1
	}
	function lre(e) {
		var t = ere.exec(e._i)
		if (t !== null) {
			e._d = new Date(+t[1])
			return
		}
		if ((UB(e), e._isValid === !1)) delete e._isValid
		else return
		if ((zB(e), e._isValid === !1)) delete e._isValid
		else return
		e._strict ? (e._isValid = !1) : Te.createFromInputFallback(e)
	}
	Te.createFromInputFallback = Ja(
		"value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are discouraged. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.",
		function (e) {
			e._d = new Date(e._i + (e._useUTC ? " UTC" : ""))
		},
	)
	function Df(e, t, n) {
		return e ?? t ?? n
	}
	function ure(e) {
		var t = new Date(Te.now())
		return e._useUTC
			? [t.getUTCFullYear(), t.getUTCMonth(), t.getUTCDate()]
			: [t.getFullYear(), t.getMonth(), t.getDate()]
	}
	function b_(e) {
		var t,
			n,
			r = [],
			i,
			a,
			o
		if (!e._d) {
			for (
				i = ure(e),
					e._w && e._a[Jo] == null && e._a[rl] == null && cre(e),
					e._dayOfYear != null &&
						((o = Df(e._a[ti], i[ti])),
						(e._dayOfYear > Mm(o) || e._dayOfYear === 0) && (bt(e)._overflowDayOfYear = !0),
						(n = lv(o, 0, e._dayOfYear)),
						(e._a[rl] = n.getUTCMonth()),
						(e._a[Jo] = n.getUTCDate())),
					t = 0;
				t < 3 && e._a[t] == null;
				++t
			)
				e._a[t] = r[t] = i[t]
			for (; t < 7; t++) e._a[t] = r[t] = e._a[t] == null ? (t === 2 ? 1 : 0) : e._a[t]
			e._a[gr] === 24 &&
				e._a[mo] === 0 &&
				e._a[il] === 0 &&
				e._a[Pc] === 0 &&
				((e._nextDay = !0), (e._a[gr] = 0)),
				(e._d = (e._useUTC ? lv : vne).apply(null, r)),
				(a = e._useUTC ? e._d.getUTCDay() : e._d.getDay()),
				e._tzm != null && e._d.setUTCMinutes(e._d.getUTCMinutes() - e._tzm),
				e._nextDay && (e._a[gr] = 24),
				e._w && typeof e._w.d < "u" && e._w.d !== a && (bt(e).weekdayMismatch = !0)
		}
	}
	function cre(e) {
		var t, n, r, i, a, o, s, l, u
		;(t = e._w),
			t.GG != null || t.W != null || t.E != null
				? ((a = 1),
				  (o = 4),
				  (n = Df(t.GG, e._a[ti], uv(En(), 1, 4).year)),
				  (r = Df(t.W, 1)),
				  (i = Df(t.E, 1)),
				  (i < 1 || i > 7) && (l = !0))
				: ((a = e._locale._week.dow),
				  (o = e._locale._week.doy),
				  (u = uv(En(), a, o)),
				  (n = Df(t.gg, e._a[ti], u.year)),
				  (r = Df(t.w, u.week)),
				  t.d != null
						? ((i = t.d), (i < 0 || i > 6) && (l = !0))
						: t.e != null
						? ((i = t.e + a), (t.e < 0 || t.e > 6) && (l = !0))
						: (i = a)),
			r < 1 || r > ul(n, a, o)
				? (bt(e)._overflowWeeks = !0)
				: l != null
				? (bt(e)._overflowWeekday = !0)
				: ((s = jB(n, r, i, a, o)), (e._a[ti] = s.year), (e._dayOfYear = s.dayOfYear))
	}
	Te.ISO_8601 = function () {}
	Te.RFC_2822 = function () {}
	function x_(e) {
		if (e._f === Te.ISO_8601) {
			UB(e)
			return
		}
		if (e._f === Te.RFC_2822) {
			zB(e)
			return
		}
		;(e._a = []), (bt(e).empty = !0)
		var t = "" + e._i,
			n,
			r,
			i,
			a,
			o,
			s = t.length,
			l = 0,
			u,
			d
		for (i = kB(e._f, e._locale).match(l_) || [], d = i.length, n = 0; n < d; n++)
			(a = i[n]),
				(r = (t.match(Xte(a, e)) || [])[0]),
				r &&
					((o = t.substr(0, t.indexOf(r))),
					o.length > 0 && bt(e).unusedInput.push(o),
					(t = t.slice(t.indexOf(r) + r.length)),
					(l += r.length)),
				zf[a]
					? (r ? (bt(e).empty = !1) : bt(e).unusedTokens.push(a), Zte(a, r, e))
					: e._strict && !r && bt(e).unusedTokens.push(a)
		;(bt(e).charsLeftOver = s - l),
			t.length > 0 && bt(e).unusedInput.push(t),
			e._a[gr] <= 12 && bt(e).bigHour === !0 && e._a[gr] > 0 && (bt(e).bigHour = void 0),
			(bt(e).parsedDateParts = e._a.slice(0)),
			(bt(e).meridiem = e._meridiem),
			(e._a[gr] = dre(e._locale, e._a[gr], e._meridiem)),
			(u = bt(e).era),
			u !== null && (e._a[ti] = e._locale.erasConvertYear(u, e._a[ti])),
			b_(e),
			y_(e)
	}
	function dre(e, t, n) {
		var r
		return n == null
			? t
			: e.meridiemHour != null
			? e.meridiemHour(t, n)
			: (e.isPM != null && ((r = e.isPM(n)), r && t < 12 && (t += 12), !r && t === 12 && (t = 0)),
			  t)
	}
	function fre(e) {
		var t,
			n,
			r,
			i,
			a,
			o,
			s = !1,
			l = e._f.length
		if (l === 0) {
			;(bt(e).invalidFormat = !0), (e._d = new Date(NaN))
			return
		}
		for (i = 0; i < l; i++)
			(a = 0),
				(o = !1),
				(t = o_({}, e)),
				e._useUTC != null && (t._useUTC = e._useUTC),
				(t._f = e._f[i]),
				x_(t),
				a_(t) && (o = !0),
				(a += bt(t).charsLeftOver),
				(a += bt(t).unusedTokens.length * 10),
				(bt(t).score = a),
				s
					? a < r && ((r = a), (n = t))
					: (r == null || a < r || o) && ((r = a), (n = t), o && (s = !0))
		gu(e, n || t)
	}
	function pre(e) {
		if (!e._d) {
			var t = u_(e._i),
				n = t.day === void 0 ? t.date : t.day
			;(e._a = EB([t.year, t.month, n, t.hour, t.minute, t.second, t.millisecond], function (r) {
				return r && parseInt(r, 10)
			})),
				b_(e)
		}
	}
	function hre(e) {
		var t = new Jv(y_(qB(e)))
		return t._nextDay && (t.add(1, "d"), (t._nextDay = void 0)), t
	}
	function qB(e) {
		var t = e._i,
			n = e._f
		return (
			(e._locale = e._locale || Dl(e._l)),
			t === null || (n === void 0 && t === "")
				? yx({ nullInput: !0 })
				: (typeof t == "string" && (e._i = t = e._locale.preparse(t)),
				  _o(t)
						? new Jv(y_(t))
						: (Xv(t) ? (e._d = t) : Do(n) ? fre(e) : n ? x_(e) : mre(e), a_(e) || (e._d = null), e))
		)
	}
	function mre(e) {
		var t = e._i
		Li(t)
			? (e._d = new Date(Te.now()))
			: Xv(t)
			? (e._d = new Date(t.valueOf()))
			: typeof t == "string"
			? lre(e)
			: Do(t)
			? ((e._a = EB(t.slice(0), function (n) {
					return parseInt(n, 10)
			  })),
			  b_(e))
			: qc(t)
			? pre(e)
			: bl(t)
			? (e._d = new Date(t))
			: Te.createFromInputFallback(e)
	}
	function VB(e, t, n, r, i) {
		var a = {}
		return (
			(t === !0 || t === !1) && ((r = t), (t = void 0)),
			(n === !0 || n === !1) && ((r = n), (n = void 0)),
			((qc(e) && i_(e)) || (Do(e) && e.length === 0)) && (e = void 0),
			(a._isAMomentObject = !0),
			(a._useUTC = a._isUTC = i),
			(a._l = n),
			(a._i = e),
			(a._f = t),
			(a._strict = r),
			hre(a)
		)
	}
	function En(e, t, n, r) {
		return VB(e, t, n, r, !1)
	}
	var vre = Ja(
			"moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/",
			function () {
				var e = En.apply(null, arguments)
				return this.isValid() && e.isValid() ? (e < this ? this : e) : yx()
			},
		),
		gre = Ja(
			"moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/",
			function () {
				var e = En.apply(null, arguments)
				return this.isValid() && e.isValid() ? (e > this ? this : e) : yx()
			},
		)
	function WB(e, t) {
		var n, r
		if ((t.length === 1 && Do(t[0]) && (t = t[0]), !t.length)) return En()
		for (n = t[0], r = 1; r < t.length; ++r) (!t[r].isValid() || t[r][e](n)) && (n = t[r])
		return n
	}
	function yre() {
		var e = [].slice.call(arguments, 0)
		return WB("isBefore", e)
	}
	function bre() {
		var e = [].slice.call(arguments, 0)
		return WB("isAfter", e)
	}
	var xre = function () {
			return Date.now ? Date.now() : +new Date()
		},
		Xh = ["year", "quarter", "month", "week", "day", "hour", "minute", "second", "millisecond"]
	function wre(e) {
		var t,
			n = !1,
			r,
			i = Xh.length
		for (t in e)
			if (zt(e, t) && !(Qn.call(Xh, t) !== -1 && (e[t] == null || !isNaN(e[t])))) return !1
		for (r = 0; r < i; ++r)
			if (e[Xh[r]]) {
				if (n) return !1
				parseFloat(e[Xh[r]]) !== Dt(e[Xh[r]]) && (n = !0)
			}
		return !0
	}
	function Ere() {
		return this._isValid
	}
	function Cre() {
		return Io(NaN)
	}
	function Sx(e) {
		var t = u_(e),
			n = t.year || 0,
			r = t.quarter || 0,
			i = t.month || 0,
			a = t.week || t.isoWeek || 0,
			o = t.day || 0,
			s = t.hour || 0,
			l = t.minute || 0,
			u = t.second || 0,
			d = t.millisecond || 0
		;(this._isValid = wre(t)),
			(this._milliseconds = +d + u * 1e3 + l * 6e4 + s * 1e3 * 60 * 60),
			(this._days = +o + a * 7),
			(this._months = +i + r * 3 + n * 12),
			(this._data = {}),
			(this._locale = Dl()),
			this._bubble()
	}
	function Jy(e) {
		return e instanceof Sx
	}
	function $S(e) {
		return e < 0 ? Math.round(-1 * e) * -1 : Math.round(e)
	}
	function Tre(e, t, n) {
		var r = Math.min(e.length, t.length),
			i = Math.abs(e.length - t.length),
			a = 0,
			o
		for (o = 0; o < r; o++) Dt(e[o]) !== Dt(t[o]) && a++
		return a + i
	}
	function YB(e, t) {
		rt(e, 0, 0, function () {
			var n = this.utcOffset(),
				r = "+"
			return n < 0 && ((n = -n), (r = "-")), r + ps(~~(n / 60), 2) + t + ps(~~n % 60, 2)
		})
	}
	YB("Z", ":")
	YB("ZZ", "")
	qe("Z", Cx)
	qe("ZZ", Cx)
	an(["Z", "ZZ"], function (e, t, n) {
		;(n._useUTC = !0), (n._tzm = w_(Cx, e))
	})
	var kre = /([\+\-]|\d\d)/gi
	function w_(e, t) {
		var n = (t || "").match(e),
			r,
			i,
			a
		return n === null
			? null
			: ((r = n[n.length - 1] || []),
			  (i = (r + "").match(kre) || ["-", 0, 0]),
			  (a = +(i[1] * 60) + Dt(i[2])),
			  a === 0 ? 0 : i[0] === "+" ? a : -a)
	}
	function E_(e, t) {
		var n, r
		return t._isUTC
			? ((n = t.clone()),
			  (r = (_o(e) || Xv(e) ? e.valueOf() : En(e).valueOf()) - n.valueOf()),
			  n._d.setTime(n._d.valueOf() + r),
			  Te.updateOffset(n, !1),
			  n)
			: En(e).local()
	}
	function US(e) {
		return -Math.round(e._d.getTimezoneOffset())
	}
	Te.updateOffset = function () {}
	function Sre(e, t, n) {
		var r = this._offset || 0,
			i
		if (!this.isValid()) return e != null ? this : NaN
		if (e != null) {
			if (typeof e == "string") {
				if (((e = w_(Cx, e)), e === null)) return this
			} else Math.abs(e) < 16 && !n && (e = e * 60)
			return (
				!this._isUTC && t && (i = US(this)),
				(this._offset = e),
				(this._isUTC = !0),
				i != null && this.add(i, "m"),
				r !== e &&
					(!t || this._changeInProgress
						? QB(this, Io(e - r, "m"), 1, !1)
						: this._changeInProgress ||
						  ((this._changeInProgress = !0),
						  Te.updateOffset(this, !0),
						  (this._changeInProgress = null))),
				this
			)
		} else return this._isUTC ? r : US(this)
	}
	function Dre(e, t) {
		return e != null
			? (typeof e != "string" && (e = -e), this.utcOffset(e, t), this)
			: -this.utcOffset()
	}
	function _re(e) {
		return this.utcOffset(0, e)
	}
	function Ore(e) {
		return (
			this._isUTC && (this.utcOffset(0, e), (this._isUTC = !1), e && this.subtract(US(this), "m")),
			this
		)
	}
	function Are() {
		if (this._tzm != null) this.utcOffset(this._tzm, !1, !0)
		else if (typeof this._i == "string") {
			var e = w_(Kte, this._i)
			e != null ? this.utcOffset(e) : this.utcOffset(0, !0)
		}
		return this
	}
	function Nre(e) {
		return this.isValid()
			? ((e = e ? En(e).utcOffset() : 0), (this.utcOffset() - e) % 60 === 0)
			: !1
	}
	function Mre() {
		return (
			this.utcOffset() > this.clone().month(0).utcOffset() ||
			this.utcOffset() > this.clone().month(5).utcOffset()
		)
	}
	function Ire() {
		if (!Li(this._isDSTShifted)) return this._isDSTShifted
		var e = {},
			t
		return (
			o_(e, this),
			(e = qB(e)),
			e._a
				? ((t = e._isUTC ? Cs(e._a) : En(e._a)),
				  (this._isDSTShifted = this.isValid() && Tre(e._a, t.toArray()) > 0))
				: (this._isDSTShifted = !1),
			this._isDSTShifted
		)
	}
	function Rre() {
		return this.isValid() ? !this._isUTC : !1
	}
	function Lre() {
		return this.isValid() ? this._isUTC : !1
	}
	function GB() {
		return this.isValid() ? this._isUTC && this._offset === 0 : !1
	}
	var Pre = /^(-|\+)?(?:(\d*)[. ])?(\d+):(\d+)(?::(\d+)(\.\d*)?)?$/,
		jre =
			/^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/
	function Io(e, t) {
		var n = e,
			r = null,
			i,
			a,
			o
		return (
			Jy(e)
				? (n = { ms: e._milliseconds, d: e._days, M: e._months })
				: bl(e) || !isNaN(+e)
				? ((n = {}), t ? (n[t] = +e) : (n.milliseconds = +e))
				: (r = Pre.exec(e))
				? ((i = r[1] === "-" ? -1 : 1),
				  (n = {
						y: 0,
						d: Dt(r[Jo]) * i,
						h: Dt(r[gr]) * i,
						m: Dt(r[mo]) * i,
						s: Dt(r[il]) * i,
						ms: Dt($S(r[Pc] * 1e3)) * i,
				  }))
				: (r = jre.exec(e))
				? ((i = r[1] === "-" ? -1 : 1),
				  (n = {
						y: xc(r[2], i),
						M: xc(r[3], i),
						w: xc(r[4], i),
						d: xc(r[5], i),
						h: xc(r[6], i),
						m: xc(r[7], i),
						s: xc(r[8], i),
				  }))
				: n == null
				? (n = {})
				: typeof n == "object" &&
				  ("from" in n || "to" in n) &&
				  ((o = Fre(En(n.from), En(n.to))), (n = {}), (n.ms = o.milliseconds), (n.M = o.months)),
			(a = new Sx(n)),
			Jy(e) && zt(e, "_locale") && (a._locale = e._locale),
			Jy(e) && zt(e, "_isValid") && (a._isValid = e._isValid),
			a
		)
	}
	Io.fn = Sx.prototype
	Io.invalid = Cre
	function xc(e, t) {
		var n = e && parseFloat(e.replace(",", "."))
		return (isNaN(n) ? 0 : n) * t
	}
	function CL(e, t) {
		var n = {}
		return (
			(n.months = t.month() - e.month() + (t.year() - e.year()) * 12),
			e.clone().add(n.months, "M").isAfter(t) && --n.months,
			(n.milliseconds = +t - +e.clone().add(n.months, "M")),
			n
		)
	}
	function Fre(e, t) {
		var n
		return e.isValid() && t.isValid()
			? ((t = E_(t, e)),
			  e.isBefore(t)
					? (n = CL(e, t))
					: ((n = CL(t, e)), (n.milliseconds = -n.milliseconds), (n.months = -n.months)),
			  n)
			: { milliseconds: 0, months: 0 }
	}
	function KB(e, t) {
		return function (n, r) {
			var i, a
			return (
				r !== null &&
					!isNaN(+r) &&
					(TB(
						t,
						"moment()." +
							t +
							"(period, number) is deprecated. Please use moment()." +
							t +
							"(number, period). See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.",
					),
					(a = n),
					(n = r),
					(r = a)),
				(i = Io(n, r)),
				QB(this, i, e),
				this
			)
		}
	}
	function QB(e, t, n, r) {
		var i = t._milliseconds,
			a = $S(t._days),
			o = $S(t._months)
		e.isValid() &&
			((r = r ?? !0),
			o && RB(e, sv(e, "Month") + o * n),
			a && NB(e, "Date", sv(e, "Date") + a * n),
			i && e._d.setTime(e._d.valueOf() + i * n),
			r && Te.updateOffset(e, a || o))
	}
	var Bre = KB(1, "add"),
		Hre = KB(-1, "subtract")
	function XB(e) {
		return typeof e == "string" || e instanceof String
	}
	function $re(e) {
		return _o(e) || Xv(e) || XB(e) || bl(e) || zre(e) || Ure(e) || e === null || e === void 0
	}
	function Ure(e) {
		var t = qc(e) && !i_(e),
			n = !1,
			r = [
				"years",
				"year",
				"y",
				"months",
				"month",
				"M",
				"days",
				"day",
				"d",
				"dates",
				"date",
				"D",
				"hours",
				"hour",
				"h",
				"minutes",
				"minute",
				"m",
				"seconds",
				"second",
				"s",
				"milliseconds",
				"millisecond",
				"ms",
			],
			i,
			a,
			o = r.length
		for (i = 0; i < o; i += 1) (a = r[i]), (n = n || zt(e, a))
		return t && n
	}
	function zre(e) {
		var t = Do(e),
			n = !1
		return (
			t &&
				(n =
					e.filter(function (r) {
						return !bl(r) && XB(e)
					}).length === 0),
			t && n
		)
	}
	function qre(e) {
		var t = qc(e) && !i_(e),
			n = !1,
			r = ["sameDay", "nextDay", "lastDay", "nextWeek", "lastWeek", "sameElse"],
			i,
			a
		for (i = 0; i < r.length; i += 1) (a = r[i]), (n = n || zt(e, a))
		return t && n
	}
	function Vre(e, t) {
		var n = e.diff(t, "days", !0)
		return n < -6
			? "sameElse"
			: n < -1
			? "lastWeek"
			: n < 0
			? "lastDay"
			: n < 1
			? "sameDay"
			: n < 2
			? "nextDay"
			: n < 7
			? "nextWeek"
			: "sameElse"
	}
	function Wre(e, t) {
		arguments.length === 1 &&
			(arguments[0]
				? $re(arguments[0])
					? ((e = arguments[0]), (t = void 0))
					: qre(arguments[0]) && ((t = arguments[0]), (e = void 0))
				: ((e = void 0), (t = void 0)))
		var n = e || En(),
			r = E_(n, this).startOf("day"),
			i = Te.calendarFormat(this, r) || "sameElse",
			a = t && (Ts(t[i]) ? t[i].call(this, n) : t[i])
		return this.format(a || this.localeData().calendar(i, this, En(n)))
	}
	function Yre() {
		return new Jv(this)
	}
	function Gre(e, t) {
		var n = _o(e) ? e : En(e)
		return this.isValid() && n.isValid()
			? ((t = Za(t) || "millisecond"),
			  t === "millisecond"
					? this.valueOf() > n.valueOf()
					: n.valueOf() < this.clone().startOf(t).valueOf())
			: !1
	}
	function Kre(e, t) {
		var n = _o(e) ? e : En(e)
		return this.isValid() && n.isValid()
			? ((t = Za(t) || "millisecond"),
			  t === "millisecond"
					? this.valueOf() < n.valueOf()
					: this.clone().endOf(t).valueOf() < n.valueOf())
			: !1
	}
	function Qre(e, t, n, r) {
		var i = _o(e) ? e : En(e),
			a = _o(t) ? t : En(t)
		return this.isValid() && i.isValid() && a.isValid()
			? ((r = r || "()"),
			  (r[0] === "(" ? this.isAfter(i, n) : !this.isBefore(i, n)) &&
					(r[1] === ")" ? this.isBefore(a, n) : !this.isAfter(a, n)))
			: !1
	}
	function Xre(e, t) {
		var n = _o(e) ? e : En(e),
			r
		return this.isValid() && n.isValid()
			? ((t = Za(t) || "millisecond"),
			  t === "millisecond"
					? this.valueOf() === n.valueOf()
					: ((r = n.valueOf()),
					  this.clone().startOf(t).valueOf() <= r && r <= this.clone().endOf(t).valueOf()))
			: !1
	}
	function Jre(e, t) {
		return this.isSame(e, t) || this.isAfter(e, t)
	}
	function Zre(e, t) {
		return this.isSame(e, t) || this.isBefore(e, t)
	}
	function eie(e, t, n) {
		var r, i, a
		if (!this.isValid()) return NaN
		if (((r = E_(e, this)), !r.isValid())) return NaN
		switch (((i = (r.utcOffset() - this.utcOffset()) * 6e4), (t = Za(t)), t)) {
			case "year":
				a = Zy(this, r) / 12
				break
			case "month":
				a = Zy(this, r)
				break
			case "quarter":
				a = Zy(this, r) / 3
				break
			case "second":
				a = (this - r) / 1e3
				break
			case "minute":
				a = (this - r) / 6e4
				break
			case "hour":
				a = (this - r) / 36e5
				break
			case "day":
				a = (this - r - i) / 864e5
				break
			case "week":
				a = (this - r - i) / 6048e5
				break
			default:
				a = this - r
		}
		return n ? a : ja(a)
	}
	function Zy(e, t) {
		if (e.date() < t.date()) return -Zy(t, e)
		var n = (t.year() - e.year()) * 12 + (t.month() - e.month()),
			r = e.clone().add(n, "months"),
			i,
			a
		return (
			t - r < 0
				? ((i = e.clone().add(n - 1, "months")), (a = (t - r) / (r - i)))
				: ((i = e.clone().add(n + 1, "months")), (a = (t - r) / (i - r))),
			-(n + a) || 0
		)
	}
	Te.defaultFormat = "YYYY-MM-DDTHH:mm:ssZ"
	Te.defaultFormatUtc = "YYYY-MM-DDTHH:mm:ss[Z]"
	function tie() {
		return this.clone().locale("en").format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ")
	}
	function nie(e) {
		if (!this.isValid()) return null
		var t = e !== !0,
			n = t ? this.clone().utc() : this
		return n.year() < 0 || n.year() > 9999
			? Xy(n, t ? "YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYYYY-MM-DD[T]HH:mm:ss.SSSZ")
			: Ts(Date.prototype.toISOString)
			? t
				? this.toDate().toISOString()
				: new Date(this.valueOf() + this.utcOffset() * 60 * 1e3)
						.toISOString()
						.replace("Z", Xy(n, "Z"))
			: Xy(n, t ? "YYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYY-MM-DD[T]HH:mm:ss.SSSZ")
	}
	function rie() {
		if (!this.isValid()) return "moment.invalid(/* " + this._i + " */)"
		var e = "moment",
			t = "",
			n,
			r,
			i,
			a
		return (
			this.isLocal() ||
				((e = this.utcOffset() === 0 ? "moment.utc" : "moment.parseZone"), (t = "Z")),
			(n = "[" + e + '("]'),
			(r = 0 <= this.year() && this.year() <= 9999 ? "YYYY" : "YYYYYY"),
			(i = "-MM-DD[T]HH:mm:ss.SSS"),
			(a = t + '[")]'),
			this.format(n + r + i + a)
		)
	}
	function iie(e) {
		e || (e = this.isUtc() ? Te.defaultFormatUtc : Te.defaultFormat)
		var t = Xy(this, e)
		return this.localeData().postformat(t)
	}
	function aie(e, t) {
		return this.isValid() && ((_o(e) && e.isValid()) || En(e).isValid())
			? Io({ to: this, from: e }).locale(this.locale()).humanize(!t)
			: this.localeData().invalidDate()
	}
	function oie(e) {
		return this.from(En(), e)
	}
	function sie(e, t) {
		return this.isValid() && ((_o(e) && e.isValid()) || En(e).isValid())
			? Io({ from: this, to: e }).locale(this.locale()).humanize(!t)
			: this.localeData().invalidDate()
	}
	function lie(e) {
		return this.to(En(), e)
	}
	function JB(e) {
		var t
		return e === void 0 ? this._locale._abbr : ((t = Dl(e)), t != null && (this._locale = t), this)
	}
	var ZB = Ja(
		"moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.",
		function (e) {
			return e === void 0 ? this.localeData() : this.locale(e)
		},
	)
	function e9() {
		return this._locale
	}
	var B1 = 1e3,
		qf = 60 * B1,
		H1 = 60 * qf,
		t9 = (365 * 400 + 97) * 24 * H1
	function Vf(e, t) {
		return ((e % t) + t) % t
	}
	function n9(e, t, n) {
		return e < 100 && e >= 0 ? new Date(e + 400, t, n) - t9 : new Date(e, t, n).valueOf()
	}
	function r9(e, t, n) {
		return e < 100 && e >= 0 ? Date.UTC(e + 400, t, n) - t9 : Date.UTC(e, t, n)
	}
	function uie(e) {
		var t, n
		if (((e = Za(e)), e === void 0 || e === "millisecond" || !this.isValid())) return this
		switch (((n = this._isUTC ? r9 : n9), e)) {
			case "year":
				t = n(this.year(), 0, 1)
				break
			case "quarter":
				t = n(this.year(), this.month() - (this.month() % 3), 1)
				break
			case "month":
				t = n(this.year(), this.month(), 1)
				break
			case "week":
				t = n(this.year(), this.month(), this.date() - this.weekday())
				break
			case "isoWeek":
				t = n(this.year(), this.month(), this.date() - (this.isoWeekday() - 1))
				break
			case "day":
			case "date":
				t = n(this.year(), this.month(), this.date())
				break
			case "hour":
				;(t = this._d.valueOf()), (t -= Vf(t + (this._isUTC ? 0 : this.utcOffset() * qf), H1))
				break
			case "minute":
				;(t = this._d.valueOf()), (t -= Vf(t, qf))
				break
			case "second":
				;(t = this._d.valueOf()), (t -= Vf(t, B1))
				break
		}
		return this._d.setTime(t), Te.updateOffset(this, !0), this
	}
	function cie(e) {
		var t, n
		if (((e = Za(e)), e === void 0 || e === "millisecond" || !this.isValid())) return this
		switch (((n = this._isUTC ? r9 : n9), e)) {
			case "year":
				t = n(this.year() + 1, 0, 1) - 1
				break
			case "quarter":
				t = n(this.year(), this.month() - (this.month() % 3) + 3, 1) - 1
				break
			case "month":
				t = n(this.year(), this.month() + 1, 1) - 1
				break
			case "week":
				t = n(this.year(), this.month(), this.date() - this.weekday() + 7) - 1
				break
			case "isoWeek":
				t = n(this.year(), this.month(), this.date() - (this.isoWeekday() - 1) + 7) - 1
				break
			case "day":
			case "date":
				t = n(this.year(), this.month(), this.date() + 1) - 1
				break
			case "hour":
				;(t = this._d.valueOf()),
					(t += H1 - Vf(t + (this._isUTC ? 0 : this.utcOffset() * qf), H1) - 1)
				break
			case "minute":
				;(t = this._d.valueOf()), (t += qf - Vf(t, qf) - 1)
				break
			case "second":
				;(t = this._d.valueOf()), (t += B1 - Vf(t, B1) - 1)
				break
		}
		return this._d.setTime(t), Te.updateOffset(this, !0), this
	}
	function die() {
		return this._d.valueOf() - (this._offset || 0) * 6e4
	}
	function fie() {
		return Math.floor(this.valueOf() / 1e3)
	}
	function pie() {
		return new Date(this.valueOf())
	}
	function hie() {
		var e = this
		return [e.year(), e.month(), e.date(), e.hour(), e.minute(), e.second(), e.millisecond()]
	}
	function mie() {
		var e = this
		return {
			years: e.year(),
			months: e.month(),
			date: e.date(),
			hours: e.hours(),
			minutes: e.minutes(),
			seconds: e.seconds(),
			milliseconds: e.milliseconds(),
		}
	}
	function vie() {
		return this.isValid() ? this.toISOString() : null
	}
	function gie() {
		return a_(this)
	}
	function yie() {
		return gu({}, bt(this))
	}
	function bie() {
		return bt(this).overflow
	}
	function xie() {
		return {
			input: this._i,
			format: this._f,
			locale: this._locale,
			isUTC: this._isUTC,
			strict: this._strict,
		}
	}
	rt("N", 0, 0, "eraAbbr")
	rt("NN", 0, 0, "eraAbbr")
	rt("NNN", 0, 0, "eraAbbr")
	rt("NNNN", 0, 0, "eraName")
	rt("NNNNN", 0, 0, "eraNarrow")
	rt("y", ["y", 1], "yo", "eraYear")
	rt("y", ["yy", 2], 0, "eraYear")
	rt("y", ["yyy", 3], 0, "eraYear")
	rt("y", ["yyyy", 4], 0, "eraYear")
	qe("N", C_)
	qe("NN", C_)
	qe("NNN", C_)
	qe("NNNN", Nie)
	qe("NNNNN", Mie)
	an(["N", "NN", "NNN", "NNNN", "NNNNN"], function (e, t, n, r) {
		var i = n._locale.erasParse(e, r, n._strict)
		i ? (bt(n).era = i) : (bt(n).invalidEra = e)
	})
	qe("y", Wp)
	qe("yy", Wp)
	qe("yyy", Wp)
	qe("yyyy", Wp)
	qe("yo", Iie)
	an(["y", "yy", "yyy", "yyyy"], ti)
	an(["yo"], function (e, t, n, r) {
		var i
		n._locale._eraYearOrdinalRegex && (i = e.match(n._locale._eraYearOrdinalRegex)),
			n._locale.eraYearOrdinalParse
				? (t[ti] = n._locale.eraYearOrdinalParse(e, i))
				: (t[ti] = parseInt(e, 10))
	})
	function wie(e, t) {
		var n,
			r,
			i,
			a = this._eras || Dl("en")._eras
		for (n = 0, r = a.length; n < r; ++n) {
			switch (typeof a[n].since) {
				case "string":
					;(i = Te(a[n].since).startOf("day")), (a[n].since = i.valueOf())
					break
			}
			switch (typeof a[n].until) {
				case "undefined":
					a[n].until = 1 / 0
					break
				case "string":
					;(i = Te(a[n].until).startOf("day").valueOf()), (a[n].until = i.valueOf())
					break
			}
		}
		return a
	}
	function Eie(e, t, n) {
		var r,
			i,
			a = this.eras(),
			o,
			s,
			l
		for (e = e.toUpperCase(), r = 0, i = a.length; r < i; ++r)
			if (
				((o = a[r].name.toUpperCase()),
				(s = a[r].abbr.toUpperCase()),
				(l = a[r].narrow.toUpperCase()),
				n)
			)
				switch (t) {
					case "N":
					case "NN":
					case "NNN":
						if (s === e) return a[r]
						break
					case "NNNN":
						if (o === e) return a[r]
						break
					case "NNNNN":
						if (l === e) return a[r]
						break
				}
			else if ([o, s, l].indexOf(e) >= 0) return a[r]
	}
	function Cie(e, t) {
		var n = e.since <= e.until ? 1 : -1
		return t === void 0 ? Te(e.since).year() : Te(e.since).year() + (t - e.offset) * n
	}
	function Tie() {
		var e,
			t,
			n,
			r = this.localeData().eras()
		for (e = 0, t = r.length; e < t; ++e)
			if (
				((n = this.clone().startOf("day").valueOf()),
				(r[e].since <= n && n <= r[e].until) || (r[e].until <= n && n <= r[e].since))
			)
				return r[e].name
		return ""
	}
	function kie() {
		var e,
			t,
			n,
			r = this.localeData().eras()
		for (e = 0, t = r.length; e < t; ++e)
			if (
				((n = this.clone().startOf("day").valueOf()),
				(r[e].since <= n && n <= r[e].until) || (r[e].until <= n && n <= r[e].since))
			)
				return r[e].narrow
		return ""
	}
	function Sie() {
		var e,
			t,
			n,
			r = this.localeData().eras()
		for (e = 0, t = r.length; e < t; ++e)
			if (
				((n = this.clone().startOf("day").valueOf()),
				(r[e].since <= n && n <= r[e].until) || (r[e].until <= n && n <= r[e].since))
			)
				return r[e].abbr
		return ""
	}
	function Die() {
		var e,
			t,
			n,
			r,
			i = this.localeData().eras()
		for (e = 0, t = i.length; e < t; ++e)
			if (
				((n = i[e].since <= i[e].until ? 1 : -1),
				(r = this.clone().startOf("day").valueOf()),
				(i[e].since <= r && r <= i[e].until) || (i[e].until <= r && r <= i[e].since))
			)
				return (this.year() - Te(i[e].since).year()) * n + i[e].offset
		return this.year()
	}
	function _ie(e) {
		return zt(this, "_erasNameRegex") || T_.call(this), e ? this._erasNameRegex : this._erasRegex
	}
	function Oie(e) {
		return zt(this, "_erasAbbrRegex") || T_.call(this), e ? this._erasAbbrRegex : this._erasRegex
	}
	function Aie(e) {
		return (
			zt(this, "_erasNarrowRegex") || T_.call(this), e ? this._erasNarrowRegex : this._erasRegex
		)
	}
	function C_(e, t) {
		return t.erasAbbrRegex(e)
	}
	function Nie(e, t) {
		return t.erasNameRegex(e)
	}
	function Mie(e, t) {
		return t.erasNarrowRegex(e)
	}
	function Iie(e, t) {
		return t._eraYearOrdinalRegex || Wp
	}
	function T_() {
		var e = [],
			t = [],
			n = [],
			r = [],
			i,
			a,
			o,
			s,
			l,
			u = this.eras()
		for (i = 0, a = u.length; i < a; ++i)
			(o = ll(u[i].name)),
				(s = ll(u[i].abbr)),
				(l = ll(u[i].narrow)),
				t.push(o),
				e.push(s),
				n.push(l),
				r.push(o),
				r.push(s),
				r.push(l)
		;(this._erasRegex = new RegExp("^(" + r.join("|") + ")", "i")),
			(this._erasNameRegex = new RegExp("^(" + t.join("|") + ")", "i")),
			(this._erasAbbrRegex = new RegExp("^(" + e.join("|") + ")", "i")),
			(this._erasNarrowRegex = new RegExp("^(" + n.join("|") + ")", "i"))
	}
	rt(0, ["gg", 2], 0, function () {
		return this.weekYear() % 100
	})
	rt(0, ["GG", 2], 0, function () {
		return this.isoWeekYear() % 100
	})
	function Dx(e, t) {
		rt(0, [e, e.length], 0, t)
	}
	Dx("gggg", "weekYear")
	Dx("ggggg", "weekYear")
	Dx("GGGG", "isoWeekYear")
	Dx("GGGGG", "isoWeekYear")
	qe("G", Ex)
	qe("g", Ex)
	qe("GG", Cn, Ta)
	qe("gg", Cn, Ta)
	qe("GGGG", d_, c_)
	qe("gggg", d_, c_)
	qe("GGGGG", wx, bx)
	qe("ggggg", wx, bx)
	eg(["gggg", "ggggg", "GGGG", "GGGGG"], function (e, t, n, r) {
		t[r.substr(0, 2)] = Dt(e)
	})
	eg(["gg", "GG"], function (e, t, n, r) {
		t[r] = Te.parseTwoDigitYear(e)
	})
	function Rie(e) {
		return i9.call(
			this,
			e,
			this.week(),
			this.weekday() + this.localeData()._week.dow,
			this.localeData()._week.dow,
			this.localeData()._week.doy,
		)
	}
	function Lie(e) {
		return i9.call(this, e, this.isoWeek(), this.isoWeekday(), 1, 4)
	}
	function Pie() {
		return ul(this.year(), 1, 4)
	}
	function jie() {
		return ul(this.isoWeekYear(), 1, 4)
	}
	function Fie() {
		var e = this.localeData()._week
		return ul(this.year(), e.dow, e.doy)
	}
	function Bie() {
		var e = this.localeData()._week
		return ul(this.weekYear(), e.dow, e.doy)
	}
	function i9(e, t, n, r, i) {
		var a
		return e == null
			? uv(this, r, i).year
			: ((a = ul(e, r, i)), t > a && (t = a), Hie.call(this, e, t, n, r, i))
	}
	function Hie(e, t, n, r, i) {
		var a = jB(e, t, n, r, i),
			o = lv(a.year, 0, a.dayOfYear)
		return (
			this.year(o.getUTCFullYear()), this.month(o.getUTCMonth()), this.date(o.getUTCDate()), this
		)
	}
	rt("Q", 0, "Qo", "quarter")
	qe("Q", SB)
	an("Q", function (e, t) {
		t[rl] = (Dt(e) - 1) * 3
	})
	function $ie(e) {
		return e == null
			? Math.ceil((this.month() + 1) / 3)
			: this.month((e - 1) * 3 + (this.month() % 3))
	}
	rt("D", ["DD", 2], "Do", "date")
	qe("D", Cn, Yp)
	qe("DD", Cn, Ta)
	qe("Do", function (e, t) {
		return e ? t._dayOfMonthOrdinalParse || t._ordinalParse : t._dayOfMonthOrdinalParseLenient
	})
	an(["D", "DD"], Jo)
	an("Do", function (e, t) {
		t[Jo] = Dt(e.match(Cn)[0])
	})
	var a9 = Gp("Date", !0)
	rt("DDD", ["DDDD", 3], "DDDo", "dayOfYear")
	qe("DDD", xx)
	qe("DDDD", DB)
	an(["DDD", "DDDD"], function (e, t, n) {
		n._dayOfYear = Dt(e)
	})
	function Uie(e) {
		var t = Math.round((this.clone().startOf("day") - this.clone().startOf("year")) / 864e5) + 1
		return e == null ? t : this.add(e - t, "d")
	}
	rt("m", ["mm", 2], 0, "minute")
	qe("m", Cn, f_)
	qe("mm", Cn, Ta)
	an(["m", "mm"], mo)
	var zie = Gp("Minutes", !1)
	rt("s", ["ss", 2], 0, "second")
	qe("s", Cn, f_)
	qe("ss", Cn, Ta)
	an(["s", "ss"], il)
	var qie = Gp("Seconds", !1)
	rt("S", 0, 0, function () {
		return ~~(this.millisecond() / 100)
	})
	rt(0, ["SS", 2], 0, function () {
		return ~~(this.millisecond() / 10)
	})
	rt(0, ["SSS", 3], 0, "millisecond")
	rt(0, ["SSSS", 4], 0, function () {
		return this.millisecond() * 10
	})
	rt(0, ["SSSSS", 5], 0, function () {
		return this.millisecond() * 100
	})
	rt(0, ["SSSSSS", 6], 0, function () {
		return this.millisecond() * 1e3
	})
	rt(0, ["SSSSSSS", 7], 0, function () {
		return this.millisecond() * 1e4
	})
	rt(0, ["SSSSSSSS", 8], 0, function () {
		return this.millisecond() * 1e5
	})
	rt(0, ["SSSSSSSSS", 9], 0, function () {
		return this.millisecond() * 1e6
	})
	qe("S", xx, SB)
	qe("SS", xx, Ta)
	qe("SSS", xx, DB)
	var yu, o9
	for (yu = "SSSS"; yu.length <= 9; yu += "S") qe(yu, Wp)
	function Vie(e, t) {
		t[Pc] = Dt(("0." + e) * 1e3)
	}
	for (yu = "S"; yu.length <= 9; yu += "S") an(yu, Vie)
	o9 = Gp("Milliseconds", !1)
	rt("z", 0, 0, "zoneAbbr")
	rt("zz", 0, 0, "zoneName")
	function Wie() {
		return this._isUTC ? "UTC" : ""
	}
	function Yie() {
		return this._isUTC ? "Coordinated Universal Time" : ""
	}
	var Ae = Jv.prototype
	Ae.add = Bre
	Ae.calendar = Wre
	Ae.clone = Yre
	Ae.diff = eie
	Ae.endOf = cie
	Ae.format = iie
	Ae.from = aie
	Ae.fromNow = oie
	Ae.to = sie
	Ae.toNow = lie
	Ae.get = rne
	Ae.invalidAt = bie
	Ae.isAfter = Gre
	Ae.isBefore = Kre
	Ae.isBetween = Qre
	Ae.isSame = Xre
	Ae.isSameOrAfter = Jre
	Ae.isSameOrBefore = Zre
	Ae.isValid = gie
	Ae.lang = ZB
	Ae.locale = JB
	Ae.localeData = e9
	Ae.max = gre
	Ae.min = vre
	Ae.parsingFlags = yie
	Ae.set = ine
	Ae.startOf = uie
	Ae.subtract = Hre
	Ae.toArray = hie
	Ae.toObject = mie
	Ae.toDate = pie
	Ae.toISOString = nie
	Ae.inspect = rie
	typeof Symbol < "u" &&
		Symbol.for != null &&
		(Ae[Symbol.for("nodejs.util.inspect.custom")] = function () {
			return "Moment<" + this.format() + ">"
		})
	Ae.toJSON = vie
	Ae.toString = tie
	Ae.unix = fie
	Ae.valueOf = die
	Ae.creationData = xie
	Ae.eraName = Tie
	Ae.eraNarrow = kie
	Ae.eraAbbr = Sie
	Ae.eraYear = Die
	Ae.year = AB
	Ae.isLeapYear = nne
	Ae.weekYear = Rie
	Ae.isoWeekYear = Lie
	Ae.quarter = Ae.quarters = $ie
	Ae.month = LB
	Ae.daysInMonth = pne
	Ae.week = Ae.weeks = wne
	Ae.isoWeek = Ae.isoWeeks = Ene
	Ae.weeksInYear = Fie
	Ae.weeksInWeekYear = Bie
	Ae.isoWeeksInYear = Pie
	Ae.isoWeeksInISOWeekYear = jie
	Ae.date = a9
	Ae.day = Ae.days = Lne
	Ae.weekday = Pne
	Ae.isoWeekday = jne
	Ae.dayOfYear = Uie
	Ae.hour = Ae.hours = qne
	Ae.minute = Ae.minutes = zie
	Ae.second = Ae.seconds = qie
	Ae.millisecond = Ae.milliseconds = o9
	Ae.utcOffset = Sre
	Ae.utc = _re
	Ae.local = Ore
	Ae.parseZone = Are
	Ae.hasAlignedHourOffset = Nre
	Ae.isDST = Mre
	Ae.isLocal = Rre
	Ae.isUtcOffset = Lre
	Ae.isUtc = GB
	Ae.isUTC = GB
	Ae.zoneAbbr = Wie
	Ae.zoneName = Yie
	Ae.dates = Ja("dates accessor is deprecated. Use date instead.", a9)
	Ae.months = Ja("months accessor is deprecated. Use month instead", LB)
	Ae.years = Ja("years accessor is deprecated. Use year instead", AB)
	Ae.zone = Ja(
		"moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/",
		Dre,
	)
	Ae.isDSTShifted = Ja(
		"isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information",
		Ire,
	)
	function Gie(e) {
		return En(e * 1e3)
	}
	function Kie() {
		return En.apply(null, arguments).parseZone()
	}
	function s9(e) {
		return e
	}
	var qt = s_.prototype
	qt.calendar = Rte
	qt.longDateFormat = Fte
	qt.invalidDate = Hte
	qt.ordinal = zte
	qt.preparse = s9
	qt.postformat = s9
	qt.relativeTime = Vte
	qt.pastFuture = Wte
	qt.set = Mte
	qt.eras = wie
	qt.erasParse = Eie
	qt.erasConvertYear = Cie
	qt.erasAbbrRegex = Oie
	qt.erasNameRegex = _ie
	qt.erasNarrowRegex = Aie
	qt.months = une
	qt.monthsShort = cne
	qt.monthsParse = fne
	qt.monthsRegex = mne
	qt.monthsShortRegex = hne
	qt.week = gne
	qt.firstDayOfYear = xne
	qt.firstDayOfWeek = bne
	qt.weekdays = Ane
	qt.weekdaysMin = Mne
	qt.weekdaysShort = Nne
	qt.weekdaysParse = Rne
	qt.weekdaysRegex = Fne
	qt.weekdaysShortRegex = Bne
	qt.weekdaysMinRegex = Hne
	qt.isPM = Une
	qt.meridiem = Vne
	function $1(e, t, n, r) {
		var i = Dl(),
			a = Cs().set(r, t)
		return i[n](a, e)
	}
	function l9(e, t, n) {
		if ((bl(e) && ((t = e), (e = void 0)), (e = e || ""), t != null)) return $1(e, t, n, "month")
		var r,
			i = []
		for (r = 0; r < 12; r++) i[r] = $1(e, r, n, "month")
		return i
	}
	function k_(e, t, n, r) {
		typeof e == "boolean"
			? (bl(t) && ((n = t), (t = void 0)), (t = t || ""))
			: ((t = e), (n = t), (e = !1), bl(t) && ((n = t), (t = void 0)), (t = t || ""))
		var i = Dl(),
			a = e ? i._week.dow : 0,
			o,
			s = []
		if (n != null) return $1(t, (n + a) % 7, r, "day")
		for (o = 0; o < 7; o++) s[o] = $1(t, (o + a) % 7, r, "day")
		return s
	}
	function Qie(e, t) {
		return l9(e, t, "months")
	}
	function Xie(e, t) {
		return l9(e, t, "monthsShort")
	}
	function Jie(e, t, n) {
		return k_(e, t, n, "weekdays")
	}
	function Zie(e, t, n) {
		return k_(e, t, n, "weekdaysShort")
	}
	function eae(e, t, n) {
		return k_(e, t, n, "weekdaysMin")
	}
	Eu("en", {
		eras: [
			{
				since: "0001-01-01",
				until: 1 / 0,
				offset: 1,
				name: "Anno Domini",
				narrow: "AD",
				abbr: "AD",
			},
			{
				since: "0000-12-31",
				until: -1 / 0,
				offset: 1,
				name: "Before Christ",
				narrow: "BC",
				abbr: "BC",
			},
		],
		dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
		ordinal: function (e) {
			var t = e % 10,
				n =
					Dt((e % 100) / 10) === 1 ? "th" : t === 1 ? "st" : t === 2 ? "nd" : t === 3 ? "rd" : "th"
			return e + n
		},
	})
	Te.lang = Ja("moment.lang is deprecated. Use moment.locale instead.", Eu)
	Te.langData = Ja("moment.langData is deprecated. Use moment.localeData instead.", Dl)
	var zs = Math.abs
	function tae() {
		var e = this._data
		return (
			(this._milliseconds = zs(this._milliseconds)),
			(this._days = zs(this._days)),
			(this._months = zs(this._months)),
			(e.milliseconds = zs(e.milliseconds)),
			(e.seconds = zs(e.seconds)),
			(e.minutes = zs(e.minutes)),
			(e.hours = zs(e.hours)),
			(e.months = zs(e.months)),
			(e.years = zs(e.years)),
			this
		)
	}
	function u9(e, t, n, r) {
		var i = Io(t, n)
		return (
			(e._milliseconds += r * i._milliseconds),
			(e._days += r * i._days),
			(e._months += r * i._months),
			e._bubble()
		)
	}
	function nae(e, t) {
		return u9(this, e, t, 1)
	}
	function rae(e, t) {
		return u9(this, e, t, -1)
	}
	function TL(e) {
		return e < 0 ? Math.floor(e) : Math.ceil(e)
	}
	function iae() {
		var e = this._milliseconds,
			t = this._days,
			n = this._months,
			r = this._data,
			i,
			a,
			o,
			s,
			l
		return (
			(e >= 0 && t >= 0 && n >= 0) ||
				(e <= 0 && t <= 0 && n <= 0) ||
				((e += TL(zS(n) + t) * 864e5), (t = 0), (n = 0)),
			(r.milliseconds = e % 1e3),
			(i = ja(e / 1e3)),
			(r.seconds = i % 60),
			(a = ja(i / 60)),
			(r.minutes = a % 60),
			(o = ja(a / 60)),
			(r.hours = o % 24),
			(t += ja(o / 24)),
			(l = ja(c9(t))),
			(n += l),
			(t -= TL(zS(l))),
			(s = ja(n / 12)),
			(n %= 12),
			(r.days = t),
			(r.months = n),
			(r.years = s),
			this
		)
	}
	function c9(e) {
		return (e * 4800) / 146097
	}
	function zS(e) {
		return (e * 146097) / 4800
	}
	function aae(e) {
		if (!this.isValid()) return NaN
		var t,
			n,
			r = this._milliseconds
		if (((e = Za(e)), e === "month" || e === "quarter" || e === "year"))
			switch (((t = this._days + r / 864e5), (n = this._months + c9(t)), e)) {
				case "month":
					return n
				case "quarter":
					return n / 3
				case "year":
					return n / 12
			}
		else
			switch (((t = this._days + Math.round(zS(this._months))), e)) {
				case "week":
					return t / 7 + r / 6048e5
				case "day":
					return t + r / 864e5
				case "hour":
					return t * 24 + r / 36e5
				case "minute":
					return t * 1440 + r / 6e4
				case "second":
					return t * 86400 + r / 1e3
				case "millisecond":
					return Math.floor(t * 864e5) + r
				default:
					throw new Error("Unknown unit " + e)
			}
	}
	function _l(e) {
		return function () {
			return this.as(e)
		}
	}
	var d9 = _l("ms"),
		oae = _l("s"),
		sae = _l("m"),
		lae = _l("h"),
		uae = _l("d"),
		cae = _l("w"),
		dae = _l("M"),
		fae = _l("Q"),
		pae = _l("y"),
		hae = d9
	function mae() {
		return Io(this)
	}
	function vae(e) {
		return (e = Za(e)), this.isValid() ? this[e + "s"]() : NaN
	}
	function _d(e) {
		return function () {
			return this.isValid() ? this._data[e] : NaN
		}
	}
	var gae = _d("milliseconds"),
		yae = _d("seconds"),
		bae = _d("minutes"),
		xae = _d("hours"),
		wae = _d("days"),
		Eae = _d("months"),
		Cae = _d("years")
	function Tae() {
		return ja(this.days() / 7)
	}
	var Ws = Math.round,
		If = { ss: 44, s: 45, m: 45, h: 22, d: 26, w: null, M: 11 }
	function kae(e, t, n, r, i) {
		return i.relativeTime(t || 1, !!n, e, r)
	}
	function Sae(e, t, n, r) {
		var i = Io(e).abs(),
			a = Ws(i.as("s")),
			o = Ws(i.as("m")),
			s = Ws(i.as("h")),
			l = Ws(i.as("d")),
			u = Ws(i.as("M")),
			d = Ws(i.as("w")),
			p = Ws(i.as("y")),
			m =
				(a <= n.ss && ["s", a]) ||
				(a < n.s && ["ss", a]) ||
				(o <= 1 && ["m"]) ||
				(o < n.m && ["mm", o]) ||
				(s <= 1 && ["h"]) ||
				(s < n.h && ["hh", s]) ||
				(l <= 1 && ["d"]) ||
				(l < n.d && ["dd", l])
		return (
			n.w != null && (m = m || (d <= 1 && ["w"]) || (d < n.w && ["ww", d])),
			(m = m || (u <= 1 && ["M"]) || (u < n.M && ["MM", u]) || (p <= 1 && ["y"]) || ["yy", p]),
			(m[2] = t),
			(m[3] = +e > 0),
			(m[4] = r),
			kae.apply(null, m)
		)
	}
	function Dae(e) {
		return e === void 0 ? Ws : typeof e == "function" ? ((Ws = e), !0) : !1
	}
	function _ae(e, t) {
		return If[e] === void 0
			? !1
			: t === void 0
			? If[e]
			: ((If[e] = t), e === "s" && (If.ss = t - 1), !0)
	}
	function Oae(e, t) {
		if (!this.isValid()) return this.localeData().invalidDate()
		var n = !1,
			r = If,
			i,
			a
		return (
			typeof e == "object" && ((t = e), (e = !1)),
			typeof e == "boolean" && (n = e),
			typeof t == "object" &&
				((r = Object.assign({}, If, t)), t.s != null && t.ss == null && (r.ss = t.s - 1)),
			(i = this.localeData()),
			(a = Sae(this, !n, r, i)),
			n && (a = i.pastFuture(+this, a)),
			i.postformat(a)
		)
	}
	var CT = Math.abs
	function hf(e) {
		return (e > 0) - (e < 0) || +e
	}
	function _x() {
		if (!this.isValid()) return this.localeData().invalidDate()
		var e = CT(this._milliseconds) / 1e3,
			t = CT(this._days),
			n = CT(this._months),
			r,
			i,
			a,
			o,
			s = this.asSeconds(),
			l,
			u,
			d,
			p
		return s
			? ((r = ja(e / 60)),
			  (i = ja(r / 60)),
			  (e %= 60),
			  (r %= 60),
			  (a = ja(n / 12)),
			  (n %= 12),
			  (o = e ? e.toFixed(3).replace(/\.?0+$/, "") : ""),
			  (l = s < 0 ? "-" : ""),
			  (u = hf(this._months) !== hf(s) ? "-" : ""),
			  (d = hf(this._days) !== hf(s) ? "-" : ""),
			  (p = hf(this._milliseconds) !== hf(s) ? "-" : ""),
			  l +
					"P" +
					(a ? u + a + "Y" : "") +
					(n ? u + n + "M" : "") +
					(t ? d + t + "D" : "") +
					(i || r || e ? "T" : "") +
					(i ? p + i + "H" : "") +
					(r ? p + r + "M" : "") +
					(e ? p + o + "S" : ""))
			: "P0D"
	}
	var Mt = Sx.prototype
	Mt.isValid = Ere
	Mt.abs = tae
	Mt.add = nae
	Mt.subtract = rae
	Mt.as = aae
	Mt.asMilliseconds = d9
	Mt.asSeconds = oae
	Mt.asMinutes = sae
	Mt.asHours = lae
	Mt.asDays = uae
	Mt.asWeeks = cae
	Mt.asMonths = dae
	Mt.asQuarters = fae
	Mt.asYears = pae
	Mt.valueOf = hae
	Mt._bubble = iae
	Mt.clone = mae
	Mt.get = vae
	Mt.milliseconds = gae
	Mt.seconds = yae
	Mt.minutes = bae
	Mt.hours = xae
	Mt.days = wae
	Mt.weeks = Tae
	Mt.months = Eae
	Mt.years = Cae
	Mt.humanize = Oae
	Mt.toISOString = _x
	Mt.toString = _x
	Mt.toJSON = _x
	Mt.locale = JB
	Mt.localeData = e9
	Mt.toIsoString = Ja(
		"toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)",
		_x,
	)
	Mt.lang = ZB
	rt("X", 0, 0, "unix")
	rt("x", 0, 0, "valueOf")
	qe("x", Ex)
	qe("X", Qte)
	an("X", function (e, t, n) {
		n._d = new Date(parseFloat(e) * 1e3)
	})
	an("x", function (e, t, n) {
		n._d = new Date(Dt(e))
	}) //! moment.js
	Te.version = "2.30.1"
	Ate(En)
	Te.fn = Ae
	Te.min = yre
	Te.max = bre
	Te.now = xre
	Te.utc = Cs
	Te.unix = Gie
	Te.months = Qie
	Te.isDate = Xv
	Te.locale = Eu
	Te.invalid = yx
	Te.duration = Io
	Te.isMoment = _o
	Te.weekdays = Jie
	Te.parseZone = Kie
	Te.localeData = Dl
	Te.isDuration = Jy
	Te.monthsShort = Xie
	Te.weekdaysMin = eae
	Te.defineLocale = g_
	Te.updateLocale = Kne
	Te.locales = Qne
	Te.weekdaysShort = Zie
	Te.normalizeUnits = Za
	Te.relativeTimeRounding = Dae
	Te.relativeTimeThreshold = _ae
	Te.calendarFormat = Vre
	Te.prototype = Ae
	Te.HTML5_FMT = {
		DATETIME_LOCAL: "YYYY-MM-DDTHH:mm",
		DATETIME_LOCAL_SECONDS: "YYYY-MM-DDTHH:mm:ss",
		DATETIME_LOCAL_MS: "YYYY-MM-DDTHH:mm:ss.SSS",
		DATE: "YYYY-MM-DD",
		TIME: "HH:mm",
		TIME_SECONDS: "HH:mm:ss",
		TIME_MS: "HH:mm:ss.SSS",
		WEEK: "GGGG-[W]WW",
		MONTH: "YYYY-MM",
	}
	class _n {
		constructor() {
			q(this, "id")
		}
		prepJson() {
			return this.snakeCase(this)
		}
		fromJson(t) {
			return t ? this.camelCase(t) : null
		}
		snakeCase(t) {
			const n = {}
			if (t) {
				for (const r in t)
					if (Object.prototype.hasOwnProperty.call(t, r) && !this.isLocalProperty(r)) {
						const i = r
							.replace(/[\w]([A-Z])/g, function (o) {
								return o[0] + "_" + o[1]
							})
							.toLowerCase()
						let a = t[r]
						a == null
							? this.isBooleanProperty(i) && (a = !1)
							: this.isDate(i)
							? (n[i] = Te(a).toISOString())
							: (n[i] = a)
					}
			}
			return n
		}
		convertProperyName(t) {
			return t
				.replace(/[\w]([A-Z])/g, function (n) {
					return n[0] + "_" + n[1]
				})
				.toLowerCase()
		}
		isBooleanProperty(t) {
			return (
				t != null &&
				(t.startsWith("is_") ||
					t.startsWith("use_") ||
					t.startsWith("can_") ||
					t.startsWith("has_"))
			)
		}
		isLocalProperty(t) {
			return ["deleted", "dirty", "localId"].indexOf(t) >= 0
		}
		camelCase(t) {
			const n = {}
			if (t)
				for (const r in t)
					t.hasOwnProperty(r) &&
						(n[
							r.replace(/(_\w)/g, function (i) {
								return i[1].toUpperCase()
							})
						] = this.isDate(r) ? this.getDate(t[r]) : t[r])
			return n
		}
		isDate(t) {
			return t != null && (t.endsWith("_date") || t.endsWith("_start") || t.endsWith("_end"))
		}
		getDate(t) {
			return (t == null ? void 0 : t.length) === 10 ? Te(t).toDate() : new Date(t)
		}
	}
	class f9 extends _n {
		constructor(n) {
			super()
			q(this, "name", "")
			q(this, "addressTxt")
			q(this, "city")
			q(this, "state")
			q(this, "zip")
			q(this, "website")
			q(this, "logoUrl")
			q(this, "email")
			q(this, "phone")
			q(this, "notes")
			const r = this.fromJson(n)
			Object.assign(this, r)
		}
	}
	class ha extends _n {
		constructor(n) {
			super()
			q(this, "firstName", "")
			q(this, "lastName", "")
			q(this, "primaryPhone")
			q(this, "alternatePhone")
			q(this, "email", "")
			q(this, "sendEmail", !1)
			q(this, "homeClub")
			q(this, "addressTxt")
			q(this, "city")
			q(this, "state")
			q(this, "zip")
			q(this, "notes")
			const r = {
				id: (n == null ? void 0 : n.id) || 0,
				firstName: (n == null ? void 0 : n.first_name) || "",
				lastName: (n == null ? void 0 : n.last_name) || "",
				primaryPhone: n == null ? void 0 : n.primary_phone,
				alternatePhone: n == null ? void 0 : n.alternate_phone,
				email: (n == null ? void 0 : n.email) || "",
				sendEmail: (n == null ? void 0 : n.send_email) || !1,
				homeClub: n == null ? void 0 : n.home_club,
				addressTxt: n == null ? void 0 : n.address_txt,
				city: n == null ? void 0 : n.city,
				state: n == null ? void 0 : n.state,
				zip: n == null ? void 0 : n.zip,
				notes: n == null ? void 0 : n.notes,
			}
			Object.assign(this, r)
		}
		get name() {
			return `${this.firstName} ${this.lastName}`
		}
	}
	class p9 extends _n {
		constructor(n) {
			super()
			q(this, "name", "")
			q(this, "systemName", "")
			q(this, "website")
			q(this, "notes")
			q(this, "size")
			q(this, "golfCourse")
			q(this, "clubContacts", [])
			q(this, "membershipData")
			if (n) {
				const r = super.fromJson(n)
				;(r.golfCourse = new f9(n.golf_course)),
					n.club_contacts && (r.clubContacts = n.club_contacts.map((i) => new Pu(i))),
					Object.assign(this, r)
			}
		}
		addContact(n) {
			const r = new Pu({ contact: n })
			return (
				(r.club = this.id),
				(r.id = 0),
				this.clubContacts || (this.clubContacts = []),
				this.clubContacts.unshift(r),
				r
			)
		}
		prepJson() {
			return {
				name: this.name,
				website: this.website,
				notes: this.notes,
				size: this.size,
				golf_course: this.golfCourse.prepJson(),
				club_contacts: [],
			}
		}
	}
	class h9 extends _n {
		constructor(n) {
			super()
			q(this, "year", 0)
			q(this, "club", 0)
			q(this, "paymentDate")
			q(this, "paymentType", "")
			q(this, "paymentCode")
			q(this, "notes")
			if (n) {
				const r = super.fromJson(n)
				;(r.paymentDate = n.payment_date
					? Te(n.payment_date).add(6, "hours").format("yyyy-MM-DD")
					: ""),
					Object.assign(this, r)
			}
		}
	}
	class m9 extends _n {
		constructor(n) {
			super()
			q(this, "localId", Math.floor(Math.random() * 1e3).toString())
			q(this, "year", 0)
			q(this, "club")
			q(this, "groupName", "")
			q(this, "isSenior", !1)
			q(this, "notes")
			if (n) {
				const r = super.fromJson(n)
				;(r.club = new p9(n.club)),
					(!r.club || !r.club.id) && console.log("only a club id is present"),
					Object.assign(this, r)
			}
		}
		prepJson() {
			const n = this.snakeCase(this)
			return (n.is_senior = this.isSenior ? this.isSenior : !1), (n.club = this.club.id), n
		}
		captainNames(n) {
			const r = this.captains(n)
			return r ? r.map((i) => `${i.contact.firstName} ${i.contact.lastName}`).join(", ") : ""
		}
		captains(n) {
			return this.club && this.club.clubContacts
				? n
					? this.club.clubContacts.filter((r) => r.isSeniorCaptain)
					: this.club.clubContacts.filter((r) => r.isCaptain)
				: []
		}
	}
	class TT extends _n {
		constructor(n) {
			super()
			q(this, "clubContact")
			q(this, "role")
			if (n) {
				const r = super.fromJson(n)
				Object.assign(this, r)
			}
		}
	}
	class Pu extends _n {
		constructor(n) {
			super()
			q(this, "club")
			q(this, "contact")
			q(this, "isPrimary", !1)
			q(this, "sendEmail", !1)
			q(this, "useForMailings", !1)
			q(this, "deleted", !1)
			q(this, "dirty", !1)
			q(this, "roles", [])
			q(this, "notes")
			if (n) {
				const r = super.fromJson(n)
				;(r.contact = new ha(n.contact)),
					n.roles && (r.roles = n.roles.map((i) => new TT(i))),
					Object.assign(this, r)
			}
		}
		static Create(n, r) {
			var a
			const i = new Pu({
				is_primary: r.isPrimary,
				use_for_mailings: r.useForMailings,
				notes: r.notes,
			})
			return (
				(i.contact = new ha({
					first_name: r.firstName,
					last_name: r.lastName,
					primary_phone: r.primaryPhone,
					alternate_phone: r.alternatePhone,
					email: r.email,
					address_txt: r.addressTxt,
					city: r.city,
					state: r.state,
					zip: r.zip,
				})),
				(i.roles = (a = r.roles) == null ? void 0 : a.map((o) => new TT({ role: o.role }))),
				(i.club = n),
				i
			)
		}
		addRole(n) {
			this.roles || (this.roles = [])
			const r = new TT({ role: n, clubContact: this.id })
			this.roles.push(r)
		}
		clearRoles() {
			this.roles = []
		}
		get isCaptain() {
			return this.roles !== void 0 && this.roles.some((n) => n.role === "Match Play Captain")
		}
		get isSeniorCaptain() {
			return this.roles !== void 0 && this.roles.some((n) => n.role === "Sr. Match Play Captain")
		}
		prepJson() {
			var r
			const n = super.snakeCase(this)
			return (
				(n.roles = (r = this.roles) == null ? void 0 : r.map((i) => i.prepJson())),
				(n.contact = this.contact.prepJson()),
				n
			)
		}
	}
	class dv extends _n {
		constructor(n) {
			super()
			q(this, "contact", new ha({ id: 0 }))
			q(this, "role", "")
			q(this, "homeClub", 0)
			q(this, "homeClubName", "")
			if (n) {
				const r = super.fromJson(n)
				;(r.contact = new ha(n.contact)), Object.assign(this, r)
			}
		}
		static Create(n) {
			const r = new dv({ role: n.role, home_club: n.homeClub })
			return (
				(r.contact = new ha({
					first_name: n.firstName,
					last_name: n.lastName,
					primary_phone: n.primaryPhone,
					alternate_phone: n.alternatePhone,
					email: n.email,
					address_txt: n.addressTxt,
					city: n.city,
					state: n.state,
					zip: n.zip,
				})),
				r
			)
		}
		toJson() {
			return {
				id: this.id,
				role: this.role,
				home_club: this.homeClub,
				contact: this.contact.prepJson(),
			}
		}
	}
	class v9 extends _n {
		constructor(n) {
			super()
			q(this, "groupName", "")
			q(this, "matchDate")
			q(this, "homeTeam", 0)
			q(this, "awayTeam", 0)
			q(this, "homeTeamName", "")
			q(this, "awayTeamName", "")
			q(this, "homeTeamScore", 0)
			q(this, "awayTeamScore", 0)
			q(this, "enteredBy")
			q(this, "forfeit", !1)
			q(this, "notes")
			if (n) {
				const r = super.fromJson(n)
				Object.assign(this, r)
			}
		}
		toJson() {
			return {
				group_name: this.groupName,
				match_date: Te(this.matchDate).format("YYYY-MM-DD"),
				home_team: this.homeTeam,
				away_team: this.awayTeam,
				home_team_score: this.homeTeamScore,
				away_team_score: this.awayTeamScore,
				entered_by: this.enteredBy,
				forfeit: !!this.forfeit,
				notes: this.notes,
			}
		}
		get winner() {
			let n = ""
			return (
				+this.homeTeamScore > +this.awayTeamScore
					? (n = this.homeTeamName)
					: +this.awayTeamScore > +this.homeTeamScore && (n = this.awayTeamName),
				n
			)
		}
	}
	const Rc = class Rc {
		constructor() {
			q(this, "id", 0)
			q(this, "username", "")
			q(this, "firstName", "")
			q(this, "lastName", "")
			q(this, "email", "")
			q(this, "isAuthenticated", !1)
			q(this, "isAdmin", !1)
			q(this, "isActive", !1)
			q(this, "committeeId")
			q(this, "clubId")
			q(this, "groups", [])
		}
		get isOfficer() {
			return this.isAuthenticated && this.groups.indexOf("Officer") !== -1
		}
		get isHistorian() {
			return this.isAuthenticated && this.groups.indexOf("Historian") !== -1
		}
		get isClubContact() {
			return this.isAuthenticated && this.clubId !== void 0
		}
		get isCommittee() {
			return this.isAuthenticated && this.committeeId !== void 0
		}
		get name() {
			return this.isAuthenticated ? this.firstName + " " + this.lastName : "Guest"
		}
		fromJson(t) {
			return (
				t &&
					((this.id = t.id),
					(this.username = t.username),
					(this.firstName = t.first_name),
					(this.lastName = t.last_name),
					(this.email = t.email),
					(this.isAuthenticated = t.is_authenticated),
					(this.isAdmin = t.is_staff),
					(this.isActive = t.is_active),
					(this.groups = t.groups && t.groups.map((n) => n.name))),
				this
			)
		}
		prepJson() {
			return {
				id: this.id,
				username: this.username,
				first_name: this.firstName,
				last_name: this.lastName,
				email: this.email,
			}
		}
	}
	q(Rc, "Guest", () => {
		const t = new Rc()
		return (t.isAuthenticated = !1), t
	}),
		q(Rc, "Load", (t) => {
			if (t.user) {
				const n = new Rc().fromJson(t.user)
				return (n.committeeId = t.committeeId), (n.clubId = t.clubId), n
			}
			return Rc.Guest()
		})
	let qS = Rc
	const ks = () => {
			const e = Nr((t) => t.session)
			return { user: qS.Load(e), contact: new ha(e.contact), flags: e.flags }
		},
		Aae = Ui.injectEndpoints({
			endpoints: (e) => ({
				getClubs: e.query({
					query: () => ({ url: "/clubs/", method: "GET" }),
					providesTags: (t) =>
						t
							? [...t.map(({ id: n }) => ({ type: "Clubs", id: n })), { type: "Clubs", id: "LIST" }]
							: [{ type: "Clubs", id: "LIST" }],
				}),
				getClub: e.query({
					query: (t) => ({ url: `/clubs/${t}`, method: "GET" }),
					providesTags: (t, n, r) => [{ type: "Clubs", id: r }],
				}),
				updateClub: e.mutation({
					query(t) {
						const { id: n } = t
						return { url: `/clubs/${n}/`, method: "PUT", data: t }
					},
					invalidatesTags: (t, n, { id: r }) => [{ type: "Clubs", id: r }],
				}),
				updateCourse: e.mutation({
					query(t) {
						const { id: n } = t.golf_course
						return { url: `/courses/${n}/`, method: "PATCH", data: t.golf_course }
					},
					invalidatesTags: (t, n, { id: r }) => [{ type: "Clubs", id: r }],
				}),
				addClubContact: e.mutation({
					query(t) {
						return { url: "/club-contacts/", method: "POST", data: t }
					},
					invalidatesTags: (t, n, { club: r }) => [{ type: "Clubs", id: r }],
				}),
				updateClubContact: e.mutation({
					query(t) {
						const { id: n } = t
						return { url: `/club-contacts/${n}/`, method: "PUT", data: t }
					},
					invalidatesTags: (t, n, { club: r }) => [{ type: "Clubs", id: r }],
				}),
				removeClubContact: e.mutation({
					query(t) {
						const { id: n } = t
						return { url: `/club-contacts/${n}/`, method: "DELETE" }
					},
					invalidatesTags: (t, n, { club: r }) => [{ type: "Clubs", id: r }],
				}),
				getClubContacts: e.query({
					query() {
						return { url: "/club-contacts/", method: "GET" }
					},
					providesTags: ["ClubContacts"],
				}),
				getContacts: e.query({
					query() {
						return { url: "/contacts/", method: "GET" }
					},
					providesTags: ["Contacts"],
				}),
			}),
		}),
		{
			useGetClubContactsQuery: Nae,
			useGetClubQuery: Mae,
			useGetClubsQuery: Kp,
			useGetContactsQuery: Iae,
			useUpdateClubMutation: Rae,
			useAddClubContactMutation: Lae,
			useUpdateClubContactMutation: Pae,
			useUpdateCourseMutation: jae,
			useRemoveClubContactMutation: Fae,
		} = Aae,
		Bae = ["as", "disabled"]
	function Hae(e, t) {
		if (e == null) return {}
		var n = {}
		for (var r in e)
			if ({}.hasOwnProperty.call(e, r)) {
				if (t.indexOf(r) >= 0) continue
				n[r] = e[r]
			}
		return n
	}
	function $ae(e) {
		return !e || e.trim() === "#"
	}
	function S_({
		tagName: e,
		disabled: t,
		href: n,
		target: r,
		rel: i,
		role: a,
		onClick: o,
		tabIndex: s = 0,
		type: l,
	}) {
		e || (n != null || r != null || i != null ? (e = "a") : (e = "button"))
		const u = { tagName: e }
		if (e === "button") return [{ type: l || "button", disabled: t }, u]
		const d = (m) => {
				if (((t || (e === "a" && $ae(n))) && m.preventDefault(), t)) {
					m.stopPropagation()
					return
				}
				o == null || o(m)
			},
			p = (m) => {
				m.key === " " && (m.preventDefault(), d(m))
			}
		return (
			e === "a" && (n || (n = "#"), t && (n = void 0)),
			[
				{
					role: a ?? "button",
					disabled: void 0,
					tabIndex: t ? void 0 : s,
					href: n,
					target: e === "a" ? r : void 0,
					"aria-disabled": t || void 0,
					rel: e === "a" ? i : void 0,
					onClick: d,
					onKeyDown: p,
				},
				u,
			]
		)
	}
	const D_ = _.forwardRef((e, t) => {
		let { as: n, disabled: r } = e,
			i = Hae(e, Bae)
		const [a, { tagName: o }] = S_(Object.assign({ tagName: n, disabled: r }, i))
		return h.jsx(o, Object.assign({}, i, a, { ref: t }))
	})
	D_.displayName = "Button"
	const Ge = _.forwardRef(
		(
			{
				as: e,
				bsPrefix: t,
				variant: n = "primary",
				size: r,
				active: i = !1,
				disabled: a = !1,
				className: o,
				...s
			},
			l,
		) => {
			const u = nt(t, "btn"),
				[d, { tagName: p }] = S_({ tagName: e, disabled: a, ...s }),
				m = p
			return h.jsx(m, {
				...d,
				...s,
				ref: l,
				disabled: a,
				className: Fe(
					o,
					u,
					i && "active",
					n && `${u}-${n}`,
					r && `${u}-${r}`,
					s.href && a && "disabled",
				),
			})
		},
	)
	Ge.displayName = "Button"
	var Hi = function () {
		return (
			(Hi =
				Object.assign ||
				function (t) {
					for (var n, r = 1, i = arguments.length; r < i; r++) {
						n = arguments[r]
						for (var a in n) Object.prototype.hasOwnProperty.call(n, a) && (t[a] = n[a])
					}
					return t
				}),
			Hi.apply(this, arguments)
		)
	}
	function fv(e, t, n) {
		if (n || arguments.length === 2)
			for (var r = 0, i = t.length, a; r < i; r++)
				(a || !(r in t)) && (a || (a = Array.prototype.slice.call(t, 0, r)), (a[r] = t[r]))
		return e.concat(a || Array.prototype.slice.call(t))
	}
	var yn = "-ms-",
		Im = "-moz-",
		Kt = "-webkit-",
		g9 = "comm",
		Ox = "rule",
		__ = "decl",
		Uae = "@import",
		y9 = "@keyframes",
		zae = "@layer",
		b9 = Math.abs,
		O_ = String.fromCharCode,
		VS = Object.assign
	function qae(e, t) {
		return Sr(e, 0) ^ 45
			? (((((((t << 2) ^ Sr(e, 0)) << 2) ^ Sr(e, 1)) << 2) ^ Sr(e, 2)) << 2) ^ Sr(e, 3)
			: 0
	}
	function x9(e) {
		return e.trim()
	}
	function Ys(e, t) {
		return (e = t.exec(e)) ? e[0] : e
	}
	function xt(e, t, n) {
		return e.replace(t, n)
	}
	function e1(e, t, n) {
		return e.indexOf(t, n)
	}
	function Sr(e, t) {
		return e.charCodeAt(t) | 0
	}
	function tp(e, t, n) {
		return e.slice(t, n)
	}
	function Ko(e) {
		return e.length
	}
	function w9(e) {
		return e.length
	}
	function ym(e, t) {
		return t.push(e), e
	}
	function Vae(e, t) {
		return e.map(t).join("")
	}
	function kL(e, t) {
		return e.filter(function (n) {
			return !Ys(n, t)
		})
	}
	var Ax = 1,
		np = 1,
		E9 = 0,
		Va = 0,
		ir = 0,
		Qp = ""
	function Nx(e, t, n, r, i, a, o, s) {
		return {
			value: e,
			root: t,
			parent: n,
			type: r,
			props: i,
			children: a,
			line: Ax,
			column: np,
			length: o,
			return: "",
			siblings: s,
		}
	}
	function lu(e, t) {
		return VS(Nx("", null, null, "", null, null, 0, e.siblings), e, { length: -e.length }, t)
	}
	function mf(e) {
		for (; e.root; ) e = lu(e.root, { children: [e] })
		ym(e, e.siblings)
	}
	function Wae() {
		return ir
	}
	function Yae() {
		return (ir = Va > 0 ? Sr(Qp, --Va) : 0), np--, ir === 10 && ((np = 1), Ax--), ir
	}
	function xo() {
		return (ir = Va < E9 ? Sr(Qp, Va++) : 0), np++, ir === 10 && ((np = 1), Ax++), ir
	}
	function Vc() {
		return Sr(Qp, Va)
	}
	function t1() {
		return Va
	}
	function Mx(e, t) {
		return tp(Qp, e, t)
	}
	function WS(e) {
		switch (e) {
			case 0:
			case 9:
			case 10:
			case 13:
			case 32:
				return 5
			case 33:
			case 43:
			case 44:
			case 47:
			case 62:
			case 64:
			case 126:
			case 59:
			case 123:
			case 125:
				return 4
			case 58:
				return 3
			case 34:
			case 39:
			case 40:
			case 91:
				return 2
			case 41:
			case 93:
				return 1
		}
		return 0
	}
	function Gae(e) {
		return (Ax = np = 1), (E9 = Ko((Qp = e))), (Va = 0), []
	}
	function Kae(e) {
		return (Qp = ""), e
	}
	function kT(e) {
		return x9(Mx(Va - 1, YS(e === 91 ? e + 2 : e === 40 ? e + 1 : e)))
	}
	function Qae(e) {
		for (; (ir = Vc()) && ir < 33; ) xo()
		return WS(e) > 2 || WS(ir) > 3 ? "" : " "
	}
	function Xae(e, t) {
		for (; --t && xo() && !(ir < 48 || ir > 102 || (ir > 57 && ir < 65) || (ir > 70 && ir < 97)); );
		return Mx(e, t1() + (t < 6 && Vc() == 32 && xo() == 32))
	}
	function YS(e) {
		for (; xo(); )
			switch (ir) {
				case e:
					return Va
				case 34:
				case 39:
					e !== 34 && e !== 39 && YS(ir)
					break
				case 40:
					e === 41 && YS(e)
					break
				case 92:
					xo()
					break
			}
		return Va
	}
	function Jae(e, t) {
		for (; xo() && e + ir !== 57; ) if (e + ir === 84 && Vc() === 47) break
		return "/*" + Mx(t, Va - 1) + "*" + O_(e === 47 ? e : xo())
	}
	function Zae(e) {
		for (; !WS(Vc()); ) xo()
		return Mx(e, Va)
	}
	function eoe(e) {
		return Kae(n1("", null, null, null, [""], (e = Gae(e)), 0, [0], e))
	}
	function n1(e, t, n, r, i, a, o, s, l) {
		for (
			var u = 0,
				d = 0,
				p = o,
				m = 0,
				v = 0,
				y = 0,
				b = 1,
				x = 1,
				E = 1,
				T = 0,
				C = "",
				D = i,
				O = a,
				A = r,
				N = C;
			x;

		)
			switch (((y = T), (T = xo()))) {
				case 40:
					if (y != 108 && Sr(N, p - 1) == 58) {
						e1((N += xt(kT(T), "&", "&\f")), "&\f", b9(u ? s[u - 1] : 0)) != -1 && (E = -1)
						break
					}
				case 34:
				case 39:
				case 91:
					N += kT(T)
					break
				case 9:
				case 10:
				case 13:
				case 32:
					N += Qae(y)
					break
				case 92:
					N += Xae(t1() - 1, 7)
					continue
				case 47:
					switch (Vc()) {
						case 42:
						case 47:
							ym(toe(Jae(xo(), t1()), t, n, l), l)
							break
						default:
							N += "/"
					}
					break
				case 123 * b:
					s[u++] = Ko(N) * E
				case 125 * b:
				case 59:
				case 0:
					switch (T) {
						case 0:
						case 125:
							x = 0
						case 59 + d:
							E == -1 && (N = xt(N, /\f/g, "")),
								v > 0 &&
									Ko(N) - p &&
									ym(
										v > 32 ? DL(N + ";", r, n, p - 1, l) : DL(xt(N, " ", "") + ";", r, n, p - 2, l),
										l,
									)
							break
						case 59:
							N += ";"
						default:
							if ((ym((A = SL(N, t, n, u, d, i, s, C, (D = []), (O = []), p, a)), a), T === 123))
								if (d === 0) n1(N, t, A, A, D, a, p, s, O)
								else
									switch (m === 99 && Sr(N, 3) === 110 ? 100 : m) {
										case 100:
										case 108:
										case 109:
										case 115:
											n1(
												e,
												A,
												A,
												r && ym(SL(e, A, A, 0, 0, i, s, C, i, (D = []), p, O), O),
												i,
												O,
												p,
												s,
												r ? D : O,
											)
											break
										default:
											n1(N, A, A, A, [""], O, 0, s, O)
									}
					}
					;(u = d = v = 0), (b = E = 1), (C = N = ""), (p = o)
					break
				case 58:
					;(p = 1 + Ko(N)), (v = y)
				default:
					if (b < 1) {
						if (T == 123) --b
						else if (T == 125 && b++ == 0 && Yae() == 125) continue
					}
					switch (((N += O_(T)), T * b)) {
						case 38:
							E = d > 0 ? 1 : ((N += "\f"), -1)
							break
						case 44:
							;(s[u++] = (Ko(N) - 1) * E), (E = 1)
							break
						case 64:
							Vc() === 45 && (N += kT(xo())), (m = Vc()), (d = p = Ko((C = N += Zae(t1())))), T++
							break
						case 45:
							y === 45 && Ko(N) == 2 && (b = 0)
					}
			}
		return a
	}
	function SL(e, t, n, r, i, a, o, s, l, u, d, p) {
		for (var m = i - 1, v = i === 0 ? a : [""], y = w9(v), b = 0, x = 0, E = 0; b < r; ++b)
			for (var T = 0, C = tp(e, m + 1, (m = b9((x = o[b])))), D = e; T < y; ++T)
				(D = x9(x > 0 ? v[T] + " " + C : xt(C, /&\f/g, v[T]))) && (l[E++] = D)
		return Nx(e, t, n, i === 0 ? Ox : s, l, u, d, p)
	}
	function toe(e, t, n, r) {
		return Nx(e, t, n, g9, O_(Wae()), tp(e, 2, -2), 0, r)
	}
	function DL(e, t, n, r, i) {
		return Nx(e, t, n, __, tp(e, 0, r), tp(e, r + 1, -1), r, i)
	}
	function C9(e, t, n) {
		switch (qae(e, t)) {
			case 5103:
				return Kt + "print-" + e + e
			case 5737:
			case 4201:
			case 3177:
			case 3433:
			case 1641:
			case 4457:
			case 2921:
			case 5572:
			case 6356:
			case 5844:
			case 3191:
			case 6645:
			case 3005:
			case 6391:
			case 5879:
			case 5623:
			case 6135:
			case 4599:
			case 4855:
			case 4215:
			case 6389:
			case 5109:
			case 5365:
			case 5621:
			case 3829:
				return Kt + e + e
			case 4789:
				return Im + e + e
			case 5349:
			case 4246:
			case 4810:
			case 6968:
			case 2756:
				return Kt + e + Im + e + yn + e + e
			case 5936:
				switch (Sr(e, t + 11)) {
					case 114:
						return Kt + e + yn + xt(e, /[svh]\w+-[tblr]{2}/, "tb") + e
					case 108:
						return Kt + e + yn + xt(e, /[svh]\w+-[tblr]{2}/, "tb-rl") + e
					case 45:
						return Kt + e + yn + xt(e, /[svh]\w+-[tblr]{2}/, "lr") + e
				}
			case 6828:
			case 4268:
			case 2903:
				return Kt + e + yn + e + e
			case 6165:
				return Kt + e + yn + "flex-" + e + e
			case 5187:
				return Kt + e + xt(e, /(\w+).+(:[^]+)/, Kt + "box-$1$2" + yn + "flex-$1$2") + e
			case 5443:
				return (
					Kt +
					e +
					yn +
					"flex-item-" +
					xt(e, /flex-|-self/g, "") +
					(Ys(e, /flex-|baseline/) ? "" : yn + "grid-row-" + xt(e, /flex-|-self/g, "")) +
					e
				)
			case 4675:
				return Kt + e + yn + "flex-line-pack" + xt(e, /align-content|flex-|-self/g, "") + e
			case 5548:
				return Kt + e + yn + xt(e, "shrink", "negative") + e
			case 5292:
				return Kt + e + yn + xt(e, "basis", "preferred-size") + e
			case 6060:
				return Kt + "box-" + xt(e, "-grow", "") + Kt + e + yn + xt(e, "grow", "positive") + e
			case 4554:
				return Kt + xt(e, /([^-])(transform)/g, "$1" + Kt + "$2") + e
			case 6187:
				return xt(xt(xt(e, /(zoom-|grab)/, Kt + "$1"), /(image-set)/, Kt + "$1"), e, "") + e
			case 5495:
			case 3959:
				return xt(e, /(image-set\([^]*)/, Kt + "$1$`$1")
			case 4968:
				return (
					xt(
						xt(e, /(.+:)(flex-)?(.*)/, Kt + "box-pack:$3" + yn + "flex-pack:$3"),
						/s.+-b[^;]+/,
						"justify",
					) +
					Kt +
					e +
					e
				)
			case 4200:
				if (!Ys(e, /flex-|baseline/)) return yn + "grid-column-align" + tp(e, t) + e
				break
			case 2592:
			case 3360:
				return yn + xt(e, "template-", "") + e
			case 4384:
			case 3616:
				return n &&
					n.some(function (r, i) {
						return (t = i), Ys(r.props, /grid-\w+-end/)
					})
					? ~e1(e + (n = n[t].value), "span", 0)
						? e
						: yn +
						  xt(e, "-start", "") +
						  e +
						  yn +
						  "grid-row-span:" +
						  (~e1(n, "span", 0) ? Ys(n, /\d+/) : +Ys(n, /\d+/) - +Ys(e, /\d+/)) +
						  ";"
					: yn + xt(e, "-start", "") + e
			case 4896:
			case 4128:
				return n &&
					n.some(function (r) {
						return Ys(r.props, /grid-\w+-start/)
					})
					? e
					: yn + xt(xt(e, "-end", "-span"), "span ", "") + e
			case 4095:
			case 3583:
			case 4068:
			case 2532:
				return xt(e, /(.+)-inline(.+)/, Kt + "$1$2") + e
			case 8116:
			case 7059:
			case 5753:
			case 5535:
			case 5445:
			case 5701:
			case 4933:
			case 4677:
			case 5533:
			case 5789:
			case 5021:
			case 4765:
				if (Ko(e) - 1 - t > 6)
					switch (Sr(e, t + 1)) {
						case 109:
							if (Sr(e, t + 4) !== 45) break
						case 102:
							return (
								xt(
									e,
									/(.+:)(.+)-([^]+)/,
									"$1" + Kt + "$2-$3$1" + Im + (Sr(e, t + 3) == 108 ? "$3" : "$2-$3"),
								) + e
							)
						case 115:
							return ~e1(e, "stretch", 0) ? C9(xt(e, "stretch", "fill-available"), t, n) + e : e
					}
				break
			case 5152:
			case 5920:
				return xt(e, /(.+?):(\d+)(\s*\/\s*(span)?\s*(\d+))?(.*)/, function (r, i, a, o, s, l, u) {
					return yn + i + ":" + a + u + (o ? yn + i + "-span:" + (s ? l : +l - +a) + u : "") + e
				})
			case 4949:
				if (Sr(e, t + 6) === 121) return xt(e, ":", ":" + Kt) + e
				break
			case 6444:
				switch (Sr(e, Sr(e, 14) === 45 ? 18 : 11)) {
					case 120:
						return (
							xt(
								e,
								/(.+:)([^;\s!]+)(;|(\s+)?!.+)?/,
								"$1" +
									Kt +
									(Sr(e, 14) === 45 ? "inline-" : "") +
									"box$3$1" +
									Kt +
									"$2$3$1" +
									yn +
									"$2box$3",
							) + e
						)
					case 100:
						return xt(e, ":", ":" + yn) + e
				}
				break
			case 5719:
			case 2647:
			case 2135:
			case 3927:
			case 2391:
				return xt(e, "scroll-", "scroll-snap-") + e
		}
		return e
	}
	function U1(e, t) {
		for (var n = "", r = 0; r < e.length; r++) n += t(e[r], r, e, t) || ""
		return n
	}
	function noe(e, t, n, r) {
		switch (e.type) {
			case zae:
				if (e.children.length) break
			case Uae:
			case __:
				return (e.return = e.return || e.value)
			case g9:
				return ""
			case y9:
				return (e.return = e.value + "{" + U1(e.children, r) + "}")
			case Ox:
				if (!Ko((e.value = e.props.join(",")))) return ""
		}
		return Ko((n = U1(e.children, r))) ? (e.return = e.value + "{" + n + "}") : ""
	}
	function roe(e) {
		var t = w9(e)
		return function (n, r, i, a) {
			for (var o = "", s = 0; s < t; s++) o += e[s](n, r, i, a) || ""
			return o
		}
	}
	function ioe(e) {
		return function (t) {
			t.root || ((t = t.return) && e(t))
		}
	}
	function aoe(e, t, n, r) {
		if (e.length > -1 && !e.return)
			switch (e.type) {
				case __:
					e.return = C9(e.value, e.length, n)
					return
				case y9:
					return U1([lu(e, { value: xt(e.value, "@", "@" + Kt) })], r)
				case Ox:
					if (e.length)
						return Vae((n = e.props), function (i) {
							switch (Ys(i, (r = /(::plac\w+|:read-\w+)/))) {
								case ":read-only":
								case ":read-write":
									mf(lu(e, { props: [xt(i, /:(read-\w+)/, ":" + Im + "$1")] })),
										mf(lu(e, { props: [i] })),
										VS(e, { props: kL(n, r) })
									break
								case "::placeholder":
									mf(lu(e, { props: [xt(i, /:(plac\w+)/, ":" + Kt + "input-$1")] })),
										mf(lu(e, { props: [xt(i, /:(plac\w+)/, ":" + Im + "$1")] })),
										mf(lu(e, { props: [xt(i, /:(plac\w+)/, yn + "input-$1")] })),
										mf(lu(e, { props: [i] })),
										VS(e, { props: kL(n, r) })
									break
							}
							return ""
						})
			}
	}
	var ooe = {
			animationIterationCount: 1,
			aspectRatio: 1,
			borderImageOutset: 1,
			borderImageSlice: 1,
			borderImageWidth: 1,
			boxFlex: 1,
			boxFlexGroup: 1,
			boxOrdinalGroup: 1,
			columnCount: 1,
			columns: 1,
			flex: 1,
			flexGrow: 1,
			flexPositive: 1,
			flexShrink: 1,
			flexNegative: 1,
			flexOrder: 1,
			gridRow: 1,
			gridRowEnd: 1,
			gridRowSpan: 1,
			gridRowStart: 1,
			gridColumn: 1,
			gridColumnEnd: 1,
			gridColumnSpan: 1,
			gridColumnStart: 1,
			msGridRow: 1,
			msGridRowSpan: 1,
			msGridColumn: 1,
			msGridColumnSpan: 1,
			fontWeight: 1,
			lineHeight: 1,
			opacity: 1,
			order: 1,
			orphans: 1,
			tabSize: 1,
			widows: 1,
			zIndex: 1,
			zoom: 1,
			WebkitLineClamp: 1,
			fillOpacity: 1,
			floodOpacity: 1,
			stopOpacity: 1,
			strokeDasharray: 1,
			strokeDashoffset: 1,
			strokeMiterlimit: 1,
			strokeOpacity: 1,
			strokeWidth: 1,
		},
		ra = {},
		rp =
			(typeof process < "u" && ra !== void 0 && (ra.REACT_APP_SC_ATTR || ra.SC_ATTR)) ||
			"data-styled",
		T9 = "active",
		k9 = "data-styled-version",
		Ix = "6.1.13",
		A_ = `/*!sc*/
`,
		z1 = typeof window < "u" && "HTMLElement" in window,
		soe = !!(typeof SC_DISABLE_SPEEDY == "boolean"
			? SC_DISABLE_SPEEDY
			: typeof process < "u" &&
			  ra !== void 0 &&
			  ra.REACT_APP_SC_DISABLE_SPEEDY !== void 0 &&
			  ra.REACT_APP_SC_DISABLE_SPEEDY !== ""
			? ra.REACT_APP_SC_DISABLE_SPEEDY !== "false" && ra.REACT_APP_SC_DISABLE_SPEEDY
			: typeof process < "u" &&
			  ra !== void 0 &&
			  ra.SC_DISABLE_SPEEDY !== void 0 &&
			  ra.SC_DISABLE_SPEEDY !== "" &&
			  ra.SC_DISABLE_SPEEDY !== "false" &&
			  ra.SC_DISABLE_SPEEDY),
		Rx = Object.freeze([]),
		ip = Object.freeze({})
	function loe(e, t, n) {
		return n === void 0 && (n = ip), (e.theme !== n.theme && e.theme) || t || n.theme
	}
	var S9 = new Set([
			"a",
			"abbr",
			"address",
			"area",
			"article",
			"aside",
			"audio",
			"b",
			"base",
			"bdi",
			"bdo",
			"big",
			"blockquote",
			"body",
			"br",
			"button",
			"canvas",
			"caption",
			"cite",
			"code",
			"col",
			"colgroup",
			"data",
			"datalist",
			"dd",
			"del",
			"details",
			"dfn",
			"dialog",
			"div",
			"dl",
			"dt",
			"em",
			"embed",
			"fieldset",
			"figcaption",
			"figure",
			"footer",
			"form",
			"h1",
			"h2",
			"h3",
			"h4",
			"h5",
			"h6",
			"header",
			"hgroup",
			"hr",
			"html",
			"i",
			"iframe",
			"img",
			"input",
			"ins",
			"kbd",
			"keygen",
			"label",
			"legend",
			"li",
			"link",
			"main",
			"map",
			"mark",
			"menu",
			"menuitem",
			"meta",
			"meter",
			"nav",
			"noscript",
			"object",
			"ol",
			"optgroup",
			"option",
			"output",
			"p",
			"param",
			"picture",
			"pre",
			"progress",
			"q",
			"rp",
			"rt",
			"ruby",
			"s",
			"samp",
			"script",
			"section",
			"select",
			"small",
			"source",
			"span",
			"strong",
			"style",
			"sub",
			"summary",
			"sup",
			"table",
			"tbody",
			"td",
			"textarea",
			"tfoot",
			"th",
			"thead",
			"time",
			"tr",
			"track",
			"u",
			"ul",
			"use",
			"var",
			"video",
			"wbr",
			"circle",
			"clipPath",
			"defs",
			"ellipse",
			"foreignObject",
			"g",
			"image",
			"line",
			"linearGradient",
			"marker",
			"mask",
			"path",
			"pattern",
			"polygon",
			"polyline",
			"radialGradient",
			"rect",
			"stop",
			"svg",
			"text",
			"tspan",
		]),
		uoe = /[!"#$%&'()*+,./:;<=>?@[\\\]^`{|}~-]+/g,
		coe = /(^-|-$)/g
	function _L(e) {
		return e.replace(uoe, "-").replace(coe, "")
	}
	var doe = /(a)(d)/gi,
		V0 = 52,
		OL = function (e) {
			return String.fromCharCode(e + (e > 25 ? 39 : 97))
		}
	function GS(e) {
		var t,
			n = ""
		for (t = Math.abs(e); t > V0; t = (t / V0) | 0) n = OL(t % V0) + n
		return (OL(t % V0) + n).replace(doe, "$1-$2")
	}
	var ST,
		D9 = 5381,
		Rf = function (e, t) {
			for (var n = t.length; n; ) e = (33 * e) ^ t.charCodeAt(--n)
			return e
		},
		_9 = function (e) {
			return Rf(D9, e)
		}
	function O9(e) {
		return GS(_9(e) >>> 0)
	}
	function foe(e) {
		return e.displayName || e.name || "Component"
	}
	function DT(e) {
		return typeof e == "string" && !0
	}
	var A9 = typeof Symbol == "function" && Symbol.for,
		N9 = A9 ? Symbol.for("react.memo") : 60115,
		poe = A9 ? Symbol.for("react.forward_ref") : 60112,
		hoe = {
			childContextTypes: !0,
			contextType: !0,
			contextTypes: !0,
			defaultProps: !0,
			displayName: !0,
			getDefaultProps: !0,
			getDerivedStateFromError: !0,
			getDerivedStateFromProps: !0,
			mixins: !0,
			propTypes: !0,
			type: !0,
		},
		moe = { name: !0, length: !0, prototype: !0, caller: !0, callee: !0, arguments: !0, arity: !0 },
		M9 = { $$typeof: !0, compare: !0, defaultProps: !0, displayName: !0, propTypes: !0, type: !0 },
		voe =
			(((ST = {})[poe] = {
				$$typeof: !0,
				render: !0,
				defaultProps: !0,
				displayName: !0,
				propTypes: !0,
			}),
			(ST[N9] = M9),
			ST)
	function AL(e) {
		return ("type" in (t = e) && t.type.$$typeof) === N9
			? M9
			: "$$typeof" in e
			? voe[e.$$typeof]
			: hoe
		var t
	}
	var goe = Object.defineProperty,
		yoe = Object.getOwnPropertyNames,
		NL = Object.getOwnPropertySymbols,
		boe = Object.getOwnPropertyDescriptor,
		xoe = Object.getPrototypeOf,
		ML = Object.prototype
	function I9(e, t, n) {
		if (typeof t != "string") {
			if (ML) {
				var r = xoe(t)
				r && r !== ML && I9(e, r, n)
			}
			var i = yoe(t)
			NL && (i = i.concat(NL(t)))
			for (var a = AL(e), o = AL(t), s = 0; s < i.length; ++s) {
				var l = i[s]
				if (!(l in moe || (n && n[l]) || (o && l in o) || (a && l in a))) {
					var u = boe(t, l)
					try {
						goe(e, l, u)
					} catch {}
				}
			}
		}
		return e
	}
	function ap(e) {
		return typeof e == "function"
	}
	function N_(e) {
		return typeof e == "object" && "styledComponentId" in e
	}
	function jc(e, t) {
		return e && t ? "".concat(e, " ").concat(t) : e || t || ""
	}
	function KS(e, t) {
		if (e.length === 0) return ""
		for (var n = e[0], r = 1; r < e.length; r++) n += e[r]
		return n
	}
	function pv(e) {
		return (
			e !== null &&
			typeof e == "object" &&
			e.constructor.name === Object.name &&
			!("props" in e && e.$$typeof)
		)
	}
	function QS(e, t, n) {
		if ((n === void 0 && (n = !1), !n && !pv(e) && !Array.isArray(e))) return t
		if (Array.isArray(t)) for (var r = 0; r < t.length; r++) e[r] = QS(e[r], t[r])
		else if (pv(t)) for (var r in t) e[r] = QS(e[r], t[r])
		return e
	}
	function M_(e, t) {
		Object.defineProperty(e, "toString", { value: t })
	}
	function tg(e) {
		for (var t = [], n = 1; n < arguments.length; n++) t[n - 1] = arguments[n]
		return new Error(
			"An error occurred. See https://github.com/styled-components/styled-components/blob/main/packages/styled-components/src/utils/errors.md#"
				.concat(e, " for more information.")
				.concat(t.length > 0 ? " Args: ".concat(t.join(", ")) : ""),
		)
	}
	var woe = (function () {
			function e(t) {
				;(this.groupSizes = new Uint32Array(512)), (this.length = 512), (this.tag = t)
			}
			return (
				(e.prototype.indexOfGroup = function (t) {
					for (var n = 0, r = 0; r < t; r++) n += this.groupSizes[r]
					return n
				}),
				(e.prototype.insertRules = function (t, n) {
					if (t >= this.groupSizes.length) {
						for (var r = this.groupSizes, i = r.length, a = i; t >= a; )
							if ((a <<= 1) < 0) throw tg(16, "".concat(t))
						;(this.groupSizes = new Uint32Array(a)), this.groupSizes.set(r), (this.length = a)
						for (var o = i; o < a; o++) this.groupSizes[o] = 0
					}
					for (var s = this.indexOfGroup(t + 1), l = ((o = 0), n.length); o < l; o++)
						this.tag.insertRule(s, n[o]) && (this.groupSizes[t]++, s++)
				}),
				(e.prototype.clearGroup = function (t) {
					if (t < this.length) {
						var n = this.groupSizes[t],
							r = this.indexOfGroup(t),
							i = r + n
						this.groupSizes[t] = 0
						for (var a = r; a < i; a++) this.tag.deleteRule(r)
					}
				}),
				(e.prototype.getGroup = function (t) {
					var n = ""
					if (t >= this.length || this.groupSizes[t] === 0) return n
					for (var r = this.groupSizes[t], i = this.indexOfGroup(t), a = i + r, o = i; o < a; o++)
						n += "".concat(this.tag.getRule(o)).concat(A_)
					return n
				}),
				e
			)
		})(),
		r1 = new Map(),
		q1 = new Map(),
		i1 = 1,
		W0 = function (e) {
			if (r1.has(e)) return r1.get(e)
			for (; q1.has(i1); ) i1++
			var t = i1++
			return r1.set(e, t), q1.set(t, e), t
		},
		Eoe = function (e, t) {
			;(i1 = t + 1), r1.set(e, t), q1.set(t, e)
		},
		Coe = "style[".concat(rp, "][").concat(k9, '="').concat(Ix, '"]'),
		Toe = new RegExp("^".concat(rp, '\\.g(\\d+)\\[id="([\\w\\d-]+)"\\].*?"([^"]*)')),
		koe = function (e, t, n) {
			for (var r, i = n.split(","), a = 0, o = i.length; a < o; a++)
				(r = i[a]) && e.registerName(t, r)
		},
		Soe = function (e, t) {
			for (
				var n,
					r = ((n = t.textContent) !== null && n !== void 0 ? n : "").split(A_),
					i = [],
					a = 0,
					o = r.length;
				a < o;
				a++
			) {
				var s = r[a].trim()
				if (s) {
					var l = s.match(Toe)
					if (l) {
						var u = 0 | parseInt(l[1], 10),
							d = l[2]
						u !== 0 && (Eoe(d, u), koe(e, d, l[3]), e.getTag().insertRules(u, i)), (i.length = 0)
					} else i.push(s)
				}
			}
		},
		IL = function (e) {
			for (var t = document.querySelectorAll(Coe), n = 0, r = t.length; n < r; n++) {
				var i = t[n]
				i && i.getAttribute(rp) !== T9 && (Soe(e, i), i.parentNode && i.parentNode.removeChild(i))
			}
		}
	function Doe() {
		return typeof __webpack_nonce__ < "u" ? __webpack_nonce__ : null
	}
	var R9 = function (e) {
			var t = document.head,
				n = e || t,
				r = document.createElement("style"),
				i = (function (s) {
					var l = Array.from(s.querySelectorAll("style[".concat(rp, "]")))
					return l[l.length - 1]
				})(n),
				a = i !== void 0 ? i.nextSibling : null
			r.setAttribute(rp, T9), r.setAttribute(k9, Ix)
			var o = Doe()
			return o && r.setAttribute("nonce", o), n.insertBefore(r, a), r
		},
		_oe = (function () {
			function e(t) {
				;(this.element = R9(t)),
					this.element.appendChild(document.createTextNode("")),
					(this.sheet = (function (n) {
						if (n.sheet) return n.sheet
						for (var r = document.styleSheets, i = 0, a = r.length; i < a; i++) {
							var o = r[i]
							if (o.ownerNode === n) return o
						}
						throw tg(17)
					})(this.element)),
					(this.length = 0)
			}
			return (
				(e.prototype.insertRule = function (t, n) {
					try {
						return this.sheet.insertRule(n, t), this.length++, !0
					} catch {
						return !1
					}
				}),
				(e.prototype.deleteRule = function (t) {
					this.sheet.deleteRule(t), this.length--
				}),
				(e.prototype.getRule = function (t) {
					var n = this.sheet.cssRules[t]
					return n && n.cssText ? n.cssText : ""
				}),
				e
			)
		})(),
		Ooe = (function () {
			function e(t) {
				;(this.element = R9(t)), (this.nodes = this.element.childNodes), (this.length = 0)
			}
			return (
				(e.prototype.insertRule = function (t, n) {
					if (t <= this.length && t >= 0) {
						var r = document.createTextNode(n)
						return this.element.insertBefore(r, this.nodes[t] || null), this.length++, !0
					}
					return !1
				}),
				(e.prototype.deleteRule = function (t) {
					this.element.removeChild(this.nodes[t]), this.length--
				}),
				(e.prototype.getRule = function (t) {
					return t < this.length ? this.nodes[t].textContent : ""
				}),
				e
			)
		})(),
		Aoe = (function () {
			function e(t) {
				;(this.rules = []), (this.length = 0)
			}
			return (
				(e.prototype.insertRule = function (t, n) {
					return t <= this.length && (this.rules.splice(t, 0, n), this.length++, !0)
				}),
				(e.prototype.deleteRule = function (t) {
					this.rules.splice(t, 1), this.length--
				}),
				(e.prototype.getRule = function (t) {
					return t < this.length ? this.rules[t] : ""
				}),
				e
			)
		})(),
		RL = z1,
		Noe = { isServer: !z1, useCSSOMInjection: !soe },
		L9 = (function () {
			function e(t, n, r) {
				t === void 0 && (t = ip), n === void 0 && (n = {})
				var i = this
				;(this.options = Hi(Hi({}, Noe), t)),
					(this.gs = n),
					(this.names = new Map(r)),
					(this.server = !!t.isServer),
					!this.server && z1 && RL && ((RL = !1), IL(this)),
					M_(this, function () {
						return (function (a) {
							for (
								var o = a.getTag(),
									s = o.length,
									l = "",
									u = function (p) {
										var m = (function (E) {
											return q1.get(E)
										})(p)
										if (m === void 0) return "continue"
										var v = a.names.get(m),
											y = o.getGroup(p)
										if (v === void 0 || !v.size || y.length === 0) return "continue"
										var b = "".concat(rp, ".g").concat(p, '[id="').concat(m, '"]'),
											x = ""
										v !== void 0 &&
											v.forEach(function (E) {
												E.length > 0 && (x += "".concat(E, ","))
											}),
											(l += "".concat(y).concat(b, '{content:"').concat(x, '"}').concat(A_))
									},
									d = 0;
								d < s;
								d++
							)
								u(d)
							return l
						})(i)
					})
			}
			return (
				(e.registerId = function (t) {
					return W0(t)
				}),
				(e.prototype.rehydrate = function () {
					!this.server && z1 && IL(this)
				}),
				(e.prototype.reconstructWithOptions = function (t, n) {
					return (
						n === void 0 && (n = !0),
						new e(Hi(Hi({}, this.options), t), this.gs, (n && this.names) || void 0)
					)
				}),
				(e.prototype.allocateGSInstance = function (t) {
					return (this.gs[t] = (this.gs[t] || 0) + 1)
				}),
				(e.prototype.getTag = function () {
					return (
						this.tag ||
						(this.tag =
							((t = (function (n) {
								var r = n.useCSSOMInjection,
									i = n.target
								return n.isServer ? new Aoe(i) : r ? new _oe(i) : new Ooe(i)
							})(this.options)),
							new woe(t)))
					)
					var t
				}),
				(e.prototype.hasNameForId = function (t, n) {
					return this.names.has(t) && this.names.get(t).has(n)
				}),
				(e.prototype.registerName = function (t, n) {
					if ((W0(t), this.names.has(t))) this.names.get(t).add(n)
					else {
						var r = new Set()
						r.add(n), this.names.set(t, r)
					}
				}),
				(e.prototype.insertRules = function (t, n, r) {
					this.registerName(t, n), this.getTag().insertRules(W0(t), r)
				}),
				(e.prototype.clearNames = function (t) {
					this.names.has(t) && this.names.get(t).clear()
				}),
				(e.prototype.clearRules = function (t) {
					this.getTag().clearGroup(W0(t)), this.clearNames(t)
				}),
				(e.prototype.clearTag = function () {
					this.tag = void 0
				}),
				e
			)
		})(),
		Moe = /&/g,
		Ioe = /^\s*\/\/.*$/gm
	function P9(e, t) {
		return e.map(function (n) {
			return (
				n.type === "rule" &&
					((n.value = "".concat(t, " ").concat(n.value)),
					(n.value = n.value.replaceAll(",", ",".concat(t, " "))),
					(n.props = n.props.map(function (r) {
						return "".concat(t, " ").concat(r)
					}))),
				Array.isArray(n.children) && n.type !== "@keyframes" && (n.children = P9(n.children, t)),
				n
			)
		})
	}
	function Roe(e) {
		var t,
			n,
			r,
			i = ip,
			a = i.options,
			o = a === void 0 ? ip : a,
			s = i.plugins,
			l = s === void 0 ? Rx : s,
			u = function (m, v, y) {
				return y.startsWith(n) && y.endsWith(n) && y.replaceAll(n, "").length > 0
					? ".".concat(t)
					: m
			},
			d = l.slice()
		d.push(function (m) {
			m.type === Ox &&
				m.value.includes("&") &&
				(m.props[0] = m.props[0].replace(Moe, n).replace(r, u))
		}),
			o.prefix && d.push(aoe),
			d.push(noe)
		var p = function (m, v, y, b) {
			v === void 0 && (v = ""),
				y === void 0 && (y = ""),
				b === void 0 && (b = "&"),
				(t = b),
				(n = v),
				(r = new RegExp("\\".concat(n, "\\b"), "g"))
			var x = m.replace(Ioe, ""),
				E = eoe(y || v ? "".concat(y, " ").concat(v, " { ").concat(x, " }") : x)
			o.namespace && (E = P9(E, o.namespace))
			var T = []
			return (
				U1(
					E,
					roe(
						d.concat(
							ioe(function (C) {
								return T.push(C)
							}),
						),
					),
				),
				T
			)
		}
		return (
			(p.hash = l.length
				? l
						.reduce(function (m, v) {
							return v.name || tg(15), Rf(m, v.name)
						}, D9)
						.toString()
				: ""),
			p
		)
	}
	var Loe = new L9(),
		XS = Roe(),
		j9 = H.createContext({ shouldForwardProp: void 0, styleSheet: Loe, stylis: XS })
	j9.Consumer
	H.createContext(void 0)
	function LL() {
		return _.useContext(j9)
	}
	var F9 = (function () {
			function e(t, n) {
				var r = this
				;(this.inject = function (i, a) {
					a === void 0 && (a = XS)
					var o = r.name + a.hash
					i.hasNameForId(r.id, o) || i.insertRules(r.id, o, a(r.rules, o, "@keyframes"))
				}),
					(this.name = t),
					(this.id = "sc-keyframes-".concat(t)),
					(this.rules = n),
					M_(this, function () {
						throw tg(12, String(r.name))
					})
			}
			return (
				(e.prototype.getName = function (t) {
					return t === void 0 && (t = XS), this.name + t.hash
				}),
				e
			)
		})(),
		Poe = function (e) {
			return e >= "A" && e <= "Z"
		}
	function PL(e) {
		for (var t = "", n = 0; n < e.length; n++) {
			var r = e[n]
			if (n === 1 && r === "-" && e[0] === "-") return e
			Poe(r) ? (t += "-" + r.toLowerCase()) : (t += r)
		}
		return t.startsWith("ms-") ? "-" + t : t
	}
	var B9 = function (e) {
			return e == null || e === !1 || e === ""
		},
		H9 = function (e) {
			var t,
				n,
				r = []
			for (var i in e) {
				var a = e[i]
				e.hasOwnProperty(i) &&
					!B9(a) &&
					((Array.isArray(a) && a.isCss) || ap(a)
						? r.push("".concat(PL(i), ":"), a, ";")
						: pv(a)
						? r.push.apply(r, fv(fv(["".concat(i, " {")], H9(a), !1), ["}"], !1))
						: r.push(
								""
									.concat(PL(i), ": ")
									.concat(
										((t = i),
										(n = a) == null || typeof n == "boolean" || n === ""
											? ""
											: typeof n != "number" || n === 0 || t in ooe || t.startsWith("--")
											? String(n).trim()
											: "".concat(n, "px")),
										";",
									),
						  ))
			}
			return r
		}
	function Wc(e, t, n, r) {
		if (B9(e)) return []
		if (N_(e)) return [".".concat(e.styledComponentId)]
		if (ap(e)) {
			if (!ap((a = e)) || (a.prototype && a.prototype.isReactComponent) || !t) return [e]
			var i = e(t)
			return Wc(i, t, n, r)
		}
		var a
		return e instanceof F9
			? n
				? (e.inject(n, r), [e.getName(r)])
				: [e]
			: pv(e)
			? H9(e)
			: Array.isArray(e)
			? Array.prototype.concat.apply(
					Rx,
					e.map(function (o) {
						return Wc(o, t, n, r)
					}),
			  )
			: [e.toString()]
	}
	function joe(e) {
		for (var t = 0; t < e.length; t += 1) {
			var n = e[t]
			if (ap(n) && !N_(n)) return !1
		}
		return !0
	}
	var Foe = _9(Ix),
		Boe = (function () {
			function e(t, n, r) {
				;(this.rules = t),
					(this.staticRulesId = ""),
					(this.isStatic = (r === void 0 || r.isStatic) && joe(t)),
					(this.componentId = n),
					(this.baseHash = Rf(Foe, n)),
					(this.baseStyle = r),
					L9.registerId(n)
			}
			return (
				(e.prototype.generateAndInjectStyles = function (t, n, r) {
					var i = this.baseStyle ? this.baseStyle.generateAndInjectStyles(t, n, r) : ""
					if (this.isStatic && !r.hash)
						if (this.staticRulesId && n.hasNameForId(this.componentId, this.staticRulesId))
							i = jc(i, this.staticRulesId)
						else {
							var a = KS(Wc(this.rules, t, n, r)),
								o = GS(Rf(this.baseHash, a) >>> 0)
							if (!n.hasNameForId(this.componentId, o)) {
								var s = r(a, ".".concat(o), void 0, this.componentId)
								n.insertRules(this.componentId, o, s)
							}
							;(i = jc(i, o)), (this.staticRulesId = o)
						}
					else {
						for (var l = Rf(this.baseHash, r.hash), u = "", d = 0; d < this.rules.length; d++) {
							var p = this.rules[d]
							if (typeof p == "string") u += p
							else if (p) {
								var m = KS(Wc(p, t, n, r))
								;(l = Rf(l, m + d)), (u += m)
							}
						}
						if (u) {
							var v = GS(l >>> 0)
							n.hasNameForId(this.componentId, v) ||
								n.insertRules(this.componentId, v, r(u, ".".concat(v), void 0, this.componentId)),
								(i = jc(i, v))
						}
					}
					return i
				}),
				e
			)
		})(),
		$9 = H.createContext(void 0)
	$9.Consumer
	var _T = {}
	function Hoe(e, t, n) {
		var r = N_(e),
			i = e,
			a = !DT(e),
			o = t.attrs,
			s = o === void 0 ? Rx : o,
			l = t.componentId,
			u =
				l === void 0
					? (function (D, O) {
							var A = typeof D != "string" ? "sc" : _L(D)
							_T[A] = (_T[A] || 0) + 1
							var N = "".concat(A, "-").concat(O9(Ix + A + _T[A]))
							return O ? "".concat(O, "-").concat(N) : N
					  })(t.displayName, t.parentComponentId)
					: l,
			d = t.displayName,
			p =
				d === void 0
					? (function (D) {
							return DT(D) ? "styled.".concat(D) : "Styled(".concat(foe(D), ")")
					  })(e)
					: d,
			m =
				t.displayName && t.componentId
					? "".concat(_L(t.displayName), "-").concat(t.componentId)
					: t.componentId || u,
			v = r && i.attrs ? i.attrs.concat(s).filter(Boolean) : s,
			y = t.shouldForwardProp
		if (r && i.shouldForwardProp) {
			var b = i.shouldForwardProp
			if (t.shouldForwardProp) {
				var x = t.shouldForwardProp
				y = function (D, O) {
					return b(D, O) && x(D, O)
				}
			} else y = b
		}
		var E = new Boe(n, m, r ? i.componentStyle : void 0)
		function T(D, O) {
			return (function (A, N, I) {
				var P = A.attrs,
					L = A.componentStyle,
					B = A.defaultProps,
					z = A.foldedComponentIds,
					V = A.styledComponentId,
					K = A.target,
					ne = H.useContext($9),
					re = LL(),
					ie = A.shouldForwardProp || re.shouldForwardProp,
					J = loe(N, ne, B) || ip,
					le = (function (Se, Ee, be) {
						for (
							var Le, Be = Hi(Hi({}, Ee), { className: void 0, theme: be }), et = 0;
							et < Se.length;
							et += 1
						) {
							var pt = ap((Le = Se[et])) ? Le(Be) : Le
							for (var mt in pt)
								Be[mt] =
									mt === "className"
										? jc(Be[mt], pt[mt])
										: mt === "style"
										? Hi(Hi({}, Be[mt]), pt[mt])
										: pt[mt]
						}
						return Ee.className && (Be.className = jc(Be.className, Ee.className)), Be
					})(P, N, J),
					F = le.as || K,
					Y = {}
				for (var ee in le)
					le[ee] === void 0 ||
						ee[0] === "$" ||
						ee === "as" ||
						(ee === "theme" && le.theme === J) ||
						(ee === "forwardedAs"
							? (Y.as = le.forwardedAs)
							: (ie && !ie(ee, F)) || (Y[ee] = le[ee]))
				var $ = (function (Se, Ee) {
						var be = LL(),
							Le = Se.generateAndInjectStyles(Ee, be.styleSheet, be.stylis)
						return Le
					})(L, le),
					ge = jc(z, V)
				return (
					$ && (ge += " " + $),
					le.className && (ge += " " + le.className),
					(Y[DT(F) && !S9.has(F) ? "class" : "className"] = ge),
					(Y.ref = I),
					_.createElement(F, Y)
				)
			})(C, D, O)
		}
		T.displayName = p
		var C = H.forwardRef(T)
		return (
			(C.attrs = v),
			(C.componentStyle = E),
			(C.displayName = p),
			(C.shouldForwardProp = y),
			(C.foldedComponentIds = r ? jc(i.foldedComponentIds, i.styledComponentId) : ""),
			(C.styledComponentId = m),
			(C.target = r ? i.target : e),
			Object.defineProperty(C, "defaultProps", {
				get: function () {
					return this._foldedDefaultProps
				},
				set: function (D) {
					this._foldedDefaultProps = r
						? (function (O) {
								for (var A = [], N = 1; N < arguments.length; N++) A[N - 1] = arguments[N]
								for (var I = 0, P = A; I < P.length; I++) QS(O, P[I], !0)
								return O
						  })({}, i.defaultProps, D)
						: D
				},
			}),
			M_(C, function () {
				return ".".concat(C.styledComponentId)
			}),
			a &&
				I9(C, e, {
					attrs: !0,
					componentStyle: !0,
					displayName: !0,
					foldedComponentIds: !0,
					shouldForwardProp: !0,
					styledComponentId: !0,
					target: !0,
				}),
			C
		)
	}
	function jL(e, t) {
		for (var n = [e[0]], r = 0, i = t.length; r < i; r += 1) n.push(t[r], e[r + 1])
		return n
	}
	var FL = function (e) {
		return Object.assign(e, { isCss: !0 })
	}
	function U9(e) {
		for (var t = [], n = 1; n < arguments.length; n++) t[n - 1] = arguments[n]
		if (ap(e) || pv(e)) return FL(Wc(jL(Rx, fv([e], t, !0))))
		var r = e
		return t.length === 0 && r.length === 1 && typeof r[0] == "string" ? Wc(r) : FL(Wc(jL(r, t)))
	}
	function JS(e, t, n) {
		if ((n === void 0 && (n = ip), !t)) throw tg(1, t)
		var r = function (i) {
			for (var a = [], o = 1; o < arguments.length; o++) a[o - 1] = arguments[o]
			return e(t, n, U9.apply(void 0, fv([i], a, !1)))
		}
		return (
			(r.attrs = function (i) {
				return JS(
					e,
					t,
					Hi(Hi({}, n), { attrs: Array.prototype.concat(n.attrs, i).filter(Boolean) }),
				)
			}),
			(r.withConfig = function (i) {
				return JS(e, t, Hi(Hi({}, n), i))
			}),
			r
		)
	}
	var z9 = function (e) {
			return JS(Hoe, e)
		},
		Ft = z9
	S9.forEach(function (e) {
		Ft[e] = z9(e)
	})
	function $oe(e) {
		for (var t = [], n = 1; n < arguments.length; n++) t[n - 1] = arguments[n]
		var r = KS(U9.apply(void 0, fv([e], t, !1))),
			i = O9(r)
		return new F9(i, r)
	}
	var Uoe = function (t) {
		return zoe(t) && !qoe(t)
	}
	function zoe(e) {
		return !!e && typeof e == "object"
	}
	function qoe(e) {
		var t = Object.prototype.toString.call(e)
		return t === "[object RegExp]" || t === "[object Date]" || Yoe(e)
	}
	var Voe = typeof Symbol == "function" && Symbol.for,
		Woe = Voe ? Symbol.for("react.element") : 60103
	function Yoe(e) {
		return e.$$typeof === Woe
	}
	function Goe(e) {
		return Array.isArray(e) ? [] : {}
	}
	function V1(e, t) {
		return t.clone !== !1 && t.isMergeableObject(e) ? hv(Goe(e), e, t) : e
	}
	function Koe(e, t, n) {
		return e.concat(t).map(function (r) {
			return V1(r, n)
		})
	}
	function Qoe(e, t, n) {
		var r = {}
		return (
			n.isMergeableObject(e) &&
				Object.keys(e).forEach(function (i) {
					r[i] = V1(e[i], n)
				}),
			Object.keys(t).forEach(function (i) {
				!n.isMergeableObject(t[i]) || !e[i] ? (r[i] = V1(t[i], n)) : (r[i] = hv(e[i], t[i], n))
			}),
			r
		)
	}
	function hv(e, t, n) {
		;(n = n || {}),
			(n.arrayMerge = n.arrayMerge || Koe),
			(n.isMergeableObject = n.isMergeableObject || Uoe)
		var r = Array.isArray(t),
			i = Array.isArray(e),
			a = r === i
		return a ? (r ? n.arrayMerge(e, t, n) : Qoe(e, t, n)) : V1(t, n)
	}
	hv.all = function (t, n) {
		if (!Array.isArray(t)) throw new Error("first argument should be an array")
		return t.reduce(function (r, i) {
			return hv(r, i, n)
		}, {})
	}
	var ZS = hv,
		q9 = typeof global == "object" && global && global.Object === Object && global,
		Xoe = typeof self == "object" && self && self.Object === Object && self,
		Ss = q9 || Xoe || Function("return this")(),
		ju = Ss.Symbol,
		V9 = Object.prototype,
		Joe = V9.hasOwnProperty,
		Zoe = V9.toString,
		Jh = ju ? ju.toStringTag : void 0
	function ese(e) {
		var t = Joe.call(e, Jh),
			n = e[Jh]
		try {
			e[Jh] = void 0
			var r = !0
		} catch {}
		var i = Zoe.call(e)
		return r && (t ? (e[Jh] = n) : delete e[Jh]), i
	}
	var tse = Object.prototype,
		nse = tse.toString
	function rse(e) {
		return nse.call(e)
	}
	var ise = "[object Null]",
		ase = "[object Undefined]",
		BL = ju ? ju.toStringTag : void 0
	function Od(e) {
		return e == null ? (e === void 0 ? ase : ise) : BL && BL in Object(e) ? ese(e) : rse(e)
	}
	function W9(e, t) {
		return function (n) {
			return e(t(n))
		}
	}
	var I_ = W9(Object.getPrototypeOf, Object)
	function Ad(e) {
		return e != null && typeof e == "object"
	}
	var ose = "[object Object]",
		sse = Function.prototype,
		lse = Object.prototype,
		Y9 = sse.toString,
		use = lse.hasOwnProperty,
		cse = Y9.call(Object)
	function HL(e) {
		if (!Ad(e) || Od(e) != ose) return !1
		var t = I_(e)
		if (t === null) return !0
		var n = use.call(t, "constructor") && t.constructor
		return typeof n == "function" && n instanceof n && Y9.call(n) == cse
	}
	function dse() {
		;(this.__data__ = []), (this.size = 0)
	}
	function G9(e, t) {
		return e === t || (e !== e && t !== t)
	}
	function Lx(e, t) {
		for (var n = e.length; n--; ) if (G9(e[n][0], t)) return n
		return -1
	}
	var fse = Array.prototype,
		pse = fse.splice
	function hse(e) {
		var t = this.__data__,
			n = Lx(t, e)
		if (n < 0) return !1
		var r = t.length - 1
		return n == r ? t.pop() : pse.call(t, n, 1), --this.size, !0
	}
	function mse(e) {
		var t = this.__data__,
			n = Lx(t, e)
		return n < 0 ? void 0 : t[n][1]
	}
	function vse(e) {
		return Lx(this.__data__, e) > -1
	}
	function gse(e, t) {
		var n = this.__data__,
			r = Lx(n, e)
		return r < 0 ? (++this.size, n.push([e, t])) : (n[r][1] = t), this
	}
	function Ol(e) {
		var t = -1,
			n = e == null ? 0 : e.length
		for (this.clear(); ++t < n; ) {
			var r = e[t]
			this.set(r[0], r[1])
		}
	}
	Ol.prototype.clear = dse
	Ol.prototype.delete = hse
	Ol.prototype.get = mse
	Ol.prototype.has = vse
	Ol.prototype.set = gse
	function yse() {
		;(this.__data__ = new Ol()), (this.size = 0)
	}
	function bse(e) {
		var t = this.__data__,
			n = t.delete(e)
		return (this.size = t.size), n
	}
	function xse(e) {
		return this.__data__.get(e)
	}
	function wse(e) {
		return this.__data__.has(e)
	}
	function ng(e) {
		var t = typeof e
		return e != null && (t == "object" || t == "function")
	}
	var Ese = "[object AsyncFunction]",
		Cse = "[object Function]",
		Tse = "[object GeneratorFunction]",
		kse = "[object Proxy]"
	function K9(e) {
		if (!ng(e)) return !1
		var t = Od(e)
		return t == Cse || t == Tse || t == Ese || t == kse
	}
	var OT = Ss["__core-js_shared__"],
		$L = (function () {
			var e = /[^.]+$/.exec((OT && OT.keys && OT.keys.IE_PROTO) || "")
			return e ? "Symbol(src)_1." + e : ""
		})()
	function Sse(e) {
		return !!$L && $L in e
	}
	var Dse = Function.prototype,
		_se = Dse.toString
	function Nd(e) {
		if (e != null) {
			try {
				return _se.call(e)
			} catch {}
			try {
				return e + ""
			} catch {}
		}
		return ""
	}
	var Ose = /[\\^$.*+?()[\]{}|]/g,
		Ase = /^\[object .+?Constructor\]$/,
		Nse = Function.prototype,
		Mse = Object.prototype,
		Ise = Nse.toString,
		Rse = Mse.hasOwnProperty,
		Lse = RegExp(
			"^" +
				Ise.call(Rse)
					.replace(Ose, "\\$&")
					.replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") +
				"$",
		)
	function Pse(e) {
		if (!ng(e) || Sse(e)) return !1
		var t = K9(e) ? Lse : Ase
		return t.test(Nd(e))
	}
	function jse(e, t) {
		return e == null ? void 0 : e[t]
	}
	function Md(e, t) {
		var n = jse(e, t)
		return Pse(n) ? n : void 0
	}
	var mv = Md(Ss, "Map"),
		vv = Md(Object, "create")
	function Fse() {
		;(this.__data__ = vv ? vv(null) : {}), (this.size = 0)
	}
	function Bse(e) {
		var t = this.has(e) && delete this.__data__[e]
		return (this.size -= t ? 1 : 0), t
	}
	var Hse = "__lodash_hash_undefined__",
		$se = Object.prototype,
		Use = $se.hasOwnProperty
	function zse(e) {
		var t = this.__data__
		if (vv) {
			var n = t[e]
			return n === Hse ? void 0 : n
		}
		return Use.call(t, e) ? t[e] : void 0
	}
	var qse = Object.prototype,
		Vse = qse.hasOwnProperty
	function Wse(e) {
		var t = this.__data__
		return vv ? t[e] !== void 0 : Vse.call(t, e)
	}
	var Yse = "__lodash_hash_undefined__"
	function Gse(e, t) {
		var n = this.__data__
		return (this.size += this.has(e) ? 0 : 1), (n[e] = vv && t === void 0 ? Yse : t), this
	}
	function cd(e) {
		var t = -1,
			n = e == null ? 0 : e.length
		for (this.clear(); ++t < n; ) {
			var r = e[t]
			this.set(r[0], r[1])
		}
	}
	cd.prototype.clear = Fse
	cd.prototype.delete = Bse
	cd.prototype.get = zse
	cd.prototype.has = Wse
	cd.prototype.set = Gse
	function Kse() {
		;(this.size = 0), (this.__data__ = { hash: new cd(), map: new (mv || Ol)(), string: new cd() })
	}
	function Qse(e) {
		var t = typeof e
		return t == "string" || t == "number" || t == "symbol" || t == "boolean"
			? e !== "__proto__"
			: e === null
	}
	function Px(e, t) {
		var n = e.__data__
		return Qse(t) ? n[typeof t == "string" ? "string" : "hash"] : n.map
	}
	function Xse(e) {
		var t = Px(this, e).delete(e)
		return (this.size -= t ? 1 : 0), t
	}
	function Jse(e) {
		return Px(this, e).get(e)
	}
	function Zse(e) {
		return Px(this, e).has(e)
	}
	function ele(e, t) {
		var n = Px(this, e),
			r = n.size
		return n.set(e, t), (this.size += n.size == r ? 0 : 1), this
	}
	function Gu(e) {
		var t = -1,
			n = e == null ? 0 : e.length
		for (this.clear(); ++t < n; ) {
			var r = e[t]
			this.set(r[0], r[1])
		}
	}
	Gu.prototype.clear = Kse
	Gu.prototype.delete = Xse
	Gu.prototype.get = Jse
	Gu.prototype.has = Zse
	Gu.prototype.set = ele
	var tle = 200
	function nle(e, t) {
		var n = this.__data__
		if (n instanceof Ol) {
			var r = n.__data__
			if (!mv || r.length < tle - 1) return r.push([e, t]), (this.size = ++n.size), this
			n = this.__data__ = new Gu(r)
		}
		return n.set(e, t), (this.size = n.size), this
	}
	function Xp(e) {
		var t = (this.__data__ = new Ol(e))
		this.size = t.size
	}
	Xp.prototype.clear = yse
	Xp.prototype.delete = bse
	Xp.prototype.get = xse
	Xp.prototype.has = wse
	Xp.prototype.set = nle
	function rle(e, t) {
		for (var n = -1, r = e == null ? 0 : e.length; ++n < r && t(e[n], n, e) !== !1; );
		return e
	}
	var UL = (function () {
		try {
			var e = Md(Object, "defineProperty")
			return e({}, "", {}), e
		} catch {}
	})()
	function Q9(e, t, n) {
		t == "__proto__" && UL
			? UL(e, t, { configurable: !0, enumerable: !0, value: n, writable: !0 })
			: (e[t] = n)
	}
	var ile = Object.prototype,
		ale = ile.hasOwnProperty
	function X9(e, t, n) {
		var r = e[t]
		;(!(ale.call(e, t) && G9(r, n)) || (n === void 0 && !(t in e))) && Q9(e, t, n)
	}
	function jx(e, t, n, r) {
		var i = !n
		n || (n = {})
		for (var a = -1, o = t.length; ++a < o; ) {
			var s = t[a],
				l = void 0
			l === void 0 && (l = e[s]), i ? Q9(n, s, l) : X9(n, s, l)
		}
		return n
	}
	function ole(e, t) {
		for (var n = -1, r = Array(e); ++n < e; ) r[n] = t(n)
		return r
	}
	var sle = "[object Arguments]"
	function zL(e) {
		return Ad(e) && Od(e) == sle
	}
	var J9 = Object.prototype,
		lle = J9.hasOwnProperty,
		ule = J9.propertyIsEnumerable,
		cle = zL(
			(function () {
				return arguments
			})(),
		)
			? zL
			: function (e) {
					return Ad(e) && lle.call(e, "callee") && !ule.call(e, "callee")
			  },
		rg = Array.isArray
	function dle() {
		return !1
	}
	var Z9 = typeof pa == "object" && pa && !pa.nodeType && pa,
		qL = Z9 && typeof ei == "object" && ei && !ei.nodeType && ei,
		fle = qL && qL.exports === Z9,
		VL = fle ? Ss.Buffer : void 0,
		ple = VL ? VL.isBuffer : void 0,
		eH = ple || dle,
		hle = 9007199254740991,
		mle = /^(?:0|[1-9]\d*)$/
	function vle(e, t) {
		var n = typeof e
		return (
			(t = t ?? hle),
			!!t && (n == "number" || (n != "symbol" && mle.test(e))) && e > -1 && e % 1 == 0 && e < t
		)
	}
	var gle = 9007199254740991
	function tH(e) {
		return typeof e == "number" && e > -1 && e % 1 == 0 && e <= gle
	}
	var yle = "[object Arguments]",
		ble = "[object Array]",
		xle = "[object Boolean]",
		wle = "[object Date]",
		Ele = "[object Error]",
		Cle = "[object Function]",
		Tle = "[object Map]",
		kle = "[object Number]",
		Sle = "[object Object]",
		Dle = "[object RegExp]",
		_le = "[object Set]",
		Ole = "[object String]",
		Ale = "[object WeakMap]",
		Nle = "[object ArrayBuffer]",
		Mle = "[object DataView]",
		Ile = "[object Float32Array]",
		Rle = "[object Float64Array]",
		Lle = "[object Int8Array]",
		Ple = "[object Int16Array]",
		jle = "[object Int32Array]",
		Fle = "[object Uint8Array]",
		Ble = "[object Uint8ClampedArray]",
		Hle = "[object Uint16Array]",
		$le = "[object Uint32Array]",
		bn = {}
	bn[Ile] = bn[Rle] = bn[Lle] = bn[Ple] = bn[jle] = bn[Fle] = bn[Ble] = bn[Hle] = bn[$le] = !0
	bn[yle] =
		bn[ble] =
		bn[Nle] =
		bn[xle] =
		bn[Mle] =
		bn[wle] =
		bn[Ele] =
		bn[Cle] =
		bn[Tle] =
		bn[kle] =
		bn[Sle] =
		bn[Dle] =
		bn[_le] =
		bn[Ole] =
		bn[Ale] =
			!1
	function Ule(e) {
		return Ad(e) && tH(e.length) && !!bn[Od(e)]
	}
	function R_(e) {
		return function (t) {
			return e(t)
		}
	}
	var nH = typeof pa == "object" && pa && !pa.nodeType && pa,
		Rm = nH && typeof ei == "object" && ei && !ei.nodeType && ei,
		zle = Rm && Rm.exports === nH,
		AT = zle && q9.process,
		op = (function () {
			try {
				var e = Rm && Rm.require && Rm.require("util").types
				return e || (AT && AT.binding && AT.binding("util"))
			} catch {}
		})(),
		WL = op && op.isTypedArray,
		qle = WL ? R_(WL) : Ule,
		Vle = Object.prototype,
		Wle = Vle.hasOwnProperty
	function rH(e, t) {
		var n = rg(e),
			r = !n && cle(e),
			i = !n && !r && eH(e),
			a = !n && !r && !i && qle(e),
			o = n || r || i || a,
			s = o ? ole(e.length, String) : [],
			l = s.length
		for (var u in e)
			(t || Wle.call(e, u)) &&
				!(
					o &&
					(u == "length" ||
						(i && (u == "offset" || u == "parent")) ||
						(a && (u == "buffer" || u == "byteLength" || u == "byteOffset")) ||
						vle(u, l))
				) &&
				s.push(u)
		return s
	}
	var Yle = Object.prototype
	function L_(e) {
		var t = e && e.constructor,
			n = (typeof t == "function" && t.prototype) || Yle
		return e === n
	}
	var Gle = W9(Object.keys, Object),
		Kle = Object.prototype,
		Qle = Kle.hasOwnProperty
	function Xle(e) {
		if (!L_(e)) return Gle(e)
		var t = []
		for (var n in Object(e)) Qle.call(e, n) && n != "constructor" && t.push(n)
		return t
	}
	function iH(e) {
		return e != null && tH(e.length) && !K9(e)
	}
	function P_(e) {
		return iH(e) ? rH(e) : Xle(e)
	}
	function Jle(e, t) {
		return e && jx(t, P_(t), e)
	}
	function Zle(e) {
		var t = []
		if (e != null) for (var n in Object(e)) t.push(n)
		return t
	}
	var eue = Object.prototype,
		tue = eue.hasOwnProperty
	function nue(e) {
		if (!ng(e)) return Zle(e)
		var t = L_(e),
			n = []
		for (var r in e) (r == "constructor" && (t || !tue.call(e, r))) || n.push(r)
		return n
	}
	function j_(e) {
		return iH(e) ? rH(e, !0) : nue(e)
	}
	function rue(e, t) {
		return e && jx(t, j_(t), e)
	}
	var aH = typeof pa == "object" && pa && !pa.nodeType && pa,
		YL = aH && typeof ei == "object" && ei && !ei.nodeType && ei,
		iue = YL && YL.exports === aH,
		GL = iue ? Ss.Buffer : void 0,
		KL = GL ? GL.allocUnsafe : void 0
	function aue(e, t) {
		if (t) return e.slice()
		var n = e.length,
			r = KL ? KL(n) : new e.constructor(n)
		return e.copy(r), r
	}
	function oH(e, t) {
		var n = -1,
			r = e.length
		for (t || (t = Array(r)); ++n < r; ) t[n] = e[n]
		return t
	}
	function oue(e, t) {
		for (var n = -1, r = e == null ? 0 : e.length, i = 0, a = []; ++n < r; ) {
			var o = e[n]
			t(o, n, e) && (a[i++] = o)
		}
		return a
	}
	function sH() {
		return []
	}
	var sue = Object.prototype,
		lue = sue.propertyIsEnumerable,
		QL = Object.getOwnPropertySymbols,
		F_ = QL
			? function (e) {
					return e == null
						? []
						: ((e = Object(e)),
						  oue(QL(e), function (t) {
								return lue.call(e, t)
						  }))
			  }
			: sH
	function uue(e, t) {
		return jx(e, F_(e), t)
	}
	function lH(e, t) {
		for (var n = -1, r = t.length, i = e.length; ++n < r; ) e[i + n] = t[n]
		return e
	}
	var cue = Object.getOwnPropertySymbols,
		uH = cue
			? function (e) {
					for (var t = []; e; ) lH(t, F_(e)), (e = I_(e))
					return t
			  }
			: sH
	function due(e, t) {
		return jx(e, uH(e), t)
	}
	function cH(e, t, n) {
		var r = t(e)
		return rg(e) ? r : lH(r, n(e))
	}
	function fue(e) {
		return cH(e, P_, F_)
	}
	function pue(e) {
		return cH(e, j_, uH)
	}
	var e2 = Md(Ss, "DataView"),
		t2 = Md(Ss, "Promise"),
		n2 = Md(Ss, "Set"),
		r2 = Md(Ss, "WeakMap"),
		XL = "[object Map]",
		hue = "[object Object]",
		JL = "[object Promise]",
		ZL = "[object Set]",
		eP = "[object WeakMap]",
		tP = "[object DataView]",
		mue = Nd(e2),
		vue = Nd(mv),
		gue = Nd(t2),
		yue = Nd(n2),
		bue = Nd(r2),
		Ks = Od
	;((e2 && Ks(new e2(new ArrayBuffer(1))) != tP) ||
		(mv && Ks(new mv()) != XL) ||
		(t2 && Ks(t2.resolve()) != JL) ||
		(n2 && Ks(new n2()) != ZL) ||
		(r2 && Ks(new r2()) != eP)) &&
		(Ks = function (e) {
			var t = Od(e),
				n = t == hue ? e.constructor : void 0,
				r = n ? Nd(n) : ""
			if (r)
				switch (r) {
					case mue:
						return tP
					case vue:
						return XL
					case gue:
						return JL
					case yue:
						return ZL
					case bue:
						return eP
				}
			return t
		})
	var xue = Object.prototype,
		wue = xue.hasOwnProperty
	function Eue(e) {
		var t = e.length,
			n = new e.constructor(t)
		return (
			t &&
				typeof e[0] == "string" &&
				wue.call(e, "index") &&
				((n.index = e.index), (n.input = e.input)),
			n
		)
	}
	var nP = Ss.Uint8Array
	function B_(e) {
		var t = new e.constructor(e.byteLength)
		return new nP(t).set(new nP(e)), t
	}
	function Cue(e, t) {
		var n = t ? B_(e.buffer) : e.buffer
		return new e.constructor(n, e.byteOffset, e.byteLength)
	}
	var Tue = /\w*$/
	function kue(e) {
		var t = new e.constructor(e.source, Tue.exec(e))
		return (t.lastIndex = e.lastIndex), t
	}
	var rP = ju ? ju.prototype : void 0,
		iP = rP ? rP.valueOf : void 0
	function Sue(e) {
		return iP ? Object(iP.call(e)) : {}
	}
	function Due(e, t) {
		var n = t ? B_(e.buffer) : e.buffer
		return new e.constructor(n, e.byteOffset, e.length)
	}
	var _ue = "[object Boolean]",
		Oue = "[object Date]",
		Aue = "[object Map]",
		Nue = "[object Number]",
		Mue = "[object RegExp]",
		Iue = "[object Set]",
		Rue = "[object String]",
		Lue = "[object Symbol]",
		Pue = "[object ArrayBuffer]",
		jue = "[object DataView]",
		Fue = "[object Float32Array]",
		Bue = "[object Float64Array]",
		Hue = "[object Int8Array]",
		$ue = "[object Int16Array]",
		Uue = "[object Int32Array]",
		zue = "[object Uint8Array]",
		que = "[object Uint8ClampedArray]",
		Vue = "[object Uint16Array]",
		Wue = "[object Uint32Array]"
	function Yue(e, t, n) {
		var r = e.constructor
		switch (t) {
			case Pue:
				return B_(e)
			case _ue:
			case Oue:
				return new r(+e)
			case jue:
				return Cue(e, n)
			case Fue:
			case Bue:
			case Hue:
			case $ue:
			case Uue:
			case zue:
			case que:
			case Vue:
			case Wue:
				return Due(e, n)
			case Aue:
				return new r()
			case Nue:
			case Rue:
				return new r(e)
			case Mue:
				return kue(e)
			case Iue:
				return new r()
			case Lue:
				return Sue(e)
		}
	}
	var aP = Object.create,
		Gue = (function () {
			function e() {}
			return function (t) {
				if (!ng(t)) return {}
				if (aP) return aP(t)
				e.prototype = t
				var n = new e()
				return (e.prototype = void 0), n
			}
		})()
	function Kue(e) {
		return typeof e.constructor == "function" && !L_(e) ? Gue(I_(e)) : {}
	}
	var Que = "[object Map]"
	function Xue(e) {
		return Ad(e) && Ks(e) == Que
	}
	var oP = op && op.isMap,
		Jue = oP ? R_(oP) : Xue,
		Zue = "[object Set]"
	function ece(e) {
		return Ad(e) && Ks(e) == Zue
	}
	var sP = op && op.isSet,
		tce = sP ? R_(sP) : ece,
		nce = 1,
		rce = 2,
		ice = 4,
		dH = "[object Arguments]",
		ace = "[object Array]",
		oce = "[object Boolean]",
		sce = "[object Date]",
		lce = "[object Error]",
		fH = "[object Function]",
		uce = "[object GeneratorFunction]",
		cce = "[object Map]",
		dce = "[object Number]",
		pH = "[object Object]",
		fce = "[object RegExp]",
		pce = "[object Set]",
		hce = "[object String]",
		mce = "[object Symbol]",
		vce = "[object WeakMap]",
		gce = "[object ArrayBuffer]",
		yce = "[object DataView]",
		bce = "[object Float32Array]",
		xce = "[object Float64Array]",
		wce = "[object Int8Array]",
		Ece = "[object Int16Array]",
		Cce = "[object Int32Array]",
		Tce = "[object Uint8Array]",
		kce = "[object Uint8ClampedArray]",
		Sce = "[object Uint16Array]",
		Dce = "[object Uint32Array]",
		fn = {}
	fn[dH] =
		fn[ace] =
		fn[gce] =
		fn[yce] =
		fn[oce] =
		fn[sce] =
		fn[bce] =
		fn[xce] =
		fn[wce] =
		fn[Ece] =
		fn[Cce] =
		fn[cce] =
		fn[dce] =
		fn[pH] =
		fn[fce] =
		fn[pce] =
		fn[hce] =
		fn[mce] =
		fn[Tce] =
		fn[kce] =
		fn[Sce] =
		fn[Dce] =
			!0
	fn[lce] = fn[fH] = fn[vce] = !1
	function Lm(e, t, n, r, i, a) {
		var o,
			s = t & nce,
			l = t & rce,
			u = t & ice
		if (o !== void 0) return o
		if (!ng(e)) return e
		var d = rg(e)
		if (d) {
			if (((o = Eue(e)), !s)) return oH(e, o)
		} else {
			var p = Ks(e),
				m = p == fH || p == uce
			if (eH(e)) return aue(e, s)
			if (p == pH || p == dH || (m && !i)) {
				if (((o = l || m ? {} : Kue(e)), !s)) return l ? due(e, rue(o, e)) : uue(e, Jle(o, e))
			} else {
				if (!fn[p]) return i ? e : {}
				o = Yue(e, p, s)
			}
		}
		a || (a = new Xp())
		var v = a.get(e)
		if (v) return v
		a.set(e, o),
			tce(e)
				? e.forEach(function (x) {
						o.add(Lm(x, t, n, x, e, a))
				  })
				: Jue(e) &&
				  e.forEach(function (x, E) {
						o.set(E, Lm(x, t, n, E, e, a))
				  })
		var y = u ? (l ? pue : fue) : l ? j_ : P_,
			b = d ? void 0 : y(e)
		return (
			rle(b || e, function (x, E) {
				b && ((E = x), (x = e[E])), X9(o, E, Lm(x, t, n, E, e, a))
			}),
			o
		)
	}
	var _ce = 1,
		Oce = 4
	function Y0(e) {
		return Lm(e, _ce | Oce)
	}
	var NT, lP
	function Ace() {
		if (lP) return NT
		lP = 1
		var e = Array.isArray,
			t = Object.keys,
			n = Object.prototype.hasOwnProperty,
			r = typeof Element < "u"
		function i(a, o) {
			if (a === o) return !0
			if (a && o && typeof a == "object" && typeof o == "object") {
				var s = e(a),
					l = e(o),
					u,
					d,
					p
				if (s && l) {
					if (((d = a.length), d != o.length)) return !1
					for (u = d; u-- !== 0; ) if (!i(a[u], o[u])) return !1
					return !0
				}
				if (s != l) return !1
				var m = a instanceof Date,
					v = o instanceof Date
				if (m != v) return !1
				if (m && v) return a.getTime() == o.getTime()
				var y = a instanceof RegExp,
					b = o instanceof RegExp
				if (y != b) return !1
				if (y && b) return a.toString() == o.toString()
				var x = t(a)
				if (((d = x.length), d !== t(o).length)) return !1
				for (u = d; u-- !== 0; ) if (!n.call(o, x[u])) return !1
				if (r && a instanceof Element && o instanceof Element) return a === o
				for (u = d; u-- !== 0; )
					if (((p = x[u]), !(p === "_owner" && a.$$typeof) && !i(a[p], o[p]))) return !1
				return !0
			}
			return a !== a && o !== o
		}
		return (
			(NT = function (o, s) {
				try {
					return i(o, s)
				} catch (l) {
					if ((l.message && l.message.match(/stack|recursion/i)) || l.number === -2146828260)
						return (
							console.warn(
								"Warning: react-fast-compare does not handle circular references.",
								l.name,
								l.message,
							),
							!1
						)
					throw l
				}
			}),
			NT
		)
	}
	var Nce = Ace()
	const Oc = Ti(Nce)
	var Mce = 4
	function uP(e) {
		return Lm(e, Mce)
	}
	function hH(e, t) {
		for (var n = -1, r = e == null ? 0 : e.length, i = Array(r); ++n < r; ) i[n] = t(e[n], n, e)
		return i
	}
	var Ice = "[object Symbol]"
	function H_(e) {
		return typeof e == "symbol" || (Ad(e) && Od(e) == Ice)
	}
	var Rce = "Expected a function"
	function $_(e, t) {
		if (typeof e != "function" || (t != null && typeof t != "function")) throw new TypeError(Rce)
		var n = function () {
			var r = arguments,
				i = t ? t.apply(this, r) : r[0],
				a = n.cache
			if (a.has(i)) return a.get(i)
			var o = e.apply(this, r)
			return (n.cache = a.set(i, o) || a), o
		}
		return (n.cache = new ($_.Cache || Gu)()), n
	}
	$_.Cache = Gu
	var Lce = 500
	function Pce(e) {
		var t = $_(e, function (r) {
				return n.size === Lce && n.clear(), r
			}),
			n = t.cache
		return t
	}
	var jce =
			/[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,
		Fce = /\\(\\)?/g,
		Bce = Pce(function (e) {
			var t = []
			return (
				e.charCodeAt(0) === 46 && t.push(""),
				e.replace(jce, function (n, r, i, a) {
					t.push(i ? a.replace(Fce, "$1") : r || n)
				}),
				t
			)
		}),
		Hce = 1 / 0
	function $ce(e) {
		if (typeof e == "string" || H_(e)) return e
		var t = e + ""
		return t == "0" && 1 / e == -Hce ? "-0" : t
	}
	var Uce = 1 / 0,
		cP = ju ? ju.prototype : void 0,
		dP = cP ? cP.toString : void 0
	function mH(e) {
		if (typeof e == "string") return e
		if (rg(e)) return hH(e, mH) + ""
		if (H_(e)) return dP ? dP.call(e) : ""
		var t = e + ""
		return t == "0" && 1 / e == -Uce ? "-0" : t
	}
	function zce(e) {
		return e == null ? "" : mH(e)
	}
	function vH(e) {
		return rg(e) ? hH(e, $ce) : H_(e) ? [e] : oH(Bce(zce(e)))
	}
	var MT = { exports: {} },
		Gt = {}
	/** @license React v16.13.1
	 * react-is.production.min.js
	 *
	 * Copyright (c) Facebook, Inc. and its affiliates.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */ var fP
	function qce() {
		if (fP) return Gt
		fP = 1
		var e = typeof Symbol == "function" && Symbol.for,
			t = e ? Symbol.for("react.element") : 60103,
			n = e ? Symbol.for("react.portal") : 60106,
			r = e ? Symbol.for("react.fragment") : 60107,
			i = e ? Symbol.for("react.strict_mode") : 60108,
			a = e ? Symbol.for("react.profiler") : 60114,
			o = e ? Symbol.for("react.provider") : 60109,
			s = e ? Symbol.for("react.context") : 60110,
			l = e ? Symbol.for("react.async_mode") : 60111,
			u = e ? Symbol.for("react.concurrent_mode") : 60111,
			d = e ? Symbol.for("react.forward_ref") : 60112,
			p = e ? Symbol.for("react.suspense") : 60113,
			m = e ? Symbol.for("react.suspense_list") : 60120,
			v = e ? Symbol.for("react.memo") : 60115,
			y = e ? Symbol.for("react.lazy") : 60116,
			b = e ? Symbol.for("react.block") : 60121,
			x = e ? Symbol.for("react.fundamental") : 60117,
			E = e ? Symbol.for("react.responder") : 60118,
			T = e ? Symbol.for("react.scope") : 60119
		function C(O) {
			if (typeof O == "object" && O !== null) {
				var A = O.$$typeof
				switch (A) {
					case t:
						switch (((O = O.type), O)) {
							case l:
							case u:
							case r:
							case a:
							case i:
							case p:
								return O
							default:
								switch (((O = O && O.$$typeof), O)) {
									case s:
									case d:
									case y:
									case v:
									case o:
										return O
									default:
										return A
								}
						}
					case n:
						return A
				}
			}
		}
		function D(O) {
			return C(O) === u
		}
		return (
			(Gt.AsyncMode = l),
			(Gt.ConcurrentMode = u),
			(Gt.ContextConsumer = s),
			(Gt.ContextProvider = o),
			(Gt.Element = t),
			(Gt.ForwardRef = d),
			(Gt.Fragment = r),
			(Gt.Lazy = y),
			(Gt.Memo = v),
			(Gt.Portal = n),
			(Gt.Profiler = a),
			(Gt.StrictMode = i),
			(Gt.Suspense = p),
			(Gt.isAsyncMode = function (O) {
				return D(O) || C(O) === l
			}),
			(Gt.isConcurrentMode = D),
			(Gt.isContextConsumer = function (O) {
				return C(O) === s
			}),
			(Gt.isContextProvider = function (O) {
				return C(O) === o
			}),
			(Gt.isElement = function (O) {
				return typeof O == "object" && O !== null && O.$$typeof === t
			}),
			(Gt.isForwardRef = function (O) {
				return C(O) === d
			}),
			(Gt.isFragment = function (O) {
				return C(O) === r
			}),
			(Gt.isLazy = function (O) {
				return C(O) === y
			}),
			(Gt.isMemo = function (O) {
				return C(O) === v
			}),
			(Gt.isPortal = function (O) {
				return C(O) === n
			}),
			(Gt.isProfiler = function (O) {
				return C(O) === a
			}),
			(Gt.isStrictMode = function (O) {
				return C(O) === i
			}),
			(Gt.isSuspense = function (O) {
				return C(O) === p
			}),
			(Gt.isValidElementType = function (O) {
				return (
					typeof O == "string" ||
					typeof O == "function" ||
					O === r ||
					O === u ||
					O === a ||
					O === i ||
					O === p ||
					O === m ||
					(typeof O == "object" &&
						O !== null &&
						(O.$$typeof === y ||
							O.$$typeof === v ||
							O.$$typeof === o ||
							O.$$typeof === s ||
							O.$$typeof === d ||
							O.$$typeof === x ||
							O.$$typeof === E ||
							O.$$typeof === T ||
							O.$$typeof === b))
				)
			}),
			(Gt.typeOf = C),
			Gt
		)
	}
	var pP
	function Vce() {
		return pP || ((pP = 1), (MT.exports = qce())), MT.exports
	}
	var IT, hP
	function Wce() {
		if (hP) return IT
		hP = 1
		var e = Vce(),
			t = {
				childContextTypes: !0,
				contextType: !0,
				contextTypes: !0,
				defaultProps: !0,
				displayName: !0,
				getDefaultProps: !0,
				getDerivedStateFromError: !0,
				getDerivedStateFromProps: !0,
				mixins: !0,
				propTypes: !0,
				type: !0,
			},
			n = { name: !0, length: !0, prototype: !0, caller: !0, callee: !0, arguments: !0, arity: !0 },
			r = { $$typeof: !0, render: !0, defaultProps: !0, displayName: !0, propTypes: !0 },
			i = { $$typeof: !0, compare: !0, defaultProps: !0, displayName: !0, propTypes: !0, type: !0 },
			a = {}
		;(a[e.ForwardRef] = r), (a[e.Memo] = i)
		function o(y) {
			return e.isMemo(y) ? i : a[y.$$typeof] || t
		}
		var s = Object.defineProperty,
			l = Object.getOwnPropertyNames,
			u = Object.getOwnPropertySymbols,
			d = Object.getOwnPropertyDescriptor,
			p = Object.getPrototypeOf,
			m = Object.prototype
		function v(y, b, x) {
			if (typeof b != "string") {
				if (m) {
					var E = p(b)
					E && E !== m && v(y, E, x)
				}
				var T = l(b)
				u && (T = T.concat(u(b)))
				for (var C = o(y), D = o(b), O = 0; O < T.length; ++O) {
					var A = T[O]
					if (!n[A] && !(x && x[A]) && !(D && D[A]) && !(C && C[A])) {
						var N = d(b, A)
						try {
							s(y, A, N)
						} catch {}
					}
				}
			}
			return y
		}
		return (IT = v), IT
	}
	Wce()
	function kr() {
		return (
			(kr =
				Object.assign ||
				function (e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t]
						for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r])
					}
					return e
				}),
			kr.apply(this, arguments)
		)
	}
	function gH(e, t) {
		if (e == null) return {}
		var n = {},
			r = Object.keys(e),
			i,
			a
		for (a = 0; a < r.length; a++) (i = r[a]), !(t.indexOf(i) >= 0) && (n[i] = e[i])
		return n
	}
	var Fx = _.createContext(void 0)
	Fx.displayName = "FormikContext"
	var Yce = Fx.Provider
	Fx.Consumer
	function Bx() {
		var e = _.useContext(Fx)
		return e
	}
	var Ra = function (t) {
			return typeof t == "function"
		},
		ig = function (t) {
			return t !== null && typeof t == "object"
		},
		Gce = function (t) {
			return String(Math.floor(Number(t))) === t
		},
		RT = function (t) {
			return Object.prototype.toString.call(t) === "[object String]"
		},
		Kce = function (t) {
			return _.Children.count(t) === 0
		},
		LT = function (t) {
			return ig(t) && Ra(t.then)
		}
	function na(e, t, n, r) {
		r === void 0 && (r = 0)
		for (var i = vH(t); e && r < i.length; ) e = e[i[r++]]
		return (r !== i.length && !e) || e === void 0 ? n : e
	}
	function Yc(e, t, n) {
		for (var r = uP(e), i = r, a = 0, o = vH(t); a < o.length - 1; a++) {
			var s = o[a],
				l = na(e, o.slice(0, a + 1))
			if (l && (ig(l) || Array.isArray(l))) i = i[s] = uP(l)
			else {
				var u = o[a + 1]
				i = i[s] = Gce(u) && Number(u) >= 0 ? [] : {}
			}
		}
		return (a === 0 ? e : i)[o[a]] === n
			? e
			: (n === void 0 ? delete i[o[a]] : (i[o[a]] = n),
			  a === 0 && n === void 0 && delete r[o[a]],
			  r)
	}
	function yH(e, t, n, r) {
		n === void 0 && (n = new WeakMap()), r === void 0 && (r = {})
		for (var i = 0, a = Object.keys(e); i < a.length; i++) {
			var o = a[i],
				s = e[o]
			ig(s)
				? n.get(s) || (n.set(s, !0), (r[o] = Array.isArray(s) ? [] : {}), yH(s, t, n, r[o]))
				: (r[o] = t)
		}
		return r
	}
	function Qce(e, t) {
		switch (t.type) {
			case "SET_VALUES":
				return kr({}, e, { values: t.payload })
			case "SET_TOUCHED":
				return kr({}, e, { touched: t.payload })
			case "SET_ERRORS":
				return Oc(e.errors, t.payload) ? e : kr({}, e, { errors: t.payload })
			case "SET_STATUS":
				return kr({}, e, { status: t.payload })
			case "SET_ISSUBMITTING":
				return kr({}, e, { isSubmitting: t.payload })
			case "SET_ISVALIDATING":
				return kr({}, e, { isValidating: t.payload })
			case "SET_FIELD_VALUE":
				return kr({}, e, { values: Yc(e.values, t.payload.field, t.payload.value) })
			case "SET_FIELD_TOUCHED":
				return kr({}, e, { touched: Yc(e.touched, t.payload.field, t.payload.value) })
			case "SET_FIELD_ERROR":
				return kr({}, e, { errors: Yc(e.errors, t.payload.field, t.payload.value) })
			case "RESET_FORM":
				return kr({}, e, t.payload)
			case "SET_FORMIK_STATE":
				return t.payload(e)
			case "SUBMIT_ATTEMPT":
				return kr({}, e, {
					touched: yH(e.values, !0),
					isSubmitting: !0,
					submitCount: e.submitCount + 1,
				})
			case "SUBMIT_FAILURE":
				return kr({}, e, { isSubmitting: !1 })
			case "SUBMIT_SUCCESS":
				return kr({}, e, { isSubmitting: !1 })
			default:
				return e
		}
	}
	var wc = {},
		G0 = {}
	function Xce(e) {
		var t = e.validateOnChange,
			n = t === void 0 ? !0 : t,
			r = e.validateOnBlur,
			i = r === void 0 ? !0 : r,
			a = e.validateOnMount,
			o = a === void 0 ? !1 : a,
			s = e.isInitialValid,
			l = e.enableReinitialize,
			u = l === void 0 ? !1 : l,
			d = e.onSubmit,
			p = gH(e, [
				"validateOnChange",
				"validateOnBlur",
				"validateOnMount",
				"isInitialValid",
				"enableReinitialize",
				"onSubmit",
			]),
			m = kr({ validateOnChange: n, validateOnBlur: i, validateOnMount: o, onSubmit: d }, p),
			v = _.useRef(m.initialValues),
			y = _.useRef(m.initialErrors || wc),
			b = _.useRef(m.initialTouched || G0),
			x = _.useRef(m.initialStatus),
			E = _.useRef(!1),
			T = _.useRef({})
		_.useEffect(function () {
			return (
				(E.current = !0),
				function () {
					E.current = !1
				}
			)
		}, [])
		var C = _.useState(0),
			D = C[1],
			O = _.useRef({
				values: Y0(m.initialValues),
				errors: Y0(m.initialErrors) || wc,
				touched: Y0(m.initialTouched) || G0,
				status: Y0(m.initialStatus),
				isSubmitting: !1,
				isValidating: !1,
				submitCount: 0,
			}),
			A = O.current,
			N = _.useCallback(function (ue) {
				var Re = O.current
				;(O.current = Qce(Re, ue)),
					Re !== O.current &&
						D(function (pe) {
							return pe + 1
						})
			}, []),
			I = _.useCallback(
				function (ue, Re) {
					return new Promise(function (pe, ye) {
						var X = m.validate(ue, Re)
						X == null
							? pe(wc)
							: LT(X)
							? X.then(
									function (de) {
										pe(de || wc)
									},
									function (de) {
										ye(de)
									},
							  )
							: pe(X)
					})
				},
				[m.validate],
			),
			P = _.useCallback(
				function (ue, Re) {
					var pe = m.validationSchema,
						ye = Ra(pe) ? pe(Re) : pe,
						X = Re && ye.validateAt ? ye.validateAt(Re, ue) : Zce(ue, ye)
					return new Promise(function (de, Me) {
						X.then(
							function () {
								de(wc)
							},
							function (Ze) {
								Ze.name === "ValidationError" ? de(Jce(Ze)) : Me(Ze)
							},
						)
					})
				},
				[m.validationSchema],
			),
			L = _.useCallback(function (ue, Re) {
				return new Promise(function (pe) {
					return pe(T.current[ue].validate(Re))
				})
			}, []),
			B = _.useCallback(
				function (ue) {
					var Re = Object.keys(T.current).filter(function (ye) {
							return Ra(T.current[ye].validate)
						}),
						pe =
							Re.length > 0
								? Re.map(function (ye) {
										return L(ye, na(ue, ye))
								  })
								: [Promise.resolve("DO_NOT_DELETE_YOU_WILL_BE_FIRED")]
					return Promise.all(pe).then(function (ye) {
						return ye.reduce(function (X, de, Me) {
							return de === "DO_NOT_DELETE_YOU_WILL_BE_FIRED" || (de && (X = Yc(X, Re[Me], de))), X
						}, {})
					})
				},
				[L],
			),
			z = _.useCallback(
				function (ue) {
					return Promise.all([
						B(ue),
						m.validationSchema ? P(ue) : {},
						m.validate ? I(ue) : {},
					]).then(function (Re) {
						var pe = Re[0],
							ye = Re[1],
							X = Re[2],
							de = ZS.all([pe, ye, X], { arrayMerge: ede })
						return de
					})
				},
				[m.validate, m.validationSchema, B, I, P],
			),
			V = Ia(function (ue) {
				return (
					ue === void 0 && (ue = A.values),
					N({ type: "SET_ISVALIDATING", payload: !0 }),
					z(ue).then(function (Re) {
						return (
							E.current &&
								(N({ type: "SET_ISVALIDATING", payload: !1 }),
								N({ type: "SET_ERRORS", payload: Re })),
							Re
						)
					})
				)
			})
		_.useEffect(
			function () {
				o && E.current === !0 && Oc(v.current, m.initialValues) && V(v.current)
			},
			[o, V],
		)
		var K = _.useCallback(
			function (ue) {
				var Re = ue && ue.values ? ue.values : v.current,
					pe = ue && ue.errors ? ue.errors : y.current ? y.current : m.initialErrors || {},
					ye = ue && ue.touched ? ue.touched : b.current ? b.current : m.initialTouched || {},
					X = ue && ue.status ? ue.status : x.current ? x.current : m.initialStatus
				;(v.current = Re), (y.current = pe), (b.current = ye), (x.current = X)
				var de = function () {
					N({
						type: "RESET_FORM",
						payload: {
							isSubmitting: !!ue && !!ue.isSubmitting,
							errors: pe,
							touched: ye,
							status: X,
							values: Re,
							isValidating: !!ue && !!ue.isValidating,
							submitCount:
								ue && ue.submitCount && typeof ue.submitCount == "number" ? ue.submitCount : 0,
						},
					})
				}
				if (m.onReset) {
					var Me = m.onReset(A.values, Xt)
					LT(Me) ? Me.then(de) : de()
				} else de()
			},
			[m.initialErrors, m.initialStatus, m.initialTouched, m.onReset],
		)
		_.useEffect(
			function () {
				E.current === !0 &&
					!Oc(v.current, m.initialValues) &&
					u &&
					((v.current = m.initialValues), K(), o && V(v.current))
			},
			[u, m.initialValues, K, o, V],
		),
			_.useEffect(
				function () {
					u &&
						E.current === !0 &&
						!Oc(y.current, m.initialErrors) &&
						((y.current = m.initialErrors || wc),
						N({ type: "SET_ERRORS", payload: m.initialErrors || wc }))
				},
				[u, m.initialErrors],
			),
			_.useEffect(
				function () {
					u &&
						E.current === !0 &&
						!Oc(b.current, m.initialTouched) &&
						((b.current = m.initialTouched || G0),
						N({ type: "SET_TOUCHED", payload: m.initialTouched || G0 }))
				},
				[u, m.initialTouched],
			),
			_.useEffect(
				function () {
					u &&
						E.current === !0 &&
						!Oc(x.current, m.initialStatus) &&
						((x.current = m.initialStatus), N({ type: "SET_STATUS", payload: m.initialStatus }))
				},
				[u, m.initialStatus, m.initialTouched],
			)
		var ne = Ia(function (ue) {
				if (T.current[ue] && Ra(T.current[ue].validate)) {
					var Re = na(A.values, ue),
						pe = T.current[ue].validate(Re)
					return LT(pe)
						? (N({ type: "SET_ISVALIDATING", payload: !0 }),
						  pe
								.then(function (ye) {
									return ye
								})
								.then(function (ye) {
									N({ type: "SET_FIELD_ERROR", payload: { field: ue, value: ye } }),
										N({ type: "SET_ISVALIDATING", payload: !1 })
								}))
						: (N({ type: "SET_FIELD_ERROR", payload: { field: ue, value: pe } }),
						  Promise.resolve(pe))
				} else if (m.validationSchema)
					return (
						N({ type: "SET_ISVALIDATING", payload: !0 }),
						P(A.values, ue)
							.then(function (ye) {
								return ye
							})
							.then(function (ye) {
								N({ type: "SET_FIELD_ERROR", payload: { field: ue, value: na(ye, ue) } }),
									N({ type: "SET_ISVALIDATING", payload: !1 })
							})
					)
				return Promise.resolve()
			}),
			re = _.useCallback(function (ue, Re) {
				var pe = Re.validate
				T.current[ue] = { validate: pe }
			}, []),
			ie = _.useCallback(function (ue) {
				delete T.current[ue]
			}, []),
			J = Ia(function (ue, Re) {
				N({ type: "SET_TOUCHED", payload: ue })
				var pe = Re === void 0 ? i : Re
				return pe ? V(A.values) : Promise.resolve()
			}),
			le = _.useCallback(function (ue) {
				N({ type: "SET_ERRORS", payload: ue })
			}, []),
			F = Ia(function (ue, Re) {
				var pe = Ra(ue) ? ue(A.values) : ue
				N({ type: "SET_VALUES", payload: pe })
				var ye = Re === void 0 ? n : Re
				return ye ? V(pe) : Promise.resolve()
			}),
			Y = _.useCallback(function (ue, Re) {
				N({ type: "SET_FIELD_ERROR", payload: { field: ue, value: Re } })
			}, []),
			ee = Ia(function (ue, Re, pe) {
				N({ type: "SET_FIELD_VALUE", payload: { field: ue, value: Re } })
				var ye = pe === void 0 ? n : pe
				return ye ? V(Yc(A.values, ue, Re)) : Promise.resolve()
			}),
			$ = _.useCallback(
				function (ue, Re) {
					var pe = Re,
						ye = ue,
						X
					if (!RT(ue)) {
						ue.persist && ue.persist()
						var de = ue.target ? ue.target : ue.currentTarget,
							Me = de.type,
							Ze = de.name,
							ct = de.id,
							Ot = de.value,
							tr = de.checked,
							Wn = de.outerHTML,
							An = de.options,
							li = de.multiple
						;(pe = Re || Ze || ct),
							(ye = /number|range/.test(Me)
								? ((X = parseFloat(Ot)), isNaN(X) ? "" : X)
								: /checkbox/.test(Me)
								? nde(na(A.values, pe), tr, Ot)
								: An && li
								? tde(An)
								: Ot)
					}
					pe && ee(pe, ye)
				},
				[ee, A.values],
			),
			ge = Ia(function (ue) {
				if (RT(ue))
					return function (Re) {
						return $(Re, ue)
					}
				$(ue)
			}),
			Se = Ia(function (ue, Re, pe) {
				Re === void 0 && (Re = !0),
					N({ type: "SET_FIELD_TOUCHED", payload: { field: ue, value: Re } })
				var ye = pe === void 0 ? i : pe
				return ye ? V(A.values) : Promise.resolve()
			}),
			Ee = _.useCallback(
				function (ue, Re) {
					ue.persist && ue.persist()
					var pe = ue.target,
						ye = pe.name,
						X = pe.id,
						de = pe.outerHTML,
						Me = Re || ye || X
					Se(Me, !0)
				},
				[Se],
			),
			be = Ia(function (ue) {
				if (RT(ue))
					return function (Re) {
						return Ee(Re, ue)
					}
				Ee(ue)
			}),
			Le = _.useCallback(function (ue) {
				Ra(ue)
					? N({ type: "SET_FORMIK_STATE", payload: ue })
					: N({
							type: "SET_FORMIK_STATE",
							payload: function () {
								return ue
							},
					  })
			}, []),
			Be = _.useCallback(function (ue) {
				N({ type: "SET_STATUS", payload: ue })
			}, []),
			et = _.useCallback(function (ue) {
				N({ type: "SET_ISSUBMITTING", payload: ue })
			}, []),
			pt = Ia(function () {
				return (
					N({ type: "SUBMIT_ATTEMPT" }),
					V().then(function (ue) {
						var Re = ue instanceof Error,
							pe = !Re && Object.keys(ue).length === 0
						if (pe) {
							var ye
							try {
								if (((ye = on()), ye === void 0)) return
							} catch (X) {
								throw X
							}
							return Promise.resolve(ye)
								.then(function (X) {
									return E.current && N({ type: "SUBMIT_SUCCESS" }), X
								})
								.catch(function (X) {
									if (E.current) throw (N({ type: "SUBMIT_FAILURE" }), X)
								})
						} else if (E.current && (N({ type: "SUBMIT_FAILURE" }), Re)) throw ue
					})
				)
			}),
			mt = Ia(function (ue) {
				ue && ue.preventDefault && Ra(ue.preventDefault) && ue.preventDefault(),
					ue && ue.stopPropagation && Ra(ue.stopPropagation) && ue.stopPropagation(),
					pt().catch(function (Re) {
						console.warn("Warning: An unhandled error was caught from submitForm()", Re)
					})
			}),
			Xt = {
				resetForm: K,
				validateForm: V,
				validateField: ne,
				setErrors: le,
				setFieldError: Y,
				setFieldTouched: Se,
				setFieldValue: ee,
				setStatus: Be,
				setSubmitting: et,
				setTouched: J,
				setValues: F,
				setFormikState: Le,
				submitForm: pt,
			},
			on = Ia(function () {
				return d(A.values, Xt)
			}),
			dt = Ia(function (ue) {
				ue && ue.preventDefault && Ra(ue.preventDefault) && ue.preventDefault(),
					ue && ue.stopPropagation && Ra(ue.stopPropagation) && ue.stopPropagation(),
					K()
			}),
			cn = _.useCallback(
				function (ue) {
					return {
						value: na(A.values, ue),
						error: na(A.errors, ue),
						touched: !!na(A.touched, ue),
						initialValue: na(v.current, ue),
						initialTouched: !!na(b.current, ue),
						initialError: na(y.current, ue),
					}
				},
				[A.errors, A.touched, A.values],
			),
			sn = _.useCallback(
				function (ue) {
					return {
						setValue: function (pe, ye) {
							return ee(ue, pe, ye)
						},
						setTouched: function (pe, ye) {
							return Se(ue, pe, ye)
						},
						setError: function (pe) {
							return Y(ue, pe)
						},
					}
				},
				[ee, Se, Y],
			),
			ur = _.useCallback(
				function (ue) {
					var Re = ig(ue),
						pe = Re ? ue.name : ue,
						ye = na(A.values, pe),
						X = { name: pe, value: ye, onChange: ge, onBlur: be }
					if (Re) {
						var de = ue.type,
							Me = ue.value,
							Ze = ue.as,
							ct = ue.multiple
						de === "checkbox"
							? Me === void 0
								? (X.checked = !!ye)
								: ((X.checked = !!(Array.isArray(ye) && ~ye.indexOf(Me))), (X.value = Me))
							: de === "radio"
							? ((X.checked = ye === Me), (X.value = Me))
							: Ze === "select" && ct && ((X.value = X.value || []), (X.multiple = !0))
					}
					return X
				},
				[be, ge, A.values],
			),
			Hn = _.useMemo(
				function () {
					return !Oc(v.current, A.values)
				},
				[v.current, A.values],
			),
			Jt = _.useMemo(
				function () {
					return typeof s < "u"
						? Hn
							? A.errors && Object.keys(A.errors).length === 0
							: s !== !1 && Ra(s)
							? s(m)
							: s
						: A.errors && Object.keys(A.errors).length === 0
				},
				[s, Hn, A.errors, m],
			),
			mn = kr({}, A, {
				initialValues: v.current,
				initialErrors: y.current,
				initialTouched: b.current,
				initialStatus: x.current,
				handleBlur: be,
				handleChange: ge,
				handleReset: dt,
				handleSubmit: mt,
				resetForm: K,
				setErrors: le,
				setFormikState: Le,
				setFieldTouched: Se,
				setFieldValue: ee,
				setFieldError: Y,
				setStatus: Be,
				setSubmitting: et,
				setTouched: J,
				setValues: F,
				submitForm: pt,
				validateForm: V,
				validateField: ne,
				isValid: Jt,
				dirty: Hn,
				unregisterField: ie,
				registerField: re,
				getFieldProps: ur,
				getFieldMeta: cn,
				getFieldHelpers: sn,
				validateOnBlur: i,
				validateOnChange: n,
				validateOnMount: o,
			})
		return mn
	}
	function Vt(e) {
		var t = Xce(e),
			n = e.component,
			r = e.children,
			i = e.render,
			a = e.innerRef
		return (
			_.useImperativeHandle(a, function () {
				return t
			}),
			_.createElement(
				Yce,
				{ value: t },
				n
					? _.createElement(n, t)
					: i
					? i(t)
					: r
					? Ra(r)
						? r(t)
						: Kce(r)
						? null
						: _.Children.only(r)
					: null,
			)
		)
	}
	function Jce(e) {
		var t = {}
		if (e.inner) {
			if (e.inner.length === 0) return Yc(t, e.path, e.message)
			for (var i = e.inner, n = Array.isArray(i), r = 0, i = n ? i : i[Symbol.iterator](); ; ) {
				var a
				if (n) {
					if (r >= i.length) break
					a = i[r++]
				} else {
					if (((r = i.next()), r.done)) break
					a = r.value
				}
				var o = a
				na(t, o.path) || (t = Yc(t, o.path, o.message))
			}
		}
		return t
	}
	function Zce(e, t, n, r) {
		n === void 0 && (n = !1)
		var i = i2(e)
		return t[n ? "validateSync" : "validate"](i, { abortEarly: !1, context: i })
	}
	function i2(e) {
		var t = Array.isArray(e) ? [] : {}
		for (var n in e)
			if (Object.prototype.hasOwnProperty.call(e, n)) {
				var r = String(n)
				Array.isArray(e[r]) === !0
					? (t[r] = e[r].map(function (i) {
							return Array.isArray(i) === !0 || HL(i) ? i2(i) : i !== "" ? i : void 0
					  }))
					: HL(e[r])
					? (t[r] = i2(e[r]))
					: (t[r] = e[r] !== "" ? e[r] : void 0)
			}
		return t
	}
	function ede(e, t, n) {
		var r = e.slice()
		return (
			t.forEach(function (a, o) {
				if (typeof r[o] > "u") {
					var s = n.clone !== !1,
						l = s && n.isMergeableObject(a)
					r[o] = l ? ZS(Array.isArray(a) ? [] : {}, a, n) : a
				} else n.isMergeableObject(a) ? (r[o] = ZS(e[o], a, n)) : e.indexOf(a) === -1 && r.push(a)
			}),
			r
		)
	}
	function tde(e) {
		return Array.from(e)
			.filter(function (t) {
				return t.selected
			})
			.map(function (t) {
				return t.value
			})
	}
	function nde(e, t, n) {
		if (typeof e == "boolean") return !!t
		var r = [],
			i = !1,
			a = -1
		if (Array.isArray(e)) (r = e), (a = e.indexOf(n)), (i = a >= 0)
		else if (!n || n == "true" || n == "false") return !!t
		return t && n && !i ? r.concat(n) : i ? r.slice(0, a).concat(r.slice(a + 1)) : r
	}
	var rde =
		typeof window < "u" &&
		typeof window.document < "u" &&
		typeof window.document.createElement < "u"
			? _.useLayoutEffect
			: _.useEffect
	function Ia(e) {
		var t = _.useRef(e)
		return (
			rde(function () {
				t.current = e
			}),
			_.useCallback(function () {
				for (var n = arguments.length, r = new Array(n), i = 0; i < n; i++) r[i] = arguments[i]
				return t.current.apply(void 0, r)
			}, [])
		)
	}
	function bH(e) {
		var t = Bx(),
			n = t.getFieldProps,
			r = t.getFieldMeta,
			i = t.getFieldHelpers,
			a = t.registerField,
			o = t.unregisterField,
			s = ig(e),
			l = s ? e : { name: e },
			u = l.name,
			d = l.validate
		_.useEffect(
			function () {
				return (
					u && a(u, { validate: d }),
					function () {
						u && o(u)
					}
				)
			},
			[a, o, u, d],
		)
		var p = _.useMemo(
			function () {
				return i(u)
			},
			[i, u],
		)
		return [n(l), r(u), p]
	}
	var ide = _.forwardRef(function (e, t) {
		var n = e.action,
			r = gH(e, ["action"]),
			i = n ?? "#",
			a = Bx(),
			o = a.handleReset,
			s = a.handleSubmit
		return _.createElement("form", kr({ onSubmit: s, ref: t, onReset: o, action: i }, r))
	})
	ide.displayName = "Form"
	const ade = { type: he.string, tooltip: he.bool, as: he.elementType },
		Hx = _.forwardRef(
			({ as: e = "div", className: t, type: n = "valid", tooltip: r = !1, ...i }, a) =>
				h.jsx(e, { ...i, ref: a, className: Fe(t, `${n}-${r ? "tooltip" : "feedback"}`) }),
		)
	Hx.displayName = "Feedback"
	Hx.propTypes = ade
	const xl = _.createContext({}),
		U_ = _.forwardRef(
			(
				{
					id: e,
					bsPrefix: t,
					className: n,
					type: r = "checkbox",
					isValid: i = !1,
					isInvalid: a = !1,
					as: o = "input",
					...s
				},
				l,
			) => {
				const { controlId: u } = _.useContext(xl)
				return (
					(t = nt(t, "form-check-input")),
					h.jsx(o, {
						...s,
						ref: l,
						type: r,
						id: e || u,
						className: Fe(n, t, i && "is-valid", a && "is-invalid"),
					})
				)
			},
		)
	U_.displayName = "FormCheckInput"
	const W1 = _.forwardRef(({ bsPrefix: e, className: t, htmlFor: n, ...r }, i) => {
		const { controlId: a } = _.useContext(xl)
		return (
			(e = nt(e, "form-check-label")),
			h.jsx("label", { ...r, ref: i, htmlFor: n || a, className: Fe(t, e) })
		)
	})
	W1.displayName = "FormCheckLabel"
	function ode(e, t) {
		return _.Children.toArray(e).some((n) => _.isValidElement(n) && n.type === t)
	}
	const xH = _.forwardRef(
		(
			{
				id: e,
				bsPrefix: t,
				bsSwitchPrefix: n,
				inline: r = !1,
				reverse: i = !1,
				disabled: a = !1,
				isValid: o = !1,
				isInvalid: s = !1,
				feedbackTooltip: l = !1,
				feedback: u,
				feedbackType: d,
				className: p,
				style: m,
				title: v = "",
				type: y = "checkbox",
				label: b,
				children: x,
				as: E = "input",
				...T
			},
			C,
		) => {
			;(t = nt(t, "form-check")), (n = nt(n, "form-switch"))
			const { controlId: D } = _.useContext(xl),
				O = _.useMemo(() => ({ controlId: e || D }), [D, e]),
				A = (!x && b != null && b !== !1) || ode(x, W1),
				N = h.jsx(U_, {
					...T,
					type: y === "switch" ? "checkbox" : y,
					ref: C,
					isValid: o,
					isInvalid: s,
					disabled: a,
					as: E,
				})
			return h.jsx(xl.Provider, {
				value: O,
				children: h.jsx("div", {
					style: m,
					className: Fe(p, A && t, r && `${t}-inline`, i && `${t}-reverse`, y === "switch" && n),
					children:
						x ||
						h.jsxs(h.Fragment, {
							children: [
								N,
								A && h.jsx(W1, { title: v, children: b }),
								u && h.jsx(Hx, { type: d, tooltip: l, children: u }),
							],
						}),
				}),
			})
		},
	)
	xH.displayName = "FormCheck"
	const Y1 = Object.assign(xH, { Input: U_, Label: W1 })
	var PT, mP
	function sde() {
		if (mP) return PT
		mP = 1
		var e = function () {}
		return (PT = e), PT
	}
	var lde = sde()
	const z_ = Ti(lde),
		wH = _.forwardRef(
			(
				{
					bsPrefix: e,
					type: t,
					size: n,
					htmlSize: r,
					id: i,
					className: a,
					isValid: o = !1,
					isInvalid: s = !1,
					plaintext: l,
					readOnly: u,
					as: d = "input",
					...p
				},
				m,
			) => {
				const { controlId: v } = _.useContext(xl)
				return (
					(e = nt(e, "form-control")),
					h.jsx(d, {
						...p,
						type: t,
						size: r,
						ref: m,
						readOnly: u,
						id: i || v,
						className: Fe(
							a,
							l ? `${e}-plaintext` : e,
							n && `${e}-${n}`,
							t === "color" && `${e}-color`,
							o && "is-valid",
							s && "is-invalid",
						),
					})
				)
			},
		)
	wH.displayName = "FormControl"
	const ude = Object.assign(wH, { Feedback: Hx }),
		EH = _.forwardRef(
			({ className: e, bsPrefix: t, as: n = "div", ...r }, i) => (
				(t = nt(t, "form-floating")), h.jsx(n, { ref: i, className: Fe(e, t), ...r })
			),
		)
	EH.displayName = "FormFloating"
	const q_ = _.forwardRef(({ controlId: e, as: t = "div", ...n }, r) => {
		const i = _.useMemo(() => ({ controlId: e }), [e])
		return h.jsx(xl.Provider, { value: i, children: h.jsx(t, { ...n, ref: r }) })
	})
	q_.displayName = "FormGroup"
	const CH = _.forwardRef(
		(
			{
				as: e = "label",
				bsPrefix: t,
				column: n = !1,
				visuallyHidden: r = !1,
				className: i,
				htmlFor: a,
				...o
			},
			s,
		) => {
			const { controlId: l } = _.useContext(xl)
			t = nt(t, "form-label")
			let u = "col-form-label"
			typeof n == "string" && (u = `${u} ${u}-${n}`)
			const d = Fe(i, t, r && "visually-hidden", n && u)
			return (
				(a = a || l),
				n
					? h.jsx(it, { ref: s, as: "label", className: d, htmlFor: a, ...o })
					: h.jsx(e, { ref: s, className: d, htmlFor: a, ...o })
			)
		},
	)
	CH.displayName = "FormLabel"
	const TH = _.forwardRef(({ bsPrefix: e, className: t, id: n, ...r }, i) => {
		const { controlId: a } = _.useContext(xl)
		return (
			(e = nt(e, "form-range")),
			h.jsx("input", { ...r, type: "range", ref: i, className: Fe(t, e), id: n || a })
		)
	})
	TH.displayName = "FormRange"
	const kH = _.forwardRef(
		(
			{
				bsPrefix: e,
				size: t,
				htmlSize: n,
				className: r,
				isValid: i = !1,
				isInvalid: a = !1,
				id: o,
				...s
			},
			l,
		) => {
			const { controlId: u } = _.useContext(xl)
			return (
				(e = nt(e, "form-select")),
				h.jsx("select", {
					...s,
					size: n,
					ref: l,
					className: Fe(r, e, t && `${e}-${t}`, i && "is-valid", a && "is-invalid"),
					id: o || u,
				})
			)
		},
	)
	kH.displayName = "FormSelect"
	const SH = _.forwardRef(
		({ bsPrefix: e, className: t, as: n = "small", muted: r, ...i }, a) => (
			(e = nt(e, "form-text")), h.jsx(n, { ...i, ref: a, className: Fe(t, e, r && "text-muted") })
		),
	)
	SH.displayName = "FormText"
	const DH = _.forwardRef((e, t) => h.jsx(Y1, { ...e, ref: t, type: "switch" }))
	DH.displayName = "Switch"
	const cde = Object.assign(DH, { Input: Y1.Input, Label: Y1.Label }),
		_H = _.forwardRef(
			({ bsPrefix: e, className: t, children: n, controlId: r, label: i, ...a }, o) => (
				(e = nt(e, "form-floating")),
				h.jsxs(q_, {
					ref: o,
					className: Fe(t, e),
					controlId: r,
					...a,
					children: [n, h.jsx("label", { htmlFor: r, children: i })],
				})
			),
		)
	_H.displayName = "FloatingLabel"
	const dde = { _ref: he.any, validated: he.bool, as: he.elementType },
		V_ = _.forwardRef(({ className: e, validated: t, as: n = "form", ...r }, i) =>
			h.jsx(n, { ...r, ref: i, className: Fe(e, t && "was-validated") }),
		)
	V_.displayName = "Form"
	V_.propTypes = dde
	const R = Object.assign(V_, {
		Group: q_,
		Control: ude,
		Floating: EH,
		Check: Y1,
		Switch: cde,
		Label: CH,
		Text: SH,
		Range: TH,
		Select: kH,
		FloatingLabel: _H,
	})
	var jT, vP
	function fde() {
		if (vP) return jT
		vP = 1
		function e(E) {
			;(this._maxSize = E), this.clear()
		}
		;(e.prototype.clear = function () {
			;(this._size = 0), (this._values = Object.create(null))
		}),
			(e.prototype.get = function (E) {
				return this._values[E]
			}),
			(e.prototype.set = function (E, T) {
				return (
					this._size >= this._maxSize && this.clear(),
					E in this._values || this._size++,
					(this._values[E] = T)
				)
			})
		var t = /[^.^\]^[]+|(?=\[\]|\.\.)/g,
			n = /^\d+$/,
			r = /^\d/,
			i = /[~`!#$%\^&*+=\-\[\]\\';,/{}|\\":<>\?]/g,
			a = /^\s*(['"]?)(.*?)(\1)\s*$/,
			o = 512,
			s = new e(o),
			l = new e(o),
			u = new e(o)
		jT = {
			Cache: e,
			split: p,
			normalizePath: d,
			setter: function (E) {
				var T = d(E)
				return (
					l.get(E) ||
					l.set(E, function (D, O) {
						for (var A = 0, N = T.length, I = D; A < N - 1; ) {
							var P = T[A]
							if (P === "__proto__" || P === "constructor" || P === "prototype") return D
							I = I[T[A++]]
						}
						I[T[A]] = O
					})
				)
			},
			getter: function (E, T) {
				var C = d(E)
				return (
					u.get(E) ||
					u.set(E, function (O) {
						for (var A = 0, N = C.length; A < N; )
							if (O != null || !T) O = O[C[A++]]
							else return
						return O
					})
				)
			},
			join: function (E) {
				return E.reduce(function (T, C) {
					return T + (v(C) || n.test(C) ? "[" + C + "]" : (T ? "." : "") + C)
				}, "")
			},
			forEach: function (E, T, C) {
				m(Array.isArray(E) ? E : p(E), T, C)
			},
		}
		function d(E) {
			return (
				s.get(E) ||
				s.set(
					E,
					p(E).map(function (T) {
						return T.replace(a, "$2")
					}),
				)
			)
		}
		function p(E) {
			return E.match(t) || [""]
		}
		function m(E, T, C) {
			var D = E.length,
				O,
				A,
				N,
				I
			for (A = 0; A < D; A++)
				(O = E[A]),
					O &&
						(x(O) && (O = '"' + O + '"'),
						(I = v(O)),
						(N = !I && /^\d+$/.test(O)),
						T.call(C, O, I, N, A, E))
		}
		function v(E) {
			return typeof E == "string" && E && ["'", '"'].indexOf(E.charAt(0)) !== -1
		}
		function y(E) {
			return E.match(r) && !E.match(n)
		}
		function b(E) {
			return i.test(E)
		}
		function x(E) {
			return !v(E) && (y(E) || b(E))
		}
		return jT
	}
	var Gc = fde(),
		FT,
		gP
	function pde() {
		if (gP) return FT
		gP = 1
		const e =
				/[A-Z\xc0-\xd6\xd8-\xde]?[a-z\xdf-\xf6\xf8-\xff]+(?:['](?:d|ll|m|re|s|t|ve))?(?=[\xac\xb1\xd7\xf7\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\xbf\u2000-\u206f \t\x0b\f\xa0\ufeff\n\r\u2028\u2029\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000]|[A-Z\xc0-\xd6\xd8-\xde]|$)|(?:[A-Z\xc0-\xd6\xd8-\xde]|[^\ud800-\udfff\xac\xb1\xd7\xf7\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\xbf\u2000-\u206f \t\x0b\f\xa0\ufeff\n\r\u2028\u2029\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\d+\u2700-\u27bfa-z\xdf-\xf6\xf8-\xffA-Z\xc0-\xd6\xd8-\xde])+(?:['](?:D|LL|M|RE|S|T|VE))?(?=[\xac\xb1\xd7\xf7\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\xbf\u2000-\u206f \t\x0b\f\xa0\ufeff\n\r\u2028\u2029\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000]|[A-Z\xc0-\xd6\xd8-\xde](?:[a-z\xdf-\xf6\xf8-\xff]|[^\ud800-\udfff\xac\xb1\xd7\xf7\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\xbf\u2000-\u206f \t\x0b\f\xa0\ufeff\n\r\u2028\u2029\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\d+\u2700-\u27bfa-z\xdf-\xf6\xf8-\xffA-Z\xc0-\xd6\xd8-\xde])|$)|[A-Z\xc0-\xd6\xd8-\xde]?(?:[a-z\xdf-\xf6\xf8-\xff]|[^\ud800-\udfff\xac\xb1\xd7\xf7\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\xbf\u2000-\u206f \t\x0b\f\xa0\ufeff\n\r\u2028\u2029\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\d+\u2700-\u27bfa-z\xdf-\xf6\xf8-\xffA-Z\xc0-\xd6\xd8-\xde])+(?:['](?:d|ll|m|re|s|t|ve))?|[A-Z\xc0-\xd6\xd8-\xde]+(?:['](?:D|LL|M|RE|S|T|VE))?|\d*(?:1ST|2ND|3RD|(?![123])\dTH)(?=\b|[a-z_])|\d*(?:1st|2nd|3rd|(?![123])\dth)(?=\b|[A-Z_])|\d+|(?:[\u2700-\u27bf]|(?:\ud83c[\udde6-\uddff]){2}|[\ud800-\udbff][\udc00-\udfff])[\ufe0e\ufe0f]?(?:[\u0300-\u036f\ufe20-\ufe2f\u20d0-\u20ff]|\ud83c[\udffb-\udfff])?(?:\u200d(?:[^\ud800-\udfff]|(?:\ud83c[\udde6-\uddff]){2}|[\ud800-\udbff][\udc00-\udfff])[\ufe0e\ufe0f]?(?:[\u0300-\u036f\ufe20-\ufe2f\u20d0-\u20ff]|\ud83c[\udffb-\udfff])?)*/g,
			t = (d) => d.match(e) || [],
			n = (d) => d[0].toUpperCase() + d.slice(1),
			r = (d, p) => t(d).join(p).toLowerCase(),
			i = (d) =>
				t(d).reduce(
					(p, m) => `${p}${p ? m[0].toUpperCase() + m.slice(1).toLowerCase() : m.toLowerCase()}`,
					"",
				)
		return (
			(FT = {
				words: t,
				upperFirst: n,
				camelCase: i,
				pascalCase: (d) => n(i(d)),
				snakeCase: (d) => r(d, "_"),
				kebabCase: (d) => r(d, "-"),
				sentenceCase: (d) => n(r(d, " ")),
				titleCase: (d) => t(d).map(n).join(" "),
			}),
			FT
		)
	}
	var BT = pde(),
		K0 = { exports: {} },
		yP
	function hde() {
		if (yP) return K0.exports
		;(yP = 1),
			(K0.exports = function (i) {
				return e(t(i), i)
			}),
			(K0.exports.array = e)
		function e(i, a) {
			var o = i.length,
				s = new Array(o),
				l = {},
				u = o,
				d = n(a),
				p = r(i)
			for (
				a.forEach(function (v) {
					if (!p.has(v[0]) || !p.has(v[1]))
						throw new Error("Unknown node. There is an unknown node in the supplied edges.")
				});
				u--;

			)
				l[u] || m(i[u], u, new Set())
			return s
			function m(v, y, b) {
				if (b.has(v)) {
					var x
					try {
						x = ", node was:" + JSON.stringify(v)
					} catch {
						x = ""
					}
					throw new Error("Cyclic dependency" + x)
				}
				if (!p.has(v))
					throw new Error(
						"Found unknown node. Make sure to provided all involved nodes. Unknown node: " +
							JSON.stringify(v),
					)
				if (!l[y]) {
					l[y] = !0
					var E = d.get(v) || new Set()
					if (((E = Array.from(E)), (y = E.length))) {
						b.add(v)
						do {
							var T = E[--y]
							m(T, p.get(T), b)
						} while (y)
						b.delete(v)
					}
					s[--o] = v
				}
			}
		}
		function t(i) {
			for (var a = new Set(), o = 0, s = i.length; o < s; o++) {
				var l = i[o]
				a.add(l[0]), a.add(l[1])
			}
			return Array.from(a)
		}
		function n(i) {
			for (var a = new Map(), o = 0, s = i.length; o < s; o++) {
				var l = i[o]
				a.has(l[0]) || a.set(l[0], new Set()),
					a.has(l[1]) || a.set(l[1], new Set()),
					a.get(l[0]).add(l[1])
			}
			return a
		}
		function r(i) {
			for (var a = new Map(), o = 0, s = i.length; o < s; o++) a.set(i[o], o)
			return a
		}
		return K0.exports
	}
	var mde = hde()
	const vde = Ti(mde),
		gde = Object.prototype.toString,
		yde = Error.prototype.toString,
		bde = RegExp.prototype.toString,
		xde = typeof Symbol < "u" ? Symbol.prototype.toString : () => "",
		wde = /^Symbol\((.*)\)(.*)$/
	function Ede(e) {
		return e != +e ? "NaN" : e === 0 && 1 / e < 0 ? "-0" : "" + e
	}
	function bP(e, t = !1) {
		if (e == null || e === !0 || e === !1) return "" + e
		const n = typeof e
		if (n === "number") return Ede(e)
		if (n === "string") return t ? `"${e}"` : e
		if (n === "function") return "[Function " + (e.name || "anonymous") + "]"
		if (n === "symbol") return xde.call(e).replace(wde, "Symbol($1)")
		const r = gde.call(e).slice(8, -1)
		return r === "Date"
			? isNaN(e.getTime())
				? "" + e
				: e.toISOString(e)
			: r === "Error" || e instanceof Error
			? "[" + yde.call(e) + "]"
			: r === "RegExp"
			? bde.call(e)
			: null
	}
	function Cu(e, t) {
		let n = bP(e, t)
		return n !== null
			? n
			: JSON.stringify(
					e,
					function (r, i) {
						let a = bP(this[r], t)
						return a !== null ? a : i
					},
					2,
			  )
	}
	function OH(e) {
		return e == null ? [] : [].concat(e)
	}
	let AH,
		NH,
		MH,
		Cde = /\$\{\s*(\w+)\s*\}/g
	AH = Symbol.toStringTag
	class xP {
		constructor(t, n, r, i) {
			;(this.name = void 0),
				(this.message = void 0),
				(this.value = void 0),
				(this.path = void 0),
				(this.type = void 0),
				(this.params = void 0),
				(this.errors = void 0),
				(this.inner = void 0),
				(this[AH] = "Error"),
				(this.name = "ValidationError"),
				(this.value = n),
				(this.path = r),
				(this.type = i),
				(this.errors = []),
				(this.inner = []),
				OH(t).forEach((a) => {
					if (ji.isError(a)) {
						this.errors.push(...a.errors)
						const o = a.inner.length ? a.inner : [a]
						this.inner.push(...o)
					} else this.errors.push(a)
				}),
				(this.message =
					this.errors.length > 1 ? `${this.errors.length} errors occurred` : this.errors[0])
		}
	}
	NH = Symbol.hasInstance
	MH = Symbol.toStringTag
	class ji extends Error {
		static formatError(t, n) {
			const r = n.label || n.path || "this"
			return (
				r !== n.path && (n = Object.assign({}, n, { path: r })),
				typeof t == "string"
					? t.replace(Cde, (i, a) => Cu(n[a]))
					: typeof t == "function"
					? t(n)
					: t
			)
		}
		static isError(t) {
			return t && t.name === "ValidationError"
		}
		constructor(t, n, r, i, a) {
			const o = new xP(t, n, r, i)
			if (a) return o
			super(),
				(this.value = void 0),
				(this.path = void 0),
				(this.type = void 0),
				(this.params = void 0),
				(this.errors = []),
				(this.inner = []),
				(this[MH] = "Error"),
				(this.name = o.name),
				(this.message = o.message),
				(this.type = o.type),
				(this.value = o.value),
				(this.path = o.path),
				(this.errors = o.errors),
				(this.inner = o.inner),
				Error.captureStackTrace && Error.captureStackTrace(this, ji)
		}
		static [NH](t) {
			return xP[Symbol.hasInstance](t) || super[Symbol.hasInstance](t)
		}
	}
	let Yo = {
			default: "${path} is invalid",
			required: "${path} is a required field",
			defined: "${path} must be defined",
			notNull: "${path} cannot be null",
			oneOf: "${path} must be one of the following values: ${values}",
			notOneOf: "${path} must not be one of the following values: ${values}",
			notType: ({ path: e, type: t, value: n, originalValue: r }) => {
				const i = r != null && r !== n ? ` (cast from the value \`${Cu(r, !0)}\`).` : "."
				return t !== "mixed"
					? `${e} must be a \`${t}\` type, but the final value was: \`${Cu(n, !0)}\`` + i
					: `${e} must match the configured type. The validated value was: \`${Cu(n, !0)}\`` + i
			},
		},
		Ii = {
			length: "${path} must be exactly ${length} characters",
			min: "${path} must be at least ${min} characters",
			max: "${path} must be at most ${max} characters",
			matches: '${path} must match the following: "${regex}"',
			email: "${path} must be a valid email",
			url: "${path} must be a valid URL",
			uuid: "${path} must be a valid UUID",
			datetime: "${path} must be a valid ISO date-time",
			datetime_precision:
				"${path} must be a valid ISO date-time with a sub-second precision of exactly ${precision} digits",
			datetime_offset: '${path} must be a valid ISO date-time with UTC "Z" timezone',
			trim: "${path} must be a trimmed string",
			lowercase: "${path} must be a lowercase string",
			uppercase: "${path} must be a upper case string",
		},
		uu = {
			min: "${path} must be greater than or equal to ${min}",
			max: "${path} must be less than or equal to ${max}",
			lessThan: "${path} must be less than ${less}",
			moreThan: "${path} must be greater than ${more}",
			positive: "${path} must be a positive number",
			negative: "${path} must be a negative number",
			integer: "${path} must be an integer",
		},
		a2 = {
			min: "${path} field must be later than ${min}",
			max: "${path} field must be at earlier than ${max}",
		},
		o2 = { isValue: "${path} field must be ${value}" },
		s2 = { noUnknown: "${path} field has unspecified keys: ${unknown}" },
		Tde = {
			min: "${path} field must have at least ${min} items",
			max: "${path} field must have less than or equal to ${max} items",
			length: "${path} must have ${length} items",
		},
		kde = {
			notType: (e) => {
				const { path: t, value: n, spec: r } = e,
					i = r.types.length
				if (Array.isArray(n)) {
					if (n.length < i)
						return `${t} tuple value has too few items, expected a length of ${i} but got ${
							n.length
						} for value: \`${Cu(n, !0)}\``
					if (n.length > i)
						return `${t} tuple value has too many items, expected a length of ${i} but got ${
							n.length
						} for value: \`${Cu(n, !0)}\``
				}
				return ji.formatError(Yo.notType, e)
			},
		}
	Object.assign(Object.create(null), {
		mixed: Yo,
		string: Ii,
		number: uu,
		date: a2,
		object: s2,
		array: Tde,
		boolean: o2,
		tuple: kde,
	})
	const W_ = (e) => e && e.__isYupSchema__
	class G1 {
		static fromOptions(t, n) {
			if (!n.then && !n.otherwise)
				throw new TypeError("either `then:` or `otherwise:` is required for `when()` conditions")
			let { is: r, then: i, otherwise: a } = n,
				o = typeof r == "function" ? r : (...s) => s.every((l) => l === r)
			return new G1(t, (s, l) => {
				var u
				let d = o(...s) ? i : a
				return (u = d == null ? void 0 : d(l)) != null ? u : l
			})
		}
		constructor(t, n) {
			;(this.fn = void 0), (this.refs = t), (this.refs = t), (this.fn = n)
		}
		resolve(t, n) {
			let r = this.refs.map((a) =>
					a.getValue(
						n == null ? void 0 : n.value,
						n == null ? void 0 : n.parent,
						n == null ? void 0 : n.context,
					),
				),
				i = this.fn(r, t, n)
			if (i === void 0 || i === t) return t
			if (!W_(i)) throw new TypeError("conditions must return a schema object")
			return i.resolve(n)
		}
	}
	const Q0 = { context: "$", value: "." }
	function Y_(e, t) {
		return new Ku(e, t)
	}
	class Ku {
		constructor(t, n = {}) {
			if (
				((this.key = void 0),
				(this.isContext = void 0),
				(this.isValue = void 0),
				(this.isSibling = void 0),
				(this.path = void 0),
				(this.getter = void 0),
				(this.map = void 0),
				typeof t != "string")
			)
				throw new TypeError("ref must be a string, got: " + t)
			if (((this.key = t.trim()), t === "")) throw new TypeError("ref must be a non-empty string")
			;(this.isContext = this.key[0] === Q0.context),
				(this.isValue = this.key[0] === Q0.value),
				(this.isSibling = !this.isContext && !this.isValue)
			let r = this.isContext ? Q0.context : this.isValue ? Q0.value : ""
			;(this.path = this.key.slice(r.length)),
				(this.getter = this.path && Gc.getter(this.path, !0)),
				(this.map = n.map)
		}
		getValue(t, n, r) {
			let i = this.isContext ? r : this.isValue ? t : n
			return this.getter && (i = this.getter(i || {})), this.map && (i = this.map(i)), i
		}
		cast(t, n) {
			return this.getValue(t, n == null ? void 0 : n.parent, n == null ? void 0 : n.context)
		}
		resolve() {
			return this
		}
		describe() {
			return { type: "ref", key: this.key }
		}
		toString() {
			return `Ref(${this.key})`
		}
		static isRef(t) {
			return t && t.__isYupRef
		}
	}
	Ku.prototype.__isYupRef = !0
	const vo = (e) => e == null
	function vf(e) {
		function t({ value: n, path: r = "", options: i, originalValue: a, schema: o }, s, l) {
			const { name: u, test: d, params: p, message: m, skipAbsent: v } = e
			let {
				parent: y,
				context: b,
				abortEarly: x = o.spec.abortEarly,
				disableStackTrace: E = o.spec.disableStackTrace,
			} = i
			function T(B) {
				return Ku.isRef(B) ? B.getValue(n, y, b) : B
			}
			function C(B = {}) {
				const z = Object.assign(
					{
						value: n,
						originalValue: a,
						label: o.spec.label,
						path: B.path || r,
						spec: o.spec,
						disableStackTrace: B.disableStackTrace || E,
					},
					p,
					B.params,
				)
				for (const K of Object.keys(z)) z[K] = T(z[K])
				const V = new ji(
					ji.formatError(B.message || m, z),
					n,
					z.path,
					B.type || u,
					z.disableStackTrace,
				)
				return (V.params = z), V
			}
			const D = x ? s : l
			let O = {
				path: r,
				parent: y,
				type: u,
				from: i.from,
				createError: C,
				resolve: T,
				options: i,
				originalValue: a,
				schema: o,
			}
			const A = (B) => {
					ji.isError(B) ? D(B) : B ? l(null) : D(C())
				},
				N = (B) => {
					ji.isError(B) ? D(B) : s(B)
				}
			if (v && vo(n)) return A(!0)
			let P
			try {
				var L
				if (((P = d.call(O, n, O)), typeof ((L = P) == null ? void 0 : L.then) == "function")) {
					if (i.sync)
						throw new Error(
							`Validation test of type: "${O.type}" returned a Promise during a synchronous validate. This test will finish after the validate call has returned`,
						)
					return Promise.resolve(P).then(A, N)
				}
			} catch (B) {
				N(B)
				return
			}
			A(P)
		}
		return (t.OPTIONS = e), t
	}
	function Sde(e, t, n, r = n) {
		let i, a, o
		return t
			? (Gc.forEach(t, (s, l, u) => {
					let d = l ? s.slice(1, s.length - 1) : s
					e = e.resolve({ context: r, parent: i, value: n })
					let p = e.type === "tuple",
						m = u ? parseInt(d, 10) : 0
					if (e.innerType || p) {
						if (p && !u)
							throw new Error(
								`Yup.reach cannot implicitly index into a tuple type. the path part "${o}" must contain an index to the tuple element, e.g. "${o}[0]"`,
							)
						if (n && m >= n.length)
							throw new Error(
								`Yup.reach cannot resolve an array item at index: ${s}, in the path: ${t}. because there is no value at that index. `,
							)
						;(i = n), (n = n && n[m]), (e = p ? e.spec.types[m] : e.innerType)
					}
					if (!u) {
						if (!e.fields || !e.fields[d])
							throw new Error(
								`The schema does not contain the path: ${t}. (failed at: ${o} which is a type: "${e.type}")`,
							)
						;(i = n), (n = n && n[d]), (e = e.fields[d])
					}
					;(a = d), (o = l ? "[" + s + "]" : "." + s)
			  }),
			  { schema: e, parent: i, parentPath: a })
			: { parent: i, parentPath: t, schema: e }
	}
	class K1 extends Set {
		describe() {
			const t = []
			for (const n of this.values()) t.push(Ku.isRef(n) ? n.describe() : n)
			return t
		}
		resolveAll(t) {
			let n = []
			for (const r of this.values()) n.push(t(r))
			return n
		}
		clone() {
			return new K1(this.values())
		}
		merge(t, n) {
			const r = this.clone()
			return t.forEach((i) => r.add(i)), n.forEach((i) => r.delete(i)), r
		}
	}
	function Lf(e, t = new Map()) {
		if (W_(e) || !e || typeof e != "object") return e
		if (t.has(e)) return t.get(e)
		let n
		if (e instanceof Date) (n = new Date(e.getTime())), t.set(e, n)
		else if (e instanceof RegExp) (n = new RegExp(e)), t.set(e, n)
		else if (Array.isArray(e)) {
			;(n = new Array(e.length)), t.set(e, n)
			for (let r = 0; r < e.length; r++) n[r] = Lf(e[r], t)
		} else if (e instanceof Map) {
			;(n = new Map()), t.set(e, n)
			for (const [r, i] of e.entries()) n.set(r, Lf(i, t))
		} else if (e instanceof Set) {
			;(n = new Set()), t.set(e, n)
			for (const r of e) n.add(Lf(r, t))
		} else if (e instanceof Object) {
			;(n = {}), t.set(e, n)
			for (const [r, i] of Object.entries(e)) n[r] = Lf(i, t)
		} else throw Error(`Unable to clone ${e}`)
		return n
	}
	let Wa = class {
		constructor(t) {
			;(this.type = void 0),
				(this.deps = []),
				(this.tests = void 0),
				(this.transforms = void 0),
				(this.conditions = []),
				(this._mutate = void 0),
				(this.internalTests = {}),
				(this._whitelist = new K1()),
				(this._blacklist = new K1()),
				(this.exclusiveTests = Object.create(null)),
				(this._typeCheck = void 0),
				(this.spec = void 0),
				(this.tests = []),
				(this.transforms = []),
				this.withMutation(() => {
					this.typeError(Yo.notType)
				}),
				(this.type = t.type),
				(this._typeCheck = t.check),
				(this.spec = Object.assign(
					{
						strip: !1,
						strict: !1,
						abortEarly: !0,
						recursive: !0,
						disableStackTrace: !1,
						nullable: !1,
						optional: !0,
						coerce: !0,
					},
					t == null ? void 0 : t.spec,
				)),
				this.withMutation((n) => {
					n.nonNullable()
				})
		}
		get _type() {
			return this.type
		}
		clone(t) {
			if (this._mutate) return t && Object.assign(this.spec, t), this
			const n = Object.create(Object.getPrototypeOf(this))
			return (
				(n.type = this.type),
				(n._typeCheck = this._typeCheck),
				(n._whitelist = this._whitelist.clone()),
				(n._blacklist = this._blacklist.clone()),
				(n.internalTests = Object.assign({}, this.internalTests)),
				(n.exclusiveTests = Object.assign({}, this.exclusiveTests)),
				(n.deps = [...this.deps]),
				(n.conditions = [...this.conditions]),
				(n.tests = [...this.tests]),
				(n.transforms = [...this.transforms]),
				(n.spec = Lf(Object.assign({}, this.spec, t))),
				n
			)
		}
		label(t) {
			let n = this.clone()
			return (n.spec.label = t), n
		}
		meta(...t) {
			if (t.length === 0) return this.spec.meta
			let n = this.clone()
			return (n.spec.meta = Object.assign(n.spec.meta || {}, t[0])), n
		}
		withMutation(t) {
			let n = this._mutate
			this._mutate = !0
			let r = t(this)
			return (this._mutate = n), r
		}
		concat(t) {
			if (!t || t === this) return this
			if (t.type !== this.type && this.type !== "mixed")
				throw new TypeError(
					`You cannot \`concat()\` schema's of different types: ${this.type} and ${t.type}`,
				)
			let n = this,
				r = t.clone()
			const i = Object.assign({}, n.spec, r.spec)
			return (
				(r.spec = i),
				(r.internalTests = Object.assign({}, n.internalTests, r.internalTests)),
				(r._whitelist = n._whitelist.merge(t._whitelist, t._blacklist)),
				(r._blacklist = n._blacklist.merge(t._blacklist, t._whitelist)),
				(r.tests = n.tests),
				(r.exclusiveTests = n.exclusiveTests),
				r.withMutation((a) => {
					t.tests.forEach((o) => {
						a.test(o.OPTIONS)
					})
				}),
				(r.transforms = [...n.transforms, ...r.transforms]),
				r
			)
		}
		isType(t) {
			return t == null
				? !!((this.spec.nullable && t === null) || (this.spec.optional && t === void 0))
				: this._typeCheck(t)
		}
		resolve(t) {
			let n = this
			if (n.conditions.length) {
				let r = n.conditions
				;(n = n.clone()),
					(n.conditions = []),
					(n = r.reduce((i, a) => a.resolve(i, t), n)),
					(n = n.resolve(t))
			}
			return n
		}
		resolveOptions(t) {
			var n, r, i, a
			return Object.assign({}, t, {
				from: t.from || [],
				strict: (n = t.strict) != null ? n : this.spec.strict,
				abortEarly: (r = t.abortEarly) != null ? r : this.spec.abortEarly,
				recursive: (i = t.recursive) != null ? i : this.spec.recursive,
				disableStackTrace: (a = t.disableStackTrace) != null ? a : this.spec.disableStackTrace,
			})
		}
		cast(t, n = {}) {
			let r = this.resolve(Object.assign({ value: t }, n)),
				i = n.assert === "ignore-optionality",
				a = r._cast(t, n)
			if (n.assert !== !1 && !r.isType(a)) {
				if (i && vo(a)) return a
				let o = Cu(t),
					s = Cu(a)
				throw new TypeError(
					`The value of ${
						n.path || "field"
					} could not be cast to a value that satisfies the schema type: "${r.type}". 

attempted value: ${o} 
` + (s !== o ? `result of cast: ${s}` : ""),
				)
			}
			return a
		}
		_cast(t, n) {
			let r = t === void 0 ? t : this.transforms.reduce((i, a) => a.call(this, i, t, this), t)
			return r === void 0 && (r = this.getDefault(n)), r
		}
		_validate(t, n = {}, r, i) {
			let { path: a, originalValue: o = t, strict: s = this.spec.strict } = n,
				l = t
			s || (l = this._cast(l, Object.assign({ assert: !1 }, n)))
			let u = []
			for (let d of Object.values(this.internalTests)) d && u.push(d)
			this.runTests({ path: a, value: l, originalValue: o, options: n, tests: u }, r, (d) => {
				if (d.length) return i(d, l)
				this.runTests({ path: a, value: l, originalValue: o, options: n, tests: this.tests }, r, i)
			})
		}
		runTests(t, n, r) {
			let i = !1,
				{ tests: a, value: o, originalValue: s, path: l, options: u } = t,
				d = (b) => {
					i || ((i = !0), n(b, o))
				},
				p = (b) => {
					i || ((i = !0), r(b, o))
				},
				m = a.length,
				v = []
			if (!m) return p([])
			let y = { value: o, originalValue: s, path: l, options: u, schema: this }
			for (let b = 0; b < a.length; b++) {
				const x = a[b]
				x(y, d, function (T) {
					T && (Array.isArray(T) ? v.push(...T) : v.push(T)), --m <= 0 && p(v)
				})
			}
		}
		asNestedTest({ key: t, index: n, parent: r, parentPath: i, originalParent: a, options: o }) {
			const s = t ?? n
			if (s == null) throw TypeError("Must include `key` or `index` for nested validations")
			const l = typeof s == "number"
			let u = r[s]
			const d = Object.assign({}, o, {
				strict: !0,
				parent: r,
				value: u,
				originalValue: a[s],
				key: void 0,
				[l ? "index" : "key"]: s,
				path: l || s.includes(".") ? `${i || ""}[${l ? s : `"${s}"`}]` : (i ? `${i}.` : "") + t,
			})
			return (p, m, v) => this.resolve(d)._validate(u, d, m, v)
		}
		validate(t, n) {
			var r
			let i = this.resolve(Object.assign({}, n, { value: t })),
				a = (r = n == null ? void 0 : n.disableStackTrace) != null ? r : i.spec.disableStackTrace
			return new Promise((o, s) =>
				i._validate(
					t,
					n,
					(l, u) => {
						ji.isError(l) && (l.value = u), s(l)
					},
					(l, u) => {
						l.length ? s(new ji(l, u, void 0, void 0, a)) : o(u)
					},
				),
			)
		}
		validateSync(t, n) {
			var r
			let i = this.resolve(Object.assign({}, n, { value: t })),
				a,
				o = (r = n == null ? void 0 : n.disableStackTrace) != null ? r : i.spec.disableStackTrace
			return (
				i._validate(
					t,
					Object.assign({}, n, { sync: !0 }),
					(s, l) => {
						throw (ji.isError(s) && (s.value = l), s)
					},
					(s, l) => {
						if (s.length) throw new ji(s, t, void 0, void 0, o)
						a = l
					},
				),
				a
			)
		}
		isValid(t, n) {
			return this.validate(t, n).then(
				() => !0,
				(r) => {
					if (ji.isError(r)) return !1
					throw r
				},
			)
		}
		isValidSync(t, n) {
			try {
				return this.validateSync(t, n), !0
			} catch (r) {
				if (ji.isError(r)) return !1
				throw r
			}
		}
		_getDefault(t) {
			let n = this.spec.default
			return n == null ? n : typeof n == "function" ? n.call(this, t) : Lf(n)
		}
		getDefault(t) {
			return this.resolve(t || {})._getDefault(t)
		}
		default(t) {
			return arguments.length === 0 ? this._getDefault() : this.clone({ default: t })
		}
		strict(t = !0) {
			return this.clone({ strict: t })
		}
		nullability(t, n) {
			const r = this.clone({ nullable: t })
			return (
				(r.internalTests.nullable = vf({
					message: n,
					name: "nullable",
					test(i) {
						return i === null ? this.schema.spec.nullable : !0
					},
				})),
				r
			)
		}
		optionality(t, n) {
			const r = this.clone({ optional: t })
			return (
				(r.internalTests.optionality = vf({
					message: n,
					name: "optionality",
					test(i) {
						return i === void 0 ? this.schema.spec.optional : !0
					},
				})),
				r
			)
		}
		optional() {
			return this.optionality(!0)
		}
		defined(t = Yo.defined) {
			return this.optionality(!1, t)
		}
		nullable() {
			return this.nullability(!0)
		}
		nonNullable(t = Yo.notNull) {
			return this.nullability(!1, t)
		}
		required(t = Yo.required) {
			return this.clone().withMutation((n) => n.nonNullable(t).defined(t))
		}
		notRequired() {
			return this.clone().withMutation((t) => t.nullable().optional())
		}
		transform(t) {
			let n = this.clone()
			return n.transforms.push(t), n
		}
		test(...t) {
			let n
			if (
				(t.length === 1
					? typeof t[0] == "function"
						? (n = { test: t[0] })
						: (n = t[0])
					: t.length === 2
					? (n = { name: t[0], test: t[1] })
					: (n = { name: t[0], message: t[1], test: t[2] }),
				n.message === void 0 && (n.message = Yo.default),
				typeof n.test != "function")
			)
				throw new TypeError("`test` is a required parameters")
			let r = this.clone(),
				i = vf(n),
				a = n.exclusive || (n.name && r.exclusiveTests[n.name] === !0)
			if (n.exclusive && !n.name)
				throw new TypeError("Exclusive tests must provide a unique `name` identifying the test")
			return (
				n.name && (r.exclusiveTests[n.name] = !!n.exclusive),
				(r.tests = r.tests.filter(
					(o) => !(o.OPTIONS.name === n.name && (a || o.OPTIONS.test === i.OPTIONS.test)),
				)),
				r.tests.push(i),
				r
			)
		}
		when(t, n) {
			!Array.isArray(t) && typeof t != "string" && ((n = t), (t = "."))
			let r = this.clone(),
				i = OH(t).map((a) => new Ku(a))
			return (
				i.forEach((a) => {
					a.isSibling && r.deps.push(a.key)
				}),
				r.conditions.push(typeof n == "function" ? new G1(i, n) : G1.fromOptions(i, n)),
				r
			)
		}
		typeError(t) {
			let n = this.clone()
			return (
				(n.internalTests.typeError = vf({
					message: t,
					name: "typeError",
					skipAbsent: !0,
					test(r) {
						return this.schema._typeCheck(r)
							? !0
							: this.createError({ params: { type: this.schema.type } })
					},
				})),
				n
			)
		}
		oneOf(t, n = Yo.oneOf) {
			let r = this.clone()
			return (
				t.forEach((i) => {
					r._whitelist.add(i), r._blacklist.delete(i)
				}),
				(r.internalTests.whiteList = vf({
					message: n,
					name: "oneOf",
					skipAbsent: !0,
					test(i) {
						let a = this.schema._whitelist,
							o = a.resolveAll(this.resolve)
						return o.includes(i)
							? !0
							: this.createError({ params: { values: Array.from(a).join(", "), resolved: o } })
					},
				})),
				r
			)
		}
		notOneOf(t, n = Yo.notOneOf) {
			let r = this.clone()
			return (
				t.forEach((i) => {
					r._blacklist.add(i), r._whitelist.delete(i)
				}),
				(r.internalTests.blacklist = vf({
					message: n,
					name: "notOneOf",
					test(i) {
						let a = this.schema._blacklist,
							o = a.resolveAll(this.resolve)
						return o.includes(i)
							? this.createError({ params: { values: Array.from(a).join(", "), resolved: o } })
							: !0
					},
				})),
				r
			)
		}
		strip(t = !0) {
			let n = this.clone()
			return (n.spec.strip = t), n
		}
		describe(t) {
			const n = (t ? this.resolve(t) : this).clone(),
				{ label: r, meta: i, optional: a, nullable: o } = n.spec
			return {
				meta: i,
				label: r,
				optional: a,
				nullable: o,
				default: n.getDefault(t),
				type: n.type,
				oneOf: n._whitelist.describe(),
				notOneOf: n._blacklist.describe(),
				tests: n.tests
					.map((l) => ({ name: l.OPTIONS.name, params: l.OPTIONS.params }))
					.filter((l, u, d) => d.findIndex((p) => p.name === l.name) === u),
			}
		}
	}
	Wa.prototype.__isYupSchema__ = !0
	for (const e of ["validate", "validateSync"])
		Wa.prototype[`${e}At`] = function (t, n, r = {}) {
			const { parent: i, parentPath: a, schema: o } = Sde(this, t, n, r.context)
			return o[e](i && i[a], Object.assign({}, r, { parent: i, path: t }))
		}
	for (const e of ["equals", "is"]) Wa.prototype[e] = Wa.prototype.oneOf
	for (const e of ["not", "nope"]) Wa.prototype[e] = Wa.prototype.notOneOf
	function dd() {
		return new IH()
	}
	class IH extends Wa {
		constructor() {
			super({
				type: "boolean",
				check(t) {
					return t instanceof Boolean && (t = t.valueOf()), typeof t == "boolean"
				},
			}),
				this.withMutation(() => {
					this.transform((t, n, r) => {
						if (r.spec.coerce && !r.isType(t)) {
							if (/^(true|1)$/i.test(String(t))) return !0
							if (/^(false|0)$/i.test(String(t))) return !1
						}
						return t
					})
				})
		}
		isTrue(t = o2.isValue) {
			return this.test({
				message: t,
				name: "is-value",
				exclusive: !0,
				params: { value: "true" },
				test(n) {
					return vo(n) || n === !0
				},
			})
		}
		isFalse(t = o2.isValue) {
			return this.test({
				message: t,
				name: "is-value",
				exclusive: !0,
				params: { value: "false" },
				test(n) {
					return vo(n) || n === !1
				},
			})
		}
		default(t) {
			return super.default(t)
		}
		defined(t) {
			return super.defined(t)
		}
		optional() {
			return super.optional()
		}
		required(t) {
			return super.required(t)
		}
		notRequired() {
			return super.notRequired()
		}
		nullable() {
			return super.nullable()
		}
		nonNullable(t) {
			return super.nonNullable(t)
		}
		strip(t) {
			return super.strip(t)
		}
	}
	dd.prototype = IH.prototype
	const Dde =
		/^(\d{4}|[+-]\d{6})(?:-?(\d{2})(?:-?(\d{2}))?)?(?:[ T]?(\d{2}):?(\d{2})(?::?(\d{2})(?:[,.](\d{1,}))?)?(?:(Z)|([+-])(\d{2})(?::?(\d{2}))?)?)?$/
	function _de(e) {
		const t = l2(e)
		if (!t) return Date.parse ? Date.parse(e) : Number.NaN
		if (t.z === void 0 && t.plusMinus === void 0)
			return new Date(t.year, t.month, t.day, t.hour, t.minute, t.second, t.millisecond).valueOf()
		let n = 0
		return (
			t.z !== "Z" &&
				t.plusMinus !== void 0 &&
				((n = t.hourOffset * 60 + t.minuteOffset), t.plusMinus === "+" && (n = 0 - n)),
			Date.UTC(t.year, t.month, t.day, t.hour, t.minute + n, t.second, t.millisecond)
		)
	}
	function l2(e) {
		var t, n
		const r = Dde.exec(e)
		return r
			? {
					year: qs(r[1]),
					month: qs(r[2], 1) - 1,
					day: qs(r[3], 1),
					hour: qs(r[4]),
					minute: qs(r[5]),
					second: qs(r[6]),
					millisecond: r[7] ? qs(r[7].substring(0, 3)) : 0,
					precision: (t = (n = r[7]) == null ? void 0 : n.length) != null ? t : void 0,
					z: r[8] || void 0,
					plusMinus: r[9] || void 0,
					hourOffset: qs(r[10]),
					minuteOffset: qs(r[11]),
			  }
			: null
	}
	function qs(e, t = 0) {
		return Number(e) || t
	}
	let Ode =
			/^[a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/,
		Ade =
			/^((https?|ftp):)?\/\/(((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:)*@)?(((\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5]))|((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.?)(:\d*)?)(\/((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)+(\/(([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)*)*)?)?(\?((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|[\uE000-\uF8FF]|\/|\?)*)?(\#((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|\/|\?)*)?$/i,
		Nde =
			/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i,
		Mde = "^\\d{4}-\\d{2}-\\d{2}",
		Ide = "\\d{2}:\\d{2}:\\d{2}",
		Rde = "(([+-]\\d{2}(:?\\d{2})?)|Z)",
		Lde = new RegExp(`${Mde}T${Ide}(\\.\\d+)?${Rde}$`),
		Pde = (e) => vo(e) || e === e.trim(),
		jde = {}.toString()
	function Oe() {
		return new RH()
	}
	class RH extends Wa {
		constructor() {
			super({
				type: "string",
				check(t) {
					return t instanceof String && (t = t.valueOf()), typeof t == "string"
				},
			}),
				this.withMutation(() => {
					this.transform((t, n, r) => {
						if (!r.spec.coerce || r.isType(t) || Array.isArray(t)) return t
						const i = t != null && t.toString ? t.toString() : t
						return i === jde ? t : i
					})
				})
		}
		required(t) {
			return super
				.required(t)
				.withMutation((n) =>
					n.test({
						message: t || Yo.required,
						name: "required",
						skipAbsent: !0,
						test: (r) => !!r.length,
					}),
				)
		}
		notRequired() {
			return super
				.notRequired()
				.withMutation((t) => ((t.tests = t.tests.filter((n) => n.OPTIONS.name !== "required")), t))
		}
		length(t, n = Ii.length) {
			return this.test({
				message: n,
				name: "length",
				exclusive: !0,
				params: { length: t },
				skipAbsent: !0,
				test(r) {
					return r.length === this.resolve(t)
				},
			})
		}
		min(t, n = Ii.min) {
			return this.test({
				message: n,
				name: "min",
				exclusive: !0,
				params: { min: t },
				skipAbsent: !0,
				test(r) {
					return r.length >= this.resolve(t)
				},
			})
		}
		max(t, n = Ii.max) {
			return this.test({
				name: "max",
				exclusive: !0,
				message: n,
				params: { max: t },
				skipAbsent: !0,
				test(r) {
					return r.length <= this.resolve(t)
				},
			})
		}
		matches(t, n) {
			let r = !1,
				i,
				a
			return (
				n &&
					(typeof n == "object"
						? ({ excludeEmptyString: r = !1, message: i, name: a } = n)
						: (i = n)),
				this.test({
					name: a || "matches",
					message: i || Ii.matches,
					params: { regex: t },
					skipAbsent: !0,
					test: (o) => (o === "" && r) || o.search(t) !== -1,
				})
			)
		}
		email(t = Ii.email) {
			return this.matches(Ode, { name: "email", message: t, excludeEmptyString: !0 })
		}
		url(t = Ii.url) {
			return this.matches(Ade, { name: "url", message: t, excludeEmptyString: !0 })
		}
		uuid(t = Ii.uuid) {
			return this.matches(Nde, { name: "uuid", message: t, excludeEmptyString: !1 })
		}
		datetime(t) {
			let n = "",
				r,
				i
			return (
				t &&
					(typeof t == "object"
						? ({ message: n = "", allowOffset: r = !1, precision: i = void 0 } = t)
						: (n = t)),
				this.matches(Lde, { name: "datetime", message: n || Ii.datetime, excludeEmptyString: !0 })
					.test({
						name: "datetime_offset",
						message: n || Ii.datetime_offset,
						params: { allowOffset: r },
						skipAbsent: !0,
						test: (a) => {
							if (!a || r) return !0
							const o = l2(a)
							return o ? !!o.z : !1
						},
					})
					.test({
						name: "datetime_precision",
						message: n || Ii.datetime_precision,
						params: { precision: i },
						skipAbsent: !0,
						test: (a) => {
							if (!a || i == null) return !0
							const o = l2(a)
							return o ? o.precision === i : !1
						},
					})
			)
		}
		ensure() {
			return this.default("").transform((t) => (t === null ? "" : t))
		}
		trim(t = Ii.trim) {
			return this.transform((n) => (n != null ? n.trim() : n)).test({
				message: t,
				name: "trim",
				test: Pde,
			})
		}
		lowercase(t = Ii.lowercase) {
			return this.transform((n) => (vo(n) ? n : n.toLowerCase())).test({
				message: t,
				name: "string_case",
				exclusive: !0,
				skipAbsent: !0,
				test: (n) => vo(n) || n === n.toLowerCase(),
			})
		}
		uppercase(t = Ii.uppercase) {
			return this.transform((n) => (vo(n) ? n : n.toUpperCase())).test({
				message: t,
				name: "string_case",
				exclusive: !0,
				skipAbsent: !0,
				test: (n) => vo(n) || n === n.toUpperCase(),
			})
		}
	}
	Oe.prototype = RH.prototype
	let Fde = (e) => e != +e
	function gi() {
		return new LH()
	}
	class LH extends Wa {
		constructor() {
			super({
				type: "number",
				check(t) {
					return t instanceof Number && (t = t.valueOf()), typeof t == "number" && !Fde(t)
				},
			}),
				this.withMutation(() => {
					this.transform((t, n, r) => {
						if (!r.spec.coerce) return t
						let i = t
						if (typeof i == "string") {
							if (((i = i.replace(/\s/g, "")), i === "")) return NaN
							i = +i
						}
						return r.isType(i) || i === null ? i : parseFloat(i)
					})
				})
		}
		min(t, n = uu.min) {
			return this.test({
				message: n,
				name: "min",
				exclusive: !0,
				params: { min: t },
				skipAbsent: !0,
				test(r) {
					return r >= this.resolve(t)
				},
			})
		}
		max(t, n = uu.max) {
			return this.test({
				message: n,
				name: "max",
				exclusive: !0,
				params: { max: t },
				skipAbsent: !0,
				test(r) {
					return r <= this.resolve(t)
				},
			})
		}
		lessThan(t, n = uu.lessThan) {
			return this.test({
				message: n,
				name: "max",
				exclusive: !0,
				params: { less: t },
				skipAbsent: !0,
				test(r) {
					return r < this.resolve(t)
				},
			})
		}
		moreThan(t, n = uu.moreThan) {
			return this.test({
				message: n,
				name: "min",
				exclusive: !0,
				params: { more: t },
				skipAbsent: !0,
				test(r) {
					return r > this.resolve(t)
				},
			})
		}
		positive(t = uu.positive) {
			return this.moreThan(0, t)
		}
		negative(t = uu.negative) {
			return this.lessThan(0, t)
		}
		integer(t = uu.integer) {
			return this.test({
				name: "integer",
				message: t,
				skipAbsent: !0,
				test: (n) => Number.isInteger(n),
			})
		}
		truncate() {
			return this.transform((t) => (vo(t) ? t : t | 0))
		}
		round(t) {
			var n
			let r = ["ceil", "floor", "round", "trunc"]
			if (((t = ((n = t) == null ? void 0 : n.toLowerCase()) || "round"), t === "trunc"))
				return this.truncate()
			if (r.indexOf(t.toLowerCase()) === -1)
				throw new TypeError("Only valid options for round() are: " + r.join(", "))
			return this.transform((i) => (vo(i) ? i : Math[t](i)))
		}
	}
	gi.prototype = LH.prototype
	let PH = new Date(""),
		Bde = (e) => Object.prototype.toString.call(e) === "[object Date]"
	function Fu() {
		return new ag()
	}
	class ag extends Wa {
		constructor() {
			super({
				type: "date",
				check(t) {
					return Bde(t) && !isNaN(t.getTime())
				},
			}),
				this.withMutation(() => {
					this.transform((t, n, r) =>
						!r.spec.coerce || r.isType(t) || t === null
							? t
							: ((t = _de(t)), isNaN(t) ? ag.INVALID_DATE : new Date(t)),
					)
				})
		}
		prepareParam(t, n) {
			let r
			if (Ku.isRef(t)) r = t
			else {
				let i = this.cast(t)
				if (!this._typeCheck(i))
					throw new TypeError(`\`${n}\` must be a Date or a value that can be \`cast()\` to a Date`)
				r = i
			}
			return r
		}
		min(t, n = a2.min) {
			let r = this.prepareParam(t, "min")
			return this.test({
				message: n,
				name: "min",
				exclusive: !0,
				params: { min: t },
				skipAbsent: !0,
				test(i) {
					return i >= this.resolve(r)
				},
			})
		}
		max(t, n = a2.max) {
			let r = this.prepareParam(t, "max")
			return this.test({
				message: n,
				name: "max",
				exclusive: !0,
				params: { max: t },
				skipAbsent: !0,
				test(i) {
					return i <= this.resolve(r)
				},
			})
		}
	}
	ag.INVALID_DATE = PH
	Fu.prototype = ag.prototype
	Fu.INVALID_DATE = PH
	function Hde(e, t = []) {
		let n = [],
			r = new Set(),
			i = new Set(t.map(([o, s]) => `${o}-${s}`))
		function a(o, s) {
			let l = Gc.split(o)[0]
			r.add(l), i.has(`${s}-${l}`) || n.push([s, l])
		}
		for (const o of Object.keys(e)) {
			let s = e[o]
			r.add(o),
				Ku.isRef(s) && s.isSibling
					? a(s.path, o)
					: W_(s) && "deps" in s && s.deps.forEach((l) => a(l, o))
		}
		return vde.array(Array.from(r), n).reverse()
	}
	function wP(e, t) {
		let n = 1 / 0
		return (
			e.some((r, i) => {
				var a
				if ((a = t.path) != null && a.includes(r)) return (n = i), !0
			}),
			n
		)
	}
	function jH(e) {
		return (t, n) => wP(e, t) - wP(e, n)
	}
	const $de = (e, t, n) => {
		if (typeof e != "string") return e
		let r = e
		try {
			r = JSON.parse(e)
		} catch {}
		return n.isType(r) ? r : e
	}
	function a1(e) {
		if ("fields" in e) {
			const t = {}
			for (const [n, r] of Object.entries(e.fields)) t[n] = a1(r)
			return e.setFields(t)
		}
		if (e.type === "array") {
			const t = e.optional()
			return t.innerType && (t.innerType = a1(t.innerType)), t
		}
		return e.type === "tuple"
			? e.optional().clone({ types: e.spec.types.map(a1) })
			: "optional" in e
			? e.optional()
			: e
	}
	const Ude = (e, t) => {
		const n = [...Gc.normalizePath(t)]
		if (n.length === 1) return n[0] in e
		let r = n.pop(),
			i = Gc.getter(Gc.join(n), !0)(e)
		return !!(i && r in i)
	}
	let EP = (e) => Object.prototype.toString.call(e) === "[object Object]"
	function zde(e, t) {
		let n = Object.keys(e.fields)
		return Object.keys(t).filter((r) => n.indexOf(r) === -1)
	}
	const qde = jH([])
	function Bt(e) {
		return new FH(e)
	}
	class FH extends Wa {
		constructor(t) {
			super({
				type: "object",
				check(n) {
					return EP(n) || typeof n == "function"
				},
			}),
				(this.fields = Object.create(null)),
				(this._sortErrors = qde),
				(this._nodes = []),
				(this._excludedEdges = []),
				this.withMutation(() => {
					t && this.shape(t)
				})
		}
		_cast(t, n = {}) {
			var r
			let i = super._cast(t, n)
			if (i === void 0) return this.getDefault(n)
			if (!this._typeCheck(i)) return i
			let a = this.fields,
				o = (r = n.stripUnknown) != null ? r : this.spec.noUnknown,
				s = [].concat(
					this._nodes,
					Object.keys(i).filter((p) => !this._nodes.includes(p)),
				),
				l = {},
				u = Object.assign({}, n, { parent: l, __validating: n.__validating || !1 }),
				d = !1
			for (const p of s) {
				let m = a[p],
					v = p in i
				if (m) {
					let y,
						b = i[p]
					;(u.path = (n.path ? `${n.path}.` : "") + p),
						(m = m.resolve({ value: b, context: n.context, parent: l }))
					let x = m instanceof Wa ? m.spec : void 0,
						E = x == null ? void 0 : x.strict
					if (x != null && x.strip) {
						d = d || p in i
						continue
					}
					;(y = !n.__validating || !E ? m.cast(i[p], u) : i[p]), y !== void 0 && (l[p] = y)
				} else v && !o && (l[p] = i[p])
				;(v !== p in l || l[p] !== i[p]) && (d = !0)
			}
			return d ? l : i
		}
		_validate(t, n = {}, r, i) {
			let { from: a = [], originalValue: o = t, recursive: s = this.spec.recursive } = n
			;(n.from = [{ schema: this, value: o }, ...a]),
				(n.__validating = !0),
				(n.originalValue = o),
				super._validate(t, n, r, (l, u) => {
					if (!s || !EP(u)) {
						i(l, u)
						return
					}
					o = o || u
					let d = []
					for (let p of this._nodes) {
						let m = this.fields[p]
						!m ||
							Ku.isRef(m) ||
							d.push(
								m.asNestedTest({
									options: n,
									key: p,
									parent: u,
									parentPath: n.path,
									originalParent: o,
								}),
							)
					}
					this.runTests({ tests: d, value: u, originalValue: o, options: n }, r, (p) => {
						i(p.sort(this._sortErrors).concat(l), u)
					})
				})
		}
		clone(t) {
			const n = super.clone(t)
			return (
				(n.fields = Object.assign({}, this.fields)),
				(n._nodes = this._nodes),
				(n._excludedEdges = this._excludedEdges),
				(n._sortErrors = this._sortErrors),
				n
			)
		}
		concat(t) {
			let n = super.concat(t),
				r = n.fields
			for (let [i, a] of Object.entries(this.fields)) {
				const o = r[i]
				r[i] = o === void 0 ? a : o
			}
			return n.withMutation((i) => i.setFields(r, [...this._excludedEdges, ...t._excludedEdges]))
		}
		_getDefault(t) {
			if ("default" in this.spec) return super._getDefault(t)
			if (!this._nodes.length) return
			let n = {}
			return (
				this._nodes.forEach((r) => {
					var i
					const a = this.fields[r]
					let o = t
					;(i = o) != null &&
						i.value &&
						(o = Object.assign({}, o, { parent: o.value, value: o.value[r] })),
						(n[r] = a && "getDefault" in a ? a.getDefault(o) : void 0)
				}),
				n
			)
		}
		setFields(t, n) {
			let r = this.clone()
			return (
				(r.fields = t),
				(r._nodes = Hde(t, n)),
				(r._sortErrors = jH(Object.keys(t))),
				n && (r._excludedEdges = n),
				r
			)
		}
		shape(t, n = []) {
			return this.clone().withMutation((r) => {
				let i = r._excludedEdges
				return (
					n.length && (Array.isArray(n[0]) || (n = [n]), (i = [...r._excludedEdges, ...n])),
					r.setFields(Object.assign(r.fields, t), i)
				)
			})
		}
		partial() {
			const t = {}
			for (const [n, r] of Object.entries(this.fields))
				t[n] = "optional" in r && r.optional instanceof Function ? r.optional() : r
			return this.setFields(t)
		}
		deepPartial() {
			return a1(this)
		}
		pick(t) {
			const n = {}
			for (const r of t) this.fields[r] && (n[r] = this.fields[r])
			return this.setFields(
				n,
				this._excludedEdges.filter(([r, i]) => t.includes(r) && t.includes(i)),
			)
		}
		omit(t) {
			const n = []
			for (const r of Object.keys(this.fields)) t.includes(r) || n.push(r)
			return this.pick(n)
		}
		from(t, n, r) {
			let i = Gc.getter(t, !0)
			return this.transform((a) => {
				if (!a) return a
				let o = a
				return Ude(a, t) && ((o = Object.assign({}, a)), r || delete o[t], (o[n] = i(a))), o
			})
		}
		json() {
			return this.transform($de)
		}
		noUnknown(t = !0, n = s2.noUnknown) {
			typeof t != "boolean" && ((n = t), (t = !0))
			let r = this.test({
				name: "noUnknown",
				exclusive: !0,
				message: n,
				test(i) {
					if (i == null) return !0
					const a = zde(this.schema, i)
					return !t || a.length === 0 || this.createError({ params: { unknown: a.join(", ") } })
				},
			})
			return (r.spec.noUnknown = t), r
		}
		unknown(t = !0, n = s2.noUnknown) {
			return this.noUnknown(!t, n)
		}
		transformKeys(t) {
			return this.transform((n) => {
				if (!n) return n
				const r = {}
				for (const i of Object.keys(n)) r[t(i)] = n[i]
				return r
			})
		}
		camelCase() {
			return this.transformKeys(BT.camelCase)
		}
		snakeCase() {
			return this.transformKeys(BT.snakeCase)
		}
		constantCase() {
			return this.transformKeys((t) => BT.snakeCase(t).toUpperCase())
		}
		describe(t) {
			const n = (t ? this.resolve(t) : this).clone(),
				r = super.describe(t)
			r.fields = {}
			for (const [a, o] of Object.entries(n.fields)) {
				var i
				let s = t
				;(i = s) != null &&
					i.value &&
					(s = Object.assign({}, s, { parent: s.value, value: s.value[a] })),
					(r.fields[a] = o.describe(s))
			}
			return r
		}
	}
	Bt.prototype = FH.prototype
	const Vde = Bt({
			currentPassword: Oe().required("Your current password is required"),
			newPassword: Oe().required("A new password is required"),
			confirmPassword: Oe()
				.oneOf([Y_("newPassword"), null], "Passwords must match")
				.required("Password confirmation is required"),
		}),
		Wde = (e) => {
			const t = Nr((n) => n.session)
			return h.jsx(Vt, {
				validationSchema: Vde,
				validateOnBlur: !1,
				validateOnChange: !1,
				onSubmit: (n) => {
					e.OnChange(n)
				},
				initialValues: {},
				children: ({
					handleSubmit: n,
					handleChange: r,
					handleBlur: i,
					values: a,
					touched: o,
					errors: s,
				}) =>
					h.jsxs(R, {
						noValidate: !0,
						onSubmit: n,
						children: [
							h.jsxs(R.Group, {
								controlId: "currentPassword",
								children: [
									h.jsx(R.Label, { children: "Current Password" }),
									h.jsx(R.Control, {
										name: "currentPassword",
										type: "password",
										value: a.currentPassword || "",
										isValid: o.currentPassword && !s.currentPassword,
										isInvalid: !!s.currentPassword,
										onChange: r,
										onBlur: i,
									}),
									h.jsx(R.Control.Feedback, { type: "invalid", children: s.currentPassword }),
								],
							}),
							h.jsxs(R.Group, {
								controlId: "newPassword",
								children: [
									h.jsx(R.Label, { children: "New Password" }),
									h.jsx(R.Control, {
										name: "newPassword",
										type: "password",
										value: a.newPassword || "",
										isValid: o.newPassword && !s.newPassword,
										isInvalid: !!s.newPassword,
										onChange: r,
										onBlur: i,
									}),
									h.jsx(R.Control.Feedback, { type: "invalid", children: s.newPassword }),
								],
							}),
							h.jsxs(R.Group, {
								controlId: "confirmPassword",
								children: [
									h.jsx(R.Label, { children: "Confirm New Password" }),
									h.jsx(R.Control, {
										name: "confirmPassword",
										type: "password",
										value: a.confirmPassword || "",
										isValid: o.confirmPassword && !s.confirmPassword,
										isInvalid: !!s.confirmPassword,
										onChange: r,
										onBlur: i,
									}),
									h.jsx(R.Control.Feedback, { type: "invalid", children: s.confirmPassword }),
								],
							}),
							h.jsx(Ge, {
								variant: "primary",
								type: "submit",
								size: "sm",
								className: "mt-2",
								disabled: t.flags.isBusy,
								children: "Change Password",
							}),
						],
					}),
			})
		},
		$x = Ft.div`
	border-width: 1px;
	border-color: teal;
	border-style: solid;
	padding: 10px;
	margin-bottom: 10px;
`
	$x.displayName = "EditAccountContainer"
	const Yde = () => {
			const [e, t] = _.useState(!1),
				n = ki(),
				r = (i) => {
					n(
						Ky({
							password: i.currentPassword,
							new_password: i.newPassword,
							re_new_password: i.confirmPassword,
						}),
					),
						t(!1)
				}
			return h.jsxs("div", {
				children: [
					h.jsxs(ln, {
						children: [
							h.jsx(it, { xs: 3, children: "Password" }),
							h.jsx(it, { xs: 8, children: "********" }),
							h.jsx(it, {
								xs: 1,
								children: h.jsx(Ge, {
									variant: "link",
									className: "text-info",
									onClick: () => t(!e),
									children: e ? "cancel" : "change",
								}),
							}),
						],
					}),
					e &&
						h.jsx(ln, {
							children: h.jsx(it, {
								xs: 12,
								children: h.jsx($x, { children: h.jsx(Wde, { OnChange: (i) => r(i) }) }),
							}),
						}),
				],
			})
		},
		Gde = Bt({ email: Oe().email().required() }),
		Kde = (e) => {
			const t = Nr((n) => n.session)
			return h.jsx(Vt, {
				validationSchema: Gde,
				onSubmit: (n) => {
					e.OnChange(n.email)
				},
				initialValues: { email: e.email || "" },
				children: ({
					handleSubmit: n,
					handleChange: r,
					handleBlur: i,
					values: a,
					touched: o,
					errors: s,
					isValid: l,
				}) =>
					h.jsxs(R, {
						noValidate: !0,
						onSubmit: n,
						children: [
							h.jsxs(R.Group, {
								controlId: "email",
								children: [
									h.jsx(R.Label, { children: "New Email" }),
									h.jsx(R.Control, {
										placeholder: "New Email",
										name: "email",
										type: "email",
										value: a.email,
										isValid: o.email && !s.email,
										isInvalid: !!s.email,
										onChange: r,
										onBlur: i,
									}),
									h.jsx(R.Control.Feedback, { type: "invalid", children: s.email }),
								],
							}),
							h.jsx(Ge, {
								variant: "primary",
								type: "submit",
								size: "sm",
								className: "mt-2",
								disabled: t.flags.isBusy || !l,
								children: "Change Email",
							}),
						],
					}),
			})
		},
		Qde = () => {
			const [e, t] = _.useState(!1),
				n = ki(),
				{ user: r } = ks(),
				i = (a) => {
					n(pB({ email: a })), t(!1)
				}
			return h.jsxs("div", {
				children: [
					h.jsxs(ln, {
						children: [
							h.jsx(it, { xs: 3, children: "Email" }),
							h.jsx(it, { xs: 8, children: r.email }),
							h.jsx(it, {
								xs: 1,
								children: h.jsx(Ge, {
									variant: "link",
									className: "text-info",
									onClick: () => t(!e),
									children: e ? "cancel" : "change",
								}),
							}),
						],
					}),
					e &&
						h.jsx(ln, {
							children: h.jsx(it, {
								xs: 12,
								children: h.jsx($x, {
									children: h.jsx(Kde, { email: r.email, OnChange: (a) => i(a) }),
								}),
							}),
						}),
				],
			})
		},
		Xde = Bt({
			firstName: Oe().required("Please enter your first name"),
			lastName: Oe().required("Please enter your last name"),
		}),
		Jde = (e) => {
			const t = Nr((n) => n.session)
			return h.jsx(Vt, {
				validationSchema: Xde,
				validateOnBlur: !1,
				validateOnChange: !1,
				onSubmit: (n) => {
					e.OnChange(n.firstName, n.lastName)
				},
				initialValues: { firstName: e.firstName, lastName: e.lastName },
				children: ({
					handleSubmit: n,
					handleChange: r,
					handleBlur: i,
					values: a,
					touched: o,
					errors: s,
				}) =>
					h.jsxs(R, {
						noValidate: !0,
						onSubmit: n,
						children: [
							h.jsxs(R.Group, {
								controlId: "firstName",
								children: [
									h.jsx(R.Label, { children: "First Name" }),
									h.jsx(R.Control, {
										placeholder: "First Name",
										name: "firstName",
										value: a.firstName,
										isValid: o.firstName && !s.firstName,
										isInvalid: !!s.firstName,
										onChange: r,
										onBlur: i,
									}),
									h.jsx(R.Control.Feedback, { type: "invalid", children: s.firstName }),
								],
							}),
							h.jsxs(R.Group, {
								controlId: "lastName",
								children: [
									h.jsx(R.Label, { children: "Last Name" }),
									h.jsx(R.Control, {
										placeholder: "Last Name",
										name: "lastName",
										value: a.lastName,
										isValid: o.lastName && !s.lastName,
										isInvalid: !!s.lastName,
										onChange: r,
										onBlur: i,
									}),
									h.jsx(R.Control.Feedback, { type: "invalid", children: s.lastName }),
								],
							}),
							h.jsx(Ge, {
								variant: "primary",
								type: "submit",
								size: "sm",
								className: "mt-2",
								disabled: t.flags.isBusy,
								children: "Change Name",
							}),
						],
					}),
			})
		},
		Zde = () => {
			const [e, t] = _.useState(!1),
				n = ki(),
				{ user: r } = ks(),
				i = (a, o) => {
					n(pB({ first_name: a, last_name: o })), t(!1)
				}
			return h.jsxs("div", {
				children: [
					h.jsxs(ln, {
						children: [
							h.jsx(it, { xs: 3, children: "Name" }),
							h.jsx(it, { xs: 8, children: r.name }),
							h.jsx(it, {
								xs: 1,
								children: h.jsx(Ge, {
									variant: "link",
									className: "text-info",
									onClick: () => t(!e),
									children: e ? "cancel" : "change",
								}),
							}),
						],
					}),
					e &&
						h.jsx(ln, {
							children: h.jsx(it, {
								xs: 12,
								children: h.jsx($x, {
									children: h.jsx(Jde, {
										firstName: r.firstName,
										lastName: r.lastName,
										OnChange: (a, o) => i(a, o),
									}),
								}),
							}),
						}),
				],
			})
		},
		efe = Bt({ homeClub: Oe().required() }),
		tfe = (e) =>
			h.jsx("div", {
				children: h.jsx(Vt, {
					validationSchema: efe,
					onSubmit: (t, n) => {
						e.OnChange(t.homeClub)
					},
					initialValues: { homeClub: e.homeClub },
					children: ({
						handleSubmit: t,
						handleChange: n,
						handleBlur: r,
						values: i,
						touched: a,
						errors: o,
					}) =>
						h.jsxs(R, {
							noValidate: !0,
							onSubmit: t,
							children: [
								h.jsxs(R.Group, {
									controlId: "ec.homeClub",
									children: [
										h.jsx(R.Label, { children: "Home club" }),
										h.jsxs(R.Control, {
											as: "select",
											name: "homeClub",
											value: i.homeClub || "",
											isValid: a.homeClub && !o.homeClub,
											isInvalid: !!o.homeClub,
											onChange: n,
											onBlur: r,
											children: [
												h.jsx("option", { value: void 0 }, -1),
												h.jsx("option", { value: void 0, children: "Other (not listed)" }, 0),
												e.clubs.map((s) =>
													h.jsx("option", { value: s.name, children: s.name }, s.id),
												),
											],
										}),
										h.jsx(R.Control.Feedback, { type: "invalid", children: o.homeClub }),
									],
								}),
								h.jsx(Ge, {
									variant: "secondary",
									type: "submit",
									size: "sm",
									className: "mt-2",
									children: "Update Home Club",
								}),
							],
						}),
				}),
			}),
		nfe = (e) => {
			const [t, n] = _.useState(!1),
				r = ki(),
				{ contact: i } = ks(),
				a = (o) => {
					;(i.homeClub = o), r(Yy(i.prepJson())), n(!1)
				}
			return h.jsxs("div", {
				children: [
					h.jsxs(ln, {
						children: [
							h.jsx(it, { xs: 3, children: "Home Club" }),
							h.jsx(it, {
								xs: 8,
								children:
									(i == null ? void 0 : i.homeClub) || "Click 'change' to update your home club.",
							}),
							h.jsx(it, {
								xs: 1,
								children: h.jsx(Ge, {
									variant: "link",
									className: "text-info",
									onClick: () => n(!t),
									children: t ? "cancel" : "change",
								}),
							}),
						],
					}),
					t &&
						h.jsx(ln, {
							children: h.jsx(it, {
								xs: 12,
								children: h.jsx(tfe, {
									clubs: e.clubs,
									homeClub: i == null ? void 0 : i.homeClub,
									OnChange: (o) => a(o),
								}),
							}),
						}),
				],
			})
		},
		rfe = () => {
			const e = ki(),
				t = Xa(),
				{ user: n, flags: r } = ks(),
				{ data: i } = Kp()
			return (
				n.isAuthenticated || t("/"),
				_.useEffect(() => {
					e(Wy(n.email))
				}, [n.email]),
				h.jsxs("div", {
					children: [
						h.jsx("h3", { className: "text-primary", children: "MPGA Account Details" }),
						r.isBusy && h.jsx(Vp, {}),
						!r.isBusy &&
							h.jsxs(H.Fragment, {
								children: [
									h.jsx(Qde, {}),
									h.jsx(Yde, {}),
									h.jsx(Zde, {}),
									h.jsx(nfe, { clubs: i }),
								],
							}),
					],
				})
			)
		},
		G_ = _.forwardRef(
			({ className: e, bsPrefix: t, as: n = "div", ...r }, i) => (
				(t = nt(t, "card-body")), h.jsx(n, { ref: i, className: Fe(e, t), ...r })
			),
		)
	G_.displayName = "CardBody"
	const BH = _.forwardRef(
		({ className: e, bsPrefix: t, as: n = "div", ...r }, i) => (
			(t = nt(t, "card-footer")), h.jsx(n, { ref: i, className: Fe(e, t), ...r })
		),
	)
	BH.displayName = "CardFooter"
	const K_ = _.createContext(null)
	K_.displayName = "CardHeaderContext"
	const HH = _.forwardRef(({ bsPrefix: e, className: t, as: n = "div", ...r }, i) => {
		const a = nt(e, "card-header"),
			o = _.useMemo(() => ({ cardHeaderBsPrefix: a }), [a])
		return h.jsx(K_.Provider, {
			value: o,
			children: h.jsx(n, { ref: i, ...r, className: Fe(t, a) }),
		})
	})
	HH.displayName = "CardHeader"
	const $H = _.forwardRef(({ bsPrefix: e, className: t, variant: n, as: r = "img", ...i }, a) => {
		const o = nt(e, "card-img")
		return h.jsx(r, { ref: a, className: Fe(n ? `${o}-${n}` : o, t), ...i })
	})
	$H.displayName = "CardImg"
	const UH = _.forwardRef(
		({ className: e, bsPrefix: t, as: n = "div", ...r }, i) => (
			(t = nt(t, "card-img-overlay")), h.jsx(n, { ref: i, className: Fe(e, t), ...r })
		),
	)
	UH.displayName = "CardImgOverlay"
	const zH = _.forwardRef(
		({ className: e, bsPrefix: t, as: n = "a", ...r }, i) => (
			(t = nt(t, "card-link")), h.jsx(n, { ref: i, className: Fe(e, t), ...r })
		),
	)
	zH.displayName = "CardLink"
	const Ux = (e) =>
			_.forwardRef((t, n) => h.jsx("div", { ...t, ref: n, className: Fe(t.className, e) })),
		ife = Ux("h6"),
		qH = _.forwardRef(
			({ className: e, bsPrefix: t, as: n = ife, ...r }, i) => (
				(t = nt(t, "card-subtitle")), h.jsx(n, { ref: i, className: Fe(e, t), ...r })
			),
		)
	qH.displayName = "CardSubtitle"
	const VH = _.forwardRef(
		({ className: e, bsPrefix: t, as: n = "p", ...r }, i) => (
			(t = nt(t, "card-text")), h.jsx(n, { ref: i, className: Fe(e, t), ...r })
		),
	)
	VH.displayName = "CardText"
	const afe = Ux("h5"),
		WH = _.forwardRef(
			({ className: e, bsPrefix: t, as: n = afe, ...r }, i) => (
				(t = nt(t, "card-title")), h.jsx(n, { ref: i, className: Fe(e, t), ...r })
			),
		)
	WH.displayName = "CardTitle"
	const YH = _.forwardRef(
		(
			{
				bsPrefix: e,
				className: t,
				bg: n,
				text: r,
				border: i,
				body: a = !1,
				children: o,
				as: s = "div",
				...l
			},
			u,
		) => {
			const d = nt(e, "card")
			return h.jsx(s, {
				ref: u,
				...l,
				className: Fe(t, d, n && `bg-${n}`, r && `text-${r}`, i && `border-${i}`),
				children: a ? h.jsx(G_, { children: o }) : o,
			})
		},
	)
	YH.displayName = "Card"
	const xn = Object.assign(YH, {
			Img: $H,
			Title: WH,
			Subtitle: qH,
			Body: G_,
			Link: zH,
			Text: VH,
			Header: HH,
			Footer: BH,
			ImgOverlay: UH,
		}),
		ofe = () => {
			const { uid: e, token: t } = Sl(),
				n = Xa(),
				r = ki(),
				i = Nr((a) => a.session)
			return (
				_.useEffect(() => {
					e && t && r(Qy({ uid: e, token: t }))
				}, [r, e, t]),
				h.jsxs("div", {
					children: [
						i.flags.isBusy && h.jsx(Vp, {}),
						h.jsxs(xn, {
							children: [
								h.jsx(xn.Header, {
									children: h.jsx(xn.Title, { children: "Account Activation Status" }),
								}),
								h.jsxs(xn.Body, {
									children: [
										i.flags.accountActivated &&
											h.jsx("p", {
												className: "text-success mt-1",
												children:
													"Your account has been confirmed and activated. Log in now with your new password. Thank you for supporting Minnesota Public Golf!",
											}),
										i.flags.hasError &&
											h.jsx("p", { className: "text-danger mt-1", children: i.flags.errorMessage }),
									],
								}),
								i.flags.accountActivated &&
									h.jsx(xn.Footer, {
										children: h.jsx(Ge, {
											variant: "outline-secondary",
											onClick: () => n("/account/login"),
											children: "Login",
										}),
									}),
							],
						}),
					],
				})
			)
		},
		sfe = Bt({ email: Oe().email().required() }),
		lfe = (e) => {
			const t = Nr((n) => n.session)
			return h.jsx(Vt, {
				validationSchema: sfe,
				onSubmit: (n) => {
					e.OnRequestReset(n.email)
				},
				initialValues: { email: e.email || "" },
				children: ({
					handleSubmit: n,
					handleChange: r,
					handleBlur: i,
					values: a,
					touched: o,
					errors: s,
					isValid: l,
				}) =>
					h.jsxs(R, {
						noValidate: !0,
						onSubmit: n,
						children: [
							h.jsxs(R.Group, {
								controlId: "email",
								children: [
									h.jsx(R.Label, { children: "Email" }),
									h.jsx(R.Control, {
										placeholder: "email",
										name: "email",
										type: "email",
										readOnly: t.flags.pendingPasswordReset,
										value: a.email,
										isValid: o.email && !s.email,
										isInvalid: !!s.email,
										onChange: r,
										onBlur: i,
									}),
									h.jsx(R.Control.Feedback, { type: "invalid", children: s.email }),
								],
							}),
							h.jsx(Ge, {
								variant: "secondary",
								type: "submit",
								size: "sm",
								className: "mt-2",
								disabled: t.flags.isBusy || !l || t.flags.pendingPasswordReset,
								children: "Send Password Request",
							}),
						],
					}),
			})
		},
		ufe = () => {
			var i
			const e = Xa(),
				t = ki(),
				n = Nr((a) => a.session),
				r = (a) => {
					t(PS(a))
				}
			return h.jsxs("div", {
				children: [
					n.flags.isBusy && h.jsx(Vp, {}),
					h.jsxs(xn, {
						children: [
							h.jsx(xn.Header, {
								children: h.jsx(xn.Title, { children: "Request a Password Reset" }),
							}),
							h.jsxs(xn.Body, {
								children: [
									h.jsx(lfe, {
										email: ((i = n.accountRequest) == null ? void 0 : i.email) || "",
										OnRequestReset: (a) => r(a),
									}),
									n.flags.hasError &&
										h.jsx("p", { className: "text-danger", children: n.flags.errorMessage }),
									n.flags.pendingPasswordReset &&
										h.jsx("p", {
											className: "text-success mt-3",
											children:
												"An email has been sent to the address you entered above. If you don't receive a reset link within a few minutes, check to ensure that your email client is not flagging email from mpga.net as junk or spam. If we don't have an account record with this email, that would be another reason you might not receive a reset link. In that case, please register to create an account.",
										}),
								],
							}),
							h.jsxs(xn.Footer, {
								children: [
									h.jsx(Ge, {
										variant: "outline-secondary",
										onClick: () => e("/account/login"),
										children: "Login",
									}),
									h.jsx(Ge, {
										variant: "outline-secondary",
										className: "ml-2",
										onClick: () => e("/account/register"),
										children: "Register",
									}),
								],
							}),
						],
					}),
				],
			})
		},
		cfe = Bt({ email: Oe().email().required(), password: Oe().required(), remember: dd() }),
		dfe = (e) => {
			const { credentials: t } = e,
				n = Nr((r) => r.session)
			return h.jsx(Vt, {
				validationSchema: cfe,
				validateOnBlur: !1,
				validateOnChange: !1,
				onSubmit: (r) => {
					e.OnLogin(r)
				},
				initialValues: t,
				children: ({
					handleSubmit: r,
					handleChange: i,
					handleBlur: a,
					values: o,
					touched: s,
					errors: l,
				}) =>
					h.jsxs(R, {
						noValidate: !0,
						onSubmit: r,
						children: [
							h.jsxs(R.Group, {
								controlId: "login.email",
								children: [
									h.jsx(R.Label, { children: "Email" }),
									h.jsx(R.Control, {
										placeholder: "email",
										name: "email",
										type: "email",
										value: o.email,
										isValid: s.email && !l.email,
										isInvalid: !!l.email,
										onChange: i,
										onBlur: a,
									}),
									h.jsx(R.Control.Feedback, { type: "invalid", children: l.email }),
								],
							}),
							h.jsxs(R.Group, {
								controlId: "login.password",
								children: [
									h.jsx(R.Label, { children: "Password" }),
									h.jsx(R.Control, {
										placeholder: "password",
										name: "password",
										type: "password",
										value: o.password,
										isValid: s.password && !l.password,
										isInvalid: !!l.password,
										onChange: i,
										onBlur: a,
									}),
									h.jsx(R.Control.Feedback, { type: "invalid", children: l.password }),
								],
							}),
							h.jsx(R.Group, {
								controlId: "loginremember",
								children: h.jsx(R.Check, {
									type: "switch",
									defaultChecked: o.remember,
									onChange: i,
									label: "Remember me on this device",
								}),
							}),
							h.jsx(Ge, {
								variant: "secondary",
								type: "submit",
								size: "sm",
								className: "mt-2",
								disabled: n.flags.isBusy,
								children: "Login",
							}),
						],
					}),
			})
		},
		ffe = () => {
			const e = ki(),
				t = Xa(),
				n = Nr((s) => s.app),
				r = Nr((s) => s.session),
				{ user: i } = ks(),
				a = { email: "", password: "", remember: !0 }
			i.isAuthenticated && t(n.location || "/account")
			const o = (s) => {
				e(qy(s))
			}
			return h.jsxs("div", {
				children: [
					r.flags.isBusy && h.jsx(Vp, {}),
					h.jsxs(xn, {
						children: [
							h.jsx(xn.Header, { children: h.jsx(xn.Title, { children: "Log in to MPGA.net" }) }),
							h.jsxs(xn.Body, {
								children: [
									h.jsx(dfe, { credentials: a, OnLogin: (s) => o(s) }),
									r.flags.hasError &&
										h.jsx("p", { className: "text-danger", children: r.flags.errorMessage }),
								],
							}),
							h.jsxs(xn.Footer, {
								children: [
									h.jsx(Ge, {
										variant: "outline-secondary",
										onClick: () => t("/account/forgot"),
										children: "Forgot Password",
									}),
									h.jsx(Ge, {
										variant: "outline-secondary",
										className: "ml-2",
										onClick: () => t("/account/register"),
										children: "Register",
									}),
								],
							}),
						],
					}),
				],
			})
		},
		pfe = Bt({
			password: Oe().required("Password is required"),
			confirmPassword: Oe()
				.oneOf([Y_("password"), null], "Passwords must match")
				.required("Password confirmation is required"),
		}),
		hfe = (e) => {
			const t = Nr((n) => n.session)
			return h.jsx(Vt, {
				validationSchema: pfe,
				onSubmit: (n) => {
					e.OnReset(n)
				},
				initialValues: {},
				children: ({
					handleSubmit: n,
					handleChange: r,
					handleBlur: i,
					values: a,
					touched: o,
					errors: s,
					isValid: l,
				}) =>
					h.jsxs(R, {
						noValidate: !0,
						onSubmit: n,
						children: [
							h.jsxs(R.Group, {
								controlId: "password",
								children: [
									h.jsx(R.Label, { children: "New Password" }),
									h.jsx(R.Control, {
										name: "password",
										type: "password",
										readOnly: t.flags.passwordResetConfirmed,
										value: a.password || "",
										isValid: o.password && !s.password,
										isInvalid: !!s.password,
										onChange: r,
										onBlur: i,
									}),
									h.jsx(R.Control.Feedback, { type: "invalid", children: s.password }),
								],
							}),
							h.jsxs(R.Group, {
								controlId: "confirmPassword",
								children: [
									h.jsx(R.Label, { children: "Confirm New Password" }),
									h.jsx(R.Control, {
										name: "confirmPassword",
										type: "password",
										readOnly: t.flags.passwordResetConfirmed,
										value: a.confirmPassword || "",
										isValid: o.confirmPassword && !s.confirmPassword,
										isInvalid: !!s.confirmPassword,
										onChange: r,
										onBlur: i,
									}),
									h.jsx(R.Control.Feedback, { type: "invalid", children: s.confirmPassword }),
								],
							}),
							h.jsx(Ge, {
								variant: "secondary",
								type: "submit",
								size: "sm",
								className: "mt-2",
								disabled: t.flags.isBusy || !l || t.flags.passwordResetConfirmed,
								children: "Change Password",
							}),
						],
					}),
			})
		},
		mfe = () => {
			const { uid: e, token: t } = Sl(),
				n = Xa(),
				r = ki(),
				i = Nr((o) => o.session),
				a = (o) => {
					const s = { uid: e || "", token: t || "", new_password: o.password }
					r(Gy(s))
				}
			return h.jsxs("div", {
				children: [
					i.flags.isBusy && h.jsx(Vp, {}),
					h.jsxs(xn, {
						children: [
							h.jsx(xn.Header, {
								children: h.jsx(xn.Title, { children: "Create or Reset Your Password" }),
							}),
							h.jsxs(xn.Body, {
								children: [
									!i.flags.passwordResetConfirmed &&
										h.jsx("p", { children: "Enter and confirm your new password." }),
									i.flags.passwordResetConfirmed &&
										h.jsx("p", {
											className: "text-success",
											children:
												"Your password has been changed. Log in now with your new password.",
										}),
									h.jsx(hfe, { OnReset: (o) => a(o) }),
									i.flags.hasError &&
										h.jsx("p", { className: "text-danger mt-3", children: i.flags.errorMessage }),
								],
							}),
							i.flags.passwordResetConfirmed &&
								h.jsx(xn.Footer, {
									children: h.jsx(Ge, {
										variant: "outline-secondary",
										onClick: () => n("/account/login"),
										children: "Login",
									}),
								}),
						],
					}),
				],
			})
		},
		vfe = Bt({
			firstName: Oe().required("Please enter a first name"),
			lastName: Oe().required("Please enter a last name"),
			email: Oe().email().required("A valid email is required"),
			password: Oe().required("Password is required"),
			confirmPassword: Oe()
				.oneOf([Y_("password"), null], "Passwords must match")
				.required("Password confirmation is required"),
		}),
		gfe = (e) => {
			const t = Nr((n) => n.session)
			return h.jsx(Vt, {
				validationSchema: vfe,
				validateOnBlur: !1,
				validateOnChange: !1,
				onSubmit: (n) => {
					e.OnRegister(n)
				},
				initialValues: {},
				children: ({
					handleSubmit: n,
					handleChange: r,
					handleBlur: i,
					values: a,
					touched: o,
					errors: s,
				}) =>
					h.jsxs(R, {
						noValidate: !0,
						onSubmit: n,
						children: [
							h.jsxs(R.Group, {
								controlId: "email",
								children: [
									h.jsx(R.Control, {
										placeholder: "Email",
										name: "email",
										type: "email",
										value: a.email || "",
										isValid: o.email && !s.email,
										isInvalid: !!s.email,
										onChange: r,
										onBlur: i,
									}),
									h.jsx(R.Control.Feedback, { type: "invalid", children: s.email }),
								],
							}),
							h.jsxs(R.Group, {
								controlId: "firstName",
								children: [
									h.jsx(R.Control, {
										placeholder: "First Name",
										name: "firstName",
										value: a.firstName || "",
										isValid: o.firstName && !s.firstName,
										isInvalid: !!s.firstName,
										onChange: r,
										onBlur: i,
									}),
									h.jsx(R.Control.Feedback, { type: "invalid", children: s.firstName }),
								],
							}),
							h.jsxs(R.Group, {
								controlId: "lastName",
								children: [
									h.jsx(R.Control, {
										placeholder: "Last Name",
										name: "lastName",
										value: a.lastName || "",
										isValid: o.lastName && !s.lastName,
										isInvalid: !!s.lastName,
										onChange: r,
										onBlur: i,
									}),
									h.jsx(R.Control.Feedback, { type: "invalid", children: s.lastName }),
								],
							}),
							h.jsxs(R.Group, {
								controlId: "password",
								children: [
									h.jsx(R.Control, {
										placeholder: "Password",
										name: "password",
										type: "password",
										value: a.password || "",
										isValid: o.password && !s.password,
										isInvalid: !!s.password,
										onChange: r,
										onBlur: i,
									}),
									h.jsx(R.Control.Feedback, { type: "invalid", children: s.password }),
								],
							}),
							h.jsxs(R.Group, {
								controlId: "confirmPassword",
								children: [
									h.jsx(R.Control, {
										placeholder: "Confirm your password",
										name: "confirmPassword",
										type: "password",
										value: a.confirmPassword || "",
										isValid: o.confirmPassword && !s.confirmPassword,
										isInvalid: !!s.confirmPassword,
										onChange: r,
										onBlur: i,
									}),
									h.jsx(R.Control.Feedback, { type: "invalid", children: s.confirmPassword }),
								],
							}),
							h.jsx(Ge, {
								variant: "secondary",
								type: "submit",
								size: "sm",
								className: "mt-2",
								disabled: t.flags.isBusy,
								children: "Register",
							}),
						],
					}),
			})
		},
		yfe = () => {
			const e = Xa(),
				t = ki(),
				n = Nr((i) => i.session),
				r = (i) => {
					t(Vy(i))
				}
			return h.jsxs("div", {
				children: [
					n.flags.isBusy && h.jsx(Vp, {}),
					h.jsxs(xn, {
						children: [
							h.jsx(xn.Header, {
								children: h.jsx(xn.Title, { children: "Sign Up for an Account" }),
							}),
							h.jsxs(xn.Body, {
								children: [
									h.jsx("p", {
										className: "text-info",
										children:
											"It is possible that we already have an account for you in our system. This is because we automatically create accounts for officers or contacts for our member clubs. If that is the case, you will get a message below when you try to create your account.",
									}),
									h.jsx(gfe, { OnRegister: (i) => r(i) }),
									n.flags.hasError &&
										h.jsx("p", { className: "text-danger mt-3", children: n.flags.errorMessage }),
									n.flags.accountExists &&
										h.jsx("p", {
											className: "text-danger mt-3",
											children:
												"Please create a password for your account by clicking the Reset Password button below.",
										}),
									n.flags.accountCreated &&
										h.jsx("p", {
											className: "text-success mt-3",
											children:
												"Your account has been created, but not yet activated. We have sent an email to your email address above for confirmation. If you do not receive that email, please confirm that your email client is not blocking mpga.net as junk or spam.",
										}),
								],
							}),
							h.jsxs(xn.Footer, {
								children: [
									h.jsx(Ge, {
										variant: "outline-secondary",
										onClick: () => e("/account/login"),
										children: "Login",
									}),
									n.flags.accountExists &&
										h.jsx(Ge, {
											variant: "outline-secondary",
											className: "ml-2",
											onClick: () => e("/account/forgot"),
											children: "Reset Password",
										}),
								],
							}),
						],
					}),
				],
			})
		},
		fd = _.createContext(null),
		gv = (e, t = null) => (e != null ? String(e) : t || null)
	function zn() {
		return (
			(zn = Object.assign
				? Object.assign.bind()
				: function (e) {
						for (var t = 1; t < arguments.length; t++) {
							var n = arguments[t]
							for (var r in n) ({}).hasOwnProperty.call(n, r) && (e[r] = n[r])
						}
						return e
				  }),
			zn.apply(null, arguments)
		)
	}
	function Q_(e, t) {
		if (e == null) return {}
		var n = {}
		for (var r in e)
			if ({}.hasOwnProperty.call(e, r)) {
				if (t.includes(r)) continue
				n[r] = e[r]
			}
		return n
	}
	var HT, CP
	function bfe() {
		if (CP) return HT
		CP = 1
		var e = function (t, n, r, i, a, o, s, l) {
			if (!t) {
				var u
				if (n === void 0)
					u = new Error(
						"Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.",
					)
				else {
					var d = [r, i, a, o, s, l],
						p = 0
					;(u = new Error(
						n.replace(/%s/g, function () {
							return d[p++]
						}),
					)),
						(u.name = "Invariant Violation")
				}
				throw ((u.framesToPop = 1), u)
			}
		}
		return (HT = e), HT
	}
	var xfe = bfe()
	const GH = Ti(xfe)
	function TP(e) {
		return "default" + e.charAt(0).toUpperCase() + e.substr(1)
	}
	function wfe(e) {
		var t = Efe(e, "string")
		return typeof t == "symbol" ? t : String(t)
	}
	function Efe(e, t) {
		if (typeof e != "object" || e === null) return e
		var n = e[Symbol.toPrimitive]
		if (n !== void 0) {
			var r = n.call(e, t)
			if (typeof r != "object") return r
			throw new TypeError("@@toPrimitive must return a primitive value.")
		}
		return String(e)
	}
	function Cfe(e, t, n) {
		var r = _.useRef(e !== void 0),
			i = _.useState(t),
			a = i[0],
			o = i[1],
			s = e !== void 0,
			l = r.current
		return (
			(r.current = s),
			!s && l && a !== t && o(t),
			[
				s ? e : a,
				_.useCallback(
					function (u) {
						for (var d = arguments.length, p = new Array(d > 1 ? d - 1 : 0), m = 1; m < d; m++)
							p[m - 1] = arguments[m]
						n && n.apply(void 0, [u].concat(p)), o(u)
					},
					[n],
				),
			]
		)
	}
	function X_(e, t) {
		return Object.keys(t).reduce(function (n, r) {
			var i,
				a = n,
				o = a[TP(r)],
				s = a[r],
				l = Q_(a, [TP(r), r].map(wfe)),
				u = t[r],
				d = Cfe(s, o, e[u]),
				p = d[0],
				m = d[1]
			return zn({}, l, ((i = {}), (i[r] = p), (i[u] = m), i))
		}, e)
	}
	function Q1(e, t) {
		return (
			(Q1 = Object.setPrototypeOf
				? Object.setPrototypeOf.bind()
				: function (n, r) {
						return (n.__proto__ = r), n
				  }),
			Q1(e, t)
		)
	}
	function Tfe(e, t) {
		;(e.prototype = Object.create(t.prototype)), (e.prototype.constructor = e), Q1(e, t)
	}
	const KH = _.forwardRef(({ bsPrefix: e, className: t, as: n, ...r }, i) => {
		e = nt(e, "navbar-brand")
		const a = n || (r.href ? "a" : "span")
		return h.jsx(a, { ...r, ref: i, className: Fe(t, e) })
	})
	KH.displayName = "NavbarBrand"
	function Jp(e) {
		return (e && e.ownerDocument) || document
	}
	function kfe(e) {
		var t = Jp(e)
		return (t && t.defaultView) || window
	}
	function Sfe(e, t) {
		return kfe(e).getComputedStyle(e, t)
	}
	var Dfe = /([A-Z])/g
	function _fe(e) {
		return e.replace(Dfe, "-$1").toLowerCase()
	}
	var Ofe = /^ms-/
	function X0(e) {
		return _fe(e).replace(Ofe, "-ms-")
	}
	var Afe = /^((translate|rotate|scale)(X|Y|Z|3d)?|matrix(3d)?|perspective|skew(X|Y)?)$/i
	function Nfe(e) {
		return !!(e && Afe.test(e))
	}
	function cl(e, t) {
		var n = "",
			r = ""
		if (typeof t == "string")
			return e.style.getPropertyValue(X0(t)) || Sfe(e).getPropertyValue(X0(t))
		Object.keys(t).forEach(function (i) {
			var a = t[i]
			!a && a !== 0
				? e.style.removeProperty(X0(i))
				: Nfe(i)
				? (r += i + "(" + a + ") ")
				: (n += X0(i) + ": " + a + ";")
		}),
			r && (n += "transform: " + r + ";"),
			(e.style.cssText += ";" + n)
	}
	const kP = { disabled: !1 },
		QH = H.createContext(null)
	var Mfe = function (t) {
			return t.scrollTop
		},
		bm = "unmounted",
		pu = "exited",
		fo = "entering",
		el = "entered",
		yv = "exiting",
		Al = (function (e) {
			Tfe(t, e)
			function t(r, i) {
				var a
				a = e.call(this, r, i) || this
				var o = i,
					s = o && !o.isMounting ? r.enter : r.appear,
					l
				return (
					(a.appearStatus = null),
					r.in
						? s
							? ((l = pu), (a.appearStatus = fo))
							: (l = el)
						: r.unmountOnExit || r.mountOnEnter
						? (l = bm)
						: (l = pu),
					(a.state = { status: l }),
					(a.nextCallback = null),
					a
				)
			}
			t.getDerivedStateFromProps = function (i, a) {
				var o = i.in
				return o && a.status === bm ? { status: pu } : null
			}
			var n = t.prototype
			return (
				(n.componentDidMount = function () {
					this.updateStatus(!0, this.appearStatus)
				}),
				(n.componentDidUpdate = function (i) {
					var a = null
					if (i !== this.props) {
						var o = this.state.status
						this.props.in ? o !== fo && o !== el && (a = fo) : (o === fo || o === el) && (a = yv)
					}
					this.updateStatus(!1, a)
				}),
				(n.componentWillUnmount = function () {
					this.cancelNextCallback()
				}),
				(n.getTimeouts = function () {
					var i = this.props.timeout,
						a,
						o,
						s
					return (
						(a = o = s = i),
						i != null &&
							typeof i != "number" &&
							((a = i.exit), (o = i.enter), (s = i.appear !== void 0 ? i.appear : o)),
						{ exit: a, enter: o, appear: s }
					)
				}),
				(n.updateStatus = function (i, a) {
					if ((i === void 0 && (i = !1), a !== null))
						if ((this.cancelNextCallback(), a === fo)) {
							if (this.props.unmountOnExit || this.props.mountOnEnter) {
								var o = this.props.nodeRef ? this.props.nodeRef.current : nl.findDOMNode(this)
								o && Mfe(o)
							}
							this.performEnter(i)
						} else this.performExit()
					else this.props.unmountOnExit && this.state.status === pu && this.setState({ status: bm })
				}),
				(n.performEnter = function (i) {
					var a = this,
						o = this.props.enter,
						s = this.context ? this.context.isMounting : i,
						l = this.props.nodeRef ? [s] : [nl.findDOMNode(this), s],
						u = l[0],
						d = l[1],
						p = this.getTimeouts(),
						m = s ? p.appear : p.enter
					if ((!i && !o) || kP.disabled) {
						this.safeSetState({ status: el }, function () {
							a.props.onEntered(u)
						})
						return
					}
					this.props.onEnter(u, d),
						this.safeSetState({ status: fo }, function () {
							a.props.onEntering(u, d),
								a.onTransitionEnd(m, function () {
									a.safeSetState({ status: el }, function () {
										a.props.onEntered(u, d)
									})
								})
						})
				}),
				(n.performExit = function () {
					var i = this,
						a = this.props.exit,
						o = this.getTimeouts(),
						s = this.props.nodeRef ? void 0 : nl.findDOMNode(this)
					if (!a || kP.disabled) {
						this.safeSetState({ status: pu }, function () {
							i.props.onExited(s)
						})
						return
					}
					this.props.onExit(s),
						this.safeSetState({ status: yv }, function () {
							i.props.onExiting(s),
								i.onTransitionEnd(o.exit, function () {
									i.safeSetState({ status: pu }, function () {
										i.props.onExited(s)
									})
								})
						})
				}),
				(n.cancelNextCallback = function () {
					this.nextCallback !== null && (this.nextCallback.cancel(), (this.nextCallback = null))
				}),
				(n.safeSetState = function (i, a) {
					;(a = this.setNextCallback(a)), this.setState(i, a)
				}),
				(n.setNextCallback = function (i) {
					var a = this,
						o = !0
					return (
						(this.nextCallback = function (s) {
							o && ((o = !1), (a.nextCallback = null), i(s))
						}),
						(this.nextCallback.cancel = function () {
							o = !1
						}),
						this.nextCallback
					)
				}),
				(n.onTransitionEnd = function (i, a) {
					this.setNextCallback(a)
					var o = this.props.nodeRef ? this.props.nodeRef.current : nl.findDOMNode(this),
						s = i == null && !this.props.addEndListener
					if (!o || s) {
						setTimeout(this.nextCallback, 0)
						return
					}
					if (this.props.addEndListener) {
						var l = this.props.nodeRef ? [this.nextCallback] : [o, this.nextCallback],
							u = l[0],
							d = l[1]
						this.props.addEndListener(u, d)
					}
					i != null && setTimeout(this.nextCallback, i)
				}),
				(n.render = function () {
					var i = this.state.status
					if (i === bm) return null
					var a = this.props,
						o = a.children
					a.in,
						a.mountOnEnter,
						a.unmountOnExit,
						a.appear,
						a.enter,
						a.exit,
						a.timeout,
						a.addEndListener,
						a.onEnter,
						a.onEntering,
						a.onEntered,
						a.onExit,
						a.onExiting,
						a.onExited,
						a.nodeRef
					var s = Q_(a, [
						"children",
						"in",
						"mountOnEnter",
						"unmountOnExit",
						"appear",
						"enter",
						"exit",
						"timeout",
						"addEndListener",
						"onEnter",
						"onEntering",
						"onEntered",
						"onExit",
						"onExiting",
						"onExited",
						"nodeRef",
					])
					return H.createElement(
						QH.Provider,
						{ value: null },
						typeof o == "function" ? o(i, s) : H.cloneElement(H.Children.only(o), s),
					)
				}),
				t
			)
		})(H.Component)
	Al.contextType = QH
	Al.propTypes = {}
	function gf() {}
	Al.defaultProps = {
		in: !1,
		mountOnEnter: !1,
		unmountOnExit: !1,
		appear: !1,
		enter: !0,
		exit: !0,
		onEnter: gf,
		onEntering: gf,
		onEntered: gf,
		onExit: gf,
		onExiting: gf,
		onExited: gf,
	}
	Al.UNMOUNTED = bm
	Al.EXITED = pu
	Al.ENTERING = fo
	Al.ENTERED = el
	Al.EXITING = yv
	function Ife(e) {
		return e.code === "Escape" || e.keyCode === 27
	}
	function Rfe() {
		const e = _.version.split(".")
		return { major: +e[0], minor: +e[1], patch: +e[2] }
	}
	function zx(e) {
		if (!e || typeof e == "function") return null
		const { major: t } = Rfe()
		return t >= 19 ? e.props.ref : e.ref
	}
	const Zp = !!(typeof window < "u" && window.document && window.document.createElement)
	var u2 = !1,
		c2 = !1
	try {
		var $T = {
			get passive() {
				return (u2 = !0)
			},
			get once() {
				return (c2 = u2 = !0)
			},
		}
		Zp && (window.addEventListener("test", $T, $T), window.removeEventListener("test", $T, !0))
	} catch {}
	function J_(e, t, n, r) {
		if (r && typeof r != "boolean" && !c2) {
			var i = r.once,
				a = r.capture,
				o = n
			!c2 &&
				i &&
				((o =
					n.__once ||
					function s(l) {
						this.removeEventListener(t, s, a), n.call(this, l)
					}),
				(n.__once = o)),
				e.addEventListener(t, o, u2 ? r : a)
		}
		e.addEventListener(t, n, r)
	}
	function d2(e, t, n, r) {
		var i = r && typeof r != "boolean" ? r.capture : r
		e.removeEventListener(t, n, i), n.__once && e.removeEventListener(t, n.__once, i)
	}
	function za(e, t, n, r) {
		return (
			J_(e, t, n, r),
			function () {
				d2(e, t, n, r)
			}
		)
	}
	function Lfe(e, t, n, r) {
		if ((r === void 0 && (r = !0), e)) {
			var i = document.createEvent("HTMLEvents")
			i.initEvent(t, n, r), e.dispatchEvent(i)
		}
	}
	function Pfe(e) {
		var t = cl(e, "transitionDuration") || "",
			n = t.indexOf("ms") === -1 ? 1e3 : 1
		return parseFloat(t) * n
	}
	function jfe(e, t, n) {
		n === void 0 && (n = 5)
		var r = !1,
			i = setTimeout(function () {
				r || Lfe(e, "transitionend", !0)
			}, t + n),
			a = za(
				e,
				"transitionend",
				function () {
					r = !0
				},
				{ once: !0 },
			)
		return function () {
			clearTimeout(i), a()
		}
	}
	function XH(e, t, n, r) {
		n == null && (n = Pfe(e) || 0)
		var i = jfe(e, n, r),
			a = za(e, "transitionend", t)
		return function () {
			i(), a()
		}
	}
	function SP(e, t) {
		const n = cl(e, t) || "",
			r = n.indexOf("ms") === -1 ? 1e3 : 1
		return parseFloat(n) * r
	}
	function Z_(e, t) {
		const n = SP(e, "transitionDuration"),
			r = SP(e, "transitionDelay"),
			i = XH(
				e,
				(a) => {
					a.target === e && (i(), t(a))
				},
				n + r,
			)
	}
	function Zh(...e) {
		return e
			.filter((t) => t != null)
			.reduce((t, n) => {
				if (typeof n != "function")
					throw new Error("Invalid Argument Type, must only provide functions, undefined, or null.")
				return t === null
					? n
					: function (...i) {
							t.apply(this, i), n.apply(this, i)
					  }
			}, null)
	}
	function JH(e) {
		e.offsetHeight
	}
	const DP = (e) =>
		!e || typeof e == "function"
			? e
			: (t) => {
					e.current = t
			  }
	function Ffe(e, t) {
		const n = DP(e),
			r = DP(t)
		return (i) => {
			n && n(i), r && r(i)
		}
	}
	function qx(e, t) {
		return _.useMemo(() => Ffe(e, t), [e, t])
	}
	function Bfe(e) {
		return e && "setState" in e ? nl.findDOMNode(e) : e ?? null
	}
	const eO = H.forwardRef(
			(
				{
					onEnter: e,
					onEntering: t,
					onEntered: n,
					onExit: r,
					onExiting: i,
					onExited: a,
					addEndListener: o,
					children: s,
					childRef: l,
					...u
				},
				d,
			) => {
				const p = _.useRef(null),
					m = qx(p, l),
					v = (A) => {
						m(Bfe(A))
					},
					y = (A) => (N) => {
						A && p.current && A(p.current, N)
					},
					b = _.useCallback(y(e), [e]),
					x = _.useCallback(y(t), [t]),
					E = _.useCallback(y(n), [n]),
					T = _.useCallback(y(r), [r]),
					C = _.useCallback(y(i), [i]),
					D = _.useCallback(y(a), [a]),
					O = _.useCallback(y(o), [o])
				return h.jsx(Al, {
					ref: d,
					...u,
					onEnter: b,
					onEntered: E,
					onEntering: x,
					onExit: T,
					onExited: D,
					onExiting: C,
					addEndListener: O,
					nodeRef: p,
					children:
						typeof s == "function"
							? (A, N) => s(A, { ...N, ref: v })
							: H.cloneElement(s, { ref: v }),
				})
			},
		),
		Hfe = { height: ["marginTop", "marginBottom"], width: ["marginLeft", "marginRight"] }
	function $fe(e, t) {
		const n = `offset${e[0].toUpperCase()}${e.slice(1)}`,
			r = t[n],
			i = Hfe[e]
		return r + parseInt(cl(t, i[0]), 10) + parseInt(cl(t, i[1]), 10)
	}
	const Ufe = { [pu]: "collapse", [yv]: "collapsing", [fo]: "collapsing", [el]: "collapse show" },
		zfe = H.forwardRef(
			(
				{
					onEnter: e,
					onEntering: t,
					onEntered: n,
					onExit: r,
					onExiting: i,
					className: a,
					children: o,
					dimension: s = "height",
					in: l = !1,
					timeout: u = 300,
					mountOnEnter: d = !1,
					unmountOnExit: p = !1,
					appear: m = !1,
					getDimensionValue: v = $fe,
					...y
				},
				b,
			) => {
				const x = typeof s == "function" ? s() : s,
					E = _.useMemo(
						() =>
							Zh((A) => {
								A.style[x] = "0"
							}, e),
						[x, e],
					),
					T = _.useMemo(
						() =>
							Zh((A) => {
								const N = `scroll${x[0].toUpperCase()}${x.slice(1)}`
								A.style[x] = `${A[N]}px`
							}, t),
						[x, t],
					),
					C = _.useMemo(
						() =>
							Zh((A) => {
								A.style[x] = null
							}, n),
						[x, n],
					),
					D = _.useMemo(
						() =>
							Zh((A) => {
								;(A.style[x] = `${v(x, A)}px`), JH(A)
							}, r),
						[r, v, x],
					),
					O = _.useMemo(
						() =>
							Zh((A) => {
								A.style[x] = null
							}, i),
						[x, i],
					)
				return h.jsx(eO, {
					ref: b,
					addEndListener: Z_,
					...y,
					"aria-expanded": y.role ? l : null,
					onEnter: E,
					onEntering: T,
					onEntered: C,
					onExit: D,
					onExiting: O,
					childRef: zx(o),
					in: l,
					timeout: u,
					mountOnEnter: d,
					unmountOnExit: p,
					appear: m,
					children: (A, N) =>
						H.cloneElement(o, {
							...N,
							className: Fe(a, o.props.className, Ufe[A], x === "width" && "collapse-horizontal"),
						}),
				})
			},
		),
		Id = _.createContext(null)
	Id.displayName = "NavbarContext"
	const ZH = _.forwardRef(({ children: e, bsPrefix: t, ...n }, r) => {
		t = nt(t, "navbar-collapse")
		const i = _.useContext(Id)
		return h.jsx(zfe, {
			in: !!(i && i.expanded),
			...n,
			children: h.jsx("div", { ref: r, className: t, children: e }),
		})
	})
	ZH.displayName = "NavbarCollapse"
	function qfe(e) {
		const t = _.useRef(e)
		return (
			_.useEffect(() => {
				t.current = e
			}, [e]),
			t
		)
	}
	function wl(e) {
		const t = qfe(e)
		return _.useCallback(
			function (...n) {
				return t.current && t.current(...n)
			},
			[t],
		)
	}
	const e$ = _.forwardRef(
		(
			{
				bsPrefix: e,
				className: t,
				children: n,
				label: r = "Toggle navigation",
				as: i = "button",
				onClick: a,
				...o
			},
			s,
		) => {
			e = nt(e, "navbar-toggler")
			const { onToggle: l, expanded: u } = _.useContext(Id) || {},
				d = wl((p) => {
					a && a(p), l && l()
				})
			return (
				i === "button" && (o.type = "button"),
				h.jsx(i, {
					...o,
					ref: s,
					onClick: d,
					"aria-label": r,
					className: Fe(t, e, !u && "collapsed"),
					children: n || h.jsx("span", { className: `${e}-icon` }),
				})
			)
		},
	)
	e$.displayName = "NavbarToggle"
	const Vfe = typeof global < "u" && global.navigator && global.navigator.product === "ReactNative",
		Wfe = typeof document < "u",
		t$ = Wfe || Vfe ? _.useLayoutEffect : _.useEffect,
		f2 = new WeakMap(),
		_P = (e, t) => {
			if (!e || !t) return
			const n = f2.get(t) || new Map()
			f2.set(t, n)
			let r = n.get(e)
			return r || ((r = t.matchMedia(e)), (r.refCount = 0), n.set(r.media, r)), r
		}
	function Yfe(e, t = typeof window > "u" ? void 0 : window) {
		const n = _P(e, t),
			[r, i] = _.useState(() => (n ? n.matches : !1))
		return (
			t$(() => {
				let a = _P(e, t)
				if (!a) return i(!1)
				let o = f2.get(t)
				const s = () => {
					i(a.matches)
				}
				return (
					a.refCount++,
					a.addListener(s),
					s(),
					() => {
						a.removeListener(s),
							a.refCount--,
							a.refCount <= 0 && (o == null || o.delete(a.media)),
							(a = void 0)
					}
				)
			}, [e]),
			r
		)
	}
	function Gfe(e) {
		const t = Object.keys(e)
		function n(s, l) {
			return s === l ? l : s ? `${s} and ${l}` : l
		}
		function r(s) {
			return t[Math.min(t.indexOf(s) + 1, t.length - 1)]
		}
		function i(s) {
			const l = r(s)
			let u = e[l]
			return (
				typeof u == "number" ? (u = `${u - 0.2}px`) : (u = `calc(${u} - 0.2px)`),
				`(max-width: ${u})`
			)
		}
		function a(s) {
			let l = e[s]
			return typeof l == "number" && (l = `${l}px`), `(min-width: ${l})`
		}
		function o(s, l, u) {
			let d
			typeof s == "object" ? ((d = s), (u = l), (l = !0)) : ((l = l || !0), (d = { [s]: l }))
			let p = _.useMemo(
				() =>
					Object.entries(d).reduce(
						(m, [v, y]) => (
							(y === "up" || y === !0) && (m = n(m, a(v))),
							(y === "down" || y === !0) && (m = n(m, i(v))),
							m
						),
						"",
					),
				[JSON.stringify(d)],
			)
			return Yfe(p, u)
		}
		return o
	}
	const Kfe = Gfe({ xs: 0, sm: 576, md: 768, lg: 992, xl: 1200, xxl: 1400 })
	function UT(e) {
		e === void 0 && (e = Jp())
		try {
			var t = e.activeElement
			return !t || !t.nodeName ? null : t
		} catch {
			return e.body
		}
	}
	function bv(e, t) {
		if (e.contains) return e.contains(t)
		if (e.compareDocumentPosition) return e === t || !!(e.compareDocumentPosition(t) & 16)
	}
	function n$() {
		const e = _.useRef(!0),
			t = _.useRef(() => e.current)
		return (
			_.useEffect(
				() => (
					(e.current = !0),
					() => {
						e.current = !1
					}
				),
				[],
			),
			t.current
		)
	}
	function Qfe(e) {
		const t = _.useRef(e)
		return (t.current = e), t
	}
	function Xfe(e) {
		const t = Qfe(e)
		_.useEffect(() => () => t.current(), [])
	}
	function r$(e) {
		const t = _.useRef(null)
		return (
			_.useEffect(() => {
				t.current = e
			}),
			t.current
		)
	}
	function Jfe(e) {
		const t = _.useRef(e)
		return (
			_.useEffect(() => {
				t.current = e
			}, [e]),
			t
		)
	}
	function Jr(e) {
		const t = Jfe(e)
		return _.useCallback(
			function (...n) {
				return t.current && t.current(...n)
			},
			[t],
		)
	}
	const Zfe = "data-rr-ui-",
		epe = "rrUi"
	function eh(e) {
		return `${Zfe}${e}`
	}
	function tpe(e) {
		return `${epe}${e}`
	}
	function npe(e = document) {
		const t = e.defaultView
		return Math.abs(t.innerWidth - e.documentElement.clientWidth)
	}
	const OP = eh("modal-open")
	class tO {
		constructor({ ownerDocument: t, handleContainerOverflow: n = !0, isRTL: r = !1 } = {}) {
			;(this.handleContainerOverflow = n),
				(this.isRTL = r),
				(this.modals = []),
				(this.ownerDocument = t)
		}
		getScrollbarWidth() {
			return npe(this.ownerDocument)
		}
		getElement() {
			return (this.ownerDocument || document).body
		}
		setModalAttributes(t) {}
		removeModalAttributes(t) {}
		setContainerStyle(t) {
			const n = { overflow: "hidden" },
				r = this.isRTL ? "paddingLeft" : "paddingRight",
				i = this.getElement()
			;(t.style = { overflow: i.style.overflow, [r]: i.style[r] }),
				t.scrollBarWidth && (n[r] = `${parseInt(cl(i, r) || "0", 10) + t.scrollBarWidth}px`),
				i.setAttribute(OP, ""),
				cl(i, n)
		}
		reset() {
			;[...this.modals].forEach((t) => this.remove(t))
		}
		removeContainerStyle(t) {
			const n = this.getElement()
			n.removeAttribute(OP), Object.assign(n.style, t.style)
		}
		add(t) {
			let n = this.modals.indexOf(t)
			return (
				n !== -1 ||
					((n = this.modals.length), this.modals.push(t), this.setModalAttributes(t), n !== 0) ||
					((this.state = { scrollBarWidth: this.getScrollbarWidth(), style: {} }),
					this.handleContainerOverflow && this.setContainerStyle(this.state)),
				n
			)
		}
		remove(t) {
			const n = this.modals.indexOf(t)
			n !== -1 &&
				(this.modals.splice(n, 1),
				!this.modals.length &&
					this.handleContainerOverflow &&
					this.removeContainerStyle(this.state),
				this.removeModalAttributes(t))
		}
		isTopModal(t) {
			return !!this.modals.length && this.modals[this.modals.length - 1] === t
		}
	}
	const i$ = _.createContext(Zp ? window : void 0)
	i$.Provider
	function Vx() {
		return _.useContext(i$)
	}
	const zT = (e, t) =>
		Zp
			? e == null
				? (t || Jp()).body
				: (typeof e == "function" && (e = e()),
				  e && "current" in e && (e = e.current),
				  e && ("nodeType" in e || e.getBoundingClientRect) ? e : null)
			: null
	function rpe(e, t) {
		const n = Vx(),
			[r, i] = _.useState(() => zT(e, n == null ? void 0 : n.document))
		if (!r) {
			const a = zT(e)
			a && i(a)
		}
		return (
			_.useEffect(() => {}, [t, r]),
			_.useEffect(() => {
				const a = zT(e)
				a !== r && i(a)
			}, [e, r]),
			r
		)
	}
	const AP = (e) =>
		!e || typeof e == "function"
			? e
			: (t) => {
					e.current = t
			  }
	function ipe(e, t) {
		const n = AP(e),
			r = AP(t)
		return (i) => {
			n && n(i), r && r(i)
		}
	}
	function Wx(e, t) {
		return _.useMemo(() => ipe(e, t), [e, t])
	}
	const ape = typeof global < "u" && global.navigator && global.navigator.product === "ReactNative",
		ope = typeof document < "u",
		NP = ope || ape ? _.useLayoutEffect : _.useEffect
	function spe({ children: e, in: t, onExited: n, mountOnEnter: r, unmountOnExit: i }) {
		const a = _.useRef(null),
			o = _.useRef(t),
			s = Jr(n)
		_.useEffect(() => {
			t ? (o.current = !0) : s(a.current)
		}, [t, s])
		const l = Wx(a, e.ref),
			u = _.cloneElement(e, { ref: l })
		return t ? u : i || (!o.current && r) ? null : u
	}
	const lpe = [
		"onEnter",
		"onEntering",
		"onEntered",
		"onExit",
		"onExiting",
		"onExited",
		"addEndListener",
		"children",
	]
	function upe(e, t) {
		if (e == null) return {}
		var n = {}
		for (var r in e)
			if ({}.hasOwnProperty.call(e, r)) {
				if (t.indexOf(r) >= 0) continue
				n[r] = e[r]
			}
		return n
	}
	function cpe(e) {
		let {
				onEnter: t,
				onEntering: n,
				onEntered: r,
				onExit: i,
				onExiting: a,
				onExited: o,
				addEndListener: s,
				children: l,
			} = e,
			u = upe(e, lpe)
		const d = _.useRef(null),
			p = Wx(d, zx(l)),
			m = (D) => (O) => {
				D && d.current && D(d.current, O)
			},
			v = _.useCallback(m(t), [t]),
			y = _.useCallback(m(n), [n]),
			b = _.useCallback(m(r), [r]),
			x = _.useCallback(m(i), [i]),
			E = _.useCallback(m(a), [a]),
			T = _.useCallback(m(o), [o]),
			C = _.useCallback(m(s), [s])
		return Object.assign(
			{},
			u,
			{ nodeRef: d },
			t && { onEnter: v },
			n && { onEntering: y },
			r && { onEntered: b },
			i && { onExit: x },
			a && { onExiting: E },
			o && { onExited: T },
			s && { addEndListener: C },
			{
				children:
					typeof l == "function"
						? (D, O) => l(D, Object.assign({}, O, { ref: p }))
						: _.cloneElement(l, { ref: p }),
			},
		)
	}
	const dpe = ["component"]
	function fpe(e, t) {
		if (e == null) return {}
		var n = {}
		for (var r in e)
			if ({}.hasOwnProperty.call(e, r)) {
				if (t.indexOf(r) >= 0) continue
				n[r] = e[r]
			}
		return n
	}
	const ppe = _.forwardRef((e, t) => {
		let { component: n } = e,
			r = fpe(e, dpe)
		const i = cpe(r)
		return h.jsx(n, Object.assign({ ref: t }, i))
	})
	function hpe({ in: e, onTransition: t }) {
		const n = _.useRef(null),
			r = _.useRef(!0),
			i = Jr(t)
		return (
			NP(() => {
				if (!n.current) return
				let a = !1
				return (
					i({ in: e, element: n.current, initial: r.current, isStale: () => a }),
					() => {
						a = !0
					}
				)
			}, [e, i]),
			NP(
				() => (
					(r.current = !1),
					() => {
						r.current = !0
					}
				),
				[],
			),
			n
		)
	}
	function mpe({ children: e, in: t, onExited: n, onEntered: r, transition: i }) {
		const [a, o] = _.useState(!t)
		t && a && o(!1)
		const s = hpe({
				in: !!t,
				onTransition: (u) => {
					const d = () => {
						u.isStale() ||
							(u.in ? r == null || r(u.element, u.initial) : (o(!0), n == null || n(u.element)))
					}
					Promise.resolve(i(u)).then(d, (p) => {
						throw (u.in || o(!0), p)
					})
				},
			}),
			l = Wx(s, e.ref)
		return a && !t ? null : _.cloneElement(e, { ref: l })
	}
	function MP(e, t, n) {
		return e
			? h.jsx(ppe, Object.assign({}, n, { component: e }))
			: t
			? h.jsx(mpe, Object.assign({}, n, { transition: t }))
			: h.jsx(spe, Object.assign({}, n))
	}
	const vpe = [
		"show",
		"role",
		"className",
		"style",
		"children",
		"backdrop",
		"keyboard",
		"onBackdropClick",
		"onEscapeKeyDown",
		"transition",
		"runTransition",
		"backdropTransition",
		"runBackdropTransition",
		"autoFocus",
		"enforceFocus",
		"restoreFocus",
		"restoreFocusOptions",
		"renderDialog",
		"renderBackdrop",
		"manager",
		"container",
		"onShow",
		"onHide",
		"onExit",
		"onExited",
		"onExiting",
		"onEnter",
		"onEntering",
		"onEntered",
	]
	function gpe(e, t) {
		if (e == null) return {}
		var n = {}
		for (var r in e)
			if ({}.hasOwnProperty.call(e, r)) {
				if (t.indexOf(r) >= 0) continue
				n[r] = e[r]
			}
		return n
	}
	let qT
	function ype(e) {
		return qT || (qT = new tO({ ownerDocument: e == null ? void 0 : e.document })), qT
	}
	function bpe(e) {
		const t = Vx(),
			n = e || ype(t),
			r = _.useRef({ dialog: null, backdrop: null })
		return Object.assign(r.current, {
			add: () => n.add(r.current),
			remove: () => n.remove(r.current),
			isTopModal: () => n.isTopModal(r.current),
			setDialogRef: _.useCallback((i) => {
				r.current.dialog = i
			}, []),
			setBackdropRef: _.useCallback((i) => {
				r.current.backdrop = i
			}, []),
		})
	}
	const a$ = _.forwardRef((e, t) => {
		let {
				show: n = !1,
				role: r = "dialog",
				className: i,
				style: a,
				children: o,
				backdrop: s = !0,
				keyboard: l = !0,
				onBackdropClick: u,
				onEscapeKeyDown: d,
				transition: p,
				runTransition: m,
				backdropTransition: v,
				runBackdropTransition: y,
				autoFocus: b = !0,
				enforceFocus: x = !0,
				restoreFocus: E = !0,
				restoreFocusOptions: T,
				renderDialog: C,
				renderBackdrop: D = (dt) => h.jsx("div", Object.assign({}, dt)),
				manager: O,
				container: A,
				onShow: N,
				onHide: I = () => {},
				onExit: P,
				onExited: L,
				onExiting: B,
				onEnter: z,
				onEntering: V,
				onEntered: K,
			} = e,
			ne = gpe(e, vpe)
		const re = Vx(),
			ie = rpe(A),
			J = bpe(O),
			le = n$(),
			F = r$(n),
			[Y, ee] = _.useState(!n),
			$ = _.useRef(null)
		_.useImperativeHandle(t, () => J, [J]),
			Zp && !F && n && ($.current = UT(re == null ? void 0 : re.document)),
			n && Y && ee(!1)
		const ge = Jr(() => {
				if (
					(J.add(),
					(et.current = za(document, "keydown", Le)),
					(Be.current = za(document, "focus", () => setTimeout(Ee), !0)),
					N && N(),
					b)
				) {
					var dt, cn
					const sn = UT(
						(dt = (cn = J.dialog) == null ? void 0 : cn.ownerDocument) != null
							? dt
							: re == null
							? void 0
							: re.document,
					)
					J.dialog && sn && !bv(J.dialog, sn) && (($.current = sn), J.dialog.focus())
				}
			}),
			Se = Jr(() => {
				if (
					(J.remove(), et.current == null || et.current(), Be.current == null || Be.current(), E)
				) {
					var dt
					;(dt = $.current) == null || dt.focus == null || dt.focus(T), ($.current = null)
				}
			})
		_.useEffect(() => {
			!n || !ie || ge()
		}, [n, ie, ge]),
			_.useEffect(() => {
				Y && Se()
			}, [Y, Se]),
			Xfe(() => {
				Se()
			})
		const Ee = Jr(() => {
				if (!x || !le() || !J.isTopModal()) return
				const dt = UT(re == null ? void 0 : re.document)
				J.dialog && dt && !bv(J.dialog, dt) && J.dialog.focus()
			}),
			be = Jr((dt) => {
				dt.target === dt.currentTarget && (u == null || u(dt), s === !0 && I())
			}),
			Le = Jr((dt) => {
				l && Ife(dt) && J.isTopModal() && (d == null || d(dt), dt.defaultPrevented || I())
			}),
			Be = _.useRef(),
			et = _.useRef(),
			pt = (...dt) => {
				ee(!0), L == null || L(...dt)
			}
		if (!ie) return null
		const mt = Object.assign(
			{ role: r, ref: J.setDialogRef, "aria-modal": r === "dialog" ? !0 : void 0 },
			ne,
			{ style: a, className: i, tabIndex: -1 },
		)
		let Xt = C
			? C(mt)
			: h.jsx("div", Object.assign({}, mt, { children: _.cloneElement(o, { role: "document" }) }))
		Xt = MP(p, m, {
			unmountOnExit: !0,
			mountOnEnter: !0,
			appear: !0,
			in: !!n,
			onExit: P,
			onExiting: B,
			onExited: pt,
			onEnter: z,
			onEntering: V,
			onEntered: K,
			children: Xt,
		})
		let on = null
		return (
			s &&
				((on = D({ ref: J.setBackdropRef, onClick: be })),
				(on = MP(v, y, {
					in: !!n,
					appear: !0,
					mountOnEnter: !0,
					unmountOnExit: !0,
					children: on,
				}))),
			h.jsx(h.Fragment, {
				children: nl.createPortal(h.jsxs(h.Fragment, { children: [on, Xt] }), ie),
			})
		)
	})
	a$.displayName = "Modal"
	const o$ = Object.assign(a$, { Manager: tO }),
		xpe = { [fo]: "show", [el]: "show" },
		Yx = _.forwardRef(
			({ className: e, children: t, transitionClasses: n = {}, onEnter: r, ...i }, a) => {
				const o = { in: !1, timeout: 300, mountOnEnter: !1, unmountOnExit: !1, appear: !1, ...i },
					s = _.useCallback(
						(l, u) => {
							JH(l), r == null || r(l, u)
						},
						[r],
					)
				return h.jsx(eO, {
					ref: a,
					addEndListener: Z_,
					...o,
					onEnter: s,
					childRef: zx(t),
					children: (l, u) =>
						_.cloneElement(t, { ...u, className: Fe("fade", e, t.props.className, xpe[l], n[l]) }),
				})
			},
		)
	Yx.displayName = "Fade"
	const s$ = _.forwardRef(
		({ className: e, bsPrefix: t, as: n = "div", ...r }, i) => (
			(t = nt(t, "offcanvas-body")), h.jsx(n, { ref: i, className: Fe(e, t), ...r })
		),
	)
	s$.displayName = "OffcanvasBody"
	const wpe = { [fo]: "show", [el]: "show" },
		l$ = _.forwardRef(
			(
				{
					bsPrefix: e,
					className: t,
					children: n,
					in: r = !1,
					mountOnEnter: i = !1,
					unmountOnExit: a = !1,
					appear: o = !1,
					...s
				},
				l,
			) => (
				(e = nt(e, "offcanvas")),
				h.jsx(eO, {
					ref: l,
					addEndListener: Z_,
					in: r,
					mountOnEnter: i,
					unmountOnExit: a,
					appear: o,
					...s,
					childRef: zx(n),
					children: (u, d) =>
						_.cloneElement(n, {
							...d,
							className: Fe(
								t,
								n.props.className,
								(u === fo || u === yv) && `${e}-toggling`,
								wpe[u],
							),
						}),
				})
			),
		)
	l$.displayName = "OffcanvasToggling"
	const nO = _.createContext({ onHide() {} }),
		Epe = { "aria-label": he.string, onClick: he.func, variant: he.oneOf(["white"]) },
		rO = _.forwardRef(({ className: e, variant: t, "aria-label": n = "Close", ...r }, i) =>
			h.jsx("button", {
				ref: i,
				type: "button",
				className: Fe("btn-close", t && `btn-close-${t}`, e),
				"aria-label": n,
				...r,
			}),
		)
	rO.displayName = "CloseButton"
	rO.propTypes = Epe
	const u$ = _.forwardRef(
			(
				{
					closeLabel: e = "Close",
					closeVariant: t,
					closeButton: n = !1,
					onHide: r,
					children: i,
					...a
				},
				o,
			) => {
				const s = _.useContext(nO),
					l = wl(() => {
						s == null || s.onHide(), r == null || r()
					})
				return h.jsxs("div", {
					ref: o,
					...a,
					children: [i, n && h.jsx(rO, { "aria-label": e, variant: t, onClick: l })],
				})
			},
		),
		c$ = _.forwardRef(
			({ bsPrefix: e, className: t, closeLabel: n = "Close", closeButton: r = !1, ...i }, a) => (
				(e = nt(e, "offcanvas-header")),
				h.jsx(u$, { ref: a, ...i, className: Fe(t, e), closeLabel: n, closeButton: r })
			),
		)
	c$.displayName = "OffcanvasHeader"
	const Cpe = Ux("h5"),
		d$ = _.forwardRef(
			({ className: e, bsPrefix: t, as: n = Cpe, ...r }, i) => (
				(t = nt(t, "offcanvas-title")), h.jsx(n, { ref: i, className: Fe(e, t), ...r })
			),
		)
	d$.displayName = "OffcanvasTitle"
	function Tpe(e, t) {
		return e.classList
			? e.classList.contains(t)
			: (" " + (e.className.baseVal || e.className) + " ").indexOf(" " + t + " ") !== -1
	}
	function kpe(e, t) {
		e.classList
			? e.classList.add(t)
			: Tpe(e, t) ||
			  (typeof e.className == "string"
					? (e.className = e.className + " " + t)
					: e.setAttribute("class", ((e.className && e.className.baseVal) || "") + " " + t))
	}
	var Spe = Function.prototype.bind.call(Function.prototype.call, [].slice)
	function Qs(e, t) {
		return Spe(e.querySelectorAll(t))
	}
	function IP(e, t) {
		return e
			.replace(new RegExp("(^|\\s)" + t + "(?:\\s|$)", "g"), "$1")
			.replace(/\s+/g, " ")
			.replace(/^\s*|\s*$/g, "")
	}
	function Dpe(e, t) {
		e.classList
			? e.classList.remove(t)
			: typeof e.className == "string"
			? (e.className = IP(e.className, t))
			: e.setAttribute("class", IP((e.className && e.className.baseVal) || "", t))
	}
	const yf = {
		FIXED_CONTENT: ".fixed-top, .fixed-bottom, .is-fixed, .sticky-top",
		STICKY_CONTENT: ".sticky-top",
		NAVBAR_TOGGLER: ".navbar-toggler",
	}
	class f$ extends tO {
		adjustAndStore(t, n, r) {
			const i = n.style[t]
			;(n.dataset[t] = i), cl(n, { [t]: `${parseFloat(cl(n, t)) + r}px` })
		}
		restore(t, n) {
			const r = n.dataset[t]
			r !== void 0 && (delete n.dataset[t], cl(n, { [t]: r }))
		}
		setContainerStyle(t) {
			super.setContainerStyle(t)
			const n = this.getElement()
			if ((kpe(n, "modal-open"), !t.scrollBarWidth)) return
			const r = this.isRTL ? "paddingLeft" : "paddingRight",
				i = this.isRTL ? "marginLeft" : "marginRight"
			Qs(n, yf.FIXED_CONTENT).forEach((a) => this.adjustAndStore(r, a, t.scrollBarWidth)),
				Qs(n, yf.STICKY_CONTENT).forEach((a) => this.adjustAndStore(i, a, -t.scrollBarWidth)),
				Qs(n, yf.NAVBAR_TOGGLER).forEach((a) => this.adjustAndStore(i, a, t.scrollBarWidth))
		}
		removeContainerStyle(t) {
			super.removeContainerStyle(t)
			const n = this.getElement()
			Dpe(n, "modal-open")
			const r = this.isRTL ? "paddingLeft" : "paddingRight",
				i = this.isRTL ? "marginLeft" : "marginRight"
			Qs(n, yf.FIXED_CONTENT).forEach((a) => this.restore(r, a)),
				Qs(n, yf.STICKY_CONTENT).forEach((a) => this.restore(i, a)),
				Qs(n, yf.NAVBAR_TOGGLER).forEach((a) => this.restore(i, a))
		}
	}
	let VT
	function p$(e) {
		return VT || (VT = new f$(e)), VT
	}
	function _pe(e) {
		return h.jsx(l$, { ...e })
	}
	function Ope(e) {
		return h.jsx(Yx, { ...e })
	}
	const h$ = _.forwardRef(
		(
			{
				bsPrefix: e,
				className: t,
				children: n,
				"aria-labelledby": r,
				placement: i = "start",
				responsive: a,
				show: o = !1,
				backdrop: s = !0,
				keyboard: l = !0,
				scroll: u = !1,
				onEscapeKeyDown: d,
				onShow: p,
				onHide: m,
				container: v,
				autoFocus: y = !0,
				enforceFocus: b = !0,
				restoreFocus: x = !0,
				restoreFocusOptions: E,
				onEntered: T,
				onExit: C,
				onExiting: D,
				onEnter: O,
				onEntering: A,
				onExited: N,
				backdropClassName: I,
				manager: P,
				renderStaticNode: L = !1,
				...B
			},
			z,
		) => {
			const V = _.useRef()
			e = nt(e, "offcanvas")
			const [K, ne] = _.useState(!1),
				re = wl(m),
				ie = Kfe(a || "xs", "up")
			_.useEffect(() => {
				ne(a ? o && !ie : o)
			}, [o, a, ie])
			const J = _.useMemo(() => ({ onHide: re }), [re])
			function le() {
				return (
					P ||
					(u
						? (V.current || (V.current = new f$({ handleContainerOverflow: !1 })), V.current)
						: p$())
				)
			}
			const F = (ge, ...Se) => {
					ge && (ge.style.visibility = "visible"), O == null || O(ge, ...Se)
				},
				Y = (ge, ...Se) => {
					ge && (ge.style.visibility = ""), N == null || N(...Se)
				},
				ee = _.useCallback(
					(ge) => h.jsx("div", { ...ge, className: Fe(`${e}-backdrop`, I) }),
					[I, e],
				),
				$ = (ge) =>
					h.jsx("div", {
						...ge,
						...B,
						className: Fe(t, a ? `${e}-${a}` : e, `${e}-${i}`),
						"aria-labelledby": r,
						children: n,
					})
			return h.jsxs(h.Fragment, {
				children: [
					!K && (a || L) && $({}),
					h.jsx(nO.Provider, {
						value: J,
						children: h.jsx(o$, {
							show: K,
							ref: z,
							backdrop: s,
							container: v,
							keyboard: l,
							autoFocus: y,
							enforceFocus: b && !u,
							restoreFocus: x,
							restoreFocusOptions: E,
							onEscapeKeyDown: d,
							onShow: p,
							onHide: re,
							onEnter: F,
							onEntering: A,
							onEntered: T,
							onExit: C,
							onExiting: D,
							onExited: Y,
							manager: le(),
							transition: _pe,
							backdropTransition: Ope,
							renderBackdrop: ee,
							renderDialog: $,
						}),
					}),
				],
			})
		},
	)
	h$.displayName = "Offcanvas"
	const Ape = Object.assign(h$, { Body: s$, Header: c$, Title: d$ }),
		m$ = _.forwardRef(({ onHide: e, ...t }, n) => {
			const r = _.useContext(Id),
				i = wl(() => {
					r == null || r.onToggle == null || r.onToggle(), e == null || e()
				})
			return h.jsx(Ape, {
				ref: n,
				show: !!(r != null && r.expanded),
				...t,
				renderStaticNode: !0,
				onHide: i,
			})
		})
	m$.displayName = "NavbarOffcanvas"
	const v$ = _.forwardRef(
		({ className: e, bsPrefix: t, as: n = "span", ...r }, i) => (
			(t = nt(t, "navbar-text")), h.jsx(n, { ref: i, className: Fe(e, t), ...r })
		),
	)
	v$.displayName = "NavbarText"
	const g$ = _.forwardRef((e, t) => {
		const {
				bsPrefix: n,
				expand: r = !0,
				variant: i = "light",
				bg: a,
				fixed: o,
				sticky: s,
				className: l,
				as: u = "nav",
				expanded: d,
				onToggle: p,
				onSelect: m,
				collapseOnSelect: v = !1,
				...y
			} = X_(e, { expanded: "onToggle" }),
			b = nt(n, "navbar"),
			x = _.useCallback(
				(...C) => {
					m == null || m(...C), v && d && (p == null || p(!1))
				},
				[m, v, d, p],
			)
		y.role === void 0 && u !== "nav" && (y.role = "navigation")
		let E = `${b}-expand`
		typeof r == "string" && (E = `${E}-${r}`)
		const T = _.useMemo(
			() => ({
				onToggle: () => (p == null ? void 0 : p(!d)),
				bsPrefix: b,
				expanded: !!d,
				expand: r,
			}),
			[b, d, r, p],
		)
		return h.jsx(Id.Provider, {
			value: T,
			children: h.jsx(fd.Provider, {
				value: x,
				children: h.jsx(u, {
					ref: t,
					...y,
					className: Fe(
						l,
						b,
						r && E,
						i && `${b}-${i}`,
						a && `bg-${a}`,
						s && `sticky-${s}`,
						o && `fixed-${o}`,
					),
				}),
			}),
		})
	})
	g$.displayName = "Navbar"
	const o1 = Object.assign(g$, { Brand: KH, Collapse: ZH, Offcanvas: m$, Text: v$, Toggle: e$ })
	function y$(e) {
		var t,
			n,
			r = ""
		if (typeof e == "string" || typeof e == "number") r += e
		else if (typeof e == "object")
			if (Array.isArray(e)) {
				var i = e.length
				for (t = 0; t < i; t++) e[t] && (n = y$(e[t])) && (r && (r += " "), (r += n))
			} else for (n in e) e[n] && (r && (r += " "), (r += n))
		return r
	}
	function hn() {
		for (var e, t, n = 0, r = "", i = arguments.length; n < i; n++)
			(e = arguments[n]) && (t = y$(e)) && (r && (r += " "), (r += t))
		return r
	}
	const xv = (e) => typeof e == "number" && !isNaN(e),
		Kc = (e) => typeof e == "string",
		ca = (e) => typeof e == "function",
		s1 = (e) => (Kc(e) || ca(e) ? e : null),
		p2 = (e) => _.isValidElement(e) || Kc(e) || ca(e) || xv(e)
	function Npe(e, t, n) {
		n === void 0 && (n = 300)
		const { scrollHeight: r, style: i } = e
		requestAnimationFrame(() => {
			;(i.minHeight = "initial"),
				(i.height = r + "px"),
				(i.transition = `all ${n}ms`),
				requestAnimationFrame(() => {
					;(i.height = "0"), (i.padding = "0"), (i.margin = "0"), setTimeout(t, n)
				})
		})
	}
	function Gx(e) {
		let {
			enter: t,
			exit: n,
			appendPosition: r = !1,
			collapse: i = !0,
			collapseDuration: a = 300,
		} = e
		return function (o) {
			let {
				children: s,
				position: l,
				preventExitTransition: u,
				done: d,
				nodeRef: p,
				isIn: m,
				playToast: v,
			} = o
			const y = r ? `${t}--${l}` : t,
				b = r ? `${n}--${l}` : n,
				x = _.useRef(0)
			return (
				_.useLayoutEffect(() => {
					const E = p.current,
						T = y.split(" "),
						C = (D) => {
							D.target === p.current &&
								(v(),
								E.removeEventListener("animationend", C),
								E.removeEventListener("animationcancel", C),
								x.current === 0 && D.type !== "animationcancel" && E.classList.remove(...T))
						}
					E.classList.add(...T),
						E.addEventListener("animationend", C),
						E.addEventListener("animationcancel", C)
				}, []),
				_.useEffect(() => {
					const E = p.current,
						T = () => {
							E.removeEventListener("animationend", T), i ? Npe(E, d, a) : d()
						}
					m ||
						(u
							? T()
							: ((x.current = 1), (E.className += ` ${b}`), E.addEventListener("animationend", T)))
				}, [m]),
				H.createElement(H.Fragment, null, s)
			)
		}
	}
	function RP(e, t) {
		return e != null
			? {
					content: e.content,
					containerId: e.props.containerId,
					id: e.props.toastId,
					theme: e.props.theme,
					type: e.props.type,
					data: e.props.data || {},
					isLoading: e.props.isLoading,
					icon: e.props.icon,
					status: t,
			  }
			: {}
	}
	const mi = new Map()
	let wv = []
	const h2 = new Set(),
		Mpe = (e) => h2.forEach((t) => t(e)),
		b$ = () => mi.size > 0
	function x$(e, t) {
		var n
		if (t) return !((n = mi.get(t)) == null || !n.isToastActive(e))
		let r = !1
		return (
			mi.forEach((i) => {
				i.isToastActive(e) && (r = !0)
			}),
			r
		)
	}
	function w$(e, t) {
		p2(e) &&
			(b$() || wv.push({ content: e, options: t }),
			mi.forEach((n) => {
				n.buildToast(e, t)
			}))
	}
	function LP(e, t) {
		mi.forEach((n) => {
			t != null && t != null && t.containerId
				? (t == null ? void 0 : t.containerId) === n.id && n.toggle(e, t == null ? void 0 : t.id)
				: n.toggle(e, t == null ? void 0 : t.id)
		})
	}
	function Ipe(e) {
		const {
			subscribe: t,
			getSnapshot: n,
			setProps: r,
		} = _.useRef(
			(function (a) {
				const o = a.containerId || 1
				return {
					subscribe(s) {
						const l = (function (d, p, m) {
							let v = 1,
								y = 0,
								b = [],
								x = [],
								E = [],
								T = p
							const C = new Map(),
								D = new Set(),
								O = () => {
									;(E = Array.from(C.values())), D.forEach((I) => I())
								},
								A = (I) => {
									;(x = I == null ? [] : x.filter((P) => P !== I)), O()
								},
								N = (I) => {
									const { toastId: P, onOpen: L, updateId: B, children: z } = I.props,
										V = B == null
									I.staleId && C.delete(I.staleId),
										C.set(P, I),
										(x = [...x, I.props.toastId].filter((K) => K !== I.staleId)),
										O(),
										m(RP(I, V ? "added" : "updated")),
										V && ca(L) && L(_.isValidElement(z) && z.props)
								}
							return {
								id: d,
								props: T,
								observe: (I) => (D.add(I), () => D.delete(I)),
								toggle: (I, P) => {
									C.forEach((L) => {
										;(P != null && P !== L.props.toastId) || (ca(L.toggle) && L.toggle(I))
									})
								},
								removeToast: A,
								toasts: C,
								clearQueue: () => {
									;(y -= b.length), (b = [])
								},
								buildToast: (I, P) => {
									if (
										((ee) => {
											let { containerId: $, toastId: ge, updateId: Se } = ee
											const Ee = $ ? $ !== d : d !== 1,
												be = C.has(ge) && Se == null
											return Ee || be
										})(P)
									)
										return
									const { toastId: L, updateId: B, data: z, staleId: V, delay: K } = P,
										ne = () => {
											A(L)
										},
										re = B == null
									re && y++
									const ie = {
										...T,
										style: T.toastStyle,
										key: v++,
										...Object.fromEntries(
											Object.entries(P).filter((ee) => {
												let [$, ge] = ee
												return ge != null
											}),
										),
										toastId: L,
										updateId: B,
										data: z,
										closeToast: ne,
										isIn: !1,
										className: s1(P.className || T.toastClassName),
										bodyClassName: s1(P.bodyClassName || T.bodyClassName),
										progressClassName: s1(P.progressClassName || T.progressClassName),
										autoClose:
											!P.isLoading &&
											((J = P.autoClose),
											(le = T.autoClose),
											J === !1 || (xv(J) && J > 0) ? J : le),
										deleteToast() {
											const ee = C.get(L),
												{ onClose: $, children: ge } = ee.props
											ca($) && $(_.isValidElement(ge) && ge.props),
												m(RP(ee, "removed")),
												C.delete(L),
												y--,
												y < 0 && (y = 0),
												b.length > 0 ? N(b.shift()) : O()
										},
									}
									var J, le
									;(ie.closeButton = T.closeButton),
										P.closeButton === !1 || p2(P.closeButton)
											? (ie.closeButton = P.closeButton)
											: P.closeButton === !0 &&
											  (ie.closeButton = !p2(T.closeButton) || T.closeButton)
									let F = I
									_.isValidElement(I) && !Kc(I.type)
										? (F = _.cloneElement(I, { closeToast: ne, toastProps: ie, data: z }))
										: ca(I) && (F = I({ closeToast: ne, toastProps: ie, data: z }))
									const Y = { content: F, props: ie, staleId: V }
									T.limit && T.limit > 0 && y > T.limit && re
										? b.push(Y)
										: xv(K)
										? setTimeout(() => {
												N(Y)
										  }, K)
										: N(Y)
								},
								setProps(I) {
									T = I
								},
								setToggle: (I, P) => {
									C.get(I).toggle = P
								},
								isToastActive: (I) => x.some((P) => P === I),
								getSnapshot: () => E,
							}
						})(o, a, Mpe)
						mi.set(o, l)
						const u = l.observe(s)
						return (
							wv.forEach((d) => w$(d.content, d.options)),
							(wv = []),
							() => {
								u(), mi.delete(o)
							}
						)
					},
					setProps(s) {
						var l
						;(l = mi.get(o)) == null || l.setProps(s)
					},
					getSnapshot() {
						var s
						return (s = mi.get(o)) == null ? void 0 : s.getSnapshot()
					},
				}
			})(e),
		).current
		r(e)
		const i = _.useSyncExternalStore(t, n, n)
		return {
			getToastToRender: function (a) {
				if (!i) return []
				const o = new Map()
				return (
					e.newestOnTop && i.reverse(),
					i.forEach((s) => {
						const { position: l } = s.props
						o.has(l) || o.set(l, []), o.get(l).push(s)
					}),
					Array.from(o, (s) => a(s[0], s[1]))
				)
			},
			isToastActive: x$,
			count: i == null ? void 0 : i.length,
		}
	}
	function Rpe(e) {
		const [t, n] = _.useState(!1),
			[r, i] = _.useState(!1),
			a = _.useRef(null),
			o = _.useRef({
				start: 0,
				delta: 0,
				removalDistance: 0,
				canCloseOnClick: !0,
				canDrag: !1,
				didMove: !1,
			}).current,
			{ autoClose: s, pauseOnHover: l, closeToast: u, onClick: d, closeOnClick: p } = e
		var m, v
		function y() {
			n(!0)
		}
		function b() {
			n(!1)
		}
		function x(C) {
			const D = a.current
			o.canDrag &&
				D &&
				((o.didMove = !0),
				t && b(),
				(o.delta = e.draggableDirection === "x" ? C.clientX - o.start : C.clientY - o.start),
				o.start !== C.clientX && (o.canCloseOnClick = !1),
				(D.style.transform = `translate3d(${
					e.draggableDirection === "x"
						? `${o.delta}px, var(--y)`
						: `0, calc(${o.delta}px + var(--y))`
				},0)`),
				(D.style.opacity = "" + (1 - Math.abs(o.delta / o.removalDistance))))
		}
		function E() {
			document.removeEventListener("pointermove", x), document.removeEventListener("pointerup", E)
			const C = a.current
			if (o.canDrag && o.didMove && C) {
				if (((o.canDrag = !1), Math.abs(o.delta) > o.removalDistance))
					return i(!0), e.closeToast(), void e.collapseAll()
				;(C.style.transition = "transform 0.2s, opacity 0.2s"),
					C.style.removeProperty("transform"),
					C.style.removeProperty("opacity")
			}
		}
		;(v = mi.get((m = { id: e.toastId, containerId: e.containerId, fn: n }).containerId || 1)) ==
			null || v.setToggle(m.id, m.fn),
			_.useEffect(() => {
				if (e.pauseOnFocusLoss)
					return (
						document.hasFocus() || b(),
						window.addEventListener("focus", y),
						window.addEventListener("blur", b),
						() => {
							window.removeEventListener("focus", y), window.removeEventListener("blur", b)
						}
					)
			}, [e.pauseOnFocusLoss])
		const T = {
			onPointerDown: function (C) {
				if (e.draggable === !0 || e.draggable === C.pointerType) {
					;(o.didMove = !1),
						document.addEventListener("pointermove", x),
						document.addEventListener("pointerup", E)
					const D = a.current
					;(o.canCloseOnClick = !0),
						(o.canDrag = !0),
						(D.style.transition = "none"),
						e.draggableDirection === "x"
							? ((o.start = C.clientX),
							  (o.removalDistance = D.offsetWidth * (e.draggablePercent / 100)))
							: ((o.start = C.clientY),
							  (o.removalDistance =
									(D.offsetHeight *
										(e.draggablePercent === 80 ? 1.5 * e.draggablePercent : e.draggablePercent)) /
									100))
				}
			},
			onPointerUp: function (C) {
				const { top: D, bottom: O, left: A, right: N } = a.current.getBoundingClientRect()
				C.nativeEvent.type !== "touchend" &&
				e.pauseOnHover &&
				C.clientX >= A &&
				C.clientX <= N &&
				C.clientY >= D &&
				C.clientY <= O
					? b()
					: y()
			},
		}
		return (
			s && l && ((T.onMouseEnter = b), e.stacked || (T.onMouseLeave = y)),
			p &&
				(T.onClick = (C) => {
					d && d(C), o.canCloseOnClick && u()
				}),
			{
				playToast: y,
				pauseToast: b,
				isRunning: t,
				preventExitTransition: r,
				toastRef: a,
				eventHandlers: T,
			}
		)
	}
	function Lpe(e) {
		let {
			delay: t,
			isRunning: n,
			closeToast: r,
			type: i = "default",
			hide: a,
			className: o,
			style: s,
			controlledProgress: l,
			progress: u,
			rtl: d,
			isIn: p,
			theme: m,
		} = e
		const v = a || (l && u === 0),
			y = { ...s, animationDuration: `${t}ms`, animationPlayState: n ? "running" : "paused" }
		l && (y.transform = `scaleX(${u})`)
		const b = hn(
				"Toastify__progress-bar",
				l ? "Toastify__progress-bar--controlled" : "Toastify__progress-bar--animated",
				`Toastify__progress-bar-theme--${m}`,
				`Toastify__progress-bar--${i}`,
				{ "Toastify__progress-bar--rtl": d },
			),
			x = ca(o) ? o({ rtl: d, type: i, defaultClassName: b }) : hn(b, o),
			E = {
				[l && u >= 1 ? "onTransitionEnd" : "onAnimationEnd"]:
					l && u < 1
						? null
						: () => {
								p && r()
						  },
			}
		return H.createElement(
			"div",
			{ className: "Toastify__progress-bar--wrp", "data-hidden": v },
			H.createElement("div", {
				className: `Toastify__progress-bar--bg Toastify__progress-bar-theme--${m} Toastify__progress-bar--${i}`,
			}),
			H.createElement("div", {
				role: "progressbar",
				"aria-hidden": v ? "true" : "false",
				"aria-label": "notification timer",
				className: x,
				style: y,
				...E,
			}),
		)
	}
	let Ppe = 1
	const E$ = () => "" + Ppe++
	function jpe(e) {
		return e && (Kc(e.toastId) || xv(e.toastId)) ? e.toastId : E$()
	}
	function Pm(e, t) {
		return w$(e, t), t.toastId
	}
	function X1(e, t) {
		return { ...t, type: (t && t.type) || e, toastId: jpe(t) }
	}
	function J0(e) {
		return (t, n) => Pm(t, X1(e, n))
	}
	function je(e, t) {
		return Pm(e, X1("default", t))
	}
	;(je.loading = (e, t) =>
		Pm(
			e,
			X1("default", {
				isLoading: !0,
				autoClose: !1,
				closeOnClick: !1,
				closeButton: !1,
				draggable: !1,
				...t,
			}),
		)),
		(je.promise = function (e, t, n) {
			let r,
				{ pending: i, error: a, success: o } = t
			i && (r = Kc(i) ? je.loading(i, n) : je.loading(i.render, { ...n, ...i }))
			const s = {
					isLoading: null,
					autoClose: null,
					closeOnClick: null,
					closeButton: null,
					draggable: null,
				},
				l = (d, p, m) => {
					if (p == null) return void je.dismiss(r)
					const v = { type: d, ...s, ...n, data: m },
						y = Kc(p) ? { render: p } : p
					return r ? je.update(r, { ...v, ...y }) : je(y.render, { ...v, ...y }), m
				},
				u = ca(e) ? e() : e
			return u.then((d) => l("success", o, d)).catch((d) => l("error", a, d)), u
		}),
		(je.success = J0("success")),
		(je.info = J0("info")),
		(je.error = J0("error")),
		(je.warning = J0("warning")),
		(je.warn = je.warning),
		(je.dark = (e, t) => Pm(e, X1("default", { theme: "dark", ...t }))),
		(je.dismiss = function (e) {
			;(function (t) {
				var n
				if (b$()) {
					if (t == null || Kc((n = t)) || xv(n))
						mi.forEach((r) => {
							r.removeToast(t)
						})
					else if (t && ("containerId" in t || "id" in t)) {
						const r = mi.get(t.containerId)
						r
							? r.removeToast(t.id)
							: mi.forEach((i) => {
									i.removeToast(t.id)
							  })
					}
				} else wv = wv.filter((r) => t != null && r.options.toastId !== t)
			})(e)
		}),
		(je.clearWaitingQueue = function (e) {
			e === void 0 && (e = {}),
				mi.forEach((t) => {
					!t.props.limit || (e.containerId && t.id !== e.containerId) || t.clearQueue()
				})
		}),
		(je.isActive = x$),
		(je.update = function (e, t) {
			t === void 0 && (t = {})
			const n = ((r, i) => {
				var a
				let { containerId: o } = i
				return (a = mi.get(o || 1)) == null ? void 0 : a.toasts.get(r)
			})(e, t)
			if (n) {
				const { props: r, content: i } = n,
					a = { delay: 100, ...r, ...t, toastId: t.toastId || e, updateId: E$() }
				a.toastId !== e && (a.staleId = e)
				const o = a.render || i
				delete a.render, Pm(o, a)
			}
		}),
		(je.done = (e) => {
			je.update(e, { progress: 1 })
		}),
		(je.onChange = function (e) {
			return (
				h2.add(e),
				() => {
					h2.delete(e)
				}
			)
		}),
		(je.play = (e) => LP(!0, e)),
		(je.pause = (e) => LP(!1, e))
	const Fpe = typeof window < "u" ? _.useLayoutEffect : _.useEffect,
		Z0 = (e) => {
			let { theme: t, type: n, isLoading: r, ...i } = e
			return H.createElement("svg", {
				viewBox: "0 0 24 24",
				width: "100%",
				height: "100%",
				fill: t === "colored" ? "currentColor" : `var(--toastify-icon-color-${n})`,
				...i,
			})
		},
		WT = {
			info: function (e) {
				return H.createElement(
					Z0,
					{ ...e },
					H.createElement("path", {
						d: "M12 0a12 12 0 1012 12A12.013 12.013 0 0012 0zm.25 5a1.5 1.5 0 11-1.5 1.5 1.5 1.5 0 011.5-1.5zm2.25 13.5h-4a1 1 0 010-2h.75a.25.25 0 00.25-.25v-4.5a.25.25 0 00-.25-.25h-.75a1 1 0 010-2h1a2 2 0 012 2v4.75a.25.25 0 00.25.25h.75a1 1 0 110 2z",
					}),
				)
			},
			warning: function (e) {
				return H.createElement(
					Z0,
					{ ...e },
					H.createElement("path", {
						d: "M23.32 17.191L15.438 2.184C14.728.833 13.416 0 11.996 0c-1.42 0-2.733.833-3.443 2.184L.533 17.448a4.744 4.744 0 000 4.368C1.243 23.167 2.555 24 3.975 24h16.05C22.22 24 24 22.044 24 19.632c0-.904-.251-1.746-.68-2.44zm-9.622 1.46c0 1.033-.724 1.823-1.698 1.823s-1.698-.79-1.698-1.822v-.043c0-1.028.724-1.822 1.698-1.822s1.698.79 1.698 1.822v.043zm.039-12.285l-.84 8.06c-.057.581-.408.943-.897.943-.49 0-.84-.367-.896-.942l-.84-8.065c-.057-.624.25-1.095.779-1.095h1.91c.528.005.84.476.784 1.1z",
					}),
				)
			},
			success: function (e) {
				return H.createElement(
					Z0,
					{ ...e },
					H.createElement("path", {
						d: "M12 0a12 12 0 1012 12A12.014 12.014 0 0012 0zm6.927 8.2l-6.845 9.289a1.011 1.011 0 01-1.43.188l-4.888-3.908a1 1 0 111.25-1.562l4.076 3.261 6.227-8.451a1 1 0 111.61 1.183z",
					}),
				)
			},
			error: function (e) {
				return H.createElement(
					Z0,
					{ ...e },
					H.createElement("path", {
						d: "M11.983 0a12.206 12.206 0 00-8.51 3.653A11.8 11.8 0 000 12.207 11.779 11.779 0 0011.8 24h.214A12.111 12.111 0 0024 11.791 11.766 11.766 0 0011.983 0zM10.5 16.542a1.476 1.476 0 011.449-1.53h.027a1.527 1.527 0 011.523 1.47 1.475 1.475 0 01-1.449 1.53h-.027a1.529 1.529 0 01-1.523-1.47zM11 12.5v-6a1 1 0 012 0v6a1 1 0 11-2 0z",
					}),
				)
			},
			spinner: function () {
				return H.createElement("div", { className: "Toastify__spinner" })
			},
		},
		Bpe = (e) => {
			const {
					isRunning: t,
					preventExitTransition: n,
					toastRef: r,
					eventHandlers: i,
					playToast: a,
				} = Rpe(e),
				{
					closeButton: o,
					children: s,
					autoClose: l,
					onClick: u,
					type: d,
					hideProgressBar: p,
					closeToast: m,
					transition: v,
					position: y,
					className: b,
					style: x,
					bodyClassName: E,
					bodyStyle: T,
					progressClassName: C,
					progressStyle: D,
					updateId: O,
					role: A,
					progress: N,
					rtl: I,
					toastId: P,
					deleteToast: L,
					isIn: B,
					isLoading: z,
					closeOnClick: V,
					theme: K,
				} = e,
				ne = hn(
					"Toastify__toast",
					`Toastify__toast-theme--${K}`,
					`Toastify__toast--${d}`,
					{ "Toastify__toast--rtl": I },
					{ "Toastify__toast--close-on-click": V },
				),
				re = ca(b) ? b({ rtl: I, position: y, type: d, defaultClassName: ne }) : hn(ne, b),
				ie = (function (Y) {
					let { theme: ee, type: $, isLoading: ge, icon: Se } = Y,
						Ee = null
					const be = { theme: ee, type: $ }
					return (
						Se === !1 ||
							(ca(Se)
								? (Ee = Se({ ...be, isLoading: ge }))
								: _.isValidElement(Se)
								? (Ee = _.cloneElement(Se, be))
								: ge
								? (Ee = WT.spinner())
								: ((Le) => Le in WT)($) && (Ee = WT[$](be))),
						Ee
					)
				})(e),
				J = !!N || !l,
				le = { closeToast: m, type: d, theme: K }
			let F = null
			return (
				o === !1 ||
					(F = ca(o)
						? o(le)
						: _.isValidElement(o)
						? _.cloneElement(o, le)
						: (function (Y) {
								let { closeToast: ee, theme: $, ariaLabel: ge = "close" } = Y
								return H.createElement(
									"button",
									{
										className: `Toastify__close-button Toastify__close-button--${$}`,
										type: "button",
										onClick: (Se) => {
											Se.stopPropagation(), ee(Se)
										},
										"aria-label": ge,
									},
									H.createElement(
										"svg",
										{ "aria-hidden": "true", viewBox: "0 0 14 16" },
										H.createElement("path", {
											fillRule: "evenodd",
											d: "M7.71 8.23l3.75 3.75-1.48 1.48-3.75-3.75-3.75 3.75L1 11.98l3.75-3.75L1 4.48 2.48 3l3.75 3.75L9.98 3l1.48 1.48-3.75 3.75z",
										}),
									),
								)
						  })(le)),
				H.createElement(
					v,
					{ isIn: B, done: L, position: y, preventExitTransition: n, nodeRef: r, playToast: a },
					H.createElement(
						"div",
						{ id: P, onClick: u, "data-in": B, className: re, ...i, style: x, ref: r },
						H.createElement(
							"div",
							{
								...(B && { role: A }),
								className: ca(E) ? E({ type: d }) : hn("Toastify__toast-body", E),
								style: T,
							},
							ie != null &&
								H.createElement(
									"div",
									{
										className: hn("Toastify__toast-icon", {
											"Toastify--animate-icon Toastify__zoom-enter": !z,
										}),
									},
									ie,
								),
							H.createElement("div", null, s),
						),
						F,
						H.createElement(Lpe, {
							...(O && !J ? { key: `pb-${O}` } : {}),
							rtl: I,
							theme: K,
							delay: l,
							isRunning: t,
							isIn: B,
							closeToast: m,
							hide: p,
							type: d,
							style: D,
							className: C,
							controlledProgress: J,
							progress: N || 0,
						}),
					),
				)
			)
		},
		Kx = function (e, t) {
			return (
				t === void 0 && (t = !1),
				{
					enter: `Toastify--animate Toastify__${e}-enter`,
					exit: `Toastify--animate Toastify__${e}-exit`,
					appendPosition: t,
				}
			)
		},
		Hpe = Gx(Kx("bounce", !0))
	Gx(Kx("slide", !0))
	Gx(Kx("zoom"))
	Gx(Kx("flip"))
	const $pe = {
		position: "top-right",
		transition: Hpe,
		autoClose: 5e3,
		closeButton: !0,
		pauseOnHover: !0,
		pauseOnFocusLoss: !0,
		draggable: "touch",
		draggablePercent: 80,
		draggableDirection: "x",
		role: "alert",
		theme: "light",
	}
	function Upe(e) {
		let t = { ...$pe, ...e }
		const n = e.stacked,
			[r, i] = _.useState(!0),
			a = _.useRef(null),
			{ getToastToRender: o, isToastActive: s, count: l } = Ipe(t),
			{ className: u, style: d, rtl: p, containerId: m } = t
		function v(b) {
			const x = hn("Toastify__toast-container", `Toastify__toast-container--${b}`, {
				"Toastify__toast-container--rtl": p,
			})
			return ca(u) ? u({ position: b, rtl: p, defaultClassName: x }) : hn(x, s1(u))
		}
		function y() {
			n && (i(!0), je.play())
		}
		return (
			Fpe(() => {
				if (n) {
					var b
					const x = a.current.querySelectorAll('[data-in="true"]'),
						E = 12,
						T = (b = t.position) == null ? void 0 : b.includes("top")
					let C = 0,
						D = 0
					Array.from(x)
						.reverse()
						.forEach((O, A) => {
							const N = O
							N.classList.add("Toastify__toast--stacked"),
								A > 0 && (N.dataset.collapsed = `${r}`),
								N.dataset.pos || (N.dataset.pos = T ? "top" : "bot")
							const I = C * (r ? 0.2 : 1) + (r ? 0 : E * A)
							N.style.setProperty("--y", `${T ? I : -1 * I}px`),
								N.style.setProperty("--g", `${E}`),
								N.style.setProperty("--s", "" + (1 - (r ? D : 0))),
								(C += N.offsetHeight),
								(D += 0.025)
						})
				}
			}, [r, l, n]),
			H.createElement(
				"div",
				{
					ref: a,
					className: "Toastify",
					id: m,
					onMouseEnter: () => {
						n && (i(!1), je.pause())
					},
					onMouseLeave: y,
				},
				o((b, x) => {
					const E = x.length ? { ...d } : { ...d, pointerEvents: "none" }
					return H.createElement(
						"div",
						{ className: v(b), style: E, key: `container-${b}` },
						x.map((T) => {
							let { content: C, props: D } = T
							return H.createElement(
								Bpe,
								{
									...D,
									stacked: n,
									collapseAll: y,
									isIn: s(D.toastId, D.containerId),
									style: D.style,
									key: `toast-${D.key}`,
								},
								C,
							)
						}),
					)
				}),
			)
		)
	}
	class zpe extends H.Component {
		constructor(t) {
			super(t), (this.state = { hasError: !1 })
		}
		static getDerivedStateFromError(t) {
			return { hasError: !0 }
		}
		render() {
			return this.state.hasError
				? h.jsx("p", { children: "Loading failed! Please reload." })
				: this.props.children
		}
	}
	function C$() {
		const [, e] = _.useReducer((t) => t + 1, 0)
		return e
	}
	const Qx = _.createContext(null)
	Qx.displayName = "NavContext"
	const T$ = _.createContext(null),
		qpe = ["as", "active", "eventKey"]
	function Vpe(e, t) {
		if (e == null) return {}
		var n = {}
		for (var r in e)
			if ({}.hasOwnProperty.call(e, r)) {
				if (t.indexOf(r) >= 0) continue
				n[r] = e[r]
			}
		return n
	}
	function k$({ key: e, onClick: t, active: n, id: r, role: i, disabled: a }) {
		const o = _.useContext(fd),
			s = _.useContext(Qx),
			l = _.useContext(T$)
		let u = n
		const d = { role: i }
		if (s) {
			!i && s.role === "tablist" && (d.role = "tab")
			const p = s.getControllerId(e ?? null),
				m = s.getControlledId(e ?? null)
			;(d[eh("event-key")] = e),
				(d.id = p || r),
				(u = n == null && e != null ? s.activeKey === e : n),
				(u || (!(l != null && l.unmountOnExit) && !(l != null && l.mountOnEnter))) &&
					(d["aria-controls"] = m)
		}
		return (
			d.role === "tab" &&
				((d["aria-selected"] = u),
				u || (d.tabIndex = -1),
				a && ((d.tabIndex = -1), (d["aria-disabled"] = !0))),
			(d.onClick = Jr((p) => {
				a || (t == null || t(p), e != null && o && !p.isPropagationStopped() && o(e, p))
			})),
			[d, { isActive: u }]
		)
	}
	const S$ = _.forwardRef((e, t) => {
		let { as: n = D_, active: r, eventKey: i } = e,
			a = Vpe(e, qpe)
		const [o, s] = k$(Object.assign({ key: gv(i, a.href), active: r }, a))
		return (o[eh("active")] = s.isActive), h.jsx(n, Object.assign({}, a, o, { ref: t }))
	})
	S$.displayName = "NavItem"
	const Wpe = ["as", "onSelect", "activeKey", "role", "onKeyDown"]
	function Ype(e, t) {
		if (e == null) return {}
		var n = {}
		for (var r in e)
			if ({}.hasOwnProperty.call(e, r)) {
				if (t.indexOf(r) >= 0) continue
				n[r] = e[r]
			}
		return n
	}
	const PP = () => {},
		jP = eh("event-key"),
		D$ = _.forwardRef((e, t) => {
			let { as: n = "div", onSelect: r, activeKey: i, role: a, onKeyDown: o } = e,
				s = Ype(e, Wpe)
			const l = C$(),
				u = _.useRef(!1),
				d = _.useContext(fd),
				p = _.useContext(T$)
			let m, v
			p &&
				((a = a || "tablist"), (i = p.activeKey), (m = p.getControlledId), (v = p.getControllerId))
			const y = _.useRef(null),
				b = (C) => {
					const D = y.current
					if (!D) return null
					const O = Qs(D, `[${jP}]:not([aria-disabled=true])`),
						A = D.querySelector("[aria-selected=true]")
					if (!A || A !== document.activeElement) return null
					const N = O.indexOf(A)
					if (N === -1) return null
					let I = N + C
					return I >= O.length && (I = 0), I < 0 && (I = O.length - 1), O[I]
				},
				x = (C, D) => {
					C != null && (r == null || r(C, D), d == null || d(C, D))
				},
				E = (C) => {
					if ((o == null || o(C), !p)) return
					let D
					switch (C.key) {
						case "ArrowLeft":
						case "ArrowUp":
							D = b(-1)
							break
						case "ArrowRight":
						case "ArrowDown":
							D = b(1)
							break
						default:
							return
					}
					D && (C.preventDefault(), x(D.dataset[tpe("EventKey")] || null, C), (u.current = !0), l())
				}
			_.useEffect(() => {
				if (y.current && u.current) {
					const C = y.current.querySelector(`[${jP}][aria-selected=true]`)
					C == null || C.focus()
				}
				u.current = !1
			})
			const T = Wx(t, y)
			return h.jsx(fd.Provider, {
				value: x,
				children: h.jsx(Qx.Provider, {
					value: { role: a, activeKey: gv(i), getControlledId: m || PP, getControllerId: v || PP },
					children: h.jsx(n, Object.assign({}, s, { onKeyDown: E, ref: T, role: a })),
				}),
			})
		})
	D$.displayName = "Nav"
	const Gpe = Object.assign(D$, { Item: S$ }),
		Pf = _.forwardRef(
			({ className: e, bsPrefix: t, as: n = "div", ...r }, i) => (
				(t = nt(t, "nav-item")), h.jsx(n, { ref: i, className: Fe(e, t), ...r })
			),
		)
	Pf.displayName = "NavItem"
	function Kpe() {
		return _.useState(null)
	}
	function Qpe(e, t, n, r = !1) {
		const i = Jr(n)
		_.useEffect(() => {
			const a = typeof e == "function" ? e() : e
			return a.addEventListener(t, i, r), () => a.removeEventListener(t, i, r)
		}, [e])
	}
	const Xpe = ["onKeyDown"]
	function Jpe(e, t) {
		if (e == null) return {}
		var n = {}
		for (var r in e)
			if ({}.hasOwnProperty.call(e, r)) {
				if (t.indexOf(r) >= 0) continue
				n[r] = e[r]
			}
		return n
	}
	function Zpe(e) {
		return !e || e.trim() === "#"
	}
	const iO = _.forwardRef((e, t) => {
		let { onKeyDown: n } = e,
			r = Jpe(e, Xpe)
		const [i] = S_(Object.assign({ tagName: "a" }, r)),
			a = Jr((o) => {
				i.onKeyDown(o), n == null || n(o)
			})
		return Zpe(r.href) || r.role === "button"
			? h.jsx("a", Object.assign({ ref: t }, r, i, { onKeyDown: a }))
			: h.jsx("a", Object.assign({ ref: t }, r, { onKeyDown: n }))
	})
	iO.displayName = "Anchor"
	const aO = _.forwardRef(
		(
			{ bsPrefix: e, className: t, as: n = iO, active: r, eventKey: i, disabled: a = !1, ...o },
			s,
		) => {
			e = nt(e, "nav-link")
			const [l, u] = k$({ key: gv(i, o.href), active: r, disabled: a, ...o })
			return h.jsx(n, {
				...o,
				...l,
				ref: s,
				disabled: a,
				className: Fe(t, e, a && "disabled", u.isActive && "active"),
			})
		},
	)
	aO.displayName = "NavLink"
	const _$ = _.forwardRef((e, t) => {
		const {
				as: n = "div",
				bsPrefix: r,
				variant: i,
				fill: a = !1,
				justify: o = !1,
				navbar: s,
				navbarScroll: l,
				className: u,
				activeKey: d,
				...p
			} = X_(e, { activeKey: "onSelect" }),
			m = nt(r, "nav")
		let v,
			y,
			b = !1
		const x = _.useContext(Id),
			E = _.useContext(K_)
		return (
			x ? ((v = x.bsPrefix), (b = s ?? !0)) : E && ({ cardHeaderBsPrefix: y } = E),
			h.jsx(Gpe, {
				as: n,
				ref: t,
				activeKey: d,
				className: Fe(u, {
					[m]: !b,
					[`${v}-nav`]: b,
					[`${v}-nav-scroll`]: b && l,
					[`${y}-${i}`]: !!y,
					[`${m}-${i}`]: !!i,
					[`${m}-fill`]: a,
					[`${m}-justified`]: o,
				}),
				...p,
			})
		)
	})
	_$.displayName = "Nav"
	const em = Object.assign(_$, { Item: Pf, Link: aO })
	function ehe(e, t, n) {
		const r = _.useRef(e !== void 0),
			[i, a] = _.useState(t),
			o = e !== void 0,
			s = r.current
		return (
			(r.current = o),
			!o && s && i !== t && a(t),
			[
				o ? e : i,
				_.useCallback(
					(...l) => {
						const [u, ...d] = l
						let p = n == null ? void 0 : n(u, ...d)
						return a(u), p
					},
					[n],
				),
			]
		)
	}
	const Xx = _.createContext(null)
	var FP = Object.prototype.hasOwnProperty
	function BP(e, t, n) {
		for (n of e.keys()) if (jm(n, t)) return n
	}
	function jm(e, t) {
		var n, r, i
		if (e === t) return !0
		if (e && t && (n = e.constructor) === t.constructor) {
			if (n === Date) return e.getTime() === t.getTime()
			if (n === RegExp) return e.toString() === t.toString()
			if (n === Array) {
				if ((r = e.length) === t.length) for (; r-- && jm(e[r], t[r]); );
				return r === -1
			}
			if (n === Set) {
				if (e.size !== t.size) return !1
				for (r of e)
					if (((i = r), (i && typeof i == "object" && ((i = BP(t, i)), !i)) || !t.has(i))) return !1
				return !0
			}
			if (n === Map) {
				if (e.size !== t.size) return !1
				for (r of e)
					if (
						((i = r[0]), (i && typeof i == "object" && ((i = BP(t, i)), !i)) || !jm(r[1], t.get(i)))
					)
						return !1
				return !0
			}
			if (n === ArrayBuffer) (e = new Uint8Array(e)), (t = new Uint8Array(t))
			else if (n === DataView) {
				if ((r = e.byteLength) === t.byteLength) for (; r-- && e.getInt8(r) === t.getInt8(r); );
				return r === -1
			}
			if (ArrayBuffer.isView(e)) {
				if ((r = e.byteLength) === t.byteLength) for (; r-- && e[r] === t[r]; );
				return r === -1
			}
			if (!n || typeof e == "object") {
				r = 0
				for (n in e)
					if ((FP.call(e, n) && ++r && !FP.call(t, n)) || !(n in t) || !jm(e[n], t[n])) return !1
				return Object.keys(t).length === r
			}
		}
		return e !== e && t !== t
	}
	function the(e) {
		const t = n$()
		return [
			e[0],
			_.useCallback(
				(n) => {
					if (t()) return e[1](n)
				},
				[t, e[1]],
			),
		]
	}
	var zi = "top",
		Ya = "bottom",
		Ga = "right",
		qi = "left",
		oO = "auto",
		og = [zi, Ya, Ga, qi],
		sp = "start",
		Ev = "end",
		nhe = "clippingParents",
		O$ = "viewport",
		tm = "popper",
		rhe = "reference",
		HP = og.reduce(function (e, t) {
			return e.concat([t + "-" + sp, t + "-" + Ev])
		}, []),
		A$ = [].concat(og, [oO]).reduce(function (e, t) {
			return e.concat([t, t + "-" + sp, t + "-" + Ev])
		}, []),
		ihe = "beforeRead",
		ahe = "read",
		ohe = "afterRead",
		she = "beforeMain",
		lhe = "main",
		uhe = "afterMain",
		che = "beforeWrite",
		dhe = "write",
		fhe = "afterWrite",
		phe = [ihe, ahe, ohe, she, lhe, uhe, che, dhe, fhe]
	function as(e) {
		return e.split("-")[0]
	}
	function ba(e) {
		if (e == null) return window
		if (e.toString() !== "[object Window]") {
			var t = e.ownerDocument
			return (t && t.defaultView) || window
		}
		return e
	}
	function pd(e) {
		var t = ba(e).Element
		return e instanceof t || e instanceof Element
	}
	function qa(e) {
		var t = ba(e).HTMLElement
		return e instanceof t || e instanceof HTMLElement
	}
	function sO(e) {
		if (typeof ShadowRoot > "u") return !1
		var t = ba(e).ShadowRoot
		return e instanceof t || e instanceof ShadowRoot
	}
	var Qc = Math.max,
		J1 = Math.min,
		lp = Math.round
	function m2() {
		var e = navigator.userAgentData
		return e != null && e.brands && Array.isArray(e.brands)
			? e.brands
					.map(function (t) {
						return t.brand + "/" + t.version
					})
					.join(" ")
			: navigator.userAgent
	}
	function N$() {
		return !/^((?!chrome|android).)*safari/i.test(m2())
	}
	function up(e, t, n) {
		t === void 0 && (t = !1), n === void 0 && (n = !1)
		var r = e.getBoundingClientRect(),
			i = 1,
			a = 1
		t &&
			qa(e) &&
			((i = (e.offsetWidth > 0 && lp(r.width) / e.offsetWidth) || 1),
			(a = (e.offsetHeight > 0 && lp(r.height) / e.offsetHeight) || 1))
		var o = pd(e) ? ba(e) : window,
			s = o.visualViewport,
			l = !N$() && n,
			u = (r.left + (l && s ? s.offsetLeft : 0)) / i,
			d = (r.top + (l && s ? s.offsetTop : 0)) / a,
			p = r.width / i,
			m = r.height / a
		return { width: p, height: m, top: d, right: u + p, bottom: d + m, left: u, x: u, y: d }
	}
	function lO(e) {
		var t = up(e),
			n = e.offsetWidth,
			r = e.offsetHeight
		return (
			Math.abs(t.width - n) <= 1 && (n = t.width),
			Math.abs(t.height - r) <= 1 && (r = t.height),
			{ x: e.offsetLeft, y: e.offsetTop, width: n, height: r }
		)
	}
	function M$(e, t) {
		var n = t.getRootNode && t.getRootNode()
		if (e.contains(t)) return !0
		if (n && sO(n)) {
			var r = t
			do {
				if (r && e.isSameNode(r)) return !0
				r = r.parentNode || r.host
			} while (r)
		}
		return !1
	}
	function hs(e) {
		return e ? (e.nodeName || "").toLowerCase() : null
	}
	function El(e) {
		return ba(e).getComputedStyle(e)
	}
	function hhe(e) {
		return ["table", "td", "th"].indexOf(hs(e)) >= 0
	}
	function Qu(e) {
		return ((pd(e) ? e.ownerDocument : e.document) || window.document).documentElement
	}
	function Jx(e) {
		return hs(e) === "html" ? e : e.assignedSlot || e.parentNode || (sO(e) ? e.host : null) || Qu(e)
	}
	function $P(e) {
		return !qa(e) || El(e).position === "fixed" ? null : e.offsetParent
	}
	function mhe(e) {
		var t = /firefox/i.test(m2()),
			n = /Trident/i.test(m2())
		if (n && qa(e)) {
			var r = El(e)
			if (r.position === "fixed") return null
		}
		var i = Jx(e)
		for (sO(i) && (i = i.host); qa(i) && ["html", "body"].indexOf(hs(i)) < 0; ) {
			var a = El(i)
			if (
				a.transform !== "none" ||
				a.perspective !== "none" ||
				a.contain === "paint" ||
				["transform", "perspective"].indexOf(a.willChange) !== -1 ||
				(t && a.willChange === "filter") ||
				(t && a.filter && a.filter !== "none")
			)
				return i
			i = i.parentNode
		}
		return null
	}
	function sg(e) {
		for (var t = ba(e), n = $P(e); n && hhe(n) && El(n).position === "static"; ) n = $P(n)
		return n && (hs(n) === "html" || (hs(n) === "body" && El(n).position === "static"))
			? t
			: n || mhe(e) || t
	}
	function uO(e) {
		return ["top", "bottom"].indexOf(e) >= 0 ? "x" : "y"
	}
	function Fm(e, t, n) {
		return Qc(e, J1(t, n))
	}
	function vhe(e, t, n) {
		var r = Fm(e, t, n)
		return r > n ? n : r
	}
	function I$() {
		return { top: 0, right: 0, bottom: 0, left: 0 }
	}
	function R$(e) {
		return Object.assign({}, I$(), e)
	}
	function L$(e, t) {
		return t.reduce(function (n, r) {
			return (n[r] = e), n
		}, {})
	}
	var ghe = function (t, n) {
		return (
			(t = typeof t == "function" ? t(Object.assign({}, n.rects, { placement: n.placement })) : t),
			R$(typeof t != "number" ? t : L$(t, og))
		)
	}
	function yhe(e) {
		var t,
			n = e.state,
			r = e.name,
			i = e.options,
			a = n.elements.arrow,
			o = n.modifiersData.popperOffsets,
			s = as(n.placement),
			l = uO(s),
			u = [qi, Ga].indexOf(s) >= 0,
			d = u ? "height" : "width"
		if (!(!a || !o)) {
			var p = ghe(i.padding, n),
				m = lO(a),
				v = l === "y" ? zi : qi,
				y = l === "y" ? Ya : Ga,
				b = n.rects.reference[d] + n.rects.reference[l] - o[l] - n.rects.popper[d],
				x = o[l] - n.rects.reference[l],
				E = sg(a),
				T = E ? (l === "y" ? E.clientHeight || 0 : E.clientWidth || 0) : 0,
				C = b / 2 - x / 2,
				D = p[v],
				O = T - m[d] - p[y],
				A = T / 2 - m[d] / 2 + C,
				N = Fm(D, A, O),
				I = l
			n.modifiersData[r] = ((t = {}), (t[I] = N), (t.centerOffset = N - A), t)
		}
	}
	function bhe(e) {
		var t = e.state,
			n = e.options,
			r = n.element,
			i = r === void 0 ? "[data-popper-arrow]" : r
		i != null &&
			((typeof i == "string" && ((i = t.elements.popper.querySelector(i)), !i)) ||
				(M$(t.elements.popper, i) && (t.elements.arrow = i)))
	}
	const P$ = {
		name: "arrow",
		enabled: !0,
		phase: "main",
		fn: yhe,
		effect: bhe,
		requires: ["popperOffsets"],
		requiresIfExists: ["preventOverflow"],
	}
	function cp(e) {
		return e.split("-")[1]
	}
	var xhe = { top: "auto", right: "auto", bottom: "auto", left: "auto" }
	function whe(e, t) {
		var n = e.x,
			r = e.y,
			i = t.devicePixelRatio || 1
		return { x: lp(n * i) / i || 0, y: lp(r * i) / i || 0 }
	}
	function UP(e) {
		var t,
			n = e.popper,
			r = e.popperRect,
			i = e.placement,
			a = e.variation,
			o = e.offsets,
			s = e.position,
			l = e.gpuAcceleration,
			u = e.adaptive,
			d = e.roundOffsets,
			p = e.isFixed,
			m = o.x,
			v = m === void 0 ? 0 : m,
			y = o.y,
			b = y === void 0 ? 0 : y,
			x = typeof d == "function" ? d({ x: v, y: b }) : { x: v, y: b }
		;(v = x.x), (b = x.y)
		var E = o.hasOwnProperty("x"),
			T = o.hasOwnProperty("y"),
			C = qi,
			D = zi,
			O = window
		if (u) {
			var A = sg(n),
				N = "clientHeight",
				I = "clientWidth"
			if (
				(A === ba(n) &&
					((A = Qu(n)),
					El(A).position !== "static" &&
						s === "absolute" &&
						((N = "scrollHeight"), (I = "scrollWidth"))),
				(A = A),
				i === zi || ((i === qi || i === Ga) && a === Ev))
			) {
				D = Ya
				var P = p && A === O && O.visualViewport ? O.visualViewport.height : A[N]
				;(b -= P - r.height), (b *= l ? 1 : -1)
			}
			if (i === qi || ((i === zi || i === Ya) && a === Ev)) {
				C = Ga
				var L = p && A === O && O.visualViewport ? O.visualViewport.width : A[I]
				;(v -= L - r.width), (v *= l ? 1 : -1)
			}
		}
		var B = Object.assign({ position: s }, u && xhe),
			z = d === !0 ? whe({ x: v, y: b }, ba(n)) : { x: v, y: b }
		if (((v = z.x), (b = z.y), l)) {
			var V
			return Object.assign(
				{},
				B,
				((V = {}),
				(V[D] = T ? "0" : ""),
				(V[C] = E ? "0" : ""),
				(V.transform =
					(O.devicePixelRatio || 1) <= 1
						? "translate(" + v + "px, " + b + "px)"
						: "translate3d(" + v + "px, " + b + "px, 0)"),
				V),
			)
		}
		return Object.assign(
			{},
			B,
			((t = {}), (t[D] = T ? b + "px" : ""), (t[C] = E ? v + "px" : ""), (t.transform = ""), t),
		)
	}
	function Ehe(e) {
		var t = e.state,
			n = e.options,
			r = n.gpuAcceleration,
			i = r === void 0 ? !0 : r,
			a = n.adaptive,
			o = a === void 0 ? !0 : a,
			s = n.roundOffsets,
			l = s === void 0 ? !0 : s,
			u = {
				placement: as(t.placement),
				variation: cp(t.placement),
				popper: t.elements.popper,
				popperRect: t.rects.popper,
				gpuAcceleration: i,
				isFixed: t.options.strategy === "fixed",
			}
		t.modifiersData.popperOffsets != null &&
			(t.styles.popper = Object.assign(
				{},
				t.styles.popper,
				UP(
					Object.assign({}, u, {
						offsets: t.modifiersData.popperOffsets,
						position: t.options.strategy,
						adaptive: o,
						roundOffsets: l,
					}),
				),
			)),
			t.modifiersData.arrow != null &&
				(t.styles.arrow = Object.assign(
					{},
					t.styles.arrow,
					UP(
						Object.assign({}, u, {
							offsets: t.modifiersData.arrow,
							position: "absolute",
							adaptive: !1,
							roundOffsets: l,
						}),
					),
				)),
			(t.attributes.popper = Object.assign({}, t.attributes.popper, {
				"data-popper-placement": t.placement,
			}))
	}
	const j$ = { name: "computeStyles", enabled: !0, phase: "beforeWrite", fn: Ehe, data: {} }
	var ey = { passive: !0 }
	function Che(e) {
		var t = e.state,
			n = e.instance,
			r = e.options,
			i = r.scroll,
			a = i === void 0 ? !0 : i,
			o = r.resize,
			s = o === void 0 ? !0 : o,
			l = ba(t.elements.popper),
			u = [].concat(t.scrollParents.reference, t.scrollParents.popper)
		return (
			a &&
				u.forEach(function (d) {
					d.addEventListener("scroll", n.update, ey)
				}),
			s && l.addEventListener("resize", n.update, ey),
			function () {
				a &&
					u.forEach(function (d) {
						d.removeEventListener("scroll", n.update, ey)
					}),
					s && l.removeEventListener("resize", n.update, ey)
			}
		)
	}
	const F$ = {
		name: "eventListeners",
		enabled: !0,
		phase: "write",
		fn: function () {},
		effect: Che,
		data: {},
	}
	var The = { left: "right", right: "left", bottom: "top", top: "bottom" }
	function l1(e) {
		return e.replace(/left|right|bottom|top/g, function (t) {
			return The[t]
		})
	}
	var khe = { start: "end", end: "start" }
	function zP(e) {
		return e.replace(/start|end/g, function (t) {
			return khe[t]
		})
	}
	function cO(e) {
		var t = ba(e),
			n = t.pageXOffset,
			r = t.pageYOffset
		return { scrollLeft: n, scrollTop: r }
	}
	function dO(e) {
		return up(Qu(e)).left + cO(e).scrollLeft
	}
	function She(e, t) {
		var n = ba(e),
			r = Qu(e),
			i = n.visualViewport,
			a = r.clientWidth,
			o = r.clientHeight,
			s = 0,
			l = 0
		if (i) {
			;(a = i.width), (o = i.height)
			var u = N$()
			;(u || (!u && t === "fixed")) && ((s = i.offsetLeft), (l = i.offsetTop))
		}
		return { width: a, height: o, x: s + dO(e), y: l }
	}
	function Dhe(e) {
		var t,
			n = Qu(e),
			r = cO(e),
			i = (t = e.ownerDocument) == null ? void 0 : t.body,
			a = Qc(n.scrollWidth, n.clientWidth, i ? i.scrollWidth : 0, i ? i.clientWidth : 0),
			o = Qc(n.scrollHeight, n.clientHeight, i ? i.scrollHeight : 0, i ? i.clientHeight : 0),
			s = -r.scrollLeft + dO(e),
			l = -r.scrollTop
		return (
			El(i || n).direction === "rtl" && (s += Qc(n.clientWidth, i ? i.clientWidth : 0) - a),
			{ width: a, height: o, x: s, y: l }
		)
	}
	function fO(e) {
		var t = El(e),
			n = t.overflow,
			r = t.overflowX,
			i = t.overflowY
		return /auto|scroll|overlay|hidden/.test(n + i + r)
	}
	function B$(e) {
		return ["html", "body", "#document"].indexOf(hs(e)) >= 0
			? e.ownerDocument.body
			: qa(e) && fO(e)
			? e
			: B$(Jx(e))
	}
	function Bm(e, t) {
		var n
		t === void 0 && (t = [])
		var r = B$(e),
			i = r === ((n = e.ownerDocument) == null ? void 0 : n.body),
			a = ba(r),
			o = i ? [a].concat(a.visualViewport || [], fO(r) ? r : []) : r,
			s = t.concat(o)
		return i ? s : s.concat(Bm(Jx(o)))
	}
	function v2(e) {
		return Object.assign({}, e, {
			left: e.x,
			top: e.y,
			right: e.x + e.width,
			bottom: e.y + e.height,
		})
	}
	function _he(e, t) {
		var n = up(e, !1, t === "fixed")
		return (
			(n.top = n.top + e.clientTop),
			(n.left = n.left + e.clientLeft),
			(n.bottom = n.top + e.clientHeight),
			(n.right = n.left + e.clientWidth),
			(n.width = e.clientWidth),
			(n.height = e.clientHeight),
			(n.x = n.left),
			(n.y = n.top),
			n
		)
	}
	function qP(e, t, n) {
		return t === O$ ? v2(She(e, n)) : pd(t) ? _he(t, n) : v2(Dhe(Qu(e)))
	}
	function Ohe(e) {
		var t = Bm(Jx(e)),
			n = ["absolute", "fixed"].indexOf(El(e).position) >= 0,
			r = n && qa(e) ? sg(e) : e
		return pd(r)
			? t.filter(function (i) {
					return pd(i) && M$(i, r) && hs(i) !== "body"
			  })
			: []
	}
	function Ahe(e, t, n, r) {
		var i = t === "clippingParents" ? Ohe(e) : [].concat(t),
			a = [].concat(i, [n]),
			o = a[0],
			s = a.reduce(function (l, u) {
				var d = qP(e, u, r)
				return (
					(l.top = Qc(d.top, l.top)),
					(l.right = J1(d.right, l.right)),
					(l.bottom = J1(d.bottom, l.bottom)),
					(l.left = Qc(d.left, l.left)),
					l
				)
			}, qP(e, o, r))
		return (
			(s.width = s.right - s.left), (s.height = s.bottom - s.top), (s.x = s.left), (s.y = s.top), s
		)
	}
	function H$(e) {
		var t = e.reference,
			n = e.element,
			r = e.placement,
			i = r ? as(r) : null,
			a = r ? cp(r) : null,
			o = t.x + t.width / 2 - n.width / 2,
			s = t.y + t.height / 2 - n.height / 2,
			l
		switch (i) {
			case zi:
				l = { x: o, y: t.y - n.height }
				break
			case Ya:
				l = { x: o, y: t.y + t.height }
				break
			case Ga:
				l = { x: t.x + t.width, y: s }
				break
			case qi:
				l = { x: t.x - n.width, y: s }
				break
			default:
				l = { x: t.x, y: t.y }
		}
		var u = i ? uO(i) : null
		if (u != null) {
			var d = u === "y" ? "height" : "width"
			switch (a) {
				case sp:
					l[u] = l[u] - (t[d] / 2 - n[d] / 2)
					break
				case Ev:
					l[u] = l[u] + (t[d] / 2 - n[d] / 2)
					break
			}
		}
		return l
	}
	function Cv(e, t) {
		t === void 0 && (t = {})
		var n = t,
			r = n.placement,
			i = r === void 0 ? e.placement : r,
			a = n.strategy,
			o = a === void 0 ? e.strategy : a,
			s = n.boundary,
			l = s === void 0 ? nhe : s,
			u = n.rootBoundary,
			d = u === void 0 ? O$ : u,
			p = n.elementContext,
			m = p === void 0 ? tm : p,
			v = n.altBoundary,
			y = v === void 0 ? !1 : v,
			b = n.padding,
			x = b === void 0 ? 0 : b,
			E = R$(typeof x != "number" ? x : L$(x, og)),
			T = m === tm ? rhe : tm,
			C = e.rects.popper,
			D = e.elements[y ? T : m],
			O = Ahe(pd(D) ? D : D.contextElement || Qu(e.elements.popper), l, d, o),
			A = up(e.elements.reference),
			N = H$({ reference: A, element: C, strategy: "absolute", placement: i }),
			I = v2(Object.assign({}, C, N)),
			P = m === tm ? I : A,
			L = {
				top: O.top - P.top + E.top,
				bottom: P.bottom - O.bottom + E.bottom,
				left: O.left - P.left + E.left,
				right: P.right - O.right + E.right,
			},
			B = e.modifiersData.offset
		if (m === tm && B) {
			var z = B[i]
			Object.keys(L).forEach(function (V) {
				var K = [Ga, Ya].indexOf(V) >= 0 ? 1 : -1,
					ne = [zi, Ya].indexOf(V) >= 0 ? "y" : "x"
				L[V] += z[ne] * K
			})
		}
		return L
	}
	function Nhe(e, t) {
		t === void 0 && (t = {})
		var n = t,
			r = n.placement,
			i = n.boundary,
			a = n.rootBoundary,
			o = n.padding,
			s = n.flipVariations,
			l = n.allowedAutoPlacements,
			u = l === void 0 ? A$ : l,
			d = cp(r),
			p = d
				? s
					? HP
					: HP.filter(function (y) {
							return cp(y) === d
					  })
				: og,
			m = p.filter(function (y) {
				return u.indexOf(y) >= 0
			})
		m.length === 0 && (m = p)
		var v = m.reduce(function (y, b) {
			return (y[b] = Cv(e, { placement: b, boundary: i, rootBoundary: a, padding: o })[as(b)]), y
		}, {})
		return Object.keys(v).sort(function (y, b) {
			return v[y] - v[b]
		})
	}
	function Mhe(e) {
		if (as(e) === oO) return []
		var t = l1(e)
		return [zP(e), t, zP(t)]
	}
	function Ihe(e) {
		var t = e.state,
			n = e.options,
			r = e.name
		if (!t.modifiersData[r]._skip) {
			for (
				var i = n.mainAxis,
					a = i === void 0 ? !0 : i,
					o = n.altAxis,
					s = o === void 0 ? !0 : o,
					l = n.fallbackPlacements,
					u = n.padding,
					d = n.boundary,
					p = n.rootBoundary,
					m = n.altBoundary,
					v = n.flipVariations,
					y = v === void 0 ? !0 : v,
					b = n.allowedAutoPlacements,
					x = t.options.placement,
					E = as(x),
					T = E === x,
					C = l || (T || !y ? [l1(x)] : Mhe(x)),
					D = [x].concat(C).reduce(function (ge, Se) {
						return ge.concat(
							as(Se) === oO
								? Nhe(t, {
										placement: Se,
										boundary: d,
										rootBoundary: p,
										padding: u,
										flipVariations: y,
										allowedAutoPlacements: b,
								  })
								: Se,
						)
					}, []),
					O = t.rects.reference,
					A = t.rects.popper,
					N = new Map(),
					I = !0,
					P = D[0],
					L = 0;
				L < D.length;
				L++
			) {
				var B = D[L],
					z = as(B),
					V = cp(B) === sp,
					K = [zi, Ya].indexOf(z) >= 0,
					ne = K ? "width" : "height",
					re = Cv(t, { placement: B, boundary: d, rootBoundary: p, altBoundary: m, padding: u }),
					ie = K ? (V ? Ga : qi) : V ? Ya : zi
				O[ne] > A[ne] && (ie = l1(ie))
				var J = l1(ie),
					le = []
				if (
					(a && le.push(re[z] <= 0),
					s && le.push(re[ie] <= 0, re[J] <= 0),
					le.every(function (ge) {
						return ge
					}))
				) {
					;(P = B), (I = !1)
					break
				}
				N.set(B, le)
			}
			if (I)
				for (
					var F = y ? 3 : 1,
						Y = function (Se) {
							var Ee = D.find(function (be) {
								var Le = N.get(be)
								if (Le)
									return Le.slice(0, Se).every(function (Be) {
										return Be
									})
							})
							if (Ee) return (P = Ee), "break"
						},
						ee = F;
					ee > 0;
					ee--
				) {
					var $ = Y(ee)
					if ($ === "break") break
				}
			t.placement !== P && ((t.modifiersData[r]._skip = !0), (t.placement = P), (t.reset = !0))
		}
	}
	const $$ = {
		name: "flip",
		enabled: !0,
		phase: "main",
		fn: Ihe,
		requiresIfExists: ["offset"],
		data: { _skip: !1 },
	}
	function VP(e, t, n) {
		return (
			n === void 0 && (n = { x: 0, y: 0 }),
			{
				top: e.top - t.height - n.y,
				right: e.right - t.width + n.x,
				bottom: e.bottom - t.height + n.y,
				left: e.left - t.width - n.x,
			}
		)
	}
	function WP(e) {
		return [zi, Ga, Ya, qi].some(function (t) {
			return e[t] >= 0
		})
	}
	function Rhe(e) {
		var t = e.state,
			n = e.name,
			r = t.rects.reference,
			i = t.rects.popper,
			a = t.modifiersData.preventOverflow,
			o = Cv(t, { elementContext: "reference" }),
			s = Cv(t, { altBoundary: !0 }),
			l = VP(o, r),
			u = VP(s, i, a),
			d = WP(l),
			p = WP(u)
		;(t.modifiersData[n] = {
			referenceClippingOffsets: l,
			popperEscapeOffsets: u,
			isReferenceHidden: d,
			hasPopperEscaped: p,
		}),
			(t.attributes.popper = Object.assign({}, t.attributes.popper, {
				"data-popper-reference-hidden": d,
				"data-popper-escaped": p,
			}))
	}
	const U$ = {
		name: "hide",
		enabled: !0,
		phase: "main",
		requiresIfExists: ["preventOverflow"],
		fn: Rhe,
	}
	function Lhe(e, t, n) {
		var r = as(e),
			i = [qi, zi].indexOf(r) >= 0 ? -1 : 1,
			a = typeof n == "function" ? n(Object.assign({}, t, { placement: e })) : n,
			o = a[0],
			s = a[1]
		return (
			(o = o || 0), (s = (s || 0) * i), [qi, Ga].indexOf(r) >= 0 ? { x: s, y: o } : { x: o, y: s }
		)
	}
	function Phe(e) {
		var t = e.state,
			n = e.options,
			r = e.name,
			i = n.offset,
			a = i === void 0 ? [0, 0] : i,
			o = A$.reduce(function (d, p) {
				return (d[p] = Lhe(p, t.rects, a)), d
			}, {}),
			s = o[t.placement],
			l = s.x,
			u = s.y
		t.modifiersData.popperOffsets != null &&
			((t.modifiersData.popperOffsets.x += l), (t.modifiersData.popperOffsets.y += u)),
			(t.modifiersData[r] = o)
	}
	const z$ = { name: "offset", enabled: !0, phase: "main", requires: ["popperOffsets"], fn: Phe }
	function jhe(e) {
		var t = e.state,
			n = e.name
		t.modifiersData[n] = H$({
			reference: t.rects.reference,
			element: t.rects.popper,
			strategy: "absolute",
			placement: t.placement,
		})
	}
	const q$ = { name: "popperOffsets", enabled: !0, phase: "read", fn: jhe, data: {} }
	function Fhe(e) {
		return e === "x" ? "y" : "x"
	}
	function Bhe(e) {
		var t = e.state,
			n = e.options,
			r = e.name,
			i = n.mainAxis,
			a = i === void 0 ? !0 : i,
			o = n.altAxis,
			s = o === void 0 ? !1 : o,
			l = n.boundary,
			u = n.rootBoundary,
			d = n.altBoundary,
			p = n.padding,
			m = n.tether,
			v = m === void 0 ? !0 : m,
			y = n.tetherOffset,
			b = y === void 0 ? 0 : y,
			x = Cv(t, { boundary: l, rootBoundary: u, padding: p, altBoundary: d }),
			E = as(t.placement),
			T = cp(t.placement),
			C = !T,
			D = uO(E),
			O = Fhe(D),
			A = t.modifiersData.popperOffsets,
			N = t.rects.reference,
			I = t.rects.popper,
			P = typeof b == "function" ? b(Object.assign({}, t.rects, { placement: t.placement })) : b,
			L =
				typeof P == "number"
					? { mainAxis: P, altAxis: P }
					: Object.assign({ mainAxis: 0, altAxis: 0 }, P),
			B = t.modifiersData.offset ? t.modifiersData.offset[t.placement] : null,
			z = { x: 0, y: 0 }
		if (A) {
			if (a) {
				var V,
					K = D === "y" ? zi : qi,
					ne = D === "y" ? Ya : Ga,
					re = D === "y" ? "height" : "width",
					ie = A[D],
					J = ie + x[K],
					le = ie - x[ne],
					F = v ? -I[re] / 2 : 0,
					Y = T === sp ? N[re] : I[re],
					ee = T === sp ? -I[re] : -N[re],
					$ = t.elements.arrow,
					ge = v && $ ? lO($) : { width: 0, height: 0 },
					Se = t.modifiersData["arrow#persistent"]
						? t.modifiersData["arrow#persistent"].padding
						: I$(),
					Ee = Se[K],
					be = Se[ne],
					Le = Fm(0, N[re], ge[re]),
					Be = C ? N[re] / 2 - F - Le - Ee - L.mainAxis : Y - Le - Ee - L.mainAxis,
					et = C ? -N[re] / 2 + F + Le + be + L.mainAxis : ee + Le + be + L.mainAxis,
					pt = t.elements.arrow && sg(t.elements.arrow),
					mt = pt ? (D === "y" ? pt.clientTop || 0 : pt.clientLeft || 0) : 0,
					Xt = (V = B == null ? void 0 : B[D]) != null ? V : 0,
					on = ie + Be - Xt - mt,
					dt = ie + et - Xt,
					cn = Fm(v ? J1(J, on) : J, ie, v ? Qc(le, dt) : le)
				;(A[D] = cn), (z[D] = cn - ie)
			}
			if (s) {
				var sn,
					ur = D === "x" ? zi : qi,
					Hn = D === "x" ? Ya : Ga,
					Jt = A[O],
					mn = O === "y" ? "height" : "width",
					ue = Jt + x[ur],
					Re = Jt - x[Hn],
					pe = [zi, qi].indexOf(E) !== -1,
					ye = (sn = B == null ? void 0 : B[O]) != null ? sn : 0,
					X = pe ? ue : Jt - N[mn] - I[mn] - ye + L.altAxis,
					de = pe ? Jt + N[mn] + I[mn] - ye - L.altAxis : Re,
					Me = v && pe ? vhe(X, Jt, de) : Fm(v ? X : ue, Jt, v ? de : Re)
				;(A[O] = Me), (z[O] = Me - Jt)
			}
			t.modifiersData[r] = z
		}
	}
	const V$ = {
		name: "preventOverflow",
		enabled: !0,
		phase: "main",
		fn: Bhe,
		requiresIfExists: ["offset"],
	}
	function Hhe(e) {
		return { scrollLeft: e.scrollLeft, scrollTop: e.scrollTop }
	}
	function $he(e) {
		return e === ba(e) || !qa(e) ? cO(e) : Hhe(e)
	}
	function Uhe(e) {
		var t = e.getBoundingClientRect(),
			n = lp(t.width) / e.offsetWidth || 1,
			r = lp(t.height) / e.offsetHeight || 1
		return n !== 1 || r !== 1
	}
	function zhe(e, t, n) {
		n === void 0 && (n = !1)
		var r = qa(t),
			i = qa(t) && Uhe(t),
			a = Qu(t),
			o = up(e, i, n),
			s = { scrollLeft: 0, scrollTop: 0 },
			l = { x: 0, y: 0 }
		return (
			(r || (!r && !n)) &&
				((hs(t) !== "body" || fO(a)) && (s = $he(t)),
				qa(t)
					? ((l = up(t, !0)), (l.x += t.clientLeft), (l.y += t.clientTop))
					: a && (l.x = dO(a))),
			{
				x: o.left + s.scrollLeft - l.x,
				y: o.top + s.scrollTop - l.y,
				width: o.width,
				height: o.height,
			}
		)
	}
	function qhe(e) {
		var t = new Map(),
			n = new Set(),
			r = []
		e.forEach(function (a) {
			t.set(a.name, a)
		})
		function i(a) {
			n.add(a.name)
			var o = [].concat(a.requires || [], a.requiresIfExists || [])
			o.forEach(function (s) {
				if (!n.has(s)) {
					var l = t.get(s)
					l && i(l)
				}
			}),
				r.push(a)
		}
		return (
			e.forEach(function (a) {
				n.has(a.name) || i(a)
			}),
			r
		)
	}
	function Vhe(e) {
		var t = qhe(e)
		return phe.reduce(function (n, r) {
			return n.concat(
				t.filter(function (i) {
					return i.phase === r
				}),
			)
		}, [])
	}
	function Whe(e) {
		var t
		return function () {
			return (
				t ||
					(t = new Promise(function (n) {
						Promise.resolve().then(function () {
							;(t = void 0), n(e())
						})
					})),
				t
			)
		}
	}
	function Yhe(e) {
		var t = e.reduce(function (n, r) {
			var i = n[r.name]
			return (
				(n[r.name] = i
					? Object.assign({}, i, r, {
							options: Object.assign({}, i.options, r.options),
							data: Object.assign({}, i.data, r.data),
					  })
					: r),
				n
			)
		}, {})
		return Object.keys(t).map(function (n) {
			return t[n]
		})
	}
	var YP = { placement: "bottom", modifiers: [], strategy: "absolute" }
	function GP() {
		for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++) t[n] = arguments[n]
		return !t.some(function (r) {
			return !(r && typeof r.getBoundingClientRect == "function")
		})
	}
	function W$(e) {
		e === void 0 && (e = {})
		var t = e,
			n = t.defaultModifiers,
			r = n === void 0 ? [] : n,
			i = t.defaultOptions,
			a = i === void 0 ? YP : i
		return function (s, l, u) {
			u === void 0 && (u = a)
			var d = {
					placement: "bottom",
					orderedModifiers: [],
					options: Object.assign({}, YP, a),
					modifiersData: {},
					elements: { reference: s, popper: l },
					attributes: {},
					styles: {},
				},
				p = [],
				m = !1,
				v = {
					state: d,
					setOptions: function (E) {
						var T = typeof E == "function" ? E(d.options) : E
						b(),
							(d.options = Object.assign({}, a, d.options, T)),
							(d.scrollParents = {
								reference: pd(s) ? Bm(s) : s.contextElement ? Bm(s.contextElement) : [],
								popper: Bm(l),
							})
						var C = Vhe(Yhe([].concat(r, d.options.modifiers)))
						return (
							(d.orderedModifiers = C.filter(function (D) {
								return D.enabled
							})),
							y(),
							v.update()
						)
					},
					forceUpdate: function () {
						if (!m) {
							var E = d.elements,
								T = E.reference,
								C = E.popper
							if (GP(T, C)) {
								;(d.rects = {
									reference: zhe(T, sg(C), d.options.strategy === "fixed"),
									popper: lO(C),
								}),
									(d.reset = !1),
									(d.placement = d.options.placement),
									d.orderedModifiers.forEach(function (L) {
										return (d.modifiersData[L.name] = Object.assign({}, L.data))
									})
								for (var D = 0; D < d.orderedModifiers.length; D++) {
									if (d.reset === !0) {
										;(d.reset = !1), (D = -1)
										continue
									}
									var O = d.orderedModifiers[D],
										A = O.fn,
										N = O.options,
										I = N === void 0 ? {} : N,
										P = O.name
									typeof A == "function" &&
										(d = A({ state: d, options: I, name: P, instance: v }) || d)
								}
							}
						}
					},
					update: Whe(function () {
						return new Promise(function (x) {
							v.forceUpdate(), x(d)
						})
					}),
					destroy: function () {
						b(), (m = !0)
					},
				}
			if (!GP(s, l)) return v
			v.setOptions(u).then(function (x) {
				!m && u.onFirstUpdate && u.onFirstUpdate(x)
			})
			function y() {
				d.orderedModifiers.forEach(function (x) {
					var E = x.name,
						T = x.options,
						C = T === void 0 ? {} : T,
						D = x.effect
					if (typeof D == "function") {
						var O = D({ state: d, name: E, instance: v, options: C }),
							A = function () {}
						p.push(O || A)
					}
				})
			}
			function b() {
				p.forEach(function (x) {
					return x()
				}),
					(p = [])
			}
			return v
		}
	}
	const Ghe = W$({ defaultModifiers: [U$, q$, j$, F$, z$, $$, V$, P$] }),
		Khe = ["enabled", "placement", "strategy", "modifiers"]
	function Qhe(e, t) {
		if (e == null) return {}
		var n = {}
		for (var r in e)
			if ({}.hasOwnProperty.call(e, r)) {
				if (t.indexOf(r) >= 0) continue
				n[r] = e[r]
			}
		return n
	}
	const Xhe = { name: "applyStyles", enabled: !1, phase: "afterWrite", fn: () => {} },
		Jhe = {
			name: "ariaDescribedBy",
			enabled: !0,
			phase: "afterWrite",
			effect:
				({ state: e }) =>
				() => {
					const { reference: t, popper: n } = e.elements
					if ("removeAttribute" in t) {
						const r = (t.getAttribute("aria-describedby") || "")
							.split(",")
							.filter((i) => i.trim() !== n.id)
						r.length
							? t.setAttribute("aria-describedby", r.join(","))
							: t.removeAttribute("aria-describedby")
					}
				},
			fn: ({ state: e }) => {
				var t
				const { popper: n, reference: r } = e.elements,
					i = (t = n.getAttribute("role")) == null ? void 0 : t.toLowerCase()
				if (n.id && i === "tooltip" && "setAttribute" in r) {
					const a = r.getAttribute("aria-describedby")
					if (a && a.split(",").indexOf(n.id) !== -1) return
					r.setAttribute("aria-describedby", a ? `${a},${n.id}` : n.id)
				}
			},
		},
		Zhe = []
	function eme(e, t, n = {}) {
		let {
				enabled: r = !0,
				placement: i = "bottom",
				strategy: a = "absolute",
				modifiers: o = Zhe,
			} = n,
			s = Qhe(n, Khe)
		const l = _.useRef(o),
			u = _.useRef(),
			d = _.useCallback(() => {
				var x
				;(x = u.current) == null || x.update()
			}, []),
			p = _.useCallback(() => {
				var x
				;(x = u.current) == null || x.forceUpdate()
			}, []),
			[m, v] = the(
				_.useState({
					placement: i,
					update: d,
					forceUpdate: p,
					attributes: {},
					styles: { popper: {}, arrow: {} },
				}),
			),
			y = _.useMemo(
				() => ({
					name: "updateStateModifier",
					enabled: !0,
					phase: "write",
					requires: ["computeStyles"],
					fn: ({ state: x }) => {
						const E = {},
							T = {}
						Object.keys(x.elements).forEach((C) => {
							;(E[C] = x.styles[C]), (T[C] = x.attributes[C])
						}),
							v({
								state: x,
								styles: E,
								attributes: T,
								update: d,
								forceUpdate: p,
								placement: x.placement,
							})
					},
				}),
				[d, p, v],
			),
			b = _.useMemo(() => (jm(l.current, o) || (l.current = o), l.current), [o])
		return (
			_.useEffect(() => {
				!u.current ||
					!r ||
					u.current.setOptions({ placement: i, strategy: a, modifiers: [...b, y, Xhe] })
			}, [a, i, y, r, b]),
			_.useEffect(() => {
				if (!(!r || e == null || t == null))
					return (
						(u.current = Ghe(
							e,
							t,
							Object.assign({}, s, { placement: i, strategy: a, modifiers: [...b, Jhe, y] }),
						)),
						() => {
							u.current != null &&
								(u.current.destroy(),
								(u.current = void 0),
								v((x) => Object.assign({}, x, { attributes: {}, styles: { popper: {} } })))
						}
					)
			}, [r, e, t]),
			m
		)
	}
	const KP = () => {}
	function tme(e) {
		return e.button === 0
	}
	function nme(e) {
		return !!(e.metaKey || e.altKey || e.ctrlKey || e.shiftKey)
	}
	const YT = (e) => e && ("current" in e ? e.current : e),
		QP = { click: "mousedown", mouseup: "mousedown", pointerup: "pointerdown" }
	function rme(e, t = KP, { disabled: n, clickTrigger: r = "click" } = {}) {
		const i = _.useRef(!1),
			a = _.useRef(!1),
			o = _.useCallback(
				(u) => {
					const d = YT(e)
					z_(
						!!d,
						"ClickOutside captured a close event but does not have a ref to compare it to. useClickOutside(), should be passed a ref that resolves to a DOM node",
					),
						(i.current = !d || nme(u) || !tme(u) || !!bv(d, u.target) || a.current),
						(a.current = !1)
				},
				[e],
			),
			s = Jr((u) => {
				const d = YT(e)
				d && bv(d, u.target) ? (a.current = !0) : (a.current = !1)
			}),
			l = Jr((u) => {
				i.current || t(u)
			})
		_.useEffect(() => {
			var u, d
			if (n || e == null) return
			const p = Jp(YT(e)),
				m = p.defaultView || window
			let v = (u = m.event) != null ? u : (d = m.parent) == null ? void 0 : d.event,
				y = null
			QP[r] && (y = za(p, QP[r], s, !0))
			const b = za(p, r, o, !0),
				x = za(p, r, (T) => {
					if (T === v) {
						v = void 0
						return
					}
					l(T)
				})
			let E = []
			return (
				"ontouchstart" in p.documentElement &&
					(E = [].slice.call(p.body.children).map((T) => za(T, "mousemove", KP))),
				() => {
					y == null || y(), b(), x(), E.forEach((T) => T())
				}
			)
		}, [e, n, r, o, s, l])
	}
	function ime(e) {
		const t = {}
		return Array.isArray(e)
			? (e == null ||
					e.forEach((n) => {
						t[n.name] = n
					}),
			  t)
			: e || t
	}
	function ame(e = {}) {
		return Array.isArray(e) ? e : Object.keys(e).map((t) => ((e[t].name = t), e[t]))
	}
	function ome({
		enabled: e,
		enableEvents: t,
		placement: n,
		flip: r,
		offset: i,
		fixed: a,
		containerPadding: o,
		arrowElement: s,
		popperConfig: l = {},
	}) {
		var u, d, p, m, v
		const y = ime(l.modifiers)
		return Object.assign({}, l, {
			placement: n,
			enabled: e,
			strategy: a ? "fixed" : l.strategy,
			modifiers: ame(
				Object.assign({}, y, {
					eventListeners: {
						enabled: t,
						options: (u = y.eventListeners) == null ? void 0 : u.options,
					},
					preventOverflow: Object.assign({}, y.preventOverflow, {
						options: o
							? Object.assign({ padding: o }, (d = y.preventOverflow) == null ? void 0 : d.options)
							: (p = y.preventOverflow) == null
							? void 0
							: p.options,
					}),
					offset: {
						options: Object.assign({ offset: i }, (m = y.offset) == null ? void 0 : m.options),
					},
					arrow: Object.assign({}, y.arrow, {
						enabled: !!s,
						options: Object.assign({}, (v = y.arrow) == null ? void 0 : v.options, { element: s }),
					}),
					flip: Object.assign({ enabled: !!r }, y.flip),
				}),
			),
		})
	}
	const sme = ["children", "usePopper"]
	function lme(e, t) {
		if (e == null) return {}
		var n = {}
		for (var r in e)
			if ({}.hasOwnProperty.call(e, r)) {
				if (t.indexOf(r) >= 0) continue
				n[r] = e[r]
			}
		return n
	}
	const ume = () => {}
	function Y$(e = {}) {
		const t = _.useContext(Xx),
			[n, r] = Kpe(),
			i = _.useRef(!1),
			{
				flip: a,
				offset: o,
				rootCloseEvent: s,
				fixed: l = !1,
				placement: u,
				popperConfig: d = {},
				enableEventListeners: p = !0,
				usePopper: m = !!t,
			} = e,
			v = (t == null ? void 0 : t.show) == null ? !!e.show : t.show
		v && !i.current && (i.current = !0)
		const y = (A) => {
				t == null || t.toggle(!1, A)
			},
			{ placement: b, setMenu: x, menuElement: E, toggleElement: T } = t || {},
			C = eme(
				T,
				E,
				ome({
					placement: u || b || "bottom-start",
					enabled: m,
					enableEvents: p ?? v,
					offset: o,
					flip: a,
					fixed: l,
					arrowElement: n,
					popperConfig: d,
				}),
			),
			D = Object.assign(
				{ ref: x || ume, "aria-labelledby": T == null ? void 0 : T.id },
				C.attributes.popper,
				{ style: C.styles.popper },
			),
			O = {
				show: v,
				placement: b,
				hasShown: i.current,
				toggle: t == null ? void 0 : t.toggle,
				popper: m ? C : null,
				arrowProps: m
					? Object.assign({ ref: r }, C.attributes.arrow, { style: C.styles.arrow })
					: {},
			}
		return rme(E, y, { clickTrigger: s, disabled: !v }), [D, O]
	}
	function G$(e) {
		let { children: t, usePopper: n = !0 } = e,
			r = lme(e, sme)
		const [i, a] = Y$(Object.assign({}, r, { usePopper: n }))
		return h.jsx(h.Fragment, { children: t(i, a) })
	}
	G$.displayName = "DropdownMenu"
	const Z1 = { prefix: String(Math.round(Math.random() * 1e10)), current: 0 },
		K$ = H.createContext(Z1),
		cme = H.createContext(!1)
	let dme = !!(typeof window < "u" && window.document && window.document.createElement),
		GT = new WeakMap()
	function fme(e = !1) {
		let t = _.useContext(K$),
			n = _.useRef(null)
		if (n.current === null && !e) {
			var r, i
			let a =
				(i = H.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED) === null ||
				i === void 0 ||
				(r = i.ReactCurrentOwner) === null ||
				r === void 0
					? void 0
					: r.current
			if (a) {
				let o = GT.get(a)
				o == null
					? GT.set(a, { id: t.current, state: a.memoizedState })
					: a.memoizedState !== o.state && ((t.current = o.id), GT.delete(a))
			}
			n.current = ++t.current
		}
		return n.current
	}
	function pme(e) {
		let t = _.useContext(K$)
		t === Z1 &&
			!dme &&
			console.warn(
				"When server rendering, you must wrap your application in an <SSRProvider> to ensure consistent ids are generated between the client and server.",
			)
		let n = fme(!!e),
			r = `react-aria${t.prefix}`
		return e || `${r}-${n}`
	}
	function hme(e) {
		let t = H.useId(),
			[n] = _.useState(bme()),
			r = n ? "react-aria" : `react-aria${Z1.prefix}`
		return e || `${r}-${t}`
	}
	const mme = typeof H.useId == "function" ? hme : pme
	function vme() {
		return !1
	}
	function gme() {
		return !0
	}
	function yme(e) {
		return () => {}
	}
	function bme() {
		return typeof H.useSyncExternalStore == "function"
			? H.useSyncExternalStore(yme, vme, gme)
			: _.useContext(cme)
	}
	const Q$ = (e) => {
			var t
			return ((t = e.getAttribute("role")) == null ? void 0 : t.toLowerCase()) === "menu"
		},
		XP = () => {}
	function X$() {
		const e = mme(),
			{ show: t = !1, toggle: n = XP, setToggle: r, menuElement: i } = _.useContext(Xx) || {},
			a = _.useCallback(
				(s) => {
					n(!t, s)
				},
				[t, n],
			),
			o = { id: e, ref: r || XP, onClick: a, "aria-expanded": !!t }
		return i && Q$(i) && (o["aria-haspopup"] = !0), [o, { show: t, toggle: n }]
	}
	function J$({ children: e }) {
		const [t, n] = X$()
		return h.jsx(h.Fragment, { children: e(t, n) })
	}
	J$.displayName = "DropdownToggle"
	const xme = ["eventKey", "disabled", "onClick", "active", "as"]
	function wme(e, t) {
		if (e == null) return {}
		var n = {}
		for (var r in e)
			if ({}.hasOwnProperty.call(e, r)) {
				if (t.indexOf(r) >= 0) continue
				n[r] = e[r]
			}
		return n
	}
	function Z$({ key: e, href: t, active: n, disabled: r, onClick: i }) {
		const a = _.useContext(fd),
			o = _.useContext(Qx),
			{ activeKey: s } = o || {},
			l = gv(e, t),
			u = n == null && e != null ? gv(s) === l : n
		return [
			{
				onClick: Jr((p) => {
					r || (i == null || i(p), a && !p.isPropagationStopped() && a(l, p))
				}),
				"aria-disabled": r || void 0,
				"aria-selected": u,
				[eh("dropdown-item")]: "",
			},
			{ isActive: u },
		]
	}
	const e7 = _.forwardRef((e, t) => {
		let { eventKey: n, disabled: r, onClick: i, active: a, as: o = D_ } = e,
			s = wme(e, xme)
		const [l] = Z$({ key: n, href: s.href, disabled: r, onClick: i, active: a })
		return h.jsx(o, Object.assign({}, s, { ref: t }, l))
	})
	e7.displayName = "DropdownItem"
	function JP() {
		const e = C$(),
			t = _.useRef(null),
			n = _.useCallback(
				(r) => {
					;(t.current = r), e()
				},
				[e],
			)
		return [t, n]
	}
	function lg({
		defaultShow: e,
		show: t,
		onSelect: n,
		onToggle: r,
		itemSelector: i = `* [${eh("dropdown-item")}]`,
		focusFirstItemOnShow: a,
		placement: o = "bottom-start",
		children: s,
	}) {
		const l = Vx(),
			[u, d] = ehe(t, e, r),
			[p, m] = JP(),
			v = p.current,
			[y, b] = JP(),
			x = y.current,
			E = r$(u),
			T = _.useRef(null),
			C = _.useRef(!1),
			D = _.useContext(fd),
			O = _.useCallback(
				(B, z, V = z == null ? void 0 : z.type) => {
					d(B, { originalEvent: z, source: V })
				},
				[d],
			),
			A = Jr((B, z) => {
				n == null || n(B, z), O(!1, z, "select"), z.isPropagationStopped() || D == null || D(B, z)
			}),
			N = _.useMemo(
				() => ({
					toggle: O,
					placement: o,
					show: u,
					menuElement: v,
					toggleElement: x,
					setMenu: m,
					setToggle: b,
				}),
				[O, o, u, v, x, m, b],
			)
		v && E && !u && (C.current = v.contains(v.ownerDocument.activeElement))
		const I = Jr(() => {
				x && x.focus && x.focus()
			}),
			P = Jr(() => {
				const B = T.current
				let z = a
				if (
					(z == null && (z = p.current && Q$(p.current) ? "keyboard" : !1),
					z === !1 || (z === "keyboard" && !/^key.+$/.test(B)))
				)
					return
				const V = Qs(p.current, i)[0]
				V && V.focus && V.focus()
			})
		_.useEffect(() => {
			u ? P() : C.current && ((C.current = !1), I())
		}, [u, C, I, P]),
			_.useEffect(() => {
				T.current = null
			})
		const L = (B, z) => {
			if (!p.current) return null
			const V = Qs(p.current, i)
			let K = V.indexOf(B) + z
			return (K = Math.max(0, Math.min(K, V.length))), V[K]
		}
		return (
			Qpe(
				_.useCallback(() => l.document, [l]),
				"keydown",
				(B) => {
					var z, V
					const { key: K } = B,
						ne = B.target,
						re = (z = p.current) == null ? void 0 : z.contains(ne),
						ie = (V = y.current) == null ? void 0 : V.contains(ne)
					if (
						(/input|textarea/i.test(ne.tagName) &&
							(K === " " || (K !== "Escape" && re) || (K === "Escape" && ne.type === "search"))) ||
						(!re && !ie) ||
						(K === "Tab" && (!p.current || !u))
					)
						return
					T.current = B.type
					const le = { originalEvent: B, source: B.type }
					switch (K) {
						case "ArrowUp": {
							const F = L(ne, -1)
							F && F.focus && F.focus(), B.preventDefault()
							return
						}
						case "ArrowDown":
							if ((B.preventDefault(), !u)) d(!0, le)
							else {
								const F = L(ne, 1)
								F && F.focus && F.focus()
							}
							return
						case "Tab":
							J_(
								ne.ownerDocument,
								"keyup",
								(F) => {
									var Y
									;((F.key === "Tab" && !F.target) ||
										!((Y = p.current) != null && Y.contains(F.target))) &&
										d(!1, le)
								},
								{ once: !0 },
							)
							break
						case "Escape":
							K === "Escape" && (B.preventDefault(), B.stopPropagation()), d(!1, le)
							break
					}
				},
			),
			h.jsx(fd.Provider, { value: A, children: h.jsx(Xx.Provider, { value: N, children: s }) })
		)
	}
	lg.displayName = "Dropdown"
	lg.Menu = G$
	lg.Toggle = J$
	lg.Item = e7
	const pO = _.createContext({})
	pO.displayName = "DropdownContext"
	const t7 = _.forwardRef(
		({ className: e, bsPrefix: t, as: n = "hr", role: r = "separator", ...i }, a) => (
			(t = nt(t, "dropdown-divider")), h.jsx(n, { ref: a, className: Fe(e, t), role: r, ...i })
		),
	)
	t7.displayName = "DropdownDivider"
	const n7 = _.forwardRef(
		({ className: e, bsPrefix: t, as: n = "div", role: r = "heading", ...i }, a) => (
			(t = nt(t, "dropdown-header")), h.jsx(n, { ref: a, className: Fe(e, t), role: r, ...i })
		),
	)
	n7.displayName = "DropdownHeader"
	const r7 = _.forwardRef(
		(
			{
				bsPrefix: e,
				className: t,
				eventKey: n,
				disabled: r = !1,
				onClick: i,
				active: a,
				as: o = iO,
				...s
			},
			l,
		) => {
			const u = nt(e, "dropdown-item"),
				[d, p] = Z$({ key: n, href: s.href, disabled: r, onClick: i, active: a })
			return h.jsx(o, {
				...s,
				...d,
				ref: l,
				className: Fe(t, u, p.isActive && "active", r && "disabled"),
			})
		},
	)
	r7.displayName = "DropdownItem"
	const i7 = _.forwardRef(
		({ className: e, bsPrefix: t, as: n = "span", ...r }, i) => (
			(t = nt(t, "dropdown-item-text")), h.jsx(n, { ref: i, className: Fe(e, t), ...r })
		),
	)
	i7.displayName = "DropdownItemText"
	const hO = _.createContext(null)
	hO.displayName = "InputGroupContext"
	function a7(e, t) {
		return e
	}
	function o7(e, t, n) {
		const r = n ? "top-end" : "top-start",
			i = n ? "top-start" : "top-end",
			a = n ? "bottom-end" : "bottom-start",
			o = n ? "bottom-start" : "bottom-end",
			s = n ? "right-start" : "left-start",
			l = n ? "right-end" : "left-end",
			u = n ? "left-start" : "right-start",
			d = n ? "left-end" : "right-end"
		let p = e ? o : a
		return (
			t === "up"
				? (p = e ? i : r)
				: t === "end"
				? (p = e ? d : u)
				: t === "start"
				? (p = e ? l : s)
				: t === "down-centered"
				? (p = "bottom")
				: t === "up-centered" && (p = "top"),
			p
		)
	}
	const s7 = _.forwardRef(
		(
			{
				bsPrefix: e,
				className: t,
				align: n,
				rootCloseEvent: r,
				flip: i = !0,
				show: a,
				renderOnMount: o,
				as: s = "div",
				popperConfig: l,
				variant: u,
				...d
			},
			p,
		) => {
			let m = !1
			const v = _.useContext(Id),
				y = nt(e, "dropdown-menu"),
				{ align: b, drop: x, isRTL: E } = _.useContext(pO)
			n = n || b
			const T = _.useContext(hO),
				C = []
			if (n)
				if (typeof n == "object") {
					const B = Object.keys(n)
					if (B.length) {
						const z = B[0],
							V = n[z]
						;(m = V === "start"), C.push(`${y}-${z}-${V}`)
					}
				} else n === "end" && (m = !0)
			const D = o7(m, x, E),
				[O, { hasShown: A, popper: N, show: I, toggle: P }] = Y$({
					flip: i,
					rootCloseEvent: r,
					show: a,
					usePopper: !v && C.length === 0,
					offset: [0, 2],
					popperConfig: l,
					placement: D,
				})
			if (
				((O.ref = qx(a7(p), O.ref)),
				t$(() => {
					I && (N == null || N.update())
				}, [I]),
				!A && !o && !T)
			)
				return null
			typeof s != "string" &&
				((O.show = I), (O.close = () => (P == null ? void 0 : P(!1))), (O.align = n))
			let L = d.style
			return (
				N != null &&
					N.placement &&
					((L = { ...d.style, ...O.style }), (d["x-placement"] = N.placement)),
				h.jsx(s, {
					...d,
					...O,
					style: L,
					...((C.length || v) && { "data-bs-popper": "static" }),
					className: Fe(t, y, I && "show", m && `${y}-end`, u && `${y}-${u}`, ...C),
				})
			)
		},
	)
	s7.displayName = "DropdownMenu"
	const l7 = _.forwardRef(
		({ bsPrefix: e, split: t, className: n, childBsPrefix: r, as: i = Ge, ...a }, o) => {
			const s = nt(e, "dropdown-toggle"),
				l = _.useContext(Xx)
			r !== void 0 && (a.bsPrefix = r)
			const [u] = X$()
			return (
				(u.ref = qx(u.ref, a7(o))),
				h.jsx(i, {
					className: Fe(n, s, t && `${s}-split`, (l == null ? void 0 : l.show) && "show"),
					...u,
					...a,
				})
			)
		},
	)
	l7.displayName = "DropdownToggle"
	const u7 = _.forwardRef((e, t) => {
		const {
				bsPrefix: n,
				drop: r = "down",
				show: i,
				className: a,
				align: o = "start",
				onSelect: s,
				onToggle: l,
				focusFirstItemOnShow: u,
				as: d = "div",
				navbar: p,
				autoClose: m = !0,
				...v
			} = X_(e, { show: "onToggle" }),
			y = _.useContext(hO),
			b = nt(n, "dropdown"),
			x = xB(),
			E = (N) =>
				m === !1
					? N === "click"
					: m === "inside"
					? N !== "rootClose"
					: m === "outside"
					? N !== "select"
					: !0,
			T = wl((N, I) => {
				var P
				;(!((P = I.originalEvent) == null || (P = P.target) == null) &&
					P.classList.contains("dropdown-toggle") &&
					I.source === "mousedown") ||
					(I.originalEvent.currentTarget === document &&
						(I.source !== "keydown" || I.originalEvent.key === "Escape") &&
						(I.source = "rootClose"),
					E(I.source) && (l == null || l(N, I)))
			}),
			D = o7(o === "end", r, x),
			O = _.useMemo(() => ({ align: o, drop: r, isRTL: x }), [o, r, x]),
			A = {
				down: b,
				"down-centered": `${b}-center`,
				up: "dropup",
				"up-centered": "dropup-center dropup",
				end: "dropend",
				start: "dropstart",
			}
		return h.jsx(pO.Provider, {
			value: O,
			children: h.jsx(lg, {
				placement: D,
				show: i,
				onSelect: s,
				onToggle: T,
				focusFirstItemOnShow: u,
				itemSelector: `.${b}-item:not(.disabled):not(:disabled)`,
				children: y ? v.children : h.jsx(d, { ...v, ref: t, className: Fe(a, i && "show", A[r]) }),
			}),
		})
	})
	u7.displayName = "Dropdown"
	const Fc = Object.assign(u7, {
			Toggle: l7,
			Menu: s7,
			Item: r7,
			ItemText: i7,
			Divider: t7,
			Header: n7,
		}),
		c7 = _.forwardRef(
			(
				{
					id: e,
					title: t,
					children: n,
					bsPrefix: r,
					className: i,
					rootCloseEvent: a,
					menuRole: o,
					disabled: s,
					active: l,
					renderMenuOnMount: u,
					menuVariant: d,
					...p
				},
				m,
			) => {
				const v = nt(void 0, "nav-item")
				return h.jsxs(Fc, {
					ref: m,
					...p,
					className: Fe(i, v),
					children: [
						h.jsx(Fc.Toggle, {
							id: e,
							eventKey: null,
							active: l,
							disabled: s,
							childBsPrefix: r,
							as: aO,
							children: t,
						}),
						h.jsx(Fc.Menu, {
							role: o,
							renderOnMount: u,
							rootCloseEvent: a,
							variant: d,
							children: n,
						}),
					],
				})
			},
		)
	c7.displayName = "NavDropdown"
	const nm = Object.assign(c7, {
			Item: Fc.Item,
			ItemText: Fc.ItemText,
			Divider: Fc.Divider,
			Header: Fc.Header,
		}),
		Eme = (e) => {
			const { user: t } = ks(),
				n = () =>
					t.isAuthenticated
						? h.jsxs(Un, {
								to: "/account",
								className: "nav-link",
								children: ["My Account (", t.name, ")"],
						  })
						: null,
				r = () => {
					const { subMenu: i, segments: a } = e
					switch (i) {
						case "home":
							return h.jsx(em, {
								children: h.jsxs(nm, {
									title: "Affiliated Organizations",
									id: "collasible-nav-dropdown",
									children: [
										h.jsx(nm.Item, {
											href: "https://www.mngolf.org/Home",
											target: "_blank",
											children: "Minnesota Golf Association",
										}),
										h.jsx(nm.Item, {
											href: "https://www.minnesotapga.com/",
											target: "_blank",
											children: "Minnesota PGA",
										}),
										h.jsx(nm.Item, {
											href: "http://www.wirthgolfassociation.org/tcc.html",
											target: "_blank",
											children: "Twin Cities Championship",
										}),
										h.jsx(nm.Item, {
											href: "https://www.usga.org/",
											target: "_blank",
											children: "USGA",
										}),
									],
								}),
							})
						case "tournaments":
							if (
								a.indexOf("detail") === 1 ||
								a.indexOf("contact") === 1 ||
								a.indexOf("gallery") === 1 ||
								a.indexOf("history") === 1
							) {
								const o = a[2]
								return h.jsxs(em, {
									children: [
										h.jsx(Un, {
											to: `/tournaments/history/${o}`,
											className: "nav-link",
											children: "History",
										}),
										h.jsx(Un, {
											to: `/tournaments/gallery/${o}/${lt.EventCalendarYear}`,
											className: "nav-link",
											children: "Gallery",
										}),
										h.jsx(Un, {
											to: `/tournaments/contact/${o}/${lt.EventCalendarYear}`,
											className: "nav-link",
											children: "Contact",
										}),
									],
								})
							} else return h.jsx(h.Fragment, {})
						case "match-play":
							return h.jsxs(em, {
								children: [
									h.jsx(Un, { to: "/match-play/rules", className: "nav-link", children: "Rules" }),
									h.jsx(Un, {
										to: "/match-play/results",
										className: "nav-link",
										children: "Schedule and Results",
									}),
								],
							})
						case "clubs":
							return h.jsx(h.Fragment, {})
						case "about":
							return h.jsxs(em, {
								children: [
									h.jsx(Un, {
										to: "/about/committee",
										className: "nav-link",
										children: "Executive Committee",
									}),
									h.jsx(Un, { to: "/about/awards", className: "nav-link", children: "Awards" }),
								],
							})
						default:
							return null
					}
				}
			return h.jsx(o1.Collapse, {
				id: "responsive-navbar-nav",
				className: "justify-content-end",
				children: h.jsxs(em, { id: "topnav", children: [r(), n()] }),
			})
		}
	var d7 = { color: void 0, size: void 0, className: void 0, style: void 0, attr: void 0 },
		ZP = H.createContext && H.createContext(d7),
		Cme = ["attr", "size", "title"]
	function Tme(e, t) {
		if (e == null) return {}
		var n = kme(e, t),
			r,
			i
		if (Object.getOwnPropertySymbols) {
			var a = Object.getOwnPropertySymbols(e)
			for (i = 0; i < a.length; i++)
				(r = a[i]),
					!(t.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(e, r) && (n[r] = e[r])
		}
		return n
	}
	function kme(e, t) {
		if (e == null) return {}
		var n = {}
		for (var r in e)
			if (Object.prototype.hasOwnProperty.call(e, r)) {
				if (t.indexOf(r) >= 0) continue
				n[r] = e[r]
			}
		return n
	}
	function eb() {
		return (
			(eb = Object.assign
				? Object.assign.bind()
				: function (e) {
						for (var t = 1; t < arguments.length; t++) {
							var n = arguments[t]
							for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r])
						}
						return e
				  }),
			eb.apply(this, arguments)
		)
	}
	function e3(e, t) {
		var n = Object.keys(e)
		if (Object.getOwnPropertySymbols) {
			var r = Object.getOwnPropertySymbols(e)
			t &&
				(r = r.filter(function (i) {
					return Object.getOwnPropertyDescriptor(e, i).enumerable
				})),
				n.push.apply(n, r)
		}
		return n
	}
	function tb(e) {
		for (var t = 1; t < arguments.length; t++) {
			var n = arguments[t] != null ? arguments[t] : {}
			t % 2
				? e3(Object(n), !0).forEach(function (r) {
						Sme(e, r, n[r])
				  })
				: Object.getOwnPropertyDescriptors
				? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n))
				: e3(Object(n)).forEach(function (r) {
						Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r))
				  })
		}
		return e
	}
	function Sme(e, t, n) {
		return (
			(t = Dme(t)),
			t in e
				? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 })
				: (e[t] = n),
			e
		)
	}
	function Dme(e) {
		var t = _me(e, "string")
		return typeof t == "symbol" ? t : t + ""
	}
	function _me(e, t) {
		if (typeof e != "object" || !e) return e
		var n = e[Symbol.toPrimitive]
		if (n !== void 0) {
			var r = n.call(e, t || "default")
			if (typeof r != "object") return r
			throw new TypeError("@@toPrimitive must return a primitive value.")
		}
		return (t === "string" ? String : Number)(e)
	}
	function f7(e) {
		return e && e.map((t, n) => H.createElement(t.tag, tb({ key: n }, t.attr), f7(t.child)))
	}
	function Vn(e) {
		return (t) => H.createElement(Ome, eb({ attr: tb({}, e.attr) }, t), f7(e.child))
	}
	function Ome(e) {
		var t = (n) => {
			var { attr: r, size: i, title: a } = e,
				o = Tme(e, Cme),
				s = i || n.size || "1em",
				l
			return (
				n.className && (l = n.className),
				e.className && (l = (l ? l + " " : "") + e.className),
				H.createElement(
					"svg",
					eb({ stroke: "currentColor", fill: "currentColor", strokeWidth: "0" }, n.attr, r, o, {
						className: l,
						style: tb(tb({ color: e.color || n.color }, n.style), e.style),
						height: s,
						width: s,
						xmlns: "http://www.w3.org/2000/svg",
					}),
					a && H.createElement("title", null, a),
					e.children,
				)
			)
		}
		return ZP !== void 0 ? H.createElement(ZP.Consumer, null, (n) => t(n)) : t(d7)
	}
	function Ame(e) {
		return Vn({
			tag: "svg",
			attr: { viewBox: "0 0 512 512" },
			child: [
				{
					tag: "path",
					attr: {
						d: "M512 144v288c0 26.5-21.5 48-48 48H48c-26.5 0-48-21.5-48-48V144c0-26.5 21.5-48 48-48h88l12.3-32.9c7-18.7 24.9-31.1 44.9-31.1h125.5c20 0 37.9 12.4 44.9 31.1L376 96h88c26.5 0 48 21.5 48 48zM376 288c0-66.2-53.8-120-120-120s-120 53.8-120 120 53.8 120 120 120 120-53.8 120-120zm-32 0c0 48.5-39.5 88-88 88s-88-39.5-88-88 39.5-88 88-88 88 39.5 88 88z",
					},
					child: [],
				},
			],
		})(e)
	}
	function Nme(e) {
		return Vn({
			tag: "svg",
			attr: { viewBox: "0 0 512 512" },
			child: [
				{
					tag: "path",
					attr: {
						d: "M502.3 190.8c3.9-3.1 9.7-.2 9.7 4.7V400c0 26.5-21.5 48-48 48H48c-26.5 0-48-21.5-48-48V195.6c0-5 5.7-7.8 9.7-4.7 22.4 17.4 52.1 39.5 154.1 113.6 21.1 15.4 56.7 47.8 92.2 47.6 35.7.3 72-32.8 92.3-47.6 102-74.1 131.6-96.3 154-113.7zM256 320c23.2.4 56.6-29.2 73.4-41.4 132.7-96.3 142.8-104.7 173.4-128.7 5.8-4.5 9.2-11.5 9.2-18.9v-19c0-26.5-21.5-48-48-48H48C21.5 64 0 85.5 0 112v19c0 7.4 3.4 14.3 9.2 18.9 30.6 23.9 40.7 32.4 173.4 128.7 16.8 12.2 50.2 41.8 73.4 41.4z",
					},
					child: [],
				},
			],
		})(e)
	}
	function Mme(e) {
		return Vn({
			tag: "svg",
			attr: { viewBox: "0 0 512 512" },
			child: [
				{
					tag: "path",
					attr: {
						d: "M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96 0-59.27-59.26-59.27-155.7 0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757 0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037 0 0 1-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482 0 0 1 20.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96 0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454 0 0 0 20.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037 0 0 0-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639 0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z",
					},
					child: [],
				},
			],
		})(e)
	}
	function Ime(e) {
		return Vn({
			tag: "svg",
			attr: { viewBox: "0 0 512 512" },
			child: [
				{
					tag: "path",
					attr: {
						d: "M497.9 142.1l-46.1 46.1c-4.7 4.7-12.3 4.7-17 0l-111-111c-4.7-4.7-4.7-12.3 0-17l46.1-46.1c18.7-18.7 49.1-18.7 67.9 0l60.1 60.1c18.8 18.7 18.8 49.1 0 67.9zM284.2 99.8L21.6 362.4.4 483.9c-2.9 16.4 11.4 30.6 27.8 27.8l121.5-21.3 262.6-262.6c4.7-4.7 4.7-12.3 0-17l-111-111c-4.8-4.7-12.4-4.7-17.1 0zM124.1 339.9c-5.5-5.5-5.5-14.3 0-19.8l154-154c5.5-5.5 14.3-5.5 19.8 0s5.5 14.3 0 19.8l-154 154c-5.5 5.5-14.3 5.5-19.8 0zM88 424h48v36.3l-64.5 11.3-31.1-31.1L51.7 376H88v48z",
					},
					child: [],
				},
			],
		})(e)
	}
	function Rme(e) {
		return Vn({
			tag: "svg",
			attr: { viewBox: "0 0 448 512" },
			child: [
				{
					tag: "path",
					attr: {
						d: "M433.941 129.941l-83.882-83.882A48 48 0 0 0 316.118 32H48C21.49 32 0 53.49 0 80v352c0 26.51 21.49 48 48 48h352c26.51 0 48-21.49 48-48V163.882a48 48 0 0 0-14.059-33.941zM224 416c-35.346 0-64-28.654-64-64 0-35.346 28.654-64 64-64s64 28.654 64 64c0 35.346-28.654 64-64 64zm96-304.52V212c0 6.627-5.373 12-12 12H76c-6.627 0-12-5.373-12-12V108c0-6.627 5.373-12 12-12h228.52c3.183 0 6.235 1.264 8.485 3.515l3.48 3.48A11.996 11.996 0 0 1 320 111.48z",
					},
					child: [],
				},
			],
		})(e)
	}
	function Lme(e) {
		return Vn({
			tag: "svg",
			attr: { viewBox: "0 0 576 512" },
			child: [
				{
					tag: "path",
					attr: {
						d: "M259.3 17.8L194 150.2 47.9 171.5c-26.2 3.8-36.7 36.1-17.7 54.6l105.7 103-25 145.5c-4.5 26.3 23.2 46 46.4 33.7L288 439.6l130.7 68.7c23.2 12.2 50.9-7.4 46.4-33.7l-25-145.5 105.7-103c19-18.5 8.5-50.8-17.7-54.6L382 150.2 316.7 17.8c-11.7-23.6-45.6-23.9-57.4 0z",
					},
					child: [],
				},
			],
		})(e)
	}
	function Pme(e) {
		return Vn({
			tag: "svg",
			attr: { viewBox: "0 0 512 512" },
			child: [
				{
					tag: "path",
					attr: {
						d: "M256 32C114.6 32 0 125.1 0 240c0 47.6 19.9 91.2 52.9 126.3C38 405.7 7 439.1 6.5 439.5c-6.6 7-8.4 17.2-4.6 26S14.4 480 24 480c61.5 0 110-25.7 139.1-46.3C192 442.8 223.2 448 256 448c141.4 0 256-93.1 256-208S397.4 32 256 32zm0 368c-26.7 0-53.1-4.1-78.4-12.1l-22.7-7.2-19.5 13.8c-14.3 10.1-33.9 21.4-57.5 29 7.3-12.1 14.4-25.7 19.9-40.2l10.6-28.1-20.6-21.8C69.7 314.1 48 282.2 48 240c0-88.2 93.3-160 208-160s208 71.8 208 160-93.3 160-208 160z",
					},
					child: [],
				},
			],
		})(e)
	}
	function p7(e) {
		return Vn({
			tag: "svg",
			attr: { viewBox: "0 0 384 512" },
			child: [
				{
					tag: "path",
					attr: {
						d: "M369.9 97.9L286 14C277 5 264.8-.1 252.1-.1H48C21.5 0 0 21.5 0 48v416c0 26.5 21.5 48 48 48h288c26.5 0 48-21.5 48-48V131.9c0-12.7-5.1-25-14.1-34zM332.1 128H256V51.9l76.1 76.1zM48 464V48h160v104c0 13.3 10.7 24 24 24h104v288H48zm212-240h-28.8c-4.4 0-8.4 2.4-10.5 6.3-18 33.1-22.2 42.4-28.6 57.7-13.9-29.1-6.9-17.3-28.6-57.7-2.1-3.9-6.2-6.3-10.6-6.3H124c-9.3 0-15 10-10.4 18l46.3 78-46.3 78c-4.7 8 1.1 18 10.4 18h28.9c4.4 0 8.4-2.4 10.5-6.3 21.7-40 23-45 28.6-57.7 14.9 30.2 5.9 15.9 28.6 57.7 2.1 3.9 6.2 6.3 10.6 6.3H260c9.3 0 15-10 10.4-18L224 320c.7-1.1 30.3-50.5 46.3-78 4.7-8-1.1-18-10.3-18z",
					},
					child: [],
				},
			],
		})(e)
	}
	function jme(e) {
		return Vn({
			tag: "svg",
			attr: { viewBox: "0 0 384 512" },
			child: [
				{
					tag: "path",
					attr: {
						d: "M369.9 97.9L286 14C277 5 264.8-.1 252.1-.1H48C21.5 0 0 21.5 0 48v416c0 26.5 21.5 48 48 48h288c26.5 0 48-21.5 48-48V131.9c0-12.7-5.1-25-14.1-34zM332.1 128H256V51.9l76.1 76.1zM48 464V48h160v104c0 13.3 10.7 24 24 24h104v288H48zm250.2-143.7c-12.2-12-47-8.7-64.4-6.5-17.2-10.5-28.7-25-36.8-46.3 3.9-16.1 10.1-40.6 5.4-56-4.2-26.2-37.8-23.6-42.6-5.9-4.4 16.1-.4 38.5 7 67.1-10 23.9-24.9 56-35.4 74.4-20 10.3-47 26.2-51 46.2-3.3 15.8 26 55.2 76.1-31.2 22.4-7.4 46.8-16.5 68.4-20.1 18.9 10.2 41 17 55.8 17 25.5 0 28-28.2 17.5-38.7zm-198.1 77.8c5.1-13.7 24.5-29.5 30.4-35-19 30.3-30.4 35.7-30.4 35zm81.6-190.6c7.4 0 6.7 32.1 1.8 40.8-4.4-13.9-4.3-40.8-1.8-40.8zm-24.4 136.6c9.7-16.9 18-37 24.7-54.7 8.3 15.1 18.9 27.2 30.1 35.5-20.8 4.3-38.9 13.1-54.8 19.2zm131.6-5s-5 6-37.3-7.8c35.1-2.6 40.9 5.4 37.3 7.8z",
					},
					child: [],
				},
			],
		})(e)
	}
	function h7(e) {
		return Vn({
			tag: "svg",
			attr: { viewBox: "0 0 384 512" },
			child: [
				{
					tag: "path",
					attr: {
						d: "M369.9 97.9L286 14C277 5 264.8-.1 252.1-.1H48C21.5 0 0 21.5 0 48v416c0 26.5 21.5 48 48 48h288c26.5 0 48-21.5 48-48V131.9c0-12.7-5.1-25-14.1-34zM332.1 128H256V51.9l76.1 76.1zM48 464V48h160v104c0 13.3 10.7 24 24 24h104v288H48zm220.1-208c-5.7 0-10.6 4-11.7 9.5-20.6 97.7-20.4 95.4-21 103.5-.2-1.2-.4-2.6-.7-4.3-.8-5.1.3.2-23.6-99.5-1.3-5.4-6.1-9.2-11.7-9.2h-13.3c-5.5 0-10.3 3.8-11.7 9.1-24.4 99-24 96.2-24.8 103.7-.1-1.1-.2-2.5-.5-4.2-.7-5.2-14.1-73.3-19.1-99-1.1-5.6-6-9.7-11.8-9.7h-16.8c-7.8 0-13.5 7.3-11.7 14.8 8 32.6 26.7 109.5 33.2 136 1.3 5.4 6.1 9.1 11.7 9.1h25.2c5.5 0 10.3-3.7 11.6-9.1l17.9-71.4c1.5-6.2 2.5-12 3-17.3l2.9 17.3c.1.4 12.6 50.5 17.9 71.4 1.3 5.3 6.1 9.1 11.6 9.1h24.7c5.5 0 10.3-3.7 11.6-9.1 20.8-81.9 30.2-119 34.5-136 1.9-7.6-3.8-14.9-11.6-14.9h-15.8z",
					},
					child: [],
				},
			],
		})(e)
	}
	function Fme(e) {
		return Vn({
			tag: "svg",
			attr: { viewBox: "0 0 384 512" },
			child: [
				{
					tag: "path",
					attr: {
						d: "M369.9 97.9L286 14C277 5 264.8-.1 252.1-.1H48C21.5 0 0 21.5 0 48v416c0 26.5 21.5 48 48 48h288c26.5 0 48-21.5 48-48V131.9c0-12.7-5.1-25-14.1-34zM332.1 128H256V51.9l76.1 76.1zM48 464V48h160v104c0 13.3 10.7 24 24 24h104v288H48z",
					},
					child: [],
				},
			],
		})(e)
	}
	function Bme(e) {
		return Vn({
			tag: "svg",
			attr: { viewBox: "0 0 24 24" },
			child: [
				{ tag: "path", attr: { fill: "none", d: "M0 0h24v24H0V0z" }, child: [] },
				{ tag: "circle", attr: { cx: "19.5", cy: "19.5", r: "1.5" }, child: [] },
				{
					tag: "path",
					attr: {
						d: "M17 5.92 9 2v18H7v-1.73c-1.79.35-3 .99-3 1.73 0 1.1 2.69 2 6 2s6-.9 6-2c0-.99-2.16-1.81-5-1.97V8.98l6-3.06z",
					},
					child: [],
				},
			],
		})(e)
	}
	function Hme(e) {
		return Vn({
			tag: "svg",
			attr: { viewBox: "0 0 24 24" },
			child: [
				{ tag: "path", attr: { fill: "none", d: "M0 0h24v24H0z" }, child: [] },
				{
					tag: "path",
					attr: {
						d: "M16.5 13c-1.2 0-3.07.34-4.5 1-1.43-.67-3.3-1-4.5-1C5.33 13 1 14.08 1 16.25V19h22v-2.75c0-2.17-4.33-3.25-6.5-3.25zm-4 4.5h-10v-1.25c0-.54 2.56-1.75 5-1.75s5 1.21 5 1.75v1.25zm9 0H14v-1.25c0-.46-.2-.86-.52-1.22.88-.3 1.96-.53 3.02-.53 2.44 0 5 1.21 5 1.75v1.25zM7.5 12c1.93 0 3.5-1.57 3.5-3.5S9.43 5 7.5 5 4 6.57 4 8.5 5.57 12 7.5 12zm0-5.5c1.1 0 2 .9 2 2s-.9 2-2 2-2-.9-2-2 .9-2 2-2zm9 5.5c1.93 0 3.5-1.57 3.5-3.5S18.43 5 16.5 5 13 6.57 13 8.5s1.57 3.5 3.5 3.5zm0-5.5c1.1 0 2 .9 2 2s-.9 2-2 2-2-.9-2-2 .9-2 2-2z",
					},
					child: [],
				},
			],
		})(e)
	}
	function mO(e) {
		return Vn({
			tag: "svg",
			attr: { version: "1.2", baseProfile: "tiny", viewBox: "0 0 24 24" },
			child: [
				{
					tag: "g",
					attr: {},
					child: [
						{
							tag: "path",
							attr: {
								d: "M17 21h-10c-1.654 0-3-1.346-3-3v-12c0-1.654 1.346-3 3-3h10c1.654 0 3 1.346 3 3v12c0 1.654-1.346 3-3 3zm-10-16c-.551 0-1 .449-1 1v12c0 .551.449 1 1 1h10c.551 0 1-.449 1-1v-12c0-.551-.449-1-1-1h-10zM16 11h-8c-.276 0-.5-.224-.5-.5s.224-.5.5-.5h8c.276 0 .5.224.5.5s-.224.5-.5.5zM16 8h-8c-.276 0-.5-.224-.5-.5s.224-.5.5-.5h8c.276 0 .5.224.5.5s-.224.5-.5.5zM16 14h-8c-.276 0-.5-.224-.5-.5s.224-.5.5-.5h8c.276 0 .5.224.5.5s-.224.5-.5.5zM16 17h-8c-.276 0-.5-.224-.5-.5s.224-.5.5-.5h8c.276 0 .5.224.5.5s-.224.5-.5.5z",
							},
							child: [],
						},
					],
				},
			],
		})(e)
	}
	function nb(e) {
		return Vn({
			tag: "svg",
			attr: { version: "1.2", baseProfile: "tiny", viewBox: "0 0 24 24" },
			child: [
				{
					tag: "path",
					attr: {
						d: "M21.561 5.318l-2.879-2.879c-.293-.293-.677-.439-1.061-.439-.385 0-.768.146-1.061.439l-3.56 3.561h-9c-.552 0-1 .447-1 1v13c0 .553.448 1 1 1h13c.552 0 1-.447 1-1v-9l3.561-3.561c.293-.293.439-.677.439-1.061s-.146-.767-.439-1.06zm-10.061 9.354l-2.172-2.172 6.293-6.293 2.172 2.172-6.293 6.293zm-2.561-1.339l1.756 1.728-1.695-.061-.061-1.667zm7.061 5.667h-11v-11h6l-3.18 3.18c-.293.293-.478.812-.629 1.289-.16.5-.191 1.056-.191 1.47v3.061h3.061c.414 0 1.108-.1 1.571-.29.464-.19.896-.347 1.188-.64l3.18-3.07v6zm2.5-11.328l-2.172-2.172 1.293-1.293 2.171 2.172-1.292 1.293z",
					},
					child: [],
				},
			],
		})(e)
	}
	function $me(e) {
		return Vn({
			tag: "svg",
			attr: { version: "1.2", baseProfile: "tiny", viewBox: "0 0 24 24" },
			child: [
				{
					tag: "path",
					attr: {
						d: "M12 14c2.764 0 5-2.238 5-5s-2.236-5-5-5-5 2.238-5 5 2.236 5 5 5zm0-8c1.654 0 3 1.346 3 3s-1.346 3-3 3-3-1.346-3-3 1.346-3 3-3zM20 15c1.381 0 2.5-1.117 2.5-2.5 0-1.381-1.119-2.5-2.5-2.5-1.382 0-2.5 1.119-2.5 2.5 0 1.383 1.118 2.5 2.5 2.5zm0-4c.827 0 1.5.673 1.5 1.5s-.673 1.5-1.5 1.5-1.5-.673-1.5-1.5.673-1.5 1.5-1.5zM20 15.59c-1.331 0-2.332.406-2.917.969-1.115-.918-2.878-1.559-5.083-1.559-2.266 0-3.995.648-5.092 1.564-.596-.565-1.608-.975-2.908-.975-2.188 0-3.5 1.091-3.5 2.183 0 .545 1.312 1.092 3.5 1.092.604 0 1.146-.051 1.623-.133l-.04.27c0 1 2.405 2 6.417 2 3.762 0 6.417-1 6.417-2l-.021-.255c.463.073.996.118 1.604.118 2.051 0 3.5-.547 3.5-1.092 0-1.092-1.373-2.182-3.5-2.182zm-16 2.273c-1.309 0-2.068-.207-2.417-.354.239-.405 1.003-.92 2.417-.92 1.107 0 1.837.351 2.208.706l-.235.344c-.452.119-1.108.224-1.973.224zm8 1.137c-2.163 0-3.501-.312-4.184-.561.521-.678 1.918-1.439 4.184-1.439 2.169 0 3.59.761 4.148 1.425-.755.27-2.162.575-4.148.575zm8-1.137c-.914 0-1.546-.103-1.973-.213-.072-.127-.155-.252-.248-.375.356-.345 1.071-.685 2.221-.685 1.324 0 2.141.501 2.404.911-.39.163-1.205.362-2.404.362zM4 15c1.381 0 2.5-1.119 2.5-2.5 0-1.379-1.119-2.5-2.5-2.5-1.382 0-2.5 1.121-2.5 2.5 0 1.381 1.118 2.5 2.5 2.5zm0-4c.827 0 1.5.673 1.5 1.5s-.673 1.5-1.5 1.5-1.5-.673-1.5-1.5.673-1.5 1.5-1.5z",
					},
					child: [],
				},
			],
		})(e)
	}
	function Ume(e) {
		return Vn({
			tag: "svg",
			attr: { version: "1.2", baseProfile: "tiny", viewBox: "0 0 24 24" },
			child: [
				{
					tag: "path",
					attr: {
						d: "M14.234 16.014l.554-1.104c.808-1.61.897-3.228.253-4.552-.122-.252-.277-.479-.443-.693 1.411-.619 2.402-2.026 2.402-3.664 0-2.206-1.794-4-4-4s-4 1.794-4 4c0 .783.234 1.508.624 2.126-1.696.33-2.806 1.248-2.947 1.375-.716.631-.885 1.68-.405 2.504.324.559.886.909 1.494.98l-.554 1.104c-.808 1.61-.897 3.228-.254 4.552.565 1.164 1.621 1.955 2.972 2.229.413.084.836.127 1.254.127 2.368 0 3.965-1.347 4.14-1.501.716-.63.887-1.678.407-2.503-.325-.556-.887-.909-1.497-.98zm-1.234-12.013c1.104 0 2 .896 2 2s-.896 2-2 2c-1.105 0-2-.896-2-2s.895-2 2-2zm-1.816 14.999c-.271 0-.559-.025-.854-.087-1.642-.334-2.328-1.933-1.328-3.927l1-1.995c.5-.996.47-1.63-.108-2.035-.181-.125-.431-.169-.689-.169-.577 0-1.201.214-1.201.214s1.133-1.001 2.812-1.001c.271 0 .56.025.856.087 1.64.334 2.328 1.933 1.328 3.927l-1 1.993c-.5.998-.472 1.632.106 2.035.181.126.433.169.692.169.577 0 1.2-.212 1.2-.212s-1.133 1.001-2.814 1.001z",
					},
					child: [],
				},
			],
		})(e)
	}
	function zme(e) {
		return Vn({
			tag: "svg",
			attr: { version: "1.2", baseProfile: "tiny", viewBox: "0 0 24 24" },
			child: [
				{
					tag: "path",
					attr: {
						d: "M10 21h-6v-4.414l3.783-3.783c-.187-.587-.283-1.192-.283-1.803 0-3.309 2.691-6 6-6s6 2.691 6 6-2.691 6-6 6h-1.5v2h-2v2zm-4-2h2v-2h2v-2h3.5c2.206 0 4-1.794 4-4s-1.794-4-4-4-4 1.794-4 4c0 .559.121 1.109.359 1.639l.285.631-4.144 4.144v1.586zM13.5 9.998c.551 0 1 .449 1 1.002 0 .552-.449 1-1 1s-1-.448-1-1c0-.553.449-1.002 1-1.002m0-1c-1.104 0-2 .896-2 2.002 0 1.104.896 2 2 2 1.105 0 2-.896 2-2 0-1.105-.895-2.002-2-2.002z",
					},
					child: [],
				},
			],
		})(e)
	}
	function qme(e) {
		return Vn({
			tag: "svg",
			attr: { version: "1.2", baseProfile: "tiny", viewBox: "0 0 24 24" },
			child: [
				{
					tag: "path",
					attr: {
						d: "M21 4h-18c-1.104 0-2 .896-2 2v12c0 1.104.896 2 2 2h18c1.104 0 2-.896 2-2v-12c0-1.104-.896-2-2-2zm-18 2h8v12h-8v-12zm18 12h-9v-12h9.003l-.003 12zM20 13.5c0-.275-.225-.5-.5-.5h-1c-.275 0-.5.225-.5.5v3c0 .275.225.5.5.5h1c.275 0 .5-.225.5-.5v-3zM17 7.5c0-.275-.225-.5-.5-.5h-3c-.275 0-.5.225-.5.5v5c0 .275.225.5.5.5h3c.275 0 .5-.225.5-.5v-5zM18.5 10h1c.275 0 .5-.225.5-.5s-.225-.5-.5-.5h-1c-.275 0-.5.225-.5.5s.225.5.5.5zM18.5 12h1c.275 0 .5-.225.5-.5s-.225-.5-.5-.5h-1c-.275 0-.5.225-.5.5s.225.5.5.5zM13.5 15h3c.275 0 .5-.225.5-.5s-.225-.5-.5-.5h-3c-.275 0-.5.225-.5.5s.225.5.5.5zM16.5 16h-3c-.275 0-.5.225-.5.5s.225.5.5.5h3c.275 0 .5-.225.5-.5s-.225-.5-.5-.5zM18.5 8h1c.275 0 .5-.225.5-.5s-.225-.5-.5-.5h-1c-.275 0-.5.225-.5.5s.225.5.5.5zM10 7.5c0-.275-.225-.5-.5-.5h-5c-.275 0-.5.225-.5.5v3c0 .275.225.5.5.5h5c.275 0 .5-.225.5-.5v-3zM9.501 14h-5c-.274 0-.5.225-.5.5s.226.5.5.5h5c.274 0 .499-.225.499-.5s-.225-.5-.499-.5zM9.501 12h-5c-.274 0-.5.225-.5.5s.226.5.5.5h5c.274 0 .499-.225.499-.5s-.225-.5-.499-.5zM9.501 16h-5c-.274 0-.5.225-.5.5s.226.5.5.5h5c.274 0 .499-.225.499-.5s-.225-.5-.499-.5z",
					},
					child: [],
				},
			],
		})(e)
	}
	function Vme(e) {
		return Vn({
			tag: "svg",
			attr: { version: "1.2", baseProfile: "tiny", viewBox: "0 0 24 24" },
			child: [
				{
					tag: "path",
					attr: {
						d: "M17.51 6.062c-.814-.815-1.98-1.05-3.01-.729v-.333c0-1.656-1.344-3-3-3s-3 1.344-3 3v.332c-1.029-.319-2.195-.085-3.01.73-1.605 1.606-2.49 3.741-2.49 6.011s.885 4.405 2.49 6.011c1.604 1.605 3.739 2.489 6.01 2.489s4.405-.884 6.01-2.489c1.605-1.605 2.49-3.74 2.49-6.011s-.885-4.405-2.49-6.011zm-7.01-1.062c0-.552.447-1 1-1s1 .448 1 1v5c0 .552-.447 1-1 1s-1-.448-1-1v-5zm-1 3.803v1.197c0 1.104.896 2 2 2s2-.896 2-2v-1.182c.095.284.248.554.475.78.661.661 1.025 1.54 1.025 2.475s-.364 1.814-1.025 2.476c-1.322 1.321-3.627 1.321-4.949 0-.662-.662-1.026-1.541-1.026-2.476s.364-1.814 1.025-2.476c.231-.23.383-.504.475-.794zm6.596 7.867c-1.228 1.228-2.859 1.903-4.596 1.903s-3.368-.676-4.596-1.903c-1.227-1.228-1.904-2.86-1.904-4.597s.677-3.369 1.904-4.597c.391-.391 1.023-.391 1.414 0s.391 1.023 0 1.414c-.85.851-1.318 1.981-1.318 3.183s.468 2.333 1.318 3.183c.85.85 1.979 1.317 3.182 1.317s2.332-.468 3.182-1.317c.851-.85 1.318-1.98 1.318-3.183s-.468-2.333-1.318-3.183c-.391-.391-.391-1.023 0-1.414s1.023-.391 1.414 0c1.227 1.229 1.904 2.861 1.904 4.597s-.677 3.369-1.904 4.597z",
					},
					child: [],
				},
			],
		})(e)
	}
	function m7(e) {
		return Vn({
			tag: "svg",
			attr: { version: "1.2", baseProfile: "tiny", viewBox: "0 0 24 24" },
			child: [
				{
					tag: "path",
					attr: {
						d: "M17.414 6.586c-.78-.781-2.048-.781-2.828 0l-2.586 2.586-2.586-2.586c-.78-.781-2.048-.781-2.828 0-.781.781-.781 2.047 0 2.828l2.585 2.586-2.585 2.586c-.781.781-.781 2.047 0 2.828.39.391.902.586 1.414.586s1.024-.195 1.414-.586l2.586-2.586 2.586 2.586c.39.391.902.586 1.414.586s1.024-.195 1.414-.586c.781-.781.781-2.047 0-2.828l-2.585-2.586 2.585-2.586c.781-.781.781-2.047 0-2.828z",
					},
					child: [],
				},
			],
		})(e)
	}
	const Wt = () => {
		const e = Nr((A) => A.app),
			t = Nr((A) => A.layout),
			{ user: n } = ks(),
			r = () => n.isClubContact && !n.isCommittee && !n.isAdmin
		return {
			canPostMatchResult: () => n.isAuthenticated,
			canToggleEditMode: () =>
				r()
					? t.subMenu === "clubs" && t.segments.length === 2 && t.segments[1] === n.clubId
					: n.isCommittee || n.isHistorian || n.isAdmin,
			canEditAnnouncements: () => e.editMode && (n.isOfficer || n.isAdmin),
			canEditClubPage: () =>
				e.editMode && r()
					? t.subMenu === "clubs" && t.segments.length === 2 && t.segments[1] === n.clubId
					: e.editMode && (n.isClubContact || n.isOfficer || n.isAdmin),
			canAddCommittee: () => e.editMode && (n.isOfficer || n.isAdmin),
			canEditCommittee: () => e.editMode && (n.isCommittee || n.isAdmin),
			canViewWiki: () => !1,
			canViewDocumentLibrary: () => n.isCommittee || n.isAdmin,
			canEditDocuments: () => e.editMode && (n.isCommittee || n.isAdmin),
			canViewReports: () => n.isCommittee || n.isAdmin,
			canManageEvent: () => e.editMode && (n.isCommittee || n.isAdmin),
			canEditPolicies: () => e.editMode && (n.isOfficer || n.isAdmin),
			canEditPageContent: () => e.editMode && (n.isOfficer || n.isAdmin),
			canEditTournamentHistory: () => e.editMode && (n.isCommittee || n.isHistorian || n.isAdmin),
			canEditAwards: () => e.editMode && (n.isCommittee || n.isHistorian || n.isAdmin),
			canEditPhotos: () =>
				e.editMode && (n.isCommittee || n.isClubContact || n.isHistorian || n.isAdmin),
			canUploadPhotos: () => e.editMode && (n.isCommittee || n.isHistorian || n.isAdmin),
			canEnterPayment: () => e.editMode && (n.isOfficer || n.isAdmin),
		}
	}
	function vO() {
		const e = _.useContext(r_)
		if (e === void 0) throw new Error("useLayout must be used within a LayoutProvider")
		return e
	}
	const Wme = () => {
			const { sidebarOpen: e, closeSidebar: t } = vO(),
				n = Xa(),
				r = Wt(),
				i = Ea(),
				a = ki(),
				{ user: o } = ks(),
				s = Nr((v) => v.app),
				l = 20,
				u = () => {
					n("/"), t()
				},
				d = () => {
					a(dB(i.pathname)), n("/account/login"), t()
				},
				p = () => {
					a(nte()), t()
				},
				m = () => {
					a(hte()), u()
				}
			return h.jsxs("div", {
				id: "sidebar",
				className: e ? "" : " active",
				children: [
					h.jsx("div", { className: "sidebar-header", onClick: u }),
					h.jsxs("div", {
						className: "flex-column nav",
						children: [
							h.jsxs(Un, {
								to: "/tournaments",
								onClick: t,
								className: "nav-link",
								children: [h.jsx(Bme, { size: l, color: "secondary" }), " Tournaments"],
							}),
							h.jsxs(Un, {
								to: "/match-play",
								onClick: t,
								className: "nav-link",
								children: [h.jsx(Hme, { size: l, color: "secondary" }), " Team Match Play"],
							}),
							h.jsxs(Un, {
								to: "/clubs",
								onClick: t,
								className: "nav-link",
								children: [h.jsx($me, { size: l, color: "secondary" }), " Member Clubs"],
							}),
							h.jsxs(Un, {
								to: "/about",
								onClick: t,
								className: "nav-link",
								children: [h.jsx(Ume, { size: l, color: "secondary" }), " About Us"],
							}),
							h.jsxs(Un, {
								to: "/contact",
								onClick: t,
								className: "nav-link",
								children: [h.jsx(Pme, { size: l, color: "secondary" }), " Contact Us"],
							}),
							r.canViewDocumentLibrary() &&
								h.jsxs(Un, {
									to: "/admin/library",
									onClick: t,
									className: "nav-link",
									children: [h.jsx(h7, { size: l, color: "secondary" }), " Document Library"],
								}),
							r.canViewReports() &&
								h.jsxs(Un, {
									to: "/admin/reports/current-clubs",
									onClick: t,
									className: "nav-link",
									children: [h.jsx(p7, { size: l, color: "secondary" }), " Reports"],
								}),
							r.canViewWiki() &&
								h.jsxs(Un, {
									to: "/admin/wiki",
									onClick: t,
									className: "nav-link",
									children: [h.jsx(qme, { size: l, color: "secondary" }), " Wiki"],
								}),
							!o.isAuthenticated &&
								h.jsxs(Pf, {
									onClick: () => d(),
									className: "text-secondary nav-link clickable",
									children: [h.jsx(zme, { size: l, color: "secondary" }), "Login"],
								}),
							r.canToggleEditMode() &&
								!s.editMode &&
								h.jsxs(Pf, {
									onClick: () => p(),
									className: "text-warning nav-link clickable",
									children: [h.jsx(nb, { size: l, color: "warning" }), " Turn on Edit Mode"],
								}),
							r.canToggleEditMode() &&
								s.editMode &&
								h.jsxs(Pf, {
									onClick: () => p(),
									className: "text-warning nav-link clickable",
									children: [h.jsx(nb, { size: l, color: "warning" }), " Turn off Edit Mode"],
								}),
							o.isAuthenticated &&
								h.jsxs(Pf, {
									onClick: () => m(),
									className: "text-muted nav-link clickable",
									children: [h.jsx(Vme, { size: l, color: "muted" }), " Logout"],
								}),
						],
					}),
				],
			})
		},
		Yme = () => {
			const { sidebarOpen: e, toggleSidebar: t } = vO()
			return h.jsxs(Ge, {
				variant: "secondary",
				id: "sidebarCollapse",
				className: e ? "" : " active",
				onClick: () => t(),
				children: [h.jsx("span", {}), h.jsx("span", {}), h.jsx("span", {})],
			})
		}
	function Gme() {
		const { sidebarOpen: e, closeSidebar: t } = vO(),
			n = zD(),
			r = Ea(),
			i = Up((a) => a.layout)
		return (
			_.useEffect(() => {
				n(ate(r.pathname))
			}, [n, r.pathname]),
			h.jsxs("div", {
				className: "wrapper",
				children: [
					h.jsx(Wme, {}),
					h.jsxs("div", {
						id: "content",
						className: e ? "" : " active",
						children: [
							h.jsxs(o1, {
								collapseOnSelect: !0,
								expand: "lg",
								bg: "secondary",
								variant: "light",
								sticky: "top",
								children: [
									h.jsx(Yme, {}),
									h.jsx(o1.Brand, { className: "ml-2 mpga", href: "/home", children: "MPGA" }),
									h.jsx(o1.Toggle, { "aria-controls": "responsive-navbar-nav" }),
									i.subMenu && h.jsx(Eme, { subMenu: i.subMenu, segments: i.segments }),
								],
							}),
							h.jsxs("div", {
								id: "page",
								onClick: t,
								children: [
									h.jsx(Upe, { autoClose: 3e3, hideProgressBar: !0, newestOnTop: !0 }),
									h.jsx(zpe, { children: h.jsx(A8, {}) }),
								],
							}),
						],
					}),
				],
			})
		)
	}
	const ii = _.forwardRef(
		({ bsPrefix: e, fluid: t = !1, as: n = "div", className: r, ...i }, a) => {
			const o = nt(e, "container"),
				s = typeof t == "string" ? `-${t}` : "-fluid"
			return h.jsx(n, { ref: a, ...i, className: Fe(r, t ? `${o}${s}` : o) })
		},
	)
	ii.displayName = "Container"
	const ug = (e) =>
		h.jsx(ln, {
			children: h.jsx(it, { md: 12, lg: { span: 10, offset: 1 }, children: e.children }),
		})
	function Kme(e) {
		return Vn({
			tag: "svg",
			attr: { version: "1.1", viewBox: "0 0 16 16" },
			child: [
				{
					tag: "path",
					attr: {
						d: "M6 2c0-1.105 0.895-2 2-2s2 0.895 2 2c0 1.105-0.895 2-2 2s-2-0.895-2-2zM10.243 3.757c0-1.105 0.895-2 2-2s2 0.895 2 2c0 1.105-0.895 2-2 2s-2-0.895-2-2zM13 8c0-0.552 0.448-1 1-1s1 0.448 1 1c0 0.552-0.448 1-1 1s-1-0.448-1-1zM11.243 12.243c0-0.552 0.448-1 1-1s1 0.448 1 1c0 0.552-0.448 1-1 1s-1-0.448-1-1zM7 14c0 0 0 0 0 0 0-0.552 0.448-1 1-1s1 0.448 1 1c0 0 0 0 0 0 0 0.552-0.448 1-1 1s-1-0.448-1-1zM2.757 12.243c0 0 0 0 0 0 0-0.552 0.448-1 1-1s1 0.448 1 1c0 0 0 0 0 0 0 0.552-0.448 1-1 1s-1-0.448-1-1zM2.257 3.757c0 0 0 0 0 0 0-0.828 0.672-1.5 1.5-1.5s1.5 0.672 1.5 1.5c0 0 0 0 0 0 0 0.828-0.672 1.5-1.5 1.5s-1.5-0.672-1.5-1.5zM0.875 8c0-0.621 0.504-1.125 1.125-1.125s1.125 0.504 1.125 1.125c0 0.621-0.504 1.125-1.125 1.125s-1.125-0.504-1.125-1.125z",
					},
					child: [],
				},
			],
		})(e)
	}
	const Qme = /[^#a-f\d]/gi
	function Xme(e) {
		if (!e || !(e.length === 4 || e.length === 7) || e[0] !== "#" || Qme.test(e))
			throw new Error("Expected a valid hex string")
		;(e = e.substring(1)), e.length === 3 && (e = e[0] + e[0] + e[1] + e[1] + e[2] + e[2])
		const t = parseInt(e, 16),
			n = t >> 16,
			r = (t >> 8) & 255,
			i = t & 255
		return { red: n, green: r, blue: i }
	}
	function Jme(e, t) {
		try {
			const n = Xme(e)
			return `rgba(${n.red}, ${n.green}, ${n.blue}, ${t})`
		} catch {
			throw new Error(
				`Invalid color '${e}'. Color should be a valid hexadecimal value, for example '#FFFFFF'`,
			)
		}
	}
	const Zme = Ft.div`
  position: absolute;
  margin: auto;
  width: 3rem;
  height: 3rem;
  font-size: 3rem;
  top: 0;
  left: 0;
  bottom: 0;
  right: 0;
  color: #6f42c1;
  z-index: 10;
`,
		eve = Ft.div`
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-color: ${Jme("#ffffff", 0.5)};
`,
		tve = $oe`
  from { transform: rotate(0deg); }
  to { transform: rotate(360deg); }
`,
		v7 = Ft(Kme)`
  animation: ${tve} 1s linear infinite;
`
	v7.defaultProps = { "aria-label": "loading" }
	function cg(e) {
		const { loading: t } = e
		return t ? h.jsx(eve, { children: h.jsx(Zme, { children: h.jsx(v7, {}) }) }) : null
	}
	const ht = (e) =>
			e.hide === !0
				? null
				: h.jsxs("div", {
						style: { position: "relative" },
						children: [h.jsx(cg, { loading: e.loading }), e.children],
				  }),
		g7 = Ft.div`
  float: right;
  width: 24px;
  height: 24px;
  text-align: right;
  margin: 0;
  cursor: pointer;
`
	g7.displayName = "EditButton"
	const y7 = (e) => {
			const { openIcon: t, isEditting: n, onToggled: r } = e,
				i = t || h.jsx(nb, { size: 20, color: "warning" }),
				a = () => {
					r()
				}
			return h.jsx(g7, {
				title: n ? "Close" : "Edit",
				className: n ? "text-secondary" : "text-warning",
				style: { position: "relative", zIndex: 1 },
				onClick: a,
				children: !n && i,
			})
		},
		gO = Ft("div")`
  border-width: ${(e) => (e.doEdit ? "1px" : "0")};
  border-color: silver;
  border-style: solid;
  padding: ${(e) => (e.doEdit ? "10px" : "0")};
  margin-bottom: 10px;
  & .tui-editor-contents {
    font-size: 1rem;
    font-weight: 400;
    line-height: 1.5;
    color: #212529;
  }
  & img {
    max-width: 95%;
    object-fit: contain;
  }
  & table {
    margin-bottom: 1rem;
    color: #212529;
    border-collapse: collapse;
  }
  & thead th {
    background-color: #9a72d4;
    font-weight: 500;
    color: #fff;
    vertical-align: bottom;
    border-bottom: 2px solid #6f42c1;
    border-top: 1px solid #9a72d4;
    padding: 0.3rem;
  }
  & tbody td {
    padding: 0.3rem;
    border-top: 1px solid #dee2e6;
  }
  & tbody tr:nth-of-type(2n + 1) {
    background-color: rgba(0, 0, 0, 0.05);
  }
  & blockquote {
    margin: 14px 0;
    border-left: 4px solid #e5e5e5;
    padding: 0 16px;
    min-height: 20px;
    color: #999;
  }
`
	gO.displayName = "EditOrView"
	const b7 = (e) => {
			const {
					viewComponent: t,
					editComponent: n,
					doEdit: r,
					canEdit: i,
					hideEdit: a,
					onToggleEdit: o,
				} = e,
				s = () => {
					o()
				}
			return h.jsxs(gO, {
				doEdit: r,
				children: [
					i && a !== !0 && h.jsx(y7, { isEditting: r, openIcon: e.openIcon, onToggled: s }),
					r ? n : t,
				],
			})
		},
		nve = (e, t) => {
			const { canEdit: n, initEdit: r, viewComponent: i, editComponent: a, onClose: o } = e,
				[s, l] = _.useState(r)
			_.useImperativeHandle(t, () => ({ close: () => l(!1) }))
			const u = () => {
				s && o && o(), l(!s)
			}
			return h.jsx(b7, {
				doEdit: s,
				canEdit: n,
				onToggleEdit: u,
				viewComponent: i,
				editComponent: a,
			})
		},
		Wr = H.forwardRef(nve)
	class rve extends _n {
		constructor(n) {
			super()
			q(this, "pageType", "")
			q(this, "title", "")
			q(this, "content", "")
			const r = this.fromJson(n)
			Object.assign(this, r)
		}
	}
	class g2 extends _n {
		constructor(n) {
			super()
			q(this, "policyType", "")
			q(this, "name", "")
			q(this, "title", "")
			q(this, "description", "")
			const r = this.fromJson(n)
			Object.assign(this, r)
		}
	}
	const ive = Ui.injectEndpoints({
			endpoints: (e) => ({
				getPolicies: e.query({
					query: (t) => ({ url: "/policies/?type=" + t, method: "GET" }),
					providesTags: (t) => {
						const { policy_type: n } = t[0]
						return t
							? [
									...t.map(({ id: r }) => ({ type: "Policies", id: r })),
									{ type: "Policies", policy_type: n },
							  ]
							: [{ type: "Policies", policy_type: n }]
					},
				}),
				updatePolicy: e.mutation({
					query(t) {
						const { id: n } = t
						return { url: `/policies/${n}/`, method: "PUT", data: t }
					},
					invalidatesTags: (t, n, { id: r }) => [{ type: "Policies", id: r }],
				}),
				addPolicy: e.mutation({
					query(t) {
						return { url: "/policies/", method: "POST", data: t }
					},
					invalidatesTags: (t, n, { id: r }) => [{ type: "Policies", id: r }],
				}),
				deletePolicy: e.mutation({
					query(t) {
						const { id: n } = t
						return { url: `/policies/${n}/`, method: "DELETE" }
					},
				}),
				getPageContent: e.query({
					query: () => ({ url: "/pages/", method: "GET" }),
					providesTags: (t) =>
						t
							? [...t.map(({ id: n }) => ({ type: "Pages", id: n })), { type: "Pages", id: "LIST" }]
							: [{ type: "Pages", id: "LIST" }],
				}),
				updatePageContent: e.mutation({
					query(t) {
						const { id: n } = t
						return { url: `/pages/${n}/`, method: "PUT", data: t }
					},
					invalidatesTags: (t, n, { id: r }) => [{ type: "Pages", id: r }],
				}),
			}),
		}),
		{
			useAddPolicyMutation: ave,
			useDeletePolicyMutation: ove,
			useGetPageContentQuery: sve,
			useGetPoliciesQuery: lve,
			useUpdatePageContentMutation: uve,
			useUpdatePolicyMutation: cve,
		} = ive
	function jr(e) {
		this.content = e
	}
	jr.prototype = {
		constructor: jr,
		find: function (e) {
			for (var t = 0; t < this.content.length; t += 2) if (this.content[t] === e) return t
			return -1
		},
		get: function (e) {
			var t = this.find(e)
			return t == -1 ? void 0 : this.content[t + 1]
		},
		update: function (e, t, n) {
			var r = n && n != e ? this.remove(n) : this,
				i = r.find(e),
				a = r.content.slice()
			return i == -1 ? a.push(n || e, t) : ((a[i + 1] = t), n && (a[i] = n)), new jr(a)
		},
		remove: function (e) {
			var t = this.find(e)
			if (t == -1) return this
			var n = this.content.slice()
			return n.splice(t, 2), new jr(n)
		},
		addToStart: function (e, t) {
			return new jr([e, t].concat(this.remove(e).content))
		},
		addToEnd: function (e, t) {
			var n = this.remove(e).content.slice()
			return n.push(e, t), new jr(n)
		},
		addBefore: function (e, t, n) {
			var r = this.remove(t),
				i = r.content.slice(),
				a = r.find(e)
			return i.splice(a == -1 ? i.length : a, 0, t, n), new jr(i)
		},
		forEach: function (e) {
			for (var t = 0; t < this.content.length; t += 2) e(this.content[t], this.content[t + 1])
		},
		prepend: function (e) {
			return (e = jr.from(e)), e.size ? new jr(e.content.concat(this.subtract(e).content)) : this
		},
		append: function (e) {
			return (e = jr.from(e)), e.size ? new jr(this.subtract(e).content.concat(e.content)) : this
		},
		subtract: function (e) {
			var t = this
			e = jr.from(e)
			for (var n = 0; n < e.content.length; n += 2) t = t.remove(e.content[n])
			return t
		},
		get size() {
			return this.content.length >> 1
		},
	}
	jr.from = function (e) {
		if (e instanceof jr) return e
		var t = []
		if (e) for (var n in e) t.push(n, e[n])
		return new jr(t)
	}
	function x7(e, t, n) {
		for (let r = 0; ; r++) {
			if (r == e.childCount || r == t.childCount) return e.childCount == t.childCount ? null : n
			let i = e.child(r),
				a = t.child(r)
			if (i == a) {
				n += i.nodeSize
				continue
			}
			if (!i.sameMarkup(a)) return n
			if (i.isText && i.text != a.text) {
				for (let o = 0; i.text[o] == a.text[o]; o++) n++
				return n
			}
			if (i.content.size || a.content.size) {
				let o = x7(i.content, a.content, n + 1)
				if (o != null) return o
			}
			n += i.nodeSize
		}
	}
	function w7(e, t, n, r) {
		for (let i = e.childCount, a = t.childCount; ; ) {
			if (i == 0 || a == 0) return i == a ? null : { a: n, b: r }
			let o = e.child(--i),
				s = t.child(--a),
				l = o.nodeSize
			if (o == s) {
				;(n -= l), (r -= l)
				continue
			}
			if (!o.sameMarkup(s)) return { a: n, b: r }
			if (o.isText && o.text != s.text) {
				let u = 0,
					d = Math.min(o.text.length, s.text.length)
				for (; u < d && o.text[o.text.length - u - 1] == s.text[s.text.length - u - 1]; )
					u++, n--, r--
				return { a: n, b: r }
			}
			if (o.content.size || s.content.size) {
				let u = w7(o.content, s.content, n - 1, r - 1)
				if (u) return u
			}
			;(n -= l), (r -= l)
		}
	}
	class ke {
		constructor(t, n) {
			if (((this.content = t), (this.size = n || 0), n == null))
				for (let r = 0; r < t.length; r++) this.size += t[r].nodeSize
		}
		nodesBetween(t, n, r, i = 0, a) {
			for (let o = 0, s = 0; s < n; o++) {
				let l = this.content[o],
					u = s + l.nodeSize
				if (u > t && r(l, i + s, a || null, o) !== !1 && l.content.size) {
					let d = s + 1
					l.nodesBetween(Math.max(0, t - d), Math.min(l.content.size, n - d), r, i + d)
				}
				s = u
			}
		}
		descendants(t) {
			this.nodesBetween(0, this.size, t)
		}
		textBetween(t, n, r, i) {
			let a = "",
				o = !0
			return (
				this.nodesBetween(
					t,
					n,
					(s, l) => {
						s.isText
							? ((a += s.text.slice(Math.max(t, l) - l, n - l)), (o = !r))
							: s.isLeaf
							? (i
									? (a += typeof i == "function" ? i(s) : i)
									: s.type.spec.leafText && (a += s.type.spec.leafText(s)),
							  (o = !r))
							: !o && s.isBlock && ((a += r), (o = !0))
					},
					0,
				),
				a
			)
		}
		append(t) {
			if (!t.size) return this
			if (!this.size) return t
			let n = this.lastChild,
				r = t.firstChild,
				i = this.content.slice(),
				a = 0
			for (
				n.isText && n.sameMarkup(r) && ((i[i.length - 1] = n.withText(n.text + r.text)), (a = 1));
				a < t.content.length;
				a++
			)
				i.push(t.content[a])
			return new ke(i, this.size + t.size)
		}
		cut(t, n = this.size) {
			if (t == 0 && n == this.size) return this
			let r = [],
				i = 0
			if (n > t)
				for (let a = 0, o = 0; o < n; a++) {
					let s = this.content[a],
						l = o + s.nodeSize
					l > t &&
						((o < t || l > n) &&
							(s.isText
								? (s = s.cut(Math.max(0, t - o), Math.min(s.text.length, n - o)))
								: (s = s.cut(Math.max(0, t - o - 1), Math.min(s.content.size, n - o - 1)))),
						r.push(s),
						(i += s.nodeSize)),
						(o = l)
				}
			return new ke(r, i)
		}
		cutByIndex(t, n) {
			return t == n
				? ke.empty
				: t == 0 && n == this.content.length
				? this
				: new ke(this.content.slice(t, n))
		}
		replaceChild(t, n) {
			let r = this.content[t]
			if (r == n) return this
			let i = this.content.slice(),
				a = this.size + n.nodeSize - r.nodeSize
			return (i[t] = n), new ke(i, a)
		}
		addToStart(t) {
			return new ke([t].concat(this.content), this.size + t.nodeSize)
		}
		addToEnd(t) {
			return new ke(this.content.concat(t), this.size + t.nodeSize)
		}
		eq(t) {
			if (this.content.length != t.content.length) return !1
			for (let n = 0; n < this.content.length; n++) if (!this.content[n].eq(t.content[n])) return !1
			return !0
		}
		get firstChild() {
			return this.content.length ? this.content[0] : null
		}
		get lastChild() {
			return this.content.length ? this.content[this.content.length - 1] : null
		}
		get childCount() {
			return this.content.length
		}
		child(t) {
			let n = this.content[t]
			if (!n) throw new RangeError("Index " + t + " out of range for " + this)
			return n
		}
		maybeChild(t) {
			return this.content[t] || null
		}
		forEach(t) {
			for (let n = 0, r = 0; n < this.content.length; n++) {
				let i = this.content[n]
				t(i, r, n), (r += i.nodeSize)
			}
		}
		findDiffStart(t, n = 0) {
			return x7(this, t, n)
		}
		findDiffEnd(t, n = this.size, r = t.size) {
			return w7(this, t, n, r)
		}
		findIndex(t, n = -1) {
			if (t == 0) return ty(0, t)
			if (t == this.size) return ty(this.content.length, t)
			if (t > this.size || t < 0)
				throw new RangeError(`Position ${t} outside of fragment (${this})`)
			for (let r = 0, i = 0; ; r++) {
				let a = this.child(r),
					o = i + a.nodeSize
				if (o >= t) return o == t || n > 0 ? ty(r + 1, o) : ty(r, i)
				i = o
			}
		}
		toString() {
			return "<" + this.toStringInner() + ">"
		}
		toStringInner() {
			return this.content.join(", ")
		}
		toJSON() {
			return this.content.length ? this.content.map((t) => t.toJSON()) : null
		}
		static fromJSON(t, n) {
			if (!n) return ke.empty
			if (!Array.isArray(n)) throw new RangeError("Invalid input for Fragment.fromJSON")
			return new ke(n.map(t.nodeFromJSON))
		}
		static fromArray(t) {
			if (!t.length) return ke.empty
			let n,
				r = 0
			for (let i = 0; i < t.length; i++) {
				let a = t[i]
				;(r += a.nodeSize),
					i && a.isText && t[i - 1].sameMarkup(a)
						? (n || (n = t.slice(0, i)),
						  (n[n.length - 1] = a.withText(n[n.length - 1].text + a.text)))
						: n && n.push(a)
			}
			return new ke(n || t, r)
		}
		static from(t) {
			if (!t) return ke.empty
			if (t instanceof ke) return t
			if (Array.isArray(t)) return this.fromArray(t)
			if (t.attrs) return new ke([t], t.nodeSize)
			throw new RangeError(
				"Can not convert " +
					t +
					" to a Fragment" +
					(t.nodesBetween
						? " (looks like multiple versions of prosemirror-model were loaded)"
						: ""),
			)
		}
	}
	ke.empty = new ke([], 0)
	const KT = { index: 0, offset: 0 }
	function ty(e, t) {
		return (KT.index = e), (KT.offset = t), KT
	}
	function rb(e, t) {
		if (e === t) return !0
		if (!(e && typeof e == "object") || !(t && typeof t == "object")) return !1
		let n = Array.isArray(e)
		if (Array.isArray(t) != n) return !1
		if (n) {
			if (e.length != t.length) return !1
			for (let r = 0; r < e.length; r++) if (!rb(e[r], t[r])) return !1
		} else {
			for (let r in e) if (!(r in t) || !rb(e[r], t[r])) return !1
			for (let r in t) if (!(r in e)) return !1
		}
		return !0
	}
	let tn = class y2 {
		constructor(t, n) {
			;(this.type = t), (this.attrs = n)
		}
		addToSet(t) {
			let n,
				r = !1
			for (let i = 0; i < t.length; i++) {
				let a = t[i]
				if (this.eq(a)) return t
				if (this.type.excludes(a.type)) n || (n = t.slice(0, i))
				else {
					if (a.type.excludes(this.type)) return t
					!r && a.type.rank > this.type.rank && (n || (n = t.slice(0, i)), n.push(this), (r = !0)),
						n && n.push(a)
				}
			}
			return n || (n = t.slice()), r || n.push(this), n
		}
		removeFromSet(t) {
			for (let n = 0; n < t.length; n++)
				if (this.eq(t[n])) return t.slice(0, n).concat(t.slice(n + 1))
			return t
		}
		isInSet(t) {
			for (let n = 0; n < t.length; n++) if (this.eq(t[n])) return !0
			return !1
		}
		eq(t) {
			return this == t || (this.type == t.type && rb(this.attrs, t.attrs))
		}
		toJSON() {
			let t = { type: this.type.name }
			for (let n in this.attrs) {
				t.attrs = this.attrs
				break
			}
			return t
		}
		static fromJSON(t, n) {
			if (!n) throw new RangeError("Invalid input for Mark.fromJSON")
			let r = t.marks[n.type]
			if (!r) throw new RangeError(`There is no mark type ${n.type} in this schema`)
			return r.create(n.attrs)
		}
		static sameSet(t, n) {
			if (t == n) return !0
			if (t.length != n.length) return !1
			for (let r = 0; r < t.length; r++) if (!t[r].eq(n[r])) return !1
			return !0
		}
		static setFrom(t) {
			if (!t || (Array.isArray(t) && t.length == 0)) return y2.none
			if (t instanceof y2) return [t]
			let n = t.slice()
			return n.sort((r, i) => r.type.rank - i.type.rank), n
		}
	}
	tn.none = []
	class Tv extends Error {}
	class Ue {
		constructor(t, n, r) {
			;(this.content = t), (this.openStart = n), (this.openEnd = r)
		}
		get size() {
			return this.content.size - this.openStart - this.openEnd
		}
		insertAt(t, n) {
			let r = C7(this.content, t + this.openStart, n)
			return r && new Ue(r, this.openStart, this.openEnd)
		}
		removeBetween(t, n) {
			return new Ue(
				E7(this.content, t + this.openStart, n + this.openStart),
				this.openStart,
				this.openEnd,
			)
		}
		eq(t) {
			return (
				this.content.eq(t.content) && this.openStart == t.openStart && this.openEnd == t.openEnd
			)
		}
		toString() {
			return this.content + "(" + this.openStart + "," + this.openEnd + ")"
		}
		toJSON() {
			if (!this.content.size) return null
			let t = { content: this.content.toJSON() }
			return (
				this.openStart > 0 && (t.openStart = this.openStart),
				this.openEnd > 0 && (t.openEnd = this.openEnd),
				t
			)
		}
		static fromJSON(t, n) {
			if (!n) return Ue.empty
			let r = n.openStart || 0,
				i = n.openEnd || 0
			if (typeof r != "number" || typeof i != "number")
				throw new RangeError("Invalid input for Slice.fromJSON")
			return new Ue(ke.fromJSON(t, n.content), r, i)
		}
		static maxOpen(t, n = !0) {
			let r = 0,
				i = 0
			for (let a = t.firstChild; a && !a.isLeaf && (n || !a.type.spec.isolating); a = a.firstChild)
				r++
			for (let a = t.lastChild; a && !a.isLeaf && (n || !a.type.spec.isolating); a = a.lastChild)
				i++
			return new Ue(t, r, i)
		}
	}
	Ue.empty = new Ue(ke.empty, 0, 0)
	function E7(e, t, n) {
		let { index: r, offset: i } = e.findIndex(t),
			a = e.maybeChild(r),
			{ index: o, offset: s } = e.findIndex(n)
		if (i == t || a.isText) {
			if (s != n && !e.child(o).isText) throw new RangeError("Removing non-flat range")
			return e.cut(0, t).append(e.cut(n))
		}
		if (r != o) throw new RangeError("Removing non-flat range")
		return e.replaceChild(r, a.copy(E7(a.content, t - i - 1, n - i - 1)))
	}
	function C7(e, t, n, r) {
		let { index: i, offset: a } = e.findIndex(t),
			o = e.maybeChild(i)
		if (a == t || o.isText) return e.cut(0, t).append(n).append(e.cut(t))
		let s = C7(o.content, t - a - 1, n)
		return s && e.replaceChild(i, o.copy(s))
	}
	function dve(e, t, n) {
		if (n.openStart > e.depth) throw new Tv("Inserted content deeper than insertion position")
		if (e.depth - n.openStart != t.depth - n.openEnd) throw new Tv("Inconsistent open depths")
		return T7(e, t, n, 0)
	}
	function T7(e, t, n, r) {
		let i = e.index(r),
			a = e.node(r)
		if (i == t.index(r) && r < e.depth - n.openStart) {
			let o = T7(e, t, n, r + 1)
			return a.copy(a.content.replaceChild(i, o))
		} else if (n.content.size)
			if (!n.openStart && !n.openEnd && e.depth == r && t.depth == r) {
				let o = e.parent,
					s = o.content
				return Jc(o, s.cut(0, e.parentOffset).append(n.content).append(s.cut(t.parentOffset)))
			} else {
				let { start: o, end: s } = fve(n, e)
				return Jc(a, S7(e, o, s, t, r))
			}
		else return Jc(a, ib(e, t, r))
	}
	function k7(e, t) {
		if (!t.type.compatibleContent(e.type))
			throw new Tv("Cannot join " + t.type.name + " onto " + e.type.name)
	}
	function b2(e, t, n) {
		let r = e.node(n)
		return k7(r, t.node(n)), r
	}
	function Xc(e, t) {
		let n = t.length - 1
		n >= 0 && e.isText && e.sameMarkup(t[n]) ? (t[n] = e.withText(t[n].text + e.text)) : t.push(e)
	}
	function Hm(e, t, n, r) {
		let i = (t || e).node(n),
			a = 0,
			o = t ? t.index(n) : i.childCount
		e && ((a = e.index(n)), e.depth > n ? a++ : e.textOffset && (Xc(e.nodeAfter, r), a++))
		for (let s = a; s < o; s++) Xc(i.child(s), r)
		t && t.depth == n && t.textOffset && Xc(t.nodeBefore, r)
	}
	function Jc(e, t) {
		if (!e.type.validContent(t)) throw new Tv("Invalid content for node " + e.type.name)
		return e.copy(t)
	}
	function S7(e, t, n, r, i) {
		let a = e.depth > i && b2(e, t, i + 1),
			o = r.depth > i && b2(n, r, i + 1),
			s = []
		return (
			Hm(null, e, i, s),
			a && o && t.index(i) == n.index(i)
				? (k7(a, o), Xc(Jc(a, S7(e, t, n, r, i + 1)), s))
				: (a && Xc(Jc(a, ib(e, t, i + 1)), s), Hm(t, n, i, s), o && Xc(Jc(o, ib(n, r, i + 1)), s)),
			Hm(r, null, i, s),
			new ke(s)
		)
	}
	function ib(e, t, n) {
		let r = []
		if ((Hm(null, e, n, r), e.depth > n)) {
			let i = b2(e, t, n + 1)
			Xc(Jc(i, ib(e, t, n + 1)), r)
		}
		return Hm(t, null, n, r), new ke(r)
	}
	function fve(e, t) {
		let n = t.depth - e.openStart,
			i = t.node(n).copy(e.content)
		for (let a = n - 1; a >= 0; a--) i = t.node(a).copy(ke.from(i))
		return {
			start: i.resolveNoCache(e.openStart + n),
			end: i.resolveNoCache(i.content.size - e.openEnd - n),
		}
	}
	class kv {
		constructor(t, n, r) {
			;(this.pos = t), (this.path = n), (this.parentOffset = r), (this.depth = n.length / 3 - 1)
		}
		resolveDepth(t) {
			return t == null ? this.depth : t < 0 ? this.depth + t : t
		}
		get parent() {
			return this.node(this.depth)
		}
		get doc() {
			return this.node(0)
		}
		node(t) {
			return this.path[this.resolveDepth(t) * 3]
		}
		index(t) {
			return this.path[this.resolveDepth(t) * 3 + 1]
		}
		indexAfter(t) {
			return (
				(t = this.resolveDepth(t)), this.index(t) + (t == this.depth && !this.textOffset ? 0 : 1)
			)
		}
		start(t) {
			return (t = this.resolveDepth(t)), t == 0 ? 0 : this.path[t * 3 - 1] + 1
		}
		end(t) {
			return (t = this.resolveDepth(t)), this.start(t) + this.node(t).content.size
		}
		before(t) {
			if (((t = this.resolveDepth(t)), !t))
				throw new RangeError("There is no position before the top-level node")
			return t == this.depth + 1 ? this.pos : this.path[t * 3 - 1]
		}
		after(t) {
			if (((t = this.resolveDepth(t)), !t))
				throw new RangeError("There is no position after the top-level node")
			return t == this.depth + 1 ? this.pos : this.path[t * 3 - 1] + this.path[t * 3].nodeSize
		}
		get textOffset() {
			return this.pos - this.path[this.path.length - 1]
		}
		get nodeAfter() {
			let t = this.parent,
				n = this.index(this.depth)
			if (n == t.childCount) return null
			let r = this.pos - this.path[this.path.length - 1],
				i = t.child(n)
			return r ? t.child(n).cut(r) : i
		}
		get nodeBefore() {
			let t = this.index(this.depth),
				n = this.pos - this.path[this.path.length - 1]
			return n ? this.parent.child(t).cut(0, n) : t == 0 ? null : this.parent.child(t - 1)
		}
		posAtIndex(t, n) {
			n = this.resolveDepth(n)
			let r = this.path[n * 3],
				i = n == 0 ? 0 : this.path[n * 3 - 1] + 1
			for (let a = 0; a < t; a++) i += r.child(a).nodeSize
			return i
		}
		marks() {
			let t = this.parent,
				n = this.index()
			if (t.content.size == 0) return tn.none
			if (this.textOffset) return t.child(n).marks
			let r = t.maybeChild(n - 1),
				i = t.maybeChild(n)
			if (!r) {
				let s = r
				;(r = i), (i = s)
			}
			let a = r.marks
			for (var o = 0; o < a.length; o++)
				a[o].type.spec.inclusive === !1 &&
					(!i || !a[o].isInSet(i.marks)) &&
					(a = a[o--].removeFromSet(a))
			return a
		}
		marksAcross(t) {
			let n = this.parent.maybeChild(this.index())
			if (!n || !n.isInline) return null
			let r = n.marks,
				i = t.parent.maybeChild(t.index())
			for (var a = 0; a < r.length; a++)
				r[a].type.spec.inclusive === !1 &&
					(!i || !r[a].isInSet(i.marks)) &&
					(r = r[a--].removeFromSet(r))
			return r
		}
		sharedDepth(t) {
			for (let n = this.depth; n > 0; n--) if (this.start(n) <= t && this.end(n) >= t) return n
			return 0
		}
		blockRange(t = this, n) {
			if (t.pos < this.pos) return t.blockRange(this)
			for (
				let r = this.depth - (this.parent.inlineContent || this.pos == t.pos ? 1 : 0);
				r >= 0;
				r--
			)
				if (t.pos <= this.end(r) && (!n || n(this.node(r)))) return new ab(this, t, r)
			return null
		}
		sameParent(t) {
			return this.pos - this.parentOffset == t.pos - t.parentOffset
		}
		max(t) {
			return t.pos > this.pos ? t : this
		}
		min(t) {
			return t.pos < this.pos ? t : this
		}
		toString() {
			let t = ""
			for (let n = 1; n <= this.depth; n++)
				t += (t ? "/" : "") + this.node(n).type.name + "_" + this.index(n - 1)
			return t + ":" + this.parentOffset
		}
		static resolve(t, n) {
			if (!(n >= 0 && n <= t.content.size)) throw new RangeError("Position " + n + " out of range")
			let r = [],
				i = 0,
				a = n
			for (let o = t; ; ) {
				let { index: s, offset: l } = o.content.findIndex(a),
					u = a - l
				if ((r.push(o, s, i + l), !u || ((o = o.child(s)), o.isText))) break
				;(a = u - 1), (i += l + 1)
			}
			return new kv(n, r, a)
		}
		static resolveCached(t, n) {
			for (let i = 0; i < QT.length; i++) {
				let a = QT[i]
				if (a.pos == n && a.doc == t) return a
			}
			let r = (QT[XT] = kv.resolve(t, n))
			return (XT = (XT + 1) % pve), r
		}
	}
	let QT = [],
		XT = 0,
		pve = 12
	class ab {
		constructor(t, n, r) {
			;(this.$from = t), (this.$to = n), (this.depth = r)
		}
		get start() {
			return this.$from.before(this.depth + 1)
		}
		get end() {
			return this.$to.after(this.depth + 1)
		}
		get parent() {
			return this.$from.node(this.depth)
		}
		get startIndex() {
			return this.$from.index(this.depth)
		}
		get endIndex() {
			return this.$to.indexAfter(this.depth)
		}
	}
	const hve = Object.create(null)
	let Tu = class x2 {
		constructor(t, n, r, i = tn.none) {
			;(this.type = t), (this.attrs = n), (this.marks = i), (this.content = r || ke.empty)
		}
		get nodeSize() {
			return this.isLeaf ? 1 : 2 + this.content.size
		}
		get childCount() {
			return this.content.childCount
		}
		child(t) {
			return this.content.child(t)
		}
		maybeChild(t) {
			return this.content.maybeChild(t)
		}
		forEach(t) {
			this.content.forEach(t)
		}
		nodesBetween(t, n, r, i = 0) {
			this.content.nodesBetween(t, n, r, i, this)
		}
		descendants(t) {
			this.nodesBetween(0, this.content.size, t)
		}
		get textContent() {
			return this.isLeaf && this.type.spec.leafText
				? this.type.spec.leafText(this)
				: this.textBetween(0, this.content.size, "")
		}
		textBetween(t, n, r, i) {
			return this.content.textBetween(t, n, r, i)
		}
		get firstChild() {
			return this.content.firstChild
		}
		get lastChild() {
			return this.content.lastChild
		}
		eq(t) {
			return this == t || (this.sameMarkup(t) && this.content.eq(t.content))
		}
		sameMarkup(t) {
			return this.hasMarkup(t.type, t.attrs, t.marks)
		}
		hasMarkup(t, n, r) {
			return (
				this.type == t &&
				rb(this.attrs, n || t.defaultAttrs || hve) &&
				tn.sameSet(this.marks, r || tn.none)
			)
		}
		copy(t = null) {
			return t == this.content ? this : new x2(this.type, this.attrs, t, this.marks)
		}
		mark(t) {
			return t == this.marks ? this : new x2(this.type, this.attrs, this.content, t)
		}
		cut(t, n = this.content.size) {
			return t == 0 && n == this.content.size ? this : this.copy(this.content.cut(t, n))
		}
		slice(t, n = this.content.size, r = !1) {
			if (t == n) return Ue.empty
			let i = this.resolve(t),
				a = this.resolve(n),
				o = r ? 0 : i.sharedDepth(n),
				s = i.start(o),
				u = i.node(o).content.cut(i.pos - s, a.pos - s)
			return new Ue(u, i.depth - o, a.depth - o)
		}
		replace(t, n, r) {
			return dve(this.resolve(t), this.resolve(n), r)
		}
		nodeAt(t) {
			for (let n = this; ; ) {
				let { index: r, offset: i } = n.content.findIndex(t)
				if (((n = n.maybeChild(r)), !n)) return null
				if (i == t || n.isText) return n
				t -= i + 1
			}
		}
		childAfter(t) {
			let { index: n, offset: r } = this.content.findIndex(t)
			return { node: this.content.maybeChild(n), index: n, offset: r }
		}
		childBefore(t) {
			if (t == 0) return { node: null, index: 0, offset: 0 }
			let { index: n, offset: r } = this.content.findIndex(t)
			if (r < t) return { node: this.content.child(n), index: n, offset: r }
			let i = this.content.child(n - 1)
			return { node: i, index: n - 1, offset: r - i.nodeSize }
		}
		resolve(t) {
			return kv.resolveCached(this, t)
		}
		resolveNoCache(t) {
			return kv.resolve(this, t)
		}
		rangeHasMark(t, n, r) {
			let i = !1
			return n > t && this.nodesBetween(t, n, (a) => (r.isInSet(a.marks) && (i = !0), !i)), i
		}
		get isBlock() {
			return this.type.isBlock
		}
		get isTextblock() {
			return this.type.isTextblock
		}
		get inlineContent() {
			return this.type.inlineContent
		}
		get isInline() {
			return this.type.isInline
		}
		get isText() {
			return this.type.isText
		}
		get isLeaf() {
			return this.type.isLeaf
		}
		get isAtom() {
			return this.type.isAtom
		}
		toString() {
			if (this.type.spec.toDebugString) return this.type.spec.toDebugString(this)
			let t = this.type.name
			return this.content.size && (t += "(" + this.content.toStringInner() + ")"), D7(this.marks, t)
		}
		contentMatchAt(t) {
			let n = this.type.contentMatch.matchFragment(this.content, 0, t)
			if (!n) throw new Error("Called contentMatchAt on a node with invalid content")
			return n
		}
		canReplace(t, n, r = ke.empty, i = 0, a = r.childCount) {
			let o = this.contentMatchAt(t).matchFragment(r, i, a),
				s = o && o.matchFragment(this.content, n)
			if (!s || !s.validEnd) return !1
			for (let l = i; l < a; l++) if (!this.type.allowsMarks(r.child(l).marks)) return !1
			return !0
		}
		canReplaceWith(t, n, r, i) {
			if (i && !this.type.allowsMarks(i)) return !1
			let a = this.contentMatchAt(t).matchType(r),
				o = a && a.matchFragment(this.content, n)
			return o ? o.validEnd : !1
		}
		canAppend(t) {
			return t.content.size
				? this.canReplace(this.childCount, this.childCount, t.content)
				: this.type.compatibleContent(t.type)
		}
		check() {
			if (!this.type.validContent(this.content))
				throw new RangeError(
					`Invalid content for node ${this.type.name}: ${this.content.toString().slice(0, 50)}`,
				)
			let t = tn.none
			for (let n = 0; n < this.marks.length; n++) t = this.marks[n].addToSet(t)
			if (!tn.sameSet(t, this.marks))
				throw new RangeError(
					`Invalid collection of marks for node ${this.type.name}: ${this.marks.map(
						(n) => n.type.name,
					)}`,
				)
			this.content.forEach((n) => n.check())
		}
		toJSON() {
			let t = { type: this.type.name }
			for (let n in this.attrs) {
				t.attrs = this.attrs
				break
			}
			return (
				this.content.size && (t.content = this.content.toJSON()),
				this.marks.length && (t.marks = this.marks.map((n) => n.toJSON())),
				t
			)
		}
		static fromJSON(t, n) {
			if (!n) throw new RangeError("Invalid input for Node.fromJSON")
			let r = null
			if (n.marks) {
				if (!Array.isArray(n.marks)) throw new RangeError("Invalid mark data for Node.fromJSON")
				r = n.marks.map(t.markFromJSON)
			}
			if (n.type == "text") {
				if (typeof n.text != "string") throw new RangeError("Invalid text node in JSON")
				return t.text(n.text, r)
			}
			let i = ke.fromJSON(t, n.content)
			return t.nodeType(n.type).create(n.attrs, i, r)
		}
	}
	Tu.prototype.text = void 0
	class ob extends Tu {
		constructor(t, n, r, i) {
			if ((super(t, n, null, i), !r)) throw new RangeError("Empty text nodes are not allowed")
			this.text = r
		}
		toString() {
			return this.type.spec.toDebugString
				? this.type.spec.toDebugString(this)
				: D7(this.marks, JSON.stringify(this.text))
		}
		get textContent() {
			return this.text
		}
		textBetween(t, n) {
			return this.text.slice(t, n)
		}
		get nodeSize() {
			return this.text.length
		}
		mark(t) {
			return t == this.marks ? this : new ob(this.type, this.attrs, this.text, t)
		}
		withText(t) {
			return t == this.text ? this : new ob(this.type, this.attrs, t, this.marks)
		}
		cut(t = 0, n = this.text.length) {
			return t == 0 && n == this.text.length ? this : this.withText(this.text.slice(t, n))
		}
		eq(t) {
			return this.sameMarkup(t) && this.text == t.text
		}
		toJSON() {
			let t = super.toJSON()
			return (t.text = this.text), t
		}
	}
	function D7(e, t) {
		for (let n = e.length - 1; n >= 0; n--) t = e[n].type.name + "(" + t + ")"
		return t
	}
	class hd {
		constructor(t) {
			;(this.validEnd = t), (this.next = []), (this.wrapCache = [])
		}
		static parse(t, n) {
			let r = new mve(t, n)
			if (r.next == null) return hd.empty
			let i = _7(r)
			r.next && r.err("Unexpected trailing text")
			let a = Eve(wve(i))
			return Cve(a, r), a
		}
		matchType(t) {
			for (let n = 0; n < this.next.length; n++)
				if (this.next[n].type == t) return this.next[n].next
			return null
		}
		matchFragment(t, n = 0, r = t.childCount) {
			let i = this
			for (let a = n; i && a < r; a++) i = i.matchType(t.child(a).type)
			return i
		}
		get inlineContent() {
			return this.next.length && this.next[0].type.isInline
		}
		get defaultType() {
			for (let t = 0; t < this.next.length; t++) {
				let { type: n } = this.next[t]
				if (!(n.isText || n.hasRequiredAttrs())) return n
			}
			return null
		}
		compatible(t) {
			for (let n = 0; n < this.next.length; n++)
				for (let r = 0; r < t.next.length; r++) if (this.next[n].type == t.next[r].type) return !0
			return !1
		}
		fillBefore(t, n = !1, r = 0) {
			let i = [this]
			function a(o, s) {
				let l = o.matchFragment(t, r)
				if (l && (!n || l.validEnd)) return ke.from(s.map((u) => u.createAndFill()))
				for (let u = 0; u < o.next.length; u++) {
					let { type: d, next: p } = o.next[u]
					if (!(d.isText || d.hasRequiredAttrs()) && i.indexOf(p) == -1) {
						i.push(p)
						let m = a(p, s.concat(d))
						if (m) return m
					}
				}
				return null
			}
			return a(this, [])
		}
		findWrapping(t) {
			for (let r = 0; r < this.wrapCache.length; r += 2)
				if (this.wrapCache[r] == t) return this.wrapCache[r + 1]
			let n = this.computeWrapping(t)
			return this.wrapCache.push(t, n), n
		}
		computeWrapping(t) {
			let n = Object.create(null),
				r = [{ match: this, type: null, via: null }]
			for (; r.length; ) {
				let i = r.shift(),
					a = i.match
				if (a.matchType(t)) {
					let o = []
					for (let s = i; s.type; s = s.via) o.push(s.type)
					return o.reverse()
				}
				for (let o = 0; o < a.next.length; o++) {
					let { type: s, next: l } = a.next[o]
					!s.isLeaf &&
						!s.hasRequiredAttrs() &&
						!(s.name in n) &&
						(!i.type || l.validEnd) &&
						(r.push({ match: s.contentMatch, type: s, via: i }), (n[s.name] = !0))
				}
			}
			return null
		}
		get edgeCount() {
			return this.next.length
		}
		edge(t) {
			if (t >= this.next.length)
				throw new RangeError(`There's no ${t}th edge in this content match`)
			return this.next[t]
		}
		toString() {
			let t = []
			function n(r) {
				t.push(r)
				for (let i = 0; i < r.next.length; i++) t.indexOf(r.next[i].next) == -1 && n(r.next[i].next)
			}
			return (
				n(this),
				t.map((r, i) => {
					let a = i + (r.validEnd ? "*" : " ") + " "
					for (let o = 0; o < r.next.length; o++)
						a += (o ? ", " : "") + r.next[o].type.name + "->" + t.indexOf(r.next[o].next)
					return a
				}).join(`
`)
			)
		}
	}
	hd.empty = new hd(!0)
	class mve {
		constructor(t, n) {
			;(this.string = t),
				(this.nodeTypes = n),
				(this.inline = null),
				(this.pos = 0),
				(this.tokens = t.split(/\s*(?=\b|\W|$)/)),
				this.tokens[this.tokens.length - 1] == "" && this.tokens.pop(),
				this.tokens[0] == "" && this.tokens.shift()
		}
		get next() {
			return this.tokens[this.pos]
		}
		eat(t) {
			return this.next == t && (this.pos++ || !0)
		}
		err(t) {
			throw new SyntaxError(t + " (in content expression '" + this.string + "')")
		}
	}
	function _7(e) {
		let t = []
		do t.push(vve(e))
		while (e.eat("|"))
		return t.length == 1 ? t[0] : { type: "choice", exprs: t }
	}
	function vve(e) {
		let t = []
		do t.push(gve(e))
		while (e.next && e.next != ")" && e.next != "|")
		return t.length == 1 ? t[0] : { type: "seq", exprs: t }
	}
	function gve(e) {
		let t = xve(e)
		for (;;)
			if (e.eat("+")) t = { type: "plus", expr: t }
			else if (e.eat("*")) t = { type: "star", expr: t }
			else if (e.eat("?")) t = { type: "opt", expr: t }
			else if (e.eat("{")) t = yve(e, t)
			else break
		return t
	}
	function t3(e) {
		;/\D/.test(e.next) && e.err("Expected number, got '" + e.next + "'")
		let t = Number(e.next)
		return e.pos++, t
	}
	function yve(e, t) {
		let n = t3(e),
			r = n
		return (
			e.eat(",") && (e.next != "}" ? (r = t3(e)) : (r = -1)),
			e.eat("}") || e.err("Unclosed braced range"),
			{ type: "range", min: n, max: r, expr: t }
		)
	}
	function bve(e, t) {
		let n = e.nodeTypes,
			r = n[t]
		if (r) return [r]
		let i = []
		for (let a in n) {
			let o = n[a]
			o.groups.indexOf(t) > -1 && i.push(o)
		}
		return i.length == 0 && e.err("No node type or group '" + t + "' found"), i
	}
	function xve(e) {
		if (e.eat("(")) {
			let t = _7(e)
			return e.eat(")") || e.err("Missing closing paren"), t
		} else if (/\W/.test(e.next)) e.err("Unexpected token '" + e.next + "'")
		else {
			let t = bve(e, e.next).map(
				(n) => (
					e.inline == null
						? (e.inline = n.isInline)
						: e.inline != n.isInline && e.err("Mixing inline and block content"),
					{ type: "name", value: n }
				),
			)
			return e.pos++, t.length == 1 ? t[0] : { type: "choice", exprs: t }
		}
	}
	function wve(e) {
		let t = [[]]
		return i(a(e, 0), n()), t
		function n() {
			return t.push([]) - 1
		}
		function r(o, s, l) {
			let u = { term: l, to: s }
			return t[o].push(u), u
		}
		function i(o, s) {
			o.forEach((l) => (l.to = s))
		}
		function a(o, s) {
			if (o.type == "choice") return o.exprs.reduce((l, u) => l.concat(a(u, s)), [])
			if (o.type == "seq")
				for (let l = 0; ; l++) {
					let u = a(o.exprs[l], s)
					if (l == o.exprs.length - 1) return u
					i(u, (s = n()))
				}
			else if (o.type == "star") {
				let l = n()
				return r(s, l), i(a(o.expr, l), l), [r(l)]
			} else if (o.type == "plus") {
				let l = n()
				return i(a(o.expr, s), l), i(a(o.expr, l), l), [r(l)]
			} else {
				if (o.type == "opt") return [r(s)].concat(a(o.expr, s))
				if (o.type == "range") {
					let l = s
					for (let u = 0; u < o.min; u++) {
						let d = n()
						i(a(o.expr, l), d), (l = d)
					}
					if (o.max == -1) i(a(o.expr, l), l)
					else
						for (let u = o.min; u < o.max; u++) {
							let d = n()
							r(l, d), i(a(o.expr, l), d), (l = d)
						}
					return [r(l)]
				} else {
					if (o.type == "name") return [r(s, void 0, o.value)]
					throw new Error("Unknown expr type")
				}
			}
		}
	}
	function O7(e, t) {
		return t - e
	}
	function n3(e, t) {
		let n = []
		return r(t), n.sort(O7)
		function r(i) {
			let a = e[i]
			if (a.length == 1 && !a[0].term) return r(a[0].to)
			n.push(i)
			for (let o = 0; o < a.length; o++) {
				let { term: s, to: l } = a[o]
				!s && n.indexOf(l) == -1 && r(l)
			}
		}
	}
	function Eve(e) {
		let t = Object.create(null)
		return n(n3(e, 0))
		function n(r) {
			let i = []
			r.forEach((o) => {
				e[o].forEach(({ term: s, to: l }) => {
					if (!s) return
					let u
					for (let d = 0; d < i.length; d++) i[d][0] == s && (u = i[d][1])
					n3(e, l).forEach((d) => {
						u || i.push([s, (u = [])]), u.indexOf(d) == -1 && u.push(d)
					})
				})
			})
			let a = (t[r.join(",")] = new hd(r.indexOf(e.length - 1) > -1))
			for (let o = 0; o < i.length; o++) {
				let s = i[o][1].sort(O7)
				a.next.push({ type: i[o][0], next: t[s.join(",")] || n(s) })
			}
			return a
		}
	}
	function Cve(e, t) {
		for (let n = 0, r = [e]; n < r.length; n++) {
			let i = r[n],
				a = !i.validEnd,
				o = []
			for (let s = 0; s < i.next.length; s++) {
				let { type: l, next: u } = i.next[s]
				o.push(l.name),
					a && !(l.isText || l.hasRequiredAttrs()) && (a = !1),
					r.indexOf(u) == -1 && r.push(u)
			}
			a &&
				t.err(
					"Only non-generatable nodes (" +
						o.join(", ") +
						") in a required position (see https://prosemirror.net/docs/guide/#generatable)",
				)
		}
	}
	function A7(e) {
		let t = Object.create(null)
		for (let n in e) {
			let r = e[n]
			if (!r.hasDefault) return null
			t[n] = r.default
		}
		return t
	}
	function N7(e, t) {
		let n = Object.create(null)
		for (let r in e) {
			let i = t && t[r]
			if (i === void 0) {
				let a = e[r]
				if (a.hasDefault) i = a.default
				else throw new RangeError("No value supplied for attribute " + r)
			}
			n[r] = i
		}
		return n
	}
	function M7(e) {
		let t = Object.create(null)
		if (e) for (let n in e) t[n] = new Tve(e[n])
		return t
	}
	let r3 = class I7 {
		constructor(t, n, r) {
			;(this.name = t),
				(this.schema = n),
				(this.spec = r),
				(this.markSet = null),
				(this.groups = r.group ? r.group.split(" ") : []),
				(this.attrs = M7(r.attrs)),
				(this.defaultAttrs = A7(this.attrs)),
				(this.contentMatch = null),
				(this.inlineContent = null),
				(this.isBlock = !(r.inline || t == "text")),
				(this.isText = t == "text")
		}
		get isInline() {
			return !this.isBlock
		}
		get isTextblock() {
			return this.isBlock && this.inlineContent
		}
		get isLeaf() {
			return this.contentMatch == hd.empty
		}
		get isAtom() {
			return this.isLeaf || !!this.spec.atom
		}
		get whitespace() {
			return this.spec.whitespace || (this.spec.code ? "pre" : "normal")
		}
		hasRequiredAttrs() {
			for (let t in this.attrs) if (this.attrs[t].isRequired) return !0
			return !1
		}
		compatibleContent(t) {
			return this == t || this.contentMatch.compatible(t.contentMatch)
		}
		computeAttrs(t) {
			return !t && this.defaultAttrs ? this.defaultAttrs : N7(this.attrs, t)
		}
		create(t = null, n, r) {
			if (this.isText) throw new Error("NodeType.create can't construct text nodes")
			return new Tu(this, this.computeAttrs(t), ke.from(n), tn.setFrom(r))
		}
		createChecked(t = null, n, r) {
			if (((n = ke.from(n)), !this.validContent(n)))
				throw new RangeError("Invalid content for node " + this.name)
			return new Tu(this, this.computeAttrs(t), n, tn.setFrom(r))
		}
		createAndFill(t = null, n, r) {
			if (((t = this.computeAttrs(t)), (n = ke.from(n)), n.size)) {
				let o = this.contentMatch.fillBefore(n)
				if (!o) return null
				n = o.append(n)
			}
			let i = this.contentMatch.matchFragment(n),
				a = i && i.fillBefore(ke.empty, !0)
			return a ? new Tu(this, t, n.append(a), tn.setFrom(r)) : null
		}
		validContent(t) {
			let n = this.contentMatch.matchFragment(t)
			if (!n || !n.validEnd) return !1
			for (let r = 0; r < t.childCount; r++) if (!this.allowsMarks(t.child(r).marks)) return !1
			return !0
		}
		allowsMarkType(t) {
			return this.markSet == null || this.markSet.indexOf(t) > -1
		}
		allowsMarks(t) {
			if (this.markSet == null) return !0
			for (let n = 0; n < t.length; n++) if (!this.allowsMarkType(t[n].type)) return !1
			return !0
		}
		allowedMarks(t) {
			if (this.markSet == null) return t
			let n
			for (let r = 0; r < t.length; r++)
				this.allowsMarkType(t[r].type) ? n && n.push(t[r]) : n || (n = t.slice(0, r))
			return n ? (n.length ? n : tn.none) : t
		}
		static compile(t, n) {
			let r = Object.create(null)
			t.forEach((a, o) => (r[a] = new I7(a, n, o)))
			let i = n.spec.topNode || "doc"
			if (!r[i]) throw new RangeError("Schema is missing its top node type ('" + i + "')")
			if (!r.text) throw new RangeError("Every schema needs a 'text' type")
			for (let a in r.text.attrs)
				throw new RangeError("The text node type should not have attributes")
			return r
		}
	}
	class Tve {
		constructor(t) {
			;(this.hasDefault = Object.prototype.hasOwnProperty.call(t, "default")),
				(this.default = t.default)
		}
		get isRequired() {
			return !this.hasDefault
		}
	}
	class Zx {
		constructor(t, n, r, i) {
			;(this.name = t),
				(this.rank = n),
				(this.schema = r),
				(this.spec = i),
				(this.attrs = M7(i.attrs)),
				(this.excluded = null)
			let a = A7(this.attrs)
			this.instance = a ? new tn(this, a) : null
		}
		create(t = null) {
			return !t && this.instance ? this.instance : new tn(this, N7(this.attrs, t))
		}
		static compile(t, n) {
			let r = Object.create(null),
				i = 0
			return t.forEach((a, o) => (r[a] = new Zx(a, i++, n, o))), r
		}
		removeFromSet(t) {
			for (var n = 0; n < t.length; n++)
				t[n].type == this && ((t = t.slice(0, n).concat(t.slice(n + 1))), n--)
			return t
		}
		isInSet(t) {
			for (let n = 0; n < t.length; n++) if (t[n].type == this) return t[n]
		}
		excludes(t) {
			return this.excluded.indexOf(t) > -1
		}
	}
	let R7 = class {
		constructor(t) {
			;(this.cached = Object.create(null)),
				(this.spec = {
					nodes: jr.from(t.nodes),
					marks: jr.from(t.marks || {}),
					topNode: t.topNode,
				}),
				(this.nodes = r3.compile(this.spec.nodes, this)),
				(this.marks = Zx.compile(this.spec.marks, this))
			let n = Object.create(null)
			for (let r in this.nodes) {
				if (r in this.marks) throw new RangeError(r + " can not be both a node and a mark")
				let i = this.nodes[r],
					a = i.spec.content || "",
					o = i.spec.marks
				;(i.contentMatch = n[a] || (n[a] = hd.parse(a, this.nodes))),
					(i.inlineContent = i.contentMatch.inlineContent),
					(i.markSet =
						o == "_" ? null : o ? i3(this, o.split(" ")) : o == "" || !i.inlineContent ? [] : null)
			}
			for (let r in this.marks) {
				let i = this.marks[r],
					a = i.spec.excludes
				i.excluded = a == null ? [i] : a == "" ? [] : i3(this, a.split(" "))
			}
			;(this.nodeFromJSON = this.nodeFromJSON.bind(this)),
				(this.markFromJSON = this.markFromJSON.bind(this)),
				(this.topNodeType = this.nodes[this.spec.topNode || "doc"]),
				(this.cached.wrappings = Object.create(null))
		}
		node(t, n = null, r, i) {
			if (typeof t == "string") t = this.nodeType(t)
			else if (t instanceof r3) {
				if (t.schema != this)
					throw new RangeError("Node type from different schema used (" + t.name + ")")
			} else throw new RangeError("Invalid node type: " + t)
			return t.createChecked(n, r, i)
		}
		text(t, n) {
			let r = this.nodes.text
			return new ob(r, r.defaultAttrs, t, tn.setFrom(n))
		}
		mark(t, n) {
			return typeof t == "string" && (t = this.marks[t]), t.create(n)
		}
		nodeFromJSON(t) {
			return Tu.fromJSON(this, t)
		}
		markFromJSON(t) {
			return tn.fromJSON(this, t)
		}
		nodeType(t) {
			let n = this.nodes[t]
			if (!n) throw new RangeError("Unknown node type: " + t)
			return n
		}
	}
	function i3(e, t) {
		let n = []
		for (let r = 0; r < t.length; r++) {
			let i = t[r],
				a = e.marks[i],
				o = a
			if (a) n.push(a)
			else
				for (let s in e.marks) {
					let l = e.marks[s]
					;(i == "_" || (l.spec.group && l.spec.group.split(" ").indexOf(i) > -1)) &&
						n.push((o = l))
				}
			if (!o) throw new SyntaxError("Unknown mark type: '" + t[r] + "'")
		}
		return n
	}
	class md {
		constructor(t, n) {
			;(this.schema = t),
				(this.rules = n),
				(this.tags = []),
				(this.styles = []),
				n.forEach((r) => {
					r.tag ? this.tags.push(r) : r.style && this.styles.push(r)
				}),
				(this.normalizeLists = !this.tags.some((r) => {
					if (!/^(ul|ol)\b/.test(r.tag) || !r.node) return !1
					let i = t.nodes[r.node]
					return i.contentMatch.matchType(i)
				}))
		}
		parse(t, n = {}) {
			let r = new o3(this, n, !1)
			return r.addAll(t, n.from, n.to), r.finish()
		}
		parseSlice(t, n = {}) {
			let r = new o3(this, n, !0)
			return r.addAll(t, n.from, n.to), Ue.maxOpen(r.finish())
		}
		matchTag(t, n, r) {
			for (let i = r ? this.tags.indexOf(r) + 1 : 0; i < this.tags.length; i++) {
				let a = this.tags[i]
				if (
					Dve(t, a.tag) &&
					(a.namespace === void 0 || t.namespaceURI == a.namespace) &&
					(!a.context || n.matchesContext(a.context))
				) {
					if (a.getAttrs) {
						let o = a.getAttrs(t)
						if (o === !1) continue
						a.attrs = o || void 0
					}
					return a
				}
			}
		}
		matchStyle(t, n, r, i) {
			for (let a = i ? this.styles.indexOf(i) + 1 : 0; a < this.styles.length; a++) {
				let o = this.styles[a],
					s = o.style
				if (
					!(
						s.indexOf(t) != 0 ||
						(o.context && !r.matchesContext(o.context)) ||
						(s.length > t.length && (s.charCodeAt(t.length) != 61 || s.slice(t.length + 1) != n))
					)
				) {
					if (o.getAttrs) {
						let l = o.getAttrs(n)
						if (l === !1) continue
						o.attrs = l || void 0
					}
					return o
				}
			}
		}
		static schemaRules(t) {
			let n = []
			function r(i) {
				let a = i.priority == null ? 50 : i.priority,
					o = 0
				for (; o < n.length; o++) {
					let s = n[o]
					if ((s.priority == null ? 50 : s.priority) < a) break
				}
				n.splice(o, 0, i)
			}
			for (let i in t.marks) {
				let a = t.marks[i].spec.parseDOM
				a &&
					a.forEach((o) => {
						r((o = s3(o))), (o.mark = i)
					})
			}
			for (let i in t.nodes) {
				let a = t.nodes[i].spec.parseDOM
				a &&
					a.forEach((o) => {
						r((o = s3(o))), (o.node = i)
					})
			}
			return n
		}
		static fromSchema(t) {
			return t.cached.domParser || (t.cached.domParser = new md(t, md.schemaRules(t)))
		}
	}
	const L7 = {
			address: !0,
			article: !0,
			aside: !0,
			blockquote: !0,
			canvas: !0,
			dd: !0,
			div: !0,
			dl: !0,
			fieldset: !0,
			figcaption: !0,
			figure: !0,
			footer: !0,
			form: !0,
			h1: !0,
			h2: !0,
			h3: !0,
			h4: !0,
			h5: !0,
			h6: !0,
			header: !0,
			hgroup: !0,
			hr: !0,
			li: !0,
			noscript: !0,
			ol: !0,
			output: !0,
			p: !0,
			pre: !0,
			section: !0,
			table: !0,
			tfoot: !0,
			ul: !0,
		},
		kve = { head: !0, noscript: !0, object: !0, script: !0, style: !0, title: !0 },
		P7 = { ol: !0, ul: !0 },
		sb = 1,
		lb = 2,
		$m = 4
	function a3(e, t, n) {
		return t != null
			? (t ? sb : 0) | (t === "full" ? lb : 0)
			: e && e.whitespace == "pre"
			? sb | lb
			: n & ~$m
	}
	class ny {
		constructor(t, n, r, i, a, o, s) {
			;(this.type = t),
				(this.attrs = n),
				(this.marks = r),
				(this.pendingMarks = i),
				(this.solid = a),
				(this.options = s),
				(this.content = []),
				(this.activeMarks = tn.none),
				(this.stashMarks = []),
				(this.match = o || (s & $m ? null : t.contentMatch))
		}
		findWrapping(t) {
			if (!this.match) {
				if (!this.type) return []
				let n = this.type.contentMatch.fillBefore(ke.from(t))
				if (n) this.match = this.type.contentMatch.matchFragment(n)
				else {
					let r = this.type.contentMatch,
						i
					return (i = r.findWrapping(t.type)) ? ((this.match = r), i) : null
				}
			}
			return this.match.findWrapping(t.type)
		}
		finish(t) {
			if (!(this.options & sb)) {
				let r = this.content[this.content.length - 1],
					i
				if (r && r.isText && (i = /[ \t\r\n\u000c]+$/.exec(r.text))) {
					let a = r
					r.text.length == i[0].length
						? this.content.pop()
						: (this.content[this.content.length - 1] = a.withText(
								a.text.slice(0, a.text.length - i[0].length),
						  ))
				}
			}
			let n = ke.from(this.content)
			return (
				!t && this.match && (n = n.append(this.match.fillBefore(ke.empty, !0))),
				this.type ? this.type.create(this.attrs, n, this.marks) : n
			)
		}
		popFromStashMark(t) {
			for (let n = this.stashMarks.length - 1; n >= 0; n--)
				if (t.eq(this.stashMarks[n])) return this.stashMarks.splice(n, 1)[0]
		}
		applyPending(t) {
			for (let n = 0, r = this.pendingMarks; n < r.length; n++) {
				let i = r[n]
				;(this.type ? this.type.allowsMarkType(i.type) : Ove(i.type, t)) &&
					!i.isInSet(this.activeMarks) &&
					((this.activeMarks = i.addToSet(this.activeMarks)),
					(this.pendingMarks = i.removeFromSet(this.pendingMarks)))
			}
		}
		inlineContext(t) {
			return this.type
				? this.type.inlineContent
				: this.content.length
				? this.content[0].isInline
				: t.parentNode && !L7.hasOwnProperty(t.parentNode.nodeName.toLowerCase())
		}
	}
	class o3 {
		constructor(t, n, r) {
			;(this.parser = t), (this.options = n), (this.isOpen = r), (this.open = 0)
			let i = n.topNode,
				a,
				o = a3(null, n.preserveWhitespace, 0) | (r ? $m : 0)
			i
				? (a = new ny(i.type, i.attrs, tn.none, tn.none, !0, n.topMatch || i.type.contentMatch, o))
				: r
				? (a = new ny(null, null, tn.none, tn.none, !0, null, o))
				: (a = new ny(t.schema.topNodeType, null, tn.none, tn.none, !0, null, o)),
				(this.nodes = [a]),
				(this.find = n.findPositions),
				(this.needsBlock = !1)
		}
		get top() {
			return this.nodes[this.open]
		}
		addDOM(t) {
			if (t.nodeType == 3) this.addTextNode(t)
			else if (t.nodeType == 1) {
				let n = t.getAttribute("style"),
					r = n ? this.readStyles(_ve(n)) : null,
					i = this.top
				if (r != null) for (let a = 0; a < r.length; a++) this.addPendingMark(r[a])
				if ((this.addElement(t), r != null))
					for (let a = 0; a < r.length; a++) this.removePendingMark(r[a], i)
			}
		}
		addTextNode(t) {
			let n = t.nodeValue,
				r = this.top
			if (r.options & lb || r.inlineContext(t) || /[^ \t\r\n\u000c]/.test(n)) {
				if (r.options & sb)
					r.options & lb
						? (n = n.replace(
								/\r\n?/g,
								`
`,
						  ))
						: (n = n.replace(/\r?\n|\r/g, " "))
				else if (
					((n = n.replace(/[ \t\r\n\u000c]+/g, " ")),
					/^[ \t\r\n\u000c]/.test(n) && this.open == this.nodes.length - 1)
				) {
					let i = r.content[r.content.length - 1],
						a = t.previousSibling
					;(!i || (a && a.nodeName == "BR") || (i.isText && /[ \t\r\n\u000c]$/.test(i.text))) &&
						(n = n.slice(1))
				}
				n && this.insertNode(this.parser.schema.text(n)), this.findInText(t)
			} else this.findInside(t)
		}
		addElement(t, n) {
			let r = t.nodeName.toLowerCase(),
				i
			P7.hasOwnProperty(r) && this.parser.normalizeLists && Sve(t)
			let a =
				(this.options.ruleFromNode && this.options.ruleFromNode(t)) ||
				(i = this.parser.matchTag(t, this, n))
			if (a ? a.ignore : kve.hasOwnProperty(r)) this.findInside(t), this.ignoreFallback(t)
			else if (!a || a.skip || a.closeParent) {
				a && a.closeParent
					? (this.open = Math.max(0, this.open - 1))
					: a && a.skip.nodeType && (t = a.skip)
				let o,
					s = this.top,
					l = this.needsBlock
				if (L7.hasOwnProperty(r)) (o = !0), s.type || (this.needsBlock = !0)
				else if (!t.firstChild) {
					this.leafFallback(t)
					return
				}
				this.addAll(t), o && this.sync(s), (this.needsBlock = l)
			} else this.addElementByRule(t, a, a.consuming === !1 ? i : void 0)
		}
		leafFallback(t) {
			t.nodeName == "BR" &&
				this.top.type &&
				this.top.type.inlineContent &&
				this.addTextNode(
					t.ownerDocument.createTextNode(`
`),
				)
		}
		ignoreFallback(t) {
			t.nodeName == "BR" &&
				(!this.top.type || !this.top.type.inlineContent) &&
				this.findPlace(this.parser.schema.text("-"))
		}
		readStyles(t) {
			let n = tn.none
			e: for (let r = 0; r < t.length; r += 2)
				for (let i = void 0; ; ) {
					let a = this.parser.matchStyle(t[r], t[r + 1], this, i)
					if (!a) continue e
					if (a.ignore) return null
					if (
						((n = this.parser.schema.marks[a.mark].create(a.attrs).addToSet(n)), a.consuming === !1)
					)
						i = a
					else break
				}
			return n
		}
		addElementByRule(t, n, r) {
			let i, a, o
			n.node
				? ((a = this.parser.schema.nodes[n.node]),
				  a.isLeaf
						? this.insertNode(a.create(n.attrs)) || this.leafFallback(t)
						: (i = this.enter(a, n.attrs || null, n.preserveWhitespace)))
				: ((o = this.parser.schema.marks[n.mark].create(n.attrs)), this.addPendingMark(o))
			let s = this.top
			if (a && a.isLeaf) this.findInside(t)
			else if (r) this.addElement(t, r)
			else if (n.getContent)
				this.findInside(t), n.getContent(t, this.parser.schema).forEach((l) => this.insertNode(l))
			else {
				let l = t
				typeof n.contentElement == "string"
					? (l = t.querySelector(n.contentElement))
					: typeof n.contentElement == "function"
					? (l = n.contentElement(t))
					: n.contentElement && (l = n.contentElement),
					this.findAround(t, l, !0),
					this.addAll(l)
			}
			i && this.sync(s) && this.open--, o && this.removePendingMark(o, s)
		}
		addAll(t, n, r) {
			let i = n || 0
			for (
				let a = n ? t.childNodes[n] : t.firstChild, o = r == null ? null : t.childNodes[r];
				a != o;
				a = a.nextSibling, ++i
			)
				this.findAtPoint(t, i), this.addDOM(a)
			this.findAtPoint(t, i)
		}
		findPlace(t) {
			let n, r
			for (let i = this.open; i >= 0; i--) {
				let a = this.nodes[i],
					o = a.findWrapping(t)
				if ((o && (!n || n.length > o.length) && ((n = o), (r = a), !o.length)) || a.solid) break
			}
			if (!n) return !1
			this.sync(r)
			for (let i = 0; i < n.length; i++) this.enterInner(n[i], null, !1)
			return !0
		}
		insertNode(t) {
			if (t.isInline && this.needsBlock && !this.top.type) {
				let n = this.textblockFromContext()
				n && this.enterInner(n)
			}
			if (this.findPlace(t)) {
				this.closeExtra()
				let n = this.top
				n.applyPending(t.type), n.match && (n.match = n.match.matchType(t.type))
				let r = n.activeMarks
				for (let i = 0; i < t.marks.length; i++)
					(!n.type || n.type.allowsMarkType(t.marks[i].type)) && (r = t.marks[i].addToSet(r))
				return n.content.push(t.mark(r)), !0
			}
			return !1
		}
		enter(t, n, r) {
			let i = this.findPlace(t.create(n))
			return i && this.enterInner(t, n, !0, r), i
		}
		enterInner(t, n = null, r = !1, i) {
			this.closeExtra()
			let a = this.top
			a.applyPending(t), (a.match = a.match && a.match.matchType(t))
			let o = a3(t, i, a.options)
			a.options & $m && a.content.length == 0 && (o |= $m),
				this.nodes.push(new ny(t, n, a.activeMarks, a.pendingMarks, r, null, o)),
				this.open++
		}
		closeExtra(t = !1) {
			let n = this.nodes.length - 1
			if (n > this.open) {
				for (; n > this.open; n--) this.nodes[n - 1].content.push(this.nodes[n].finish(t))
				this.nodes.length = this.open + 1
			}
		}
		finish() {
			return (
				(this.open = 0),
				this.closeExtra(this.isOpen),
				this.nodes[0].finish(this.isOpen || this.options.topOpen)
			)
		}
		sync(t) {
			for (let n = this.open; n >= 0; n--) if (this.nodes[n] == t) return (this.open = n), !0
			return !1
		}
		get currentPos() {
			this.closeExtra()
			let t = 0
			for (let n = this.open; n >= 0; n--) {
				let r = this.nodes[n].content
				for (let i = r.length - 1; i >= 0; i--) t += r[i].nodeSize
				n && t++
			}
			return t
		}
		findAtPoint(t, n) {
			if (this.find)
				for (let r = 0; r < this.find.length; r++)
					this.find[r].node == t && this.find[r].offset == n && (this.find[r].pos = this.currentPos)
		}
		findInside(t) {
			if (this.find)
				for (let n = 0; n < this.find.length; n++)
					this.find[n].pos == null &&
						t.nodeType == 1 &&
						t.contains(this.find[n].node) &&
						(this.find[n].pos = this.currentPos)
		}
		findAround(t, n, r) {
			if (t != n && this.find)
				for (let i = 0; i < this.find.length; i++)
					this.find[i].pos == null &&
						t.nodeType == 1 &&
						t.contains(this.find[i].node) &&
						n.compareDocumentPosition(this.find[i].node) & (r ? 2 : 4) &&
						(this.find[i].pos = this.currentPos)
		}
		findInText(t) {
			if (this.find)
				for (let n = 0; n < this.find.length; n++)
					this.find[n].node == t &&
						(this.find[n].pos = this.currentPos - (t.nodeValue.length - this.find[n].offset))
		}
		matchesContext(t) {
			if (t.indexOf("|") > -1) return t.split(/\s*\|\s*/).some(this.matchesContext, this)
			let n = t.split("/"),
				r = this.options.context,
				i = !this.isOpen && (!r || r.parent.type == this.nodes[0].type),
				a = -(r ? r.depth + 1 : 0) + (i ? 0 : 1),
				o = (s, l) => {
					for (; s >= 0; s--) {
						let u = n[s]
						if (u == "") {
							if (s == n.length - 1 || s == 0) continue
							for (; l >= a; l--) if (o(s - 1, l)) return !0
							return !1
						} else {
							let d =
								l > 0 || (l == 0 && i)
									? this.nodes[l].type
									: r && l >= a
									? r.node(l - a).type
									: null
							if (!d || (d.name != u && d.groups.indexOf(u) == -1)) return !1
							l--
						}
					}
					return !0
				}
			return o(n.length - 1, this.open)
		}
		textblockFromContext() {
			let t = this.options.context
			if (t)
				for (let n = t.depth; n >= 0; n--) {
					let r = t.node(n).contentMatchAt(t.indexAfter(n)).defaultType
					if (r && r.isTextblock && r.defaultAttrs) return r
				}
			for (let n in this.parser.schema.nodes) {
				let r = this.parser.schema.nodes[n]
				if (r.isTextblock && r.defaultAttrs) return r
			}
		}
		addPendingMark(t) {
			let n = Ave(t, this.top.pendingMarks)
			n && this.top.stashMarks.push(n), (this.top.pendingMarks = t.addToSet(this.top.pendingMarks))
		}
		removePendingMark(t, n) {
			for (let r = this.open; r >= 0; r--) {
				let i = this.nodes[r]
				if (i.pendingMarks.lastIndexOf(t) > -1) i.pendingMarks = t.removeFromSet(i.pendingMarks)
				else {
					i.activeMarks = t.removeFromSet(i.activeMarks)
					let o = i.popFromStashMark(t)
					o &&
						i.type &&
						i.type.allowsMarkType(o.type) &&
						(i.activeMarks = o.addToSet(i.activeMarks))
				}
				if (i == n) break
			}
		}
	}
	function Sve(e) {
		for (let t = e.firstChild, n = null; t; t = t.nextSibling) {
			let r = t.nodeType == 1 ? t.nodeName.toLowerCase() : null
			r && P7.hasOwnProperty(r) && n
				? (n.appendChild(t), (t = n))
				: r == "li"
				? (n = t)
				: r && (n = null)
		}
	}
	function Dve(e, t) {
		return (
			e.matches ||
			e.msMatchesSelector ||
			e.webkitMatchesSelector ||
			e.mozMatchesSelector
		).call(e, t)
	}
	function _ve(e) {
		let t = /\s*([\w-]+)\s*:\s*([^;]+)/g,
			n,
			r = []
		for (; (n = t.exec(e)); ) r.push(n[1], n[2].trim())
		return r
	}
	function s3(e) {
		let t = {}
		for (let n in e) t[n] = e[n]
		return t
	}
	function Ove(e, t) {
		let n = t.schema.nodes
		for (let r in n) {
			let i = n[r]
			if (!i.allowsMarkType(e)) continue
			let a = [],
				o = (s) => {
					a.push(s)
					for (let l = 0; l < s.edgeCount; l++) {
						let { type: u, next: d } = s.edge(l)
						if (u == t || (a.indexOf(d) < 0 && o(d))) return !0
					}
				}
			if (o(i.contentMatch)) return !0
		}
	}
	function Ave(e, t) {
		for (let n = 0; n < t.length; n++) if (e.eq(t[n])) return t[n]
	}
	class al {
		constructor(t, n) {
			;(this.nodes = t), (this.marks = n)
		}
		serializeFragment(t, n = {}, r) {
			r || (r = JT(n).createDocumentFragment())
			let i = r,
				a = []
			return (
				t.forEach((o) => {
					if (a.length || o.marks.length) {
						let s = 0,
							l = 0
						for (; s < a.length && l < o.marks.length; ) {
							let u = o.marks[l]
							if (!this.marks[u.type.name]) {
								l++
								continue
							}
							if (!u.eq(a[s][0]) || u.type.spec.spanning === !1) break
							s++, l++
						}
						for (; s < a.length; ) i = a.pop()[1]
						for (; l < o.marks.length; ) {
							let u = o.marks[l++],
								d = this.serializeMark(u, o.isInline, n)
							d && (a.push([u, i]), i.appendChild(d.dom), (i = d.contentDOM || d.dom))
						}
					}
					i.appendChild(this.serializeNodeInner(o, n))
				}),
				r
			)
		}
		serializeNodeInner(t, n) {
			let { dom: r, contentDOM: i } = al.renderSpec(JT(n), this.nodes[t.type.name](t))
			if (i) {
				if (t.isLeaf) throw new RangeError("Content hole not allowed in a leaf node spec")
				this.serializeFragment(t.content, n, i)
			}
			return r
		}
		serializeNode(t, n = {}) {
			let r = this.serializeNodeInner(t, n)
			for (let i = t.marks.length - 1; i >= 0; i--) {
				let a = this.serializeMark(t.marks[i], t.isInline, n)
				a && ((a.contentDOM || a.dom).appendChild(r), (r = a.dom))
			}
			return r
		}
		serializeMark(t, n, r = {}) {
			let i = this.marks[t.type.name]
			return i && al.renderSpec(JT(r), i(t, n))
		}
		static renderSpec(t, n, r = null) {
			if (typeof n == "string") return { dom: t.createTextNode(n) }
			if (n.nodeType != null) return { dom: n }
			if (n.dom && n.dom.nodeType != null) return n
			let i = n[0],
				a = i.indexOf(" ")
			a > 0 && ((r = i.slice(0, a)), (i = i.slice(a + 1)))
			let o,
				s = r ? t.createElementNS(r, i) : t.createElement(i),
				l = n[1],
				u = 1
			if (l && typeof l == "object" && l.nodeType == null && !Array.isArray(l)) {
				u = 2
				for (let d in l)
					if (l[d] != null) {
						let p = d.indexOf(" ")
						p > 0 ? s.setAttributeNS(d.slice(0, p), d.slice(p + 1), l[d]) : s.setAttribute(d, l[d])
					}
			}
			for (let d = u; d < n.length; d++) {
				let p = n[d]
				if (p === 0) {
					if (d < n.length - 1 || d > u)
						throw new RangeError("Content hole must be the only child of its parent node")
					return { dom: s, contentDOM: s }
				} else {
					let { dom: m, contentDOM: v } = al.renderSpec(t, p, r)
					if ((s.appendChild(m), v)) {
						if (o) throw new RangeError("Multiple content holes")
						o = v
					}
				}
			}
			return { dom: s, contentDOM: o }
		}
		static fromSchema(t) {
			return (
				t.cached.domSerializer ||
				(t.cached.domSerializer = new al(this.nodesFromSchema(t), this.marksFromSchema(t)))
			)
		}
		static nodesFromSchema(t) {
			let n = l3(t.nodes)
			return n.text || (n.text = (r) => r.text), n
		}
		static marksFromSchema(t) {
			return l3(t.marks)
		}
	}
	function l3(e) {
		let t = {}
		for (let n in e) {
			let r = e[n].spec.toDOM
			r && (t[n] = r)
		}
		return t
	}
	function JT(e) {
		return e.document || window.document
	}
	const j7 = 65535,
		F7 = Math.pow(2, 16)
	function Nve(e, t) {
		return e + t * F7
	}
	function u3(e) {
		return e & j7
	}
	function Mve(e) {
		return (e - (e & j7)) / F7
	}
	const B7 = 1,
		H7 = 2,
		u1 = 4,
		$7 = 8
	class w2 {
		constructor(t, n, r) {
			;(this.pos = t), (this.delInfo = n), (this.recover = r)
		}
		get deleted() {
			return (this.delInfo & $7) > 0
		}
		get deletedBefore() {
			return (this.delInfo & (B7 | u1)) > 0
		}
		get deletedAfter() {
			return (this.delInfo & (H7 | u1)) > 0
		}
		get deletedAcross() {
			return (this.delInfo & u1) > 0
		}
	}
	class Ua {
		constructor(t, n = !1) {
			if (((this.ranges = t), (this.inverted = n), !t.length && Ua.empty)) return Ua.empty
		}
		recover(t) {
			let n = 0,
				r = u3(t)
			if (!this.inverted)
				for (let i = 0; i < r; i++) n += this.ranges[i * 3 + 2] - this.ranges[i * 3 + 1]
			return this.ranges[r * 3] + n + Mve(t)
		}
		mapResult(t, n = 1) {
			return this._map(t, n, !1)
		}
		map(t, n = 1) {
			return this._map(t, n, !0)
		}
		_map(t, n, r) {
			let i = 0,
				a = this.inverted ? 2 : 1,
				o = this.inverted ? 1 : 2
			for (let s = 0; s < this.ranges.length; s += 3) {
				let l = this.ranges[s] - (this.inverted ? i : 0)
				if (l > t) break
				let u = this.ranges[s + a],
					d = this.ranges[s + o],
					p = l + u
				if (t <= p) {
					let m = u ? (t == l ? -1 : t == p ? 1 : n) : n,
						v = l + i + (m < 0 ? 0 : d)
					if (r) return v
					let y = t == (n < 0 ? l : p) ? null : Nve(s / 3, t - l),
						b = t == l ? H7 : t == p ? B7 : u1
					return (n < 0 ? t != l : t != p) && (b |= $7), new w2(v, b, y)
				}
				i += d - u
			}
			return r ? t + i : new w2(t + i, 0, null)
		}
		touches(t, n) {
			let r = 0,
				i = u3(n),
				a = this.inverted ? 2 : 1,
				o = this.inverted ? 1 : 2
			for (let s = 0; s < this.ranges.length; s += 3) {
				let l = this.ranges[s] - (this.inverted ? r : 0)
				if (l > t) break
				let u = this.ranges[s + a],
					d = l + u
				if (t <= d && s == i * 3) return !0
				r += this.ranges[s + o] - u
			}
			return !1
		}
		forEach(t) {
			let n = this.inverted ? 2 : 1,
				r = this.inverted ? 1 : 2
			for (let i = 0, a = 0; i < this.ranges.length; i += 3) {
				let o = this.ranges[i],
					s = o - (this.inverted ? a : 0),
					l = o + (this.inverted ? 0 : a),
					u = this.ranges[i + n],
					d = this.ranges[i + r]
				t(s, s + u, l, l + d), (a += d - u)
			}
		}
		invert() {
			return new Ua(this.ranges, !this.inverted)
		}
		toString() {
			return (this.inverted ? "-" : "") + JSON.stringify(this.ranges)
		}
		static offset(t) {
			return t == 0 ? Ua.empty : new Ua(t < 0 ? [0, -t, 0] : [0, 0, t])
		}
	}
	Ua.empty = new Ua([])
	class Wf {
		constructor(t = [], n, r = 0, i = t.length) {
			;(this.maps = t), (this.mirror = n), (this.from = r), (this.to = i)
		}
		slice(t = 0, n = this.maps.length) {
			return new Wf(this.maps, this.mirror, t, n)
		}
		copy() {
			return new Wf(this.maps.slice(), this.mirror && this.mirror.slice(), this.from, this.to)
		}
		appendMap(t, n) {
			;(this.to = this.maps.push(t)), n != null && this.setMirror(this.maps.length - 1, n)
		}
		appendMapping(t) {
			for (let n = 0, r = this.maps.length; n < t.maps.length; n++) {
				let i = t.getMirror(n)
				this.appendMap(t.maps[n], i != null && i < n ? r + i : void 0)
			}
		}
		getMirror(t) {
			if (this.mirror) {
				for (let n = 0; n < this.mirror.length; n++)
					if (this.mirror[n] == t) return this.mirror[n + (n % 2 ? -1 : 1)]
			}
		}
		setMirror(t, n) {
			this.mirror || (this.mirror = []), this.mirror.push(t, n)
		}
		appendMappingInverted(t) {
			for (let n = t.maps.length - 1, r = this.maps.length + t.maps.length; n >= 0; n--) {
				let i = t.getMirror(n)
				this.appendMap(t.maps[n].invert(), i != null && i > n ? r - i - 1 : void 0)
			}
		}
		invert() {
			let t = new Wf()
			return t.appendMappingInverted(this), t
		}
		map(t, n = 1) {
			if (this.mirror) return this._map(t, n, !0)
			for (let r = this.from; r < this.to; r++) t = this.maps[r].map(t, n)
			return t
		}
		mapResult(t, n = 1) {
			return this._map(t, n, !1)
		}
		_map(t, n, r) {
			let i = 0
			for (let a = this.from; a < this.to; a++) {
				let o = this.maps[a],
					s = o.mapResult(t, n)
				if (s.recover != null) {
					let l = this.getMirror(a)
					if (l != null && l > a && l < this.to) {
						;(a = l), (t = this.maps[l].recover(s.recover))
						continue
					}
				}
				;(i |= s.delInfo), (t = s.pos)
			}
			return r ? t : new w2(t, i, null)
		}
	}
	const ZT = Object.create(null)
	class Xu {
		getMap() {
			return Ua.empty
		}
		merge(t) {
			return null
		}
		static fromJSON(t, n) {
			if (!n || !n.stepType) throw new RangeError("Invalid input for Step.fromJSON")
			let r = ZT[n.stepType]
			if (!r) throw new RangeError(`No step type ${n.stepType} defined`)
			return r.fromJSON(t, n)
		}
		static jsonID(t, n) {
			if (t in ZT) throw new RangeError("Duplicate use of step JSON ID " + t)
			return (ZT[t] = n), (n.prototype.jsonID = t), n
		}
	}
	class da {
		constructor(t, n) {
			;(this.doc = t), (this.failed = n)
		}
		static ok(t) {
			return new da(t, null)
		}
		static fail(t) {
			return new da(null, t)
		}
		static fromReplace(t, n, r, i) {
			try {
				return da.ok(t.replace(n, r, i))
			} catch (a) {
				if (a instanceof Tv) return da.fail(a.message)
				throw a
			}
		}
	}
	function yO(e, t, n) {
		let r = []
		for (let i = 0; i < e.childCount; i++) {
			let a = e.child(i)
			a.content.size && (a = a.copy(yO(a.content, t, a))), a.isInline && (a = t(a, n, i)), r.push(a)
		}
		return ke.fromArray(r)
	}
	class bu extends Xu {
		constructor(t, n, r) {
			super(), (this.from = t), (this.to = n), (this.mark = r)
		}
		apply(t) {
			let n = t.slice(this.from, this.to),
				r = t.resolve(this.from),
				i = r.node(r.sharedDepth(this.to)),
				a = new Ue(
					yO(
						n.content,
						(o, s) =>
							!o.isAtom || !s.type.allowsMarkType(this.mark.type)
								? o
								: o.mark(this.mark.addToSet(o.marks)),
						i,
					),
					n.openStart,
					n.openEnd,
				)
			return da.fromReplace(t, this.from, this.to, a)
		}
		invert() {
			return new rs(this.from, this.to, this.mark)
		}
		map(t) {
			let n = t.mapResult(this.from, 1),
				r = t.mapResult(this.to, -1)
			return (n.deleted && r.deleted) || n.pos >= r.pos ? null : new bu(n.pos, r.pos, this.mark)
		}
		merge(t) {
			return t instanceof bu && t.mark.eq(this.mark) && this.from <= t.to && this.to >= t.from
				? new bu(Math.min(this.from, t.from), Math.max(this.to, t.to), this.mark)
				: null
		}
		toJSON() {
			return { stepType: "addMark", mark: this.mark.toJSON(), from: this.from, to: this.to }
		}
		static fromJSON(t, n) {
			if (typeof n.from != "number" || typeof n.to != "number")
				throw new RangeError("Invalid input for AddMarkStep.fromJSON")
			return new bu(n.from, n.to, t.markFromJSON(n.mark))
		}
	}
	Xu.jsonID("addMark", bu)
	class rs extends Xu {
		constructor(t, n, r) {
			super(), (this.from = t), (this.to = n), (this.mark = r)
		}
		apply(t) {
			let n = t.slice(this.from, this.to),
				r = new Ue(
					yO(n.content, (i) => i.mark(this.mark.removeFromSet(i.marks)), t),
					n.openStart,
					n.openEnd,
				)
			return da.fromReplace(t, this.from, this.to, r)
		}
		invert() {
			return new bu(this.from, this.to, this.mark)
		}
		map(t) {
			let n = t.mapResult(this.from, 1),
				r = t.mapResult(this.to, -1)
			return (n.deleted && r.deleted) || n.pos >= r.pos ? null : new rs(n.pos, r.pos, this.mark)
		}
		merge(t) {
			return t instanceof rs && t.mark.eq(this.mark) && this.from <= t.to && this.to >= t.from
				? new rs(Math.min(this.from, t.from), Math.max(this.to, t.to), this.mark)
				: null
		}
		toJSON() {
			return { stepType: "removeMark", mark: this.mark.toJSON(), from: this.from, to: this.to }
		}
		static fromJSON(t, n) {
			if (typeof n.from != "number" || typeof n.to != "number")
				throw new RangeError("Invalid input for RemoveMarkStep.fromJSON")
			return new rs(n.from, n.to, t.markFromJSON(n.mark))
		}
	}
	Xu.jsonID("removeMark", rs)
	class hi extends Xu {
		constructor(t, n, r, i = !1) {
			super(), (this.from = t), (this.to = n), (this.slice = r), (this.structure = i)
		}
		apply(t) {
			return this.structure && E2(t, this.from, this.to)
				? da.fail("Structure replace would overwrite content")
				: da.fromReplace(t, this.from, this.to, this.slice)
		}
		getMap() {
			return new Ua([this.from, this.to - this.from, this.slice.size])
		}
		invert(t) {
			return new hi(this.from, this.from + this.slice.size, t.slice(this.from, this.to))
		}
		map(t) {
			let n = t.mapResult(this.from, 1),
				r = t.mapResult(this.to, -1)
			return n.deletedAcross && r.deletedAcross
				? null
				: new hi(n.pos, Math.max(n.pos, r.pos), this.slice)
		}
		merge(t) {
			if (!(t instanceof hi) || t.structure || this.structure) return null
			if (this.from + this.slice.size == t.from && !this.slice.openEnd && !t.slice.openStart) {
				let n =
					this.slice.size + t.slice.size == 0
						? Ue.empty
						: new Ue(
								this.slice.content.append(t.slice.content),
								this.slice.openStart,
								t.slice.openEnd,
						  )
				return new hi(this.from, this.to + (t.to - t.from), n, this.structure)
			} else if (t.to == this.from && !this.slice.openStart && !t.slice.openEnd) {
				let n =
					this.slice.size + t.slice.size == 0
						? Ue.empty
						: new Ue(
								t.slice.content.append(this.slice.content),
								t.slice.openStart,
								this.slice.openEnd,
						  )
				return new hi(t.from, this.to, n, this.structure)
			} else return null
		}
		toJSON() {
			let t = { stepType: "replace", from: this.from, to: this.to }
			return (
				this.slice.size && (t.slice = this.slice.toJSON()), this.structure && (t.structure = !0), t
			)
		}
		static fromJSON(t, n) {
			if (typeof n.from != "number" || typeof n.to != "number")
				throw new RangeError("Invalid input for ReplaceStep.fromJSON")
			return new hi(n.from, n.to, Ue.fromJSON(t, n.slice), !!n.structure)
		}
	}
	Xu.jsonID("replace", hi)
	class Ar extends Xu {
		constructor(t, n, r, i, a, o, s = !1) {
			super(),
				(this.from = t),
				(this.to = n),
				(this.gapFrom = r),
				(this.gapTo = i),
				(this.slice = a),
				(this.insert = o),
				(this.structure = s)
		}
		apply(t) {
			if (this.structure && (E2(t, this.from, this.gapFrom) || E2(t, this.gapTo, this.to)))
				return da.fail("Structure gap-replace would overwrite content")
			let n = t.slice(this.gapFrom, this.gapTo)
			if (n.openStart || n.openEnd) return da.fail("Gap is not a flat range")
			let r = this.slice.insertAt(this.insert, n.content)
			return r ? da.fromReplace(t, this.from, this.to, r) : da.fail("Content does not fit in gap")
		}
		getMap() {
			return new Ua([
				this.from,
				this.gapFrom - this.from,
				this.insert,
				this.gapTo,
				this.to - this.gapTo,
				this.slice.size - this.insert,
			])
		}
		invert(t) {
			let n = this.gapTo - this.gapFrom
			return new Ar(
				this.from,
				this.from + this.slice.size + n,
				this.from + this.insert,
				this.from + this.insert + n,
				t.slice(this.from, this.to).removeBetween(this.gapFrom - this.from, this.gapTo - this.from),
				this.gapFrom - this.from,
				this.structure,
			)
		}
		map(t) {
			let n = t.mapResult(this.from, 1),
				r = t.mapResult(this.to, -1),
				i = t.map(this.gapFrom, -1),
				a = t.map(this.gapTo, 1)
			return (n.deletedAcross && r.deletedAcross) || i < n.pos || a > r.pos
				? null
				: new Ar(n.pos, r.pos, i, a, this.slice, this.insert, this.structure)
		}
		toJSON() {
			let t = {
				stepType: "replaceAround",
				from: this.from,
				to: this.to,
				gapFrom: this.gapFrom,
				gapTo: this.gapTo,
				insert: this.insert,
			}
			return (
				this.slice.size && (t.slice = this.slice.toJSON()), this.structure && (t.structure = !0), t
			)
		}
		static fromJSON(t, n) {
			if (
				typeof n.from != "number" ||
				typeof n.to != "number" ||
				typeof n.gapFrom != "number" ||
				typeof n.gapTo != "number" ||
				typeof n.insert != "number"
			)
				throw new RangeError("Invalid input for ReplaceAroundStep.fromJSON")
			return new Ar(
				n.from,
				n.to,
				n.gapFrom,
				n.gapTo,
				Ue.fromJSON(t, n.slice),
				n.insert,
				!!n.structure,
			)
		}
	}
	Xu.jsonID("replaceAround", Ar)
	function E2(e, t, n) {
		let r = e.resolve(t),
			i = n - t,
			a = r.depth
		for (; i > 0 && a > 0 && r.indexAfter(a) == r.node(a).childCount; ) a--, i--
		if (i > 0) {
			let o = r.node(a).maybeChild(r.indexAfter(a))
			for (; i > 0; ) {
				if (!o || o.isLeaf) return !0
				;(o = o.firstChild), i--
			}
		}
		return !1
	}
	function Ive(e, t, n, r) {
		let i = [],
			a = [],
			o,
			s
		e.doc.nodesBetween(t, n, (l, u, d) => {
			if (!l.isInline) return
			let p = l.marks
			if (!r.isInSet(p) && d.type.allowsMarkType(r.type)) {
				let m = Math.max(u, t),
					v = Math.min(u + l.nodeSize, n),
					y = r.addToSet(p)
				for (let b = 0; b < p.length; b++)
					p[b].isInSet(y) ||
						(o && o.to == m && o.mark.eq(p[b]) ? (o.to = v) : i.push((o = new rs(m, v, p[b]))))
				s && s.to == m ? (s.to = v) : a.push((s = new bu(m, v, r)))
			}
		}),
			i.forEach((l) => e.step(l)),
			a.forEach((l) => e.step(l))
	}
	function Rve(e, t, n, r) {
		let i = [],
			a = 0
		e.doc.nodesBetween(t, n, (o, s) => {
			if (!o.isInline) return
			a++
			let l = null
			if (r instanceof Zx) {
				let u = o.marks,
					d
				for (; (d = r.isInSet(u)); ) (l || (l = [])).push(d), (u = d.removeFromSet(u))
			} else r ? r.isInSet(o.marks) && (l = [r]) : (l = o.marks)
			if (l && l.length) {
				let u = Math.min(s + o.nodeSize, n)
				for (let d = 0; d < l.length; d++) {
					let p = l[d],
						m
					for (let v = 0; v < i.length; v++) {
						let y = i[v]
						y.step == a - 1 && p.eq(i[v].style) && (m = y)
					}
					m
						? ((m.to = u), (m.step = a))
						: i.push({ style: p, from: Math.max(s, t), to: u, step: a })
				}
			}
		}),
			i.forEach((o) => e.step(new rs(o.from, o.to, o.style)))
	}
	function Lve(e, t, n, r = n.contentMatch) {
		let i = e.doc.nodeAt(t),
			a = [],
			o = t + 1
		for (let s = 0; s < i.childCount; s++) {
			let l = i.child(s),
				u = o + l.nodeSize,
				d = r.matchType(l.type)
			if (!d) a.push(new hi(o, u, Ue.empty))
			else {
				r = d
				for (let p = 0; p < l.marks.length; p++)
					n.allowsMarkType(l.marks[p].type) || e.step(new rs(o, u, l.marks[p]))
			}
			o = u
		}
		if (!r.validEnd) {
			let s = r.fillBefore(ke.empty, !0)
			e.replace(o, o, new Ue(s, 0, 0))
		}
		for (let s = a.length - 1; s >= 0; s--) e.step(a[s])
	}
	function Pve(e, t, n) {
		return (t == 0 || e.canReplace(t, e.childCount)) && (n == e.childCount || e.canReplace(0, n))
	}
	function ew(e) {
		let n = e.parent.content.cutByIndex(e.startIndex, e.endIndex)
		for (let r = e.depth; ; --r) {
			let i = e.$from.node(r),
				a = e.$from.index(r),
				o = e.$to.indexAfter(r)
			if (r < e.depth && i.canReplace(a, o, n)) return r
			if (r == 0 || i.type.spec.isolating || !Pve(i, a, o)) break
		}
		return null
	}
	function jve(e, t, n) {
		let { $from: r, $to: i, depth: a } = t,
			o = r.before(a + 1),
			s = i.after(a + 1),
			l = o,
			u = s,
			d = ke.empty,
			p = 0
		for (let y = a, b = !1; y > n; y--)
			b || r.index(y) > 0 ? ((b = !0), (d = ke.from(r.node(y).copy(d))), p++) : l--
		let m = ke.empty,
			v = 0
		for (let y = a, b = !1; y > n; y--)
			b || i.after(y + 1) < i.end(y) ? ((b = !0), (m = ke.from(i.node(y).copy(m))), v++) : u++
		e.step(new Ar(l, u, o, s, new Ue(d.append(m), p, v), d.size - p, !0))
	}
	function Fve(e, t, n = null, r = e) {
		let i = Bve(e, t),
			a = i && Hve(r, t)
		return a ? i.map(c3).concat({ type: t, attrs: n }).concat(a.map(c3)) : null
	}
	function c3(e) {
		return { type: e, attrs: null }
	}
	function Bve(e, t) {
		let { parent: n, startIndex: r, endIndex: i } = e,
			a = n.contentMatchAt(r).findWrapping(t)
		if (!a) return null
		let o = a.length ? a[0] : t
		return n.canReplaceWith(r, i, o) ? a : null
	}
	function Hve(e, t) {
		let { parent: n, startIndex: r, endIndex: i } = e,
			a = n.child(r),
			o = t.contentMatch.findWrapping(a.type)
		if (!o) return null
		let l = (o.length ? o[o.length - 1] : t).contentMatch
		for (let u = r; l && u < i; u++) l = l.matchType(n.child(u).type)
		return !l || !l.validEnd ? null : o
	}
	function $ve(e, t, n) {
		let r = ke.empty
		for (let o = n.length - 1; o >= 0; o--) {
			if (r.size) {
				let s = n[o].type.contentMatch.matchFragment(r)
				if (!s || !s.validEnd)
					throw new RangeError(
						"Wrapper type given to Transform.wrap does not form valid content of its parent wrapper",
					)
			}
			r = ke.from(n[o].type.create(n[o].attrs, r))
		}
		let i = t.start,
			a = t.end
		e.step(new Ar(i, a, i, a, new Ue(r, 0, 0), n.length, !0))
	}
	function Uve(e, t, n, r, i) {
		if (!r.isTextblock) throw new RangeError("Type given to setBlockType should be a textblock")
		let a = e.steps.length
		e.doc.nodesBetween(t, n, (o, s) => {
			if (o.isTextblock && !o.hasMarkup(r, i) && zve(e.doc, e.mapping.slice(a).map(s), r)) {
				e.clearIncompatible(e.mapping.slice(a).map(s, 1), r)
				let l = e.mapping.slice(a),
					u = l.map(s, 1),
					d = l.map(s + o.nodeSize, 1)
				return (
					e.step(
						new Ar(u, d, u + 1, d - 1, new Ue(ke.from(r.create(i, null, o.marks)), 0, 0), 1, !0),
					),
					!1
				)
			}
		})
	}
	function zve(e, t, n) {
		let r = e.resolve(t),
			i = r.index()
		return r.parent.canReplaceWith(i, i + 1, n)
	}
	function qve(e, t, n, r, i) {
		let a = e.doc.nodeAt(t)
		if (!a) throw new RangeError("No node at given position")
		n || (n = a.type)
		let o = n.create(r, null, i || a.marks)
		if (a.isLeaf) return e.replaceWith(t, t + a.nodeSize, o)
		if (!n.validContent(a.content)) throw new RangeError("Invalid content for node type " + n.name)
		e.step(new Ar(t, t + a.nodeSize, t + 1, t + a.nodeSize - 1, new Ue(ke.from(o), 0, 0), 1, !0))
	}
	function Yf(e, t, n = 1, r) {
		let i = e.resolve(t),
			a = i.depth - n,
			o = (r && r[r.length - 1]) || i.parent
		if (
			a < 0 ||
			i.parent.type.spec.isolating ||
			!i.parent.canReplace(i.index(), i.parent.childCount) ||
			!o.type.validContent(i.parent.content.cutByIndex(i.index(), i.parent.childCount))
		)
			return !1
		for (let u = i.depth - 1, d = n - 2; u > a; u--, d--) {
			let p = i.node(u),
				m = i.index(u)
			if (p.type.spec.isolating) return !1
			let v = p.content.cutByIndex(m, p.childCount),
				y = (r && r[d]) || p
			if (
				(y != p && (v = v.replaceChild(0, y.type.create(y.attrs))),
				!p.canReplace(m + 1, p.childCount) || !y.type.validContent(v))
			)
				return !1
		}
		let s = i.indexAfter(a),
			l = r && r[0]
		return i.node(a).canReplaceWith(s, s, l ? l.type : i.node(a + 1).type)
	}
	function Vve(e, t, n = 1, r) {
		let i = e.doc.resolve(t),
			a = ke.empty,
			o = ke.empty
		for (let s = i.depth, l = i.depth - n, u = n - 1; s > l; s--, u--) {
			a = ke.from(i.node(s).copy(a))
			let d = r && r[u]
			o = ke.from(d ? d.type.create(d.attrs, o) : i.node(s).copy(o))
		}
		e.step(new hi(t, t, new Ue(a.append(o), n, n), !0))
	}
	function U7(e, t) {
		let n = e.resolve(t),
			r = n.index()
		return Wve(n.nodeBefore, n.nodeAfter) && n.parent.canReplace(r, r + 1)
	}
	function Wve(e, t) {
		return !!(e && t && !e.isLeaf && e.canAppend(t))
	}
	function Yve(e, t, n) {
		let r = new hi(t - n, t + n, Ue.empty, !0)
		e.step(r)
	}
	function Gve(e, t, n) {
		let r = e.resolve(t)
		if (r.parent.canReplaceWith(r.index(), r.index(), n)) return t
		if (r.parentOffset == 0)
			for (let i = r.depth - 1; i >= 0; i--) {
				let a = r.index(i)
				if (r.node(i).canReplaceWith(a, a, n)) return r.before(i + 1)
				if (a > 0) return null
			}
		if (r.parentOffset == r.parent.content.size)
			for (let i = r.depth - 1; i >= 0; i--) {
				let a = r.indexAfter(i)
				if (r.node(i).canReplaceWith(a, a, n)) return r.after(i + 1)
				if (a < r.node(i).childCount) return null
			}
		return null
	}
	function Kve(e, t, n) {
		let r = e.resolve(t)
		if (!n.content.size) return t
		let i = n.content
		for (let a = 0; a < n.openStart; a++) i = i.firstChild.content
		for (let a = 1; a <= (n.openStart == 0 && n.size ? 2 : 1); a++)
			for (let o = r.depth; o >= 0; o--) {
				let s = o == r.depth ? 0 : r.pos <= (r.start(o + 1) + r.end(o + 1)) / 2 ? -1 : 1,
					l = r.index(o) + (s > 0 ? 1 : 0),
					u = r.node(o),
					d = !1
				if (a == 1) d = u.canReplace(l, l, i)
				else {
					let p = u.contentMatchAt(l).findWrapping(i.firstChild.type)
					d = p && u.canReplaceWith(l, l, p[0])
				}
				if (d) return s == 0 ? r.pos : s < 0 ? r.before(o + 1) : r.after(o + 1)
			}
		return null
	}
	function bO(e, t, n = t, r = Ue.empty) {
		if (t == n && !r.size) return null
		let i = e.resolve(t),
			a = e.resolve(n)
		return z7(i, a, r) ? new hi(t, n, r) : new Qve(i, a, r).fit()
	}
	function z7(e, t, n) {
		return (
			!n.openStart &&
			!n.openEnd &&
			e.start() == t.start() &&
			e.parent.canReplace(e.index(), t.index(), n.content)
		)
	}
	class Qve {
		constructor(t, n, r) {
			;(this.$from = t),
				(this.$to = n),
				(this.unplaced = r),
				(this.frontier = []),
				(this.placed = ke.empty)
			for (let i = 0; i <= t.depth; i++) {
				let a = t.node(i)
				this.frontier.push({ type: a.type, match: a.contentMatchAt(t.indexAfter(i)) })
			}
			for (let i = t.depth; i > 0; i--) this.placed = ke.from(t.node(i).copy(this.placed))
		}
		get depth() {
			return this.frontier.length - 1
		}
		fit() {
			for (; this.unplaced.size; ) {
				let u = this.findFittable()
				u ? this.placeNodes(u) : this.openMore() || this.dropNode()
			}
			let t = this.mustMoveInline(),
				n = this.placed.size - this.depth - this.$from.depth,
				r = this.$from,
				i = this.close(t < 0 ? this.$to : r.doc.resolve(t))
			if (!i) return null
			let a = this.placed,
				o = r.depth,
				s = i.depth
			for (; o && s && a.childCount == 1; ) (a = a.firstChild.content), o--, s--
			let l = new Ue(a, o, s)
			return t > -1
				? new Ar(r.pos, t, this.$to.pos, this.$to.end(), l, n)
				: l.size || r.pos != this.$to.pos
				? new hi(r.pos, i.pos, l)
				: null
		}
		findFittable() {
			for (let t = 1; t <= 2; t++)
				for (let n = this.unplaced.openStart; n >= 0; n--) {
					let r,
						i = null
					n
						? ((i = ek(this.unplaced.content, n - 1).firstChild), (r = i.content))
						: (r = this.unplaced.content)
					let a = r.firstChild
					for (let o = this.depth; o >= 0; o--) {
						let { type: s, match: l } = this.frontier[o],
							u,
							d = null
						if (
							t == 1 &&
							(a
								? l.matchType(a.type) || (d = l.fillBefore(ke.from(a), !1))
								: i && s.compatibleContent(i.type))
						)
							return { sliceDepth: n, frontierDepth: o, parent: i, inject: d }
						if (t == 2 && a && (u = l.findWrapping(a.type)))
							return { sliceDepth: n, frontierDepth: o, parent: i, wrap: u }
						if (i && l.matchType(i.type)) break
					}
				}
		}
		openMore() {
			let { content: t, openStart: n, openEnd: r } = this.unplaced,
				i = ek(t, n)
			return !i.childCount || i.firstChild.isLeaf
				? !1
				: ((this.unplaced = new Ue(t, n + 1, Math.max(r, i.size + n >= t.size - r ? n + 1 : 0))),
				  !0)
		}
		dropNode() {
			let { content: t, openStart: n, openEnd: r } = this.unplaced,
				i = ek(t, n)
			if (i.childCount <= 1 && n > 0) {
				let a = t.size - n <= n + i.size
				this.unplaced = new Ue(xm(t, n - 1, 1), n - 1, a ? n - 1 : r)
			} else this.unplaced = new Ue(xm(t, n, 1), n, r)
		}
		placeNodes({ sliceDepth: t, frontierDepth: n, parent: r, inject: i, wrap: a }) {
			for (; this.depth > n; ) this.closeFrontierNode()
			if (a) for (let b = 0; b < a.length; b++) this.openFrontierNode(a[b])
			let o = this.unplaced,
				s = r ? r.content : o.content,
				l = o.openStart - t,
				u = 0,
				d = [],
				{ match: p, type: m } = this.frontier[n]
			if (i) {
				for (let b = 0; b < i.childCount; b++) d.push(i.child(b))
				p = p.matchFragment(i)
			}
			let v = s.size + t - (o.content.size - o.openEnd)
			for (; u < s.childCount; ) {
				let b = s.child(u),
					x = p.matchType(b.type)
				if (!x) break
				u++,
					(u > 1 || l == 0 || b.content.size) &&
						((p = x),
						d.push(q7(b.mark(m.allowedMarks(b.marks)), u == 1 ? l : 0, u == s.childCount ? v : -1)))
			}
			let y = u == s.childCount
			y || (v = -1),
				(this.placed = wm(this.placed, n, ke.from(d))),
				(this.frontier[n].match = p),
				y &&
					v < 0 &&
					r &&
					r.type == this.frontier[this.depth].type &&
					this.frontier.length > 1 &&
					this.closeFrontierNode()
			for (let b = 0, x = s; b < v; b++) {
				let E = x.lastChild
				this.frontier.push({ type: E.type, match: E.contentMatchAt(E.childCount) }), (x = E.content)
			}
			this.unplaced = y
				? t == 0
					? Ue.empty
					: new Ue(xm(o.content, t - 1, 1), t - 1, v < 0 ? o.openEnd : t - 1)
				: new Ue(xm(o.content, t, u), o.openStart, o.openEnd)
		}
		mustMoveInline() {
			if (!this.$to.parent.isTextblock) return -1
			let t = this.frontier[this.depth],
				n
			if (
				!t.type.isTextblock ||
				!tk(this.$to, this.$to.depth, t.type, t.match, !1) ||
				(this.$to.depth == this.depth &&
					(n = this.findCloseLevel(this.$to)) &&
					n.depth == this.depth)
			)
				return -1
			let { depth: r } = this.$to,
				i = this.$to.after(r)
			for (; r > 1 && i == this.$to.end(--r); ) ++i
			return i
		}
		findCloseLevel(t) {
			e: for (let n = Math.min(this.depth, t.depth); n >= 0; n--) {
				let { match: r, type: i } = this.frontier[n],
					a = n < t.depth && t.end(n + 1) == t.pos + (t.depth - (n + 1)),
					o = tk(t, n, i, r, a)
				if (o) {
					for (let s = n - 1; s >= 0; s--) {
						let { match: l, type: u } = this.frontier[s],
							d = tk(t, s, u, l, !0)
						if (!d || d.childCount) continue e
					}
					return { depth: n, fit: o, move: a ? t.doc.resolve(t.after(n + 1)) : t }
				}
			}
		}
		close(t) {
			let n = this.findCloseLevel(t)
			if (!n) return null
			for (; this.depth > n.depth; ) this.closeFrontierNode()
			n.fit.childCount && (this.placed = wm(this.placed, n.depth, n.fit)), (t = n.move)
			for (let r = n.depth + 1; r <= t.depth; r++) {
				let i = t.node(r),
					a = i.type.contentMatch.fillBefore(i.content, !0, t.index(r))
				this.openFrontierNode(i.type, i.attrs, a)
			}
			return t
		}
		openFrontierNode(t, n = null, r) {
			let i = this.frontier[this.depth]
			;(i.match = i.match.matchType(t)),
				(this.placed = wm(this.placed, this.depth, ke.from(t.create(n, r)))),
				this.frontier.push({ type: t, match: t.contentMatch })
		}
		closeFrontierNode() {
			let n = this.frontier.pop().match.fillBefore(ke.empty, !0)
			n.childCount && (this.placed = wm(this.placed, this.frontier.length, n))
		}
	}
	function xm(e, t, n) {
		return t == 0
			? e.cutByIndex(n, e.childCount)
			: e.replaceChild(0, e.firstChild.copy(xm(e.firstChild.content, t - 1, n)))
	}
	function wm(e, t, n) {
		return t == 0
			? e.append(n)
			: e.replaceChild(e.childCount - 1, e.lastChild.copy(wm(e.lastChild.content, t - 1, n)))
	}
	function ek(e, t) {
		for (let n = 0; n < t; n++) e = e.firstChild.content
		return e
	}
	function q7(e, t, n) {
		if (t <= 0) return e
		let r = e.content
		return (
			t > 1 && (r = r.replaceChild(0, q7(r.firstChild, t - 1, r.childCount == 1 ? n - 1 : 0))),
			t > 0 &&
				((r = e.type.contentMatch.fillBefore(r).append(r)),
				n <= 0 && (r = r.append(e.type.contentMatch.matchFragment(r).fillBefore(ke.empty, !0)))),
			e.copy(r)
		)
	}
	function tk(e, t, n, r, i) {
		let a = e.node(t),
			o = i ? e.indexAfter(t) : e.index(t)
		if (o == a.childCount && !n.compatibleContent(a.type)) return null
		let s = r.fillBefore(a.content, !0, o)
		return s && !Xve(n, a.content, o) ? s : null
	}
	function Xve(e, t, n) {
		for (let r = n; r < t.childCount; r++) if (!e.allowsMarks(t.child(r).marks)) return !0
		return !1
	}
	function Jve(e) {
		return e.spec.defining || e.spec.definingForContent
	}
	function Zve(e, t, n, r) {
		if (!r.size) return e.deleteRange(t, n)
		let i = e.doc.resolve(t),
			a = e.doc.resolve(n)
		if (z7(i, a, r)) return e.step(new hi(t, n, r))
		let o = W7(i, e.doc.resolve(n))
		o[o.length - 1] == 0 && o.pop()
		let s = -(i.depth + 1)
		o.unshift(s)
		for (let m = i.depth, v = i.pos - 1; m > 0; m--, v--) {
			let y = i.node(m).type.spec
			if (y.defining || y.definingAsContext || y.isolating) break
			o.indexOf(m) > -1 ? (s = m) : i.before(m) == v && o.splice(1, 0, -m)
		}
		let l = o.indexOf(s),
			u = [],
			d = r.openStart
		for (let m = r.content, v = 0; ; v++) {
			let y = m.firstChild
			if ((u.push(y), v == r.openStart)) break
			m = y.content
		}
		for (let m = d - 1; m >= 0; m--) {
			let v = u[m].type,
				y = Jve(v)
			if (y && i.node(l).type != v) d = m
			else if (y || !v.isTextblock) break
		}
		for (let m = r.openStart; m >= 0; m--) {
			let v = (m + d + 1) % (r.openStart + 1),
				y = u[v]
			if (y)
				for (let b = 0; b < o.length; b++) {
					let x = o[(b + l) % o.length],
						E = !0
					x < 0 && ((E = !1), (x = -x))
					let T = i.node(x - 1),
						C = i.index(x - 1)
					if (T.canReplaceWith(C, C, y.type, y.marks))
						return e.replace(
							i.before(x),
							E ? a.after(x) : n,
							new Ue(V7(r.content, 0, r.openStart, v), v, r.openEnd),
						)
				}
		}
		let p = e.steps.length
		for (let m = o.length - 1; m >= 0 && (e.replace(t, n, r), !(e.steps.length > p)); m--) {
			let v = o[m]
			v < 0 || ((t = i.before(v)), (n = a.after(v)))
		}
	}
	function V7(e, t, n, r, i) {
		if (t < n) {
			let a = e.firstChild
			e = e.replaceChild(0, a.copy(V7(a.content, t + 1, n, r, a)))
		}
		if (t > r) {
			let a = i.contentMatchAt(0),
				o = a.fillBefore(e).append(e)
			e = o.append(a.matchFragment(o).fillBefore(ke.empty, !0))
		}
		return e
	}
	function ege(e, t, n, r) {
		if (!r.isInline && t == n && e.doc.resolve(t).parent.content.size) {
			let i = Gve(e.doc, t, r.type)
			i != null && (t = n = i)
		}
		e.replaceRange(t, n, new Ue(ke.from(r), 0, 0))
	}
	function tge(e, t, n) {
		let r = e.doc.resolve(t),
			i = e.doc.resolve(n),
			a = W7(r, i)
		for (let o = 0; o < a.length; o++) {
			let s = a[o],
				l = o == a.length - 1
			if ((l && s == 0) || r.node(s).type.contentMatch.validEnd)
				return e.delete(r.start(s), i.end(s))
			if (s > 0 && (l || r.node(s - 1).canReplace(r.index(s - 1), i.indexAfter(s - 1))))
				return e.delete(r.before(s), i.after(s))
		}
		for (let o = 1; o <= r.depth && o <= i.depth; o++)
			if (t - r.start(o) == r.depth - o && n > r.end(o) && i.end(o) - n != i.depth - o)
				return e.delete(r.before(o), n)
		e.delete(t, n)
	}
	function W7(e, t) {
		let n = [],
			r = Math.min(e.depth, t.depth)
		for (let i = r; i >= 0; i--) {
			let a = e.start(i)
			if (
				a < e.pos - (e.depth - i) ||
				t.end(i) > t.pos + (t.depth - i) ||
				e.node(i).type.spec.isolating ||
				t.node(i).type.spec.isolating
			)
				break
			;(a == t.start(i) ||
				(i == e.depth &&
					i == t.depth &&
					e.parent.inlineContent &&
					t.parent.inlineContent &&
					i &&
					t.start(i - 1) == a - 1)) &&
				n.push(i)
		}
		return n
	}
	let dp = class extends Error {}
	dp = function e(t) {
		let n = Error.call(this, t)
		return (n.__proto__ = e.prototype), n
	}
	dp.prototype = Object.create(Error.prototype)
	dp.prototype.constructor = dp
	dp.prototype.name = "TransformError"
	class nge {
		constructor(t) {
			;(this.doc = t), (this.steps = []), (this.docs = []), (this.mapping = new Wf())
		}
		get before() {
			return this.docs.length ? this.docs[0] : this.doc
		}
		step(t) {
			let n = this.maybeStep(t)
			if (n.failed) throw new dp(n.failed)
			return this
		}
		maybeStep(t) {
			let n = t.apply(this.doc)
			return n.failed || this.addStep(t, n.doc), n
		}
		get docChanged() {
			return this.steps.length > 0
		}
		addStep(t, n) {
			this.docs.push(this.doc),
				this.steps.push(t),
				this.mapping.appendMap(t.getMap()),
				(this.doc = n)
		}
		replace(t, n = t, r = Ue.empty) {
			let i = bO(this.doc, t, n, r)
			return i && this.step(i), this
		}
		replaceWith(t, n, r) {
			return this.replace(t, n, new Ue(ke.from(r), 0, 0))
		}
		delete(t, n) {
			return this.replace(t, n, Ue.empty)
		}
		insert(t, n) {
			return this.replaceWith(t, t, n)
		}
		replaceRange(t, n, r) {
			return Zve(this, t, n, r), this
		}
		replaceRangeWith(t, n, r) {
			return ege(this, t, n, r), this
		}
		deleteRange(t, n) {
			return tge(this, t, n), this
		}
		lift(t, n) {
			return jve(this, t, n), this
		}
		join(t, n = 1) {
			return Yve(this, t, n), this
		}
		wrap(t, n) {
			return $ve(this, t, n), this
		}
		setBlockType(t, n = t, r, i = null) {
			return Uve(this, t, n, r, i), this
		}
		setNodeMarkup(t, n, r = null, i = []) {
			return qve(this, t, n, r, i), this
		}
		split(t, n = 1, r) {
			return Vve(this, t, n, r), this
		}
		addMark(t, n, r) {
			return Ive(this, t, n, r), this
		}
		removeMark(t, n, r) {
			return Rve(this, t, n, r), this
		}
		clearIncompatible(t, n, r) {
			return Lve(this, t, n, r), this
		}
	}
	const nk = Object.create(null)
	class _t {
		constructor(t, n, r) {
			;(this.$anchor = t), (this.$head = n), (this.ranges = r || [new Y7(t.min(n), t.max(n))])
		}
		get anchor() {
			return this.$anchor.pos
		}
		get head() {
			return this.$head.pos
		}
		get from() {
			return this.$from.pos
		}
		get to() {
			return this.$to.pos
		}
		get $from() {
			return this.ranges[0].$from
		}
		get $to() {
			return this.ranges[0].$to
		}
		get empty() {
			let t = this.ranges
			for (let n = 0; n < t.length; n++) if (t[n].$from.pos != t[n].$to.pos) return !1
			return !0
		}
		content() {
			return this.$from.doc.slice(this.from, this.to, !0)
		}
		replace(t, n = Ue.empty) {
			let r = n.content.lastChild,
				i = null
			for (let s = 0; s < n.openEnd; s++) (i = r), (r = r.lastChild)
			let a = t.steps.length,
				o = this.ranges
			for (let s = 0; s < o.length; s++) {
				let { $from: l, $to: u } = o[s],
					d = t.mapping.slice(a)
				t.replaceRange(d.map(l.pos), d.map(u.pos), s ? Ue.empty : n),
					s == 0 && p3(t, a, (r ? r.isInline : i && i.isTextblock) ? -1 : 1)
			}
		}
		replaceWith(t, n) {
			let r = t.steps.length,
				i = this.ranges
			for (let a = 0; a < i.length; a++) {
				let { $from: o, $to: s } = i[a],
					l = t.mapping.slice(r),
					u = l.map(o.pos),
					d = l.map(s.pos)
				a ? t.deleteRange(u, d) : (t.replaceRangeWith(u, d, n), p3(t, r, n.isInline ? -1 : 1))
			}
		}
		static findFrom(t, n, r = !1) {
			let i = t.parent.inlineContent ? new jt(t) : _f(t.node(0), t.parent, t.pos, t.index(), n, r)
			if (i) return i
			for (let a = t.depth - 1; a >= 0; a--) {
				let o =
					n < 0
						? _f(t.node(0), t.node(a), t.before(a + 1), t.index(a), n, r)
						: _f(t.node(0), t.node(a), t.after(a + 1), t.index(a) + 1, n, r)
				if (o) return o
			}
			return null
		}
		static near(t, n = 1) {
			return this.findFrom(t, n) || this.findFrom(t, -n) || new wi(t.node(0))
		}
		static atStart(t) {
			return _f(t, t, 0, 0, 1) || new wi(t)
		}
		static atEnd(t) {
			return _f(t, t, t.content.size, t.childCount, -1) || new wi(t)
		}
		static fromJSON(t, n) {
			if (!n || !n.type) throw new RangeError("Invalid input for Selection.fromJSON")
			let r = nk[n.type]
			if (!r) throw new RangeError(`No selection type ${n.type} defined`)
			return r.fromJSON(t, n)
		}
		static jsonID(t, n) {
			if (t in nk) throw new RangeError("Duplicate use of selection JSON ID " + t)
			return (nk[t] = n), (n.prototype.jsonID = t), n
		}
		getBookmark() {
			return jt.between(this.$anchor, this.$head).getBookmark()
		}
	}
	_t.prototype.visible = !0
	class Y7 {
		constructor(t, n) {
			;(this.$from = t), (this.$to = n)
		}
	}
	let d3 = !1
	function f3(e) {
		!d3 &&
			!e.parent.inlineContent &&
			((d3 = !0),
			console.warn(
				"TextSelection endpoint not pointing into a node with inline content (" +
					e.parent.type.name +
					")",
			))
	}
	class jt extends _t {
		constructor(t, n = t) {
			f3(t), f3(n), super(t, n)
		}
		get $cursor() {
			return this.$anchor.pos == this.$head.pos ? this.$head : null
		}
		map(t, n) {
			let r = t.resolve(n.map(this.head))
			if (!r.parent.inlineContent) return _t.near(r)
			let i = t.resolve(n.map(this.anchor))
			return new jt(i.parent.inlineContent ? i : r, r)
		}
		replace(t, n = Ue.empty) {
			if ((super.replace(t, n), n == Ue.empty)) {
				let r = this.$from.marksAcross(this.$to)
				r && t.ensureMarks(r)
			}
		}
		eq(t) {
			return t instanceof jt && t.anchor == this.anchor && t.head == this.head
		}
		getBookmark() {
			return new tw(this.anchor, this.head)
		}
		toJSON() {
			return { type: "text", anchor: this.anchor, head: this.head }
		}
		static fromJSON(t, n) {
			if (typeof n.anchor != "number" || typeof n.head != "number")
				throw new RangeError("Invalid input for TextSelection.fromJSON")
			return new jt(t.resolve(n.anchor), t.resolve(n.head))
		}
		static create(t, n, r = n) {
			let i = t.resolve(n)
			return new this(i, r == n ? i : t.resolve(r))
		}
		static between(t, n, r) {
			let i = t.pos - n.pos
			if (((!r || i) && (r = i >= 0 ? 1 : -1), !n.parent.inlineContent)) {
				let a = _t.findFrom(n, r, !0) || _t.findFrom(n, -r, !0)
				if (a) n = a.$head
				else return _t.near(n, r)
			}
			return (
				t.parent.inlineContent ||
					(i == 0
						? (t = n)
						: ((t = (_t.findFrom(t, -r, !0) || _t.findFrom(t, r, !0)).$anchor),
						  t.pos < n.pos != i < 0 && (t = n))),
				new jt(t, n)
			)
		}
	}
	_t.jsonID("text", jt)
	class tw {
		constructor(t, n) {
			;(this.anchor = t), (this.head = n)
		}
		map(t) {
			return new tw(t.map(this.anchor), t.map(this.head))
		}
		resolve(t) {
			return jt.between(t.resolve(this.anchor), t.resolve(this.head))
		}
	}
	class vt extends _t {
		constructor(t) {
			let n = t.nodeAfter,
				r = t.node(0).resolve(t.pos + n.nodeSize)
			super(t, r), (this.node = n)
		}
		map(t, n) {
			let { deleted: r, pos: i } = n.mapResult(this.anchor),
				a = t.resolve(i)
			return r ? _t.near(a) : new vt(a)
		}
		content() {
			return new Ue(ke.from(this.node), 0, 0)
		}
		eq(t) {
			return t instanceof vt && t.anchor == this.anchor
		}
		toJSON() {
			return { type: "node", anchor: this.anchor }
		}
		getBookmark() {
			return new xO(this.anchor)
		}
		static fromJSON(t, n) {
			if (typeof n.anchor != "number")
				throw new RangeError("Invalid input for NodeSelection.fromJSON")
			return new vt(t.resolve(n.anchor))
		}
		static create(t, n) {
			return new vt(t.resolve(n))
		}
		static isSelectable(t) {
			return !t.isText && t.type.spec.selectable !== !1
		}
	}
	vt.prototype.visible = !1
	_t.jsonID("node", vt)
	class xO {
		constructor(t) {
			this.anchor = t
		}
		map(t) {
			let { deleted: n, pos: r } = t.mapResult(this.anchor)
			return n ? new tw(r, r) : new xO(r)
		}
		resolve(t) {
			let n = t.resolve(this.anchor),
				r = n.nodeAfter
			return r && vt.isSelectable(r) ? new vt(n) : _t.near(n)
		}
	}
	class wi extends _t {
		constructor(t) {
			super(t.resolve(0), t.resolve(t.content.size))
		}
		replace(t, n = Ue.empty) {
			if (n == Ue.empty) {
				t.delete(0, t.doc.content.size)
				let r = _t.atStart(t.doc)
				r.eq(t.selection) || t.setSelection(r)
			} else super.replace(t, n)
		}
		toJSON() {
			return { type: "all" }
		}
		static fromJSON(t) {
			return new wi(t)
		}
		map(t) {
			return new wi(t)
		}
		eq(t) {
			return t instanceof wi
		}
		getBookmark() {
			return rge
		}
	}
	_t.jsonID("all", wi)
	const rge = {
		map() {
			return this
		},
		resolve(e) {
			return new wi(e)
		},
	}
	function _f(e, t, n, r, i, a = !1) {
		if (t.inlineContent) return jt.create(e, n)
		for (let o = r - (i > 0 ? 0 : 1); i > 0 ? o < t.childCount : o >= 0; o += i) {
			let s = t.child(o)
			if (s.isAtom) {
				if (!a && vt.isSelectable(s)) return vt.create(e, n - (i < 0 ? s.nodeSize : 0))
			} else {
				let l = _f(e, s, n + i, i < 0 ? s.childCount : 0, i, a)
				if (l) return l
			}
			n += s.nodeSize * i
		}
		return null
	}
	function p3(e, t, n) {
		let r = e.steps.length - 1
		if (r < t) return
		let i = e.steps[r]
		if (!(i instanceof hi || i instanceof Ar)) return
		let a = e.mapping.maps[r],
			o
		a.forEach((s, l, u, d) => {
			o == null && (o = d)
		}),
			e.setSelection(_t.near(e.doc.resolve(o), n))
	}
	const h3 = 1,
		ry = 2,
		m3 = 4
	class ige extends nge {
		constructor(t) {
			super(t.doc),
				(this.curSelectionFor = 0),
				(this.updated = 0),
				(this.meta = Object.create(null)),
				(this.time = Date.now()),
				(this.curSelection = t.selection),
				(this.storedMarks = t.storedMarks)
		}
		get selection() {
			return (
				this.curSelectionFor < this.steps.length &&
					((this.curSelection = this.curSelection.map(
						this.doc,
						this.mapping.slice(this.curSelectionFor),
					)),
					(this.curSelectionFor = this.steps.length)),
				this.curSelection
			)
		}
		setSelection(t) {
			if (t.$from.doc != this.doc)
				throw new RangeError("Selection passed to setSelection must point at the current document")
			return (
				(this.curSelection = t),
				(this.curSelectionFor = this.steps.length),
				(this.updated = (this.updated | h3) & ~ry),
				(this.storedMarks = null),
				this
			)
		}
		get selectionSet() {
			return (this.updated & h3) > 0
		}
		setStoredMarks(t) {
			return (this.storedMarks = t), (this.updated |= ry), this
		}
		ensureMarks(t) {
			return (
				tn.sameSet(this.storedMarks || this.selection.$from.marks(), t) || this.setStoredMarks(t),
				this
			)
		}
		addStoredMark(t) {
			return this.ensureMarks(t.addToSet(this.storedMarks || this.selection.$head.marks()))
		}
		removeStoredMark(t) {
			return this.ensureMarks(t.removeFromSet(this.storedMarks || this.selection.$head.marks()))
		}
		get storedMarksSet() {
			return (this.updated & ry) > 0
		}
		addStep(t, n) {
			super.addStep(t, n), (this.updated = this.updated & ~ry), (this.storedMarks = null)
		}
		setTime(t) {
			return (this.time = t), this
		}
		replaceSelection(t) {
			return this.selection.replace(this, t), this
		}
		replaceSelectionWith(t, n = !0) {
			let r = this.selection
			return (
				n &&
					(t = t.mark(
						this.storedMarks || (r.empty ? r.$from.marks() : r.$from.marksAcross(r.$to) || tn.none),
					)),
				r.replaceWith(this, t),
				this
			)
		}
		deleteSelection() {
			return this.selection.replace(this), this
		}
		insertText(t, n, r) {
			let i = this.doc.type.schema
			if (n == null) return t ? this.replaceSelectionWith(i.text(t), !0) : this.deleteSelection()
			{
				if ((r == null && (r = n), (r = r ?? n), !t)) return this.deleteRange(n, r)
				let a = this.storedMarks
				if (!a) {
					let o = this.doc.resolve(n)
					a = r == n ? o.marks() : o.marksAcross(this.doc.resolve(r))
				}
				return (
					this.replaceRangeWith(n, r, i.text(t, a)),
					this.selection.empty || this.setSelection(_t.near(this.selection.$to)),
					this
				)
			}
		}
		setMeta(t, n) {
			return (this.meta[typeof t == "string" ? t : t.key] = n), this
		}
		getMeta(t) {
			return this.meta[typeof t == "string" ? t : t.key]
		}
		get isGeneric() {
			for (let t in this.meta) return !1
			return !0
		}
		scrollIntoView() {
			return (this.updated |= m3), this
		}
		get scrolledIntoView() {
			return (this.updated & m3) > 0
		}
	}
	function v3(e, t) {
		return !t || !e ? e : e.bind(t)
	}
	class Em {
		constructor(t, n, r) {
			;(this.name = t), (this.init = v3(n.init, r)), (this.apply = v3(n.apply, r))
		}
	}
	const age = [
		new Em("doc", {
			init(e) {
				return e.doc || e.schema.topNodeType.createAndFill()
			},
			apply(e) {
				return e.doc
			},
		}),
		new Em("selection", {
			init(e, t) {
				return e.selection || _t.atStart(t.doc)
			},
			apply(e) {
				return e.selection
			},
		}),
		new Em("storedMarks", {
			init(e) {
				return e.storedMarks || null
			},
			apply(e, t, n, r) {
				return r.selection.$cursor ? e.storedMarks : null
			},
		}),
		new Em("scrollToSelection", {
			init() {
				return 0
			},
			apply(e, t) {
				return e.scrolledIntoView ? t + 1 : t
			},
		}),
	]
	class rk {
		constructor(t, n) {
			;(this.schema = t),
				(this.plugins = []),
				(this.pluginsByKey = Object.create(null)),
				(this.fields = age.slice()),
				n &&
					n.forEach((r) => {
						if (this.pluginsByKey[r.key])
							throw new RangeError("Adding different instances of a keyed plugin (" + r.key + ")")
						this.plugins.push(r),
							(this.pluginsByKey[r.key] = r),
							r.spec.state && this.fields.push(new Em(r.key, r.spec.state, r))
					})
		}
	}
	class Bc {
		constructor(t) {
			this.config = t
		}
		get schema() {
			return this.config.schema
		}
		get plugins() {
			return this.config.plugins
		}
		apply(t) {
			return this.applyTransaction(t).state
		}
		filterTransaction(t, n = -1) {
			for (let r = 0; r < this.config.plugins.length; r++)
				if (r != n) {
					let i = this.config.plugins[r]
					if (i.spec.filterTransaction && !i.spec.filterTransaction.call(i, t, this)) return !1
				}
			return !0
		}
		applyTransaction(t) {
			if (!this.filterTransaction(t)) return { state: this, transactions: [] }
			let n = [t],
				r = this.applyInner(t),
				i = null
			for (;;) {
				let a = !1
				for (let o = 0; o < this.config.plugins.length; o++) {
					let s = this.config.plugins[o]
					if (s.spec.appendTransaction) {
						let l = i ? i[o].n : 0,
							u = i ? i[o].state : this,
							d = l < n.length && s.spec.appendTransaction.call(s, l ? n.slice(l) : n, u, r)
						if (d && r.filterTransaction(d, o)) {
							if ((d.setMeta("appendedTransaction", t), !i)) {
								i = []
								for (let p = 0; p < this.config.plugins.length; p++)
									i.push(p < o ? { state: r, n: n.length } : { state: this, n: 0 })
							}
							n.push(d), (r = r.applyInner(d)), (a = !0)
						}
						i && (i[o] = { state: r, n: n.length })
					}
				}
				if (!a) return { state: r, transactions: n }
			}
		}
		applyInner(t) {
			if (!t.before.eq(this.doc)) throw new RangeError("Applying a mismatched transaction")
			let n = new Bc(this.config),
				r = this.config.fields
			for (let i = 0; i < r.length; i++) {
				let a = r[i]
				n[a.name] = a.apply(t, this[a.name], this, n)
			}
			return n
		}
		get tr() {
			return new ige(this)
		}
		static create(t) {
			let n = new rk(t.doc ? t.doc.type.schema : t.schema, t.plugins),
				r = new Bc(n)
			for (let i = 0; i < n.fields.length; i++) r[n.fields[i].name] = n.fields[i].init(t, r)
			return r
		}
		reconfigure(t) {
			let n = new rk(this.schema, t.plugins),
				r = n.fields,
				i = new Bc(n)
			for (let a = 0; a < r.length; a++) {
				let o = r[a].name
				i[o] = this.hasOwnProperty(o) ? this[o] : r[a].init(t, i)
			}
			return i
		}
		toJSON(t) {
			let n = { doc: this.doc.toJSON(), selection: this.selection.toJSON() }
			if (
				(this.storedMarks && (n.storedMarks = this.storedMarks.map((r) => r.toJSON())),
				t && typeof t == "object")
			)
				for (let r in t) {
					if (r == "doc" || r == "selection")
						throw new RangeError("The JSON fields `doc` and `selection` are reserved")
					let i = t[r],
						a = i.spec.state
					a && a.toJSON && (n[r] = a.toJSON.call(i, this[i.key]))
				}
			return n
		}
		static fromJSON(t, n, r) {
			if (!n) throw new RangeError("Invalid input for EditorState.fromJSON")
			if (!t.schema) throw new RangeError("Required config field 'schema' missing")
			let i = new rk(t.schema, t.plugins),
				a = new Bc(i)
			return (
				i.fields.forEach((o) => {
					if (o.name == "doc") a.doc = Tu.fromJSON(t.schema, n.doc)
					else if (o.name == "selection") a.selection = _t.fromJSON(a.doc, n.selection)
					else if (o.name == "storedMarks")
						n.storedMarks && (a.storedMarks = n.storedMarks.map(t.schema.markFromJSON))
					else {
						if (r)
							for (let s in r) {
								let l = r[s],
									u = l.spec.state
								if (
									l.key == o.name &&
									u &&
									u.fromJSON &&
									Object.prototype.hasOwnProperty.call(n, s)
								) {
									a[o.name] = u.fromJSON.call(l, t, n[s], a)
									return
								}
							}
						a[o.name] = o.init(t, a)
					}
				}),
				a
			)
		}
	}
	function G7(e, t, n) {
		for (let r in e) {
			let i = e[r]
			i instanceof Function ? (i = i.bind(t)) : r == "handleDOMEvents" && (i = G7(i, t, {})),
				(n[r] = i)
		}
		return n
	}
	class Ki {
		constructor(t) {
			;(this.spec = t),
				(this.props = {}),
				t.props && G7(t.props, this, this.props),
				(this.key = t.key ? t.key.key : K7("plugin"))
		}
		getState(t) {
			return t[this.key]
		}
	}
	const ik = Object.create(null)
	function K7(e) {
		return e in ik ? e + "$" + ++ik[e] : ((ik[e] = 0), e + "$")
	}
	class dg {
		constructor(t = "key") {
			this.key = K7(t)
		}
		get(t) {
			return t.config.pluginsByKey[this.key]
		}
		getState(t) {
			return t[this.key]
		}
	}
	const Bu = typeof navigator < "u" ? navigator : null,
		g3 = typeof document < "u" ? document : null,
		Ju = (Bu && Bu.userAgent) || "",
		C2 = /Edge\/(\d+)/.exec(Ju),
		Q7 = /MSIE \d/.exec(Ju),
		T2 = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(Ju),
		ma = !!(Q7 || T2 || C2),
		ku = Q7 ? document.documentMode : T2 ? +T2[1] : C2 ? +C2[1] : 0,
		ms = !ma && /gecko\/(\d+)/i.test(Ju)
	ms && +(/Firefox\/(\d+)/.exec(Ju) || [0, 0])[1]
	const k2 = !ma && /Chrome\/(\d+)/.exec(Ju),
		yi = !!k2,
		oge = k2 ? +k2[1] : 0,
		Wi = !ma && !!Bu && /Apple Computer/.test(Bu.vendor),
		fp = Wi && (/Mobile\/\w+/.test(Ju) || (!!Bu && Bu.maxTouchPoints > 2)),
		Pa = fp || (Bu ? /Mac/.test(Bu.platform) : !1),
		Zo = /Android \d/.test(Ju),
		nw = !!g3 && "webkitFontSmoothing" in g3.documentElement.style,
		sge = nw ? +(/\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1] : 0,
		aa = function (e) {
			for (var t = 0; ; t++) if (((e = e.previousSibling), !e)) return t
		},
		wO = function (e) {
			let t = e.assignedSlot || e.parentNode
			return t && t.nodeType == 11 ? t.host : t
		}
	let y3 = null
	const Gs = function (e, t, n) {
			let r = y3 || (y3 = document.createRange())
			return r.setEnd(e, n ?? e.nodeValue.length), r.setStart(e, t || 0), r
		},
		Sv = function (e, t, n, r) {
			return n && (b3(e, t, n, r, -1) || b3(e, t, n, r, 1))
		},
		lge = /^(img|br|input|textarea|hr)$/i
	function b3(e, t, n, r, i) {
		for (;;) {
			if (e == n && t == r) return !0
			if (t == (i < 0 ? 0 : es(e))) {
				let a = e.parentNode
				if (!a || a.nodeType != 1 || cge(e) || lge.test(e.nodeName) || e.contentEditable == "false")
					return !1
				;(t = aa(e) + (i < 0 ? 0 : 1)), (e = a)
			} else if (e.nodeType == 1) {
				if (((e = e.childNodes[t + (i < 0 ? -1 : 0)]), e.contentEditable == "false")) return !1
				t = i < 0 ? es(e) : 0
			} else return !1
		}
	}
	function es(e) {
		return e.nodeType == 3 ? e.nodeValue.length : e.childNodes.length
	}
	function uge(e, t, n) {
		for (let r = t == 0, i = t == es(e); r || i; ) {
			if (e == n) return !0
			let a = aa(e)
			if (((e = e.parentNode), !e)) return !1
			;(r = r && a == 0), (i = i && a == es(e))
		}
	}
	function cge(e) {
		let t
		for (let n = e; n && !(t = n.pmViewDesc); n = n.parentNode);
		return t && t.node && t.node.isBlock && (t.dom == e || t.contentDOM == e)
	}
	const EO = function (e) {
		let t = e.isCollapsed
		return t && yi && e.rangeCount && !e.getRangeAt(0).collapsed && (t = !1), t
	}
	function jf(e, t) {
		let n = document.createEvent("Event")
		return n.initEvent("keydown", !0, !0), (n.keyCode = e), (n.key = n.code = t), n
	}
	function dge(e) {
		return {
			left: 0,
			right: e.documentElement.clientWidth,
			top: 0,
			bottom: e.documentElement.clientHeight,
		}
	}
	function ru(e, t) {
		return typeof e == "number" ? e : e[t]
	}
	function fge(e) {
		let t = e.getBoundingClientRect(),
			n = t.width / e.offsetWidth || 1,
			r = t.height / e.offsetHeight || 1
		return {
			left: t.left,
			right: t.left + e.clientWidth * n,
			top: t.top,
			bottom: t.top + e.clientHeight * r,
		}
	}
	function x3(e, t, n) {
		let r = e.someProp("scrollThreshold") || 0,
			i = e.someProp("scrollMargin") || 5,
			a = e.dom.ownerDocument
		for (let o = n || e.dom; o; o = wO(o)) {
			if (o.nodeType != 1) continue
			let s = o,
				l = s == a.body,
				u = l ? dge(a) : fge(s),
				d = 0,
				p = 0
			if (
				(t.top < u.top + ru(r, "top")
					? (p = -(u.top - t.top + ru(i, "top")))
					: t.bottom > u.bottom - ru(r, "bottom") && (p = t.bottom - u.bottom + ru(i, "bottom")),
				t.left < u.left + ru(r, "left")
					? (d = -(u.left - t.left + ru(i, "left")))
					: t.right > u.right - ru(r, "right") && (d = t.right - u.right + ru(i, "right")),
				d || p)
			)
				if (l) a.defaultView.scrollBy(d, p)
				else {
					let m = s.scrollLeft,
						v = s.scrollTop
					p && (s.scrollTop += p), d && (s.scrollLeft += d)
					let y = s.scrollLeft - m,
						b = s.scrollTop - v
					t = { left: t.left - y, top: t.top - b, right: t.right - y, bottom: t.bottom - b }
				}
			if (l) break
		}
	}
	function pge(e) {
		let t = e.dom.getBoundingClientRect(),
			n = Math.max(0, t.top),
			r,
			i
		for (let a = (t.left + t.right) / 2, o = n + 1; o < Math.min(innerHeight, t.bottom); o += 5) {
			let s = e.root.elementFromPoint(a, o)
			if (!s || s == e.dom || !e.dom.contains(s)) continue
			let l = s.getBoundingClientRect()
			if (l.top >= n - 20) {
				;(r = s), (i = l.top)
				break
			}
		}
		return { refDOM: r, refTop: i, stack: X7(e.dom) }
	}
	function X7(e) {
		let t = [],
			n = e.ownerDocument
		for (
			let r = e;
			r && (t.push({ dom: r, top: r.scrollTop, left: r.scrollLeft }), e != n);
			r = wO(r)
		);
		return t
	}
	function hge({ refDOM: e, refTop: t, stack: n }) {
		let r = e ? e.getBoundingClientRect().top : 0
		J7(n, r == 0 ? 0 : r - t)
	}
	function J7(e, t) {
		for (let n = 0; n < e.length; n++) {
			let { dom: r, top: i, left: a } = e[n]
			r.scrollTop != i + t && (r.scrollTop = i + t), r.scrollLeft != a && (r.scrollLeft = a)
		}
	}
	let bf = null
	function mge(e) {
		if (e.setActive) return e.setActive()
		if (bf) return e.focus(bf)
		let t = X7(e)
		e.focus(
			bf == null
				? {
						get preventScroll() {
							return (bf = { preventScroll: !0 }), !0
						},
				  }
				: void 0,
		),
			bf || ((bf = !1), J7(t, 0))
	}
	function Z7(e, t) {
		let n,
			r = 2e8,
			i,
			a = 0,
			o = t.top,
			s = t.top
		for (let l = e.firstChild, u = 0; l; l = l.nextSibling, u++) {
			let d
			if (l.nodeType == 1) d = l.getClientRects()
			else if (l.nodeType == 3) d = Gs(l).getClientRects()
			else continue
			for (let p = 0; p < d.length; p++) {
				let m = d[p]
				if (m.top <= o && m.bottom >= s) {
					;(o = Math.max(m.bottom, o)), (s = Math.min(m.top, s))
					let v = m.left > t.left ? m.left - t.left : m.right < t.left ? t.left - m.right : 0
					if (v < r) {
						;(n = l),
							(r = v),
							(i =
								v && n.nodeType == 3
									? { left: m.right < t.left ? m.right : m.left, top: t.top }
									: t),
							l.nodeType == 1 && v && (a = u + (t.left >= (m.left + m.right) / 2 ? 1 : 0))
						continue
					}
				}
				!n &&
					((t.left >= m.right && t.top >= m.top) || (t.left >= m.left && t.top >= m.bottom)) &&
					(a = u + 1)
			}
		}
		return n && n.nodeType == 3
			? vge(n, i)
			: !n || (r && n.nodeType == 1)
			? { node: e, offset: a }
			: Z7(n, i)
	}
	function vge(e, t) {
		let n = e.nodeValue.length,
			r = document.createRange()
		for (let i = 0; i < n; i++) {
			r.setEnd(e, i + 1), r.setStart(e, i)
			let a = cu(r, 1)
			if (a.top != a.bottom && CO(t, a))
				return { node: e, offset: i + (t.left >= (a.left + a.right) / 2 ? 1 : 0) }
		}
		return { node: e, offset: 0 }
	}
	function CO(e, t) {
		return (
			e.left >= t.left - 1 && e.left <= t.right + 1 && e.top >= t.top - 1 && e.top <= t.bottom + 1
		)
	}
	function gge(e, t) {
		let n = e.parentNode
		return n && /^li$/i.test(n.nodeName) && t.left < e.getBoundingClientRect().left ? n : e
	}
	function yge(e, t, n) {
		let { node: r, offset: i } = Z7(t, n),
			a = -1
		if (r.nodeType == 1 && !r.firstChild) {
			let o = r.getBoundingClientRect()
			a = o.left != o.right && n.left > (o.left + o.right) / 2 ? 1 : -1
		}
		return e.docView.posFromDOM(r, i, a)
	}
	function bge(e, t, n, r) {
		let i = -1
		for (let a = t; a != e.dom; ) {
			let o = e.docView.nearestDesc(a, !0)
			if (!o) return null
			if (o.node.isBlock && o.parent) {
				let s = o.dom.getBoundingClientRect()
				if (s.left > r.left || s.top > r.top) i = o.posBefore
				else if (s.right < r.left || s.bottom < r.top) i = o.posAfter
				else break
			}
			a = o.dom.parentNode
		}
		return i > -1 ? i : e.docView.posFromDOM(t, n, 1)
	}
	function eU(e, t, n) {
		let r = e.childNodes.length
		if (r && n.top < n.bottom)
			for (
				let i = Math.max(
						0,
						Math.min(r - 1, Math.floor((r * (t.top - n.top)) / (n.bottom - n.top)) - 2),
					),
					a = i;
				;

			) {
				let o = e.childNodes[a]
				if (o.nodeType == 1) {
					let s = o.getClientRects()
					for (let l = 0; l < s.length; l++) {
						let u = s[l]
						if (CO(t, u)) return eU(o, t, u)
					}
				}
				if ((a = (a + 1) % r) == i) break
			}
		return e
	}
	function xge(e, t) {
		let n = e.dom.ownerDocument,
			r,
			i = 0
		if (n.caretPositionFromPoint)
			try {
				let l = n.caretPositionFromPoint(t.left, t.top)
				l && ({ offsetNode: r, offset: i } = l)
			} catch {}
		if (!r && n.caretRangeFromPoint) {
			let l = n.caretRangeFromPoint(t.left, t.top)
			l && ({ startContainer: r, startOffset: i } = l)
		}
		let a = (e.root.elementFromPoint ? e.root : n).elementFromPoint(t.left, t.top),
			o
		if (!a || !e.dom.contains(a.nodeType != 1 ? a.parentNode : a)) {
			let l = e.dom.getBoundingClientRect()
			if (!CO(t, l) || ((a = eU(e.dom, t, l)), !a)) return null
		}
		if (Wi) for (let l = a; r && l; l = wO(l)) l.draggable && (r = void 0)
		if (((a = gge(a, t)), r)) {
			if (
				ms &&
				r.nodeType == 1 &&
				((i = Math.min(i, r.childNodes.length)), i < r.childNodes.length)
			) {
				let l = r.childNodes[i],
					u
				l.nodeName == "IMG" &&
					(u = l.getBoundingClientRect()).right <= t.left &&
					u.bottom > t.top &&
					i++
			}
			r == e.dom &&
			i == r.childNodes.length - 1 &&
			r.lastChild.nodeType == 1 &&
			t.top > r.lastChild.getBoundingClientRect().bottom
				? (o = e.state.doc.content.size)
				: (i == 0 || r.nodeType != 1 || r.childNodes[i - 1].nodeName != "BR") &&
				  (o = bge(e, r, i, t))
		}
		o == null && (o = yge(e, a, t))
		let s = e.docView.nearestDesc(a, !0)
		return { pos: o, inside: s ? s.posAtStart - s.border : -1 }
	}
	function cu(e, t) {
		let n = e.getClientRects()
		return n.length ? n[t < 0 ? 0 : n.length - 1] : e.getBoundingClientRect()
	}
	const wge = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/
	function tU(e, t, n) {
		let { node: r, offset: i, atom: a } = e.docView.domFromPos(t, n < 0 ? -1 : 1),
			o = nw || ms
		if (r.nodeType == 3)
			if (o && (wge.test(r.nodeValue) || (n < 0 ? !i : i == r.nodeValue.length))) {
				let l = cu(Gs(r, i, i), n)
				if (ms && i && /\s/.test(r.nodeValue[i - 1]) && i < r.nodeValue.length) {
					let u = cu(Gs(r, i - 1, i - 1), -1)
					if (u.top == l.top) {
						let d = cu(Gs(r, i, i + 1), -1)
						if (d.top != l.top) return rm(d, d.left < u.left)
					}
				}
				return l
			} else {
				let l = i,
					u = i,
					d = n < 0 ? 1 : -1
				return (
					n < 0 && !i
						? (u++, (d = -1))
						: n >= 0 && i == r.nodeValue.length
						? (l--, (d = 1))
						: n < 0
						? l--
						: u++,
					rm(cu(Gs(r, l, u), d), d < 0)
				)
			}
		if (!e.state.doc.resolve(t - (a || 0)).parent.inlineContent) {
			if (a == null && i && (n < 0 || i == es(r))) {
				let l = r.childNodes[i - 1]
				if (l.nodeType == 1) return ak(l.getBoundingClientRect(), !1)
			}
			if (a == null && i < es(r)) {
				let l = r.childNodes[i]
				if (l.nodeType == 1) return ak(l.getBoundingClientRect(), !0)
			}
			return ak(r.getBoundingClientRect(), n >= 0)
		}
		if (a == null && i && (n < 0 || i == es(r))) {
			let l = r.childNodes[i - 1],
				u =
					l.nodeType == 3
						? Gs(l, es(l) - (o ? 0 : 1))
						: l.nodeType == 1 && (l.nodeName != "BR" || !l.nextSibling)
						? l
						: null
			if (u) return rm(cu(u, 1), !1)
		}
		if (a == null && i < es(r)) {
			let l = r.childNodes[i]
			for (; l.pmViewDesc && l.pmViewDesc.ignoreForCoords; ) l = l.nextSibling
			let u = l ? (l.nodeType == 3 ? Gs(l, 0, o ? 0 : 1) : l.nodeType == 1 ? l : null) : null
			if (u) return rm(cu(u, -1), !0)
		}
		return rm(cu(r.nodeType == 3 ? Gs(r) : r, -n), n >= 0)
	}
	function rm(e, t) {
		if (e.width == 0) return e
		let n = t ? e.left : e.right
		return { top: e.top, bottom: e.bottom, left: n, right: n }
	}
	function ak(e, t) {
		if (e.height == 0) return e
		let n = t ? e.top : e.bottom
		return { top: n, bottom: n, left: e.left, right: e.right }
	}
	function nU(e, t, n) {
		let r = e.state,
			i = e.root.activeElement
		r != t && e.updateState(t), i != e.dom && e.focus()
		try {
			return n()
		} finally {
			r != t && e.updateState(r), i != e.dom && i && i.focus()
		}
	}
	function Ege(e, t, n) {
		let r = t.selection,
			i = n == "up" ? r.$from : r.$to
		return nU(e, t, () => {
			let { node: a } = e.docView.domFromPos(i.pos, n == "up" ? -1 : 1)
			for (;;) {
				let s = e.docView.nearestDesc(a, !0)
				if (!s) break
				if (s.node.isBlock) {
					a = s.dom
					break
				}
				a = s.dom.parentNode
			}
			let o = tU(e, i.pos, 1)
			for (let s = a.firstChild; s; s = s.nextSibling) {
				let l
				if (s.nodeType == 1) l = s.getClientRects()
				else if (s.nodeType == 3) l = Gs(s, 0, s.nodeValue.length).getClientRects()
				else continue
				for (let u = 0; u < l.length; u++) {
					let d = l[u]
					if (
						d.bottom > d.top + 1 &&
						(n == "up"
							? o.top - d.top > (d.bottom - o.top) * 2
							: d.bottom - o.bottom > (o.bottom - d.top) * 2)
					)
						return !1
				}
			}
			return !0
		})
	}
	const Cge = /[\u0590-\u08ac]/
	function Tge(e, t, n) {
		let { $head: r } = t.selection
		if (!r.parent.isTextblock) return !1
		let i = r.parentOffset,
			a = !i,
			o = i == r.parent.content.size,
			s = e.domSelection()
		return !Cge.test(r.parent.textContent) || !s.modify
			? n == "left" || n == "backward"
				? a
				: o
			: nU(e, t, () => {
					let l = s.getRangeAt(0),
						u = s.focusNode,
						d = s.focusOffset,
						p = s.caretBidiLevel
					s.modify("move", n, "character")
					let v =
						!(r.depth ? e.docView.domAfterPos(r.before()) : e.dom).contains(
							s.focusNode.nodeType == 1 ? s.focusNode : s.focusNode.parentNode,
						) ||
						(u == s.focusNode && d == s.focusOffset)
					return s.removeAllRanges(), s.addRange(l), p != null && (s.caretBidiLevel = p), v
			  })
	}
	let w3 = null,
		E3 = null,
		C3 = !1
	function kge(e, t, n) {
		return w3 == t && E3 == n
			? C3
			: ((w3 = t), (E3 = n), (C3 = n == "up" || n == "down" ? Ege(e, t, n) : Tge(e, t, n)))
	}
	const wo = 0,
		T3 = 1,
		Ff = 2,
		vs = 3
	class fg {
		constructor(t, n, r, i) {
			;(this.parent = t),
				(this.children = n),
				(this.dom = r),
				(this.contentDOM = i),
				(this.dirty = wo),
				(r.pmViewDesc = this)
		}
		matchesWidget(t) {
			return !1
		}
		matchesMark(t) {
			return !1
		}
		matchesNode(t, n, r) {
			return !1
		}
		matchesHack(t) {
			return !1
		}
		parseRule() {
			return null
		}
		stopEvent(t) {
			return !1
		}
		get size() {
			let t = 0
			for (let n = 0; n < this.children.length; n++) t += this.children[n].size
			return t
		}
		get border() {
			return 0
		}
		destroy() {
			;(this.parent = void 0), this.dom.pmViewDesc == this && (this.dom.pmViewDesc = void 0)
			for (let t = 0; t < this.children.length; t++) this.children[t].destroy()
		}
		posBeforeChild(t) {
			for (let n = 0, r = this.posAtStart; ; n++) {
				let i = this.children[n]
				if (i == t) return r
				r += i.size
			}
		}
		get posBefore() {
			return this.parent.posBeforeChild(this)
		}
		get posAtStart() {
			return this.parent ? this.parent.posBeforeChild(this) + this.border : 0
		}
		get posAfter() {
			return this.posBefore + this.size
		}
		get posAtEnd() {
			return this.posAtStart + this.size - 2 * this.border
		}
		localPosFromDOM(t, n, r) {
			if (this.contentDOM && this.contentDOM.contains(t.nodeType == 1 ? t : t.parentNode))
				if (r < 0) {
					let a, o
					if (t == this.contentDOM) a = t.childNodes[n - 1]
					else {
						for (; t.parentNode != this.contentDOM; ) t = t.parentNode
						a = t.previousSibling
					}
					for (; a && !((o = a.pmViewDesc) && o.parent == this); ) a = a.previousSibling
					return a ? this.posBeforeChild(o) + o.size : this.posAtStart
				} else {
					let a, o
					if (t == this.contentDOM) a = t.childNodes[n]
					else {
						for (; t.parentNode != this.contentDOM; ) t = t.parentNode
						a = t.nextSibling
					}
					for (; a && !((o = a.pmViewDesc) && o.parent == this); ) a = a.nextSibling
					return a ? this.posBeforeChild(o) : this.posAtEnd
				}
			let i
			if (t == this.dom && this.contentDOM) i = n > aa(this.contentDOM)
			else if (this.contentDOM && this.contentDOM != this.dom && this.dom.contains(this.contentDOM))
				i = t.compareDocumentPosition(this.contentDOM) & 2
			else if (this.dom.firstChild) {
				if (n == 0)
					for (let a = t; ; a = a.parentNode) {
						if (a == this.dom) {
							i = !1
							break
						}
						if (a.previousSibling) break
					}
				if (i == null && n == t.childNodes.length)
					for (let a = t; ; a = a.parentNode) {
						if (a == this.dom) {
							i = !0
							break
						}
						if (a.nextSibling) break
					}
			}
			return i ?? r > 0 ? this.posAtEnd : this.posAtStart
		}
		nearestDesc(t, n = !1) {
			for (let r = !0, i = t; i; i = i.parentNode) {
				let a = this.getDesc(i),
					o
				if (a && (!n || a.node))
					if (
						r &&
						(o = a.nodeDOM) &&
						!(o.nodeType == 1 ? o.contains(t.nodeType == 1 ? t : t.parentNode) : o == t)
					)
						r = !1
					else return a
			}
		}
		getDesc(t) {
			let n = t.pmViewDesc
			for (let r = n; r; r = r.parent) if (r == this) return n
		}
		posFromDOM(t, n, r) {
			for (let i = t; i; i = i.parentNode) {
				let a = this.getDesc(i)
				if (a) return a.localPosFromDOM(t, n, r)
			}
			return -1
		}
		descAt(t) {
			for (let n = 0, r = 0; n < this.children.length; n++) {
				let i = this.children[n],
					a = r + i.size
				if (r == t && a != r) {
					for (; !i.border && i.children.length; ) i = i.children[0]
					return i
				}
				if (t < a) return i.descAt(t - r - i.border)
				r = a
			}
		}
		domFromPos(t, n) {
			if (!this.contentDOM) return { node: this.dom, offset: 0, atom: t + 1 }
			let r = 0,
				i = 0
			for (let a = 0; r < this.children.length; r++) {
				let o = this.children[r],
					s = a + o.size
				if (s > t || o instanceof iU) {
					i = t - a
					break
				}
				a = s
			}
			if (i) return this.children[r].domFromPos(i - this.children[r].border, n)
			for (let a; r && !(a = this.children[r - 1]).size && a instanceof rU && a.side >= 0; r--);
			if (n <= 0) {
				let a,
					o = !0
				for (
					;
					(a = r ? this.children[r - 1] : null), !(!a || a.dom.parentNode == this.contentDOM);
					r--, o = !1
				);
				return a && n && o && !a.border && !a.domAtom
					? a.domFromPos(a.size, n)
					: { node: this.contentDOM, offset: a ? aa(a.dom) + 1 : 0 }
			} else {
				let a,
					o = !0
				for (
					;
					(a = r < this.children.length ? this.children[r] : null),
						!(!a || a.dom.parentNode == this.contentDOM);
					r++, o = !1
				);
				return a && o && !a.border && !a.domAtom
					? a.domFromPos(0, n)
					: { node: this.contentDOM, offset: a ? aa(a.dom) : this.contentDOM.childNodes.length }
			}
		}
		parseRange(t, n, r = 0) {
			if (this.children.length == 0)
				return {
					node: this.contentDOM,
					from: t,
					to: n,
					fromOffset: 0,
					toOffset: this.contentDOM.childNodes.length,
				}
			let i = -1,
				a = -1
			for (let o = r, s = 0; ; s++) {
				let l = this.children[s],
					u = o + l.size
				if (i == -1 && t <= u) {
					let d = o + l.border
					if (
						t >= d &&
						n <= u - l.border &&
						l.node &&
						l.contentDOM &&
						this.contentDOM.contains(l.contentDOM)
					)
						return l.parseRange(t, n, d)
					t = o
					for (let p = s; p > 0; p--) {
						let m = this.children[p - 1]
						if (m.size && m.dom.parentNode == this.contentDOM && !m.emptyChildAt(1)) {
							i = aa(m.dom) + 1
							break
						}
						t -= m.size
					}
					i == -1 && (i = 0)
				}
				if (i > -1 && (u > n || s == this.children.length - 1)) {
					n = u
					for (let d = s + 1; d < this.children.length; d++) {
						let p = this.children[d]
						if (p.size && p.dom.parentNode == this.contentDOM && !p.emptyChildAt(-1)) {
							a = aa(p.dom)
							break
						}
						n += p.size
					}
					a == -1 && (a = this.contentDOM.childNodes.length)
					break
				}
				o = u
			}
			return { node: this.contentDOM, from: t, to: n, fromOffset: i, toOffset: a }
		}
		emptyChildAt(t) {
			if (this.border || !this.contentDOM || !this.children.length) return !1
			let n = this.children[t < 0 ? 0 : this.children.length - 1]
			return n.size == 0 || n.emptyChildAt(t)
		}
		domAfterPos(t) {
			let { node: n, offset: r } = this.domFromPos(t, 0)
			if (n.nodeType != 1 || r == n.childNodes.length)
				throw new RangeError("No node after pos " + t)
			return n.childNodes[r]
		}
		setSelection(t, n, r, i = !1) {
			let a = Math.min(t, n),
				o = Math.max(t, n)
			for (let m = 0, v = 0; m < this.children.length; m++) {
				let y = this.children[m],
					b = v + y.size
				if (a > v && o < b) return y.setSelection(t - v - y.border, n - v - y.border, r, i)
				v = b
			}
			let s = this.domFromPos(t, t ? -1 : 1),
				l = n == t ? s : this.domFromPos(n, n ? -1 : 1),
				u = r.getSelection(),
				d = !1
			if ((ms || Wi) && t == n) {
				let { node: m, offset: v } = s
				if (m.nodeType == 3) {
					if (
						((d = !!(
							v &&
							m.nodeValue[v - 1] ==
								`
`
						)),
						d && v == m.nodeValue.length)
					)
						for (let y = m, b; y; y = y.parentNode) {
							if ((b = y.nextSibling)) {
								b.nodeName == "BR" && (s = l = { node: b.parentNode, offset: aa(b) + 1 })
								break
							}
							let x = y.pmViewDesc
							if (x && x.node && x.node.isBlock) break
						}
				} else {
					let y = m.childNodes[v - 1]
					d = y && (y.nodeName == "BR" || y.contentEditable == "false")
				}
			}
			if (ms && u.focusNode && u.focusNode != l.node && u.focusNode.nodeType == 1) {
				let m = u.focusNode.childNodes[u.focusOffset]
				m && m.contentEditable == "false" && (i = !0)
			}
			if (
				!(i || (d && Wi)) &&
				Sv(s.node, s.offset, u.anchorNode, u.anchorOffset) &&
				Sv(l.node, l.offset, u.focusNode, u.focusOffset)
			)
				return
			let p = !1
			if ((u.extend || t == n) && !d) {
				u.collapse(s.node, s.offset)
				try {
					t != n && u.extend(l.node, l.offset), (p = !0)
				} catch (m) {
					if (!(m instanceof DOMException)) throw m
				}
			}
			if (!p) {
				if (t > n) {
					let v = s
					;(s = l), (l = v)
				}
				let m = document.createRange()
				m.setEnd(l.node, l.offset), m.setStart(s.node, s.offset), u.removeAllRanges(), u.addRange(m)
			}
		}
		ignoreMutation(t) {
			return !this.contentDOM && t.type != "selection"
		}
		get contentLost() {
			return this.contentDOM && this.contentDOM != this.dom && !this.dom.contains(this.contentDOM)
		}
		markDirty(t, n) {
			for (let r = 0, i = 0; i < this.children.length; i++) {
				let a = this.children[i],
					o = r + a.size
				if (r == o ? t <= o && n >= r : t < o && n > r) {
					let s = r + a.border,
						l = o - a.border
					if (t >= s && n <= l) {
						;(this.dirty = t == r || n == o ? Ff : T3),
							t == s && n == l && (a.contentLost || a.dom.parentNode != this.contentDOM)
								? (a.dirty = vs)
								: a.markDirty(t - s, n - s)
						return
					} else
						a.dirty =
							a.dom == a.contentDOM && a.dom.parentNode == this.contentDOM && !a.children.length
								? Ff
								: vs
				}
				r = o
			}
			this.dirty = Ff
		}
		markParentsDirty() {
			let t = 1
			for (let n = this.parent; n; n = n.parent, t++) {
				let r = t == 1 ? Ff : T3
				n.dirty < r && (n.dirty = r)
			}
		}
		get domAtom() {
			return !1
		}
		get ignoreForCoords() {
			return !1
		}
	}
	class rU extends fg {
		constructor(t, n, r, i) {
			let a,
				o = n.type.toDOM
			if (
				(typeof o == "function" &&
					(o = o(r, () => {
						if (!a) return i
						if (a.parent) return a.parent.posBeforeChild(a)
					})),
				!n.type.spec.raw)
			) {
				if (o.nodeType != 1) {
					let s = document.createElement("span")
					s.appendChild(o), (o = s)
				}
				;(o.contentEditable = "false"), o.classList.add("ProseMirror-widget")
			}
			super(t, [], o, null), (this.widget = n), (this.widget = n), (a = this)
		}
		matchesWidget(t) {
			return this.dirty == wo && t.type.eq(this.widget.type)
		}
		parseRule() {
			return { ignore: !0 }
		}
		stopEvent(t) {
			let n = this.widget.spec.stopEvent
			return n ? n(t) : !1
		}
		ignoreMutation(t) {
			return t.type != "selection" || this.widget.spec.ignoreSelection
		}
		destroy() {
			this.widget.type.destroy(this.dom), super.destroy()
		}
		get domAtom() {
			return !0
		}
		get side() {
			return this.widget.type.side
		}
	}
	class Sge extends fg {
		constructor(t, n, r, i) {
			super(t, [], n, null), (this.textDOM = r), (this.text = i)
		}
		get size() {
			return this.text.length
		}
		localPosFromDOM(t, n) {
			return t != this.textDOM ? this.posAtStart + (n ? this.size : 0) : this.posAtStart + n
		}
		domFromPos(t) {
			return { node: this.textDOM, offset: t }
		}
		ignoreMutation(t) {
			return t.type === "characterData" && t.target.nodeValue == t.oldValue
		}
	}
	class vd extends fg {
		constructor(t, n, r, i) {
			super(t, [], r, i), (this.mark = n)
		}
		static create(t, n, r, i) {
			let a = i.nodeViews[n.type.name],
				o = a && a(n, i, r)
			return (
				(!o || !o.dom) && (o = al.renderSpec(document, n.type.spec.toDOM(n, r))),
				new vd(t, n, o.dom, o.contentDOM || o.dom)
			)
		}
		parseRule() {
			return this.dirty & vs || this.mark.type.spec.reparseInView
				? null
				: {
						mark: this.mark.type.name,
						attrs: this.mark.attrs,
						contentElement: this.contentDOM || void 0,
				  }
		}
		matchesMark(t) {
			return this.dirty != vs && this.mark.eq(t)
		}
		markDirty(t, n) {
			if ((super.markDirty(t, n), this.dirty != wo)) {
				let r = this.parent
				for (; !r.node; ) r = r.parent
				r.dirty < this.dirty && (r.dirty = this.dirty), (this.dirty = wo)
			}
		}
		slice(t, n, r) {
			let i = vd.create(this.parent, this.mark, !0, r),
				a = this.children,
				o = this.size
			n < o && (a = _2(a, n, o, r)), t > 0 && (a = _2(a, 0, t, r))
			for (let s = 0; s < a.length; s++) a[s].parent = i
			return (i.children = a), i
		}
	}
	class gd extends fg {
		constructor(t, n, r, i, a, o, s, l, u) {
			super(t, [], a, o),
				(this.node = n),
				(this.outerDeco = r),
				(this.innerDeco = i),
				(this.nodeDOM = s),
				o && this.updateChildren(l, u)
		}
		static create(t, n, r, i, a, o) {
			let s = a.nodeViews[n.type.name],
				l,
				u =
					s &&
					s(
						n,
						a,
						() => {
							if (!l) return o
							if (l.parent) return l.parent.posBeforeChild(l)
						},
						r,
						i,
					),
				d = u && u.dom,
				p = u && u.contentDOM
			if (n.isText) {
				if (!d) d = document.createTextNode(n.text)
				else if (d.nodeType != 3) throw new RangeError("Text must be rendered as a DOM text node")
			} else d || ({ dom: d, contentDOM: p } = al.renderSpec(document, n.type.spec.toDOM(n)))
			!p &&
				!n.isText &&
				d.nodeName != "BR" &&
				(d.hasAttribute("contenteditable") || (d.contentEditable = "false"),
				n.type.spec.draggable && (d.draggable = !0))
			let m = d
			return (
				(d = sU(d, r, n)),
				u
					? (l = new Dge(t, n, r, i, d, p || null, m, u, a, o + 1))
					: n.isText
					? new rw(t, n, r, i, d, m, a)
					: new gd(t, n, r, i, d, p || null, m, a, o + 1)
			)
		}
		parseRule() {
			if (this.node.type.spec.reparseInView) return null
			let t = { node: this.node.type.name, attrs: this.node.attrs }
			if ((this.node.type.whitespace == "pre" && (t.preserveWhitespace = "full"), !this.contentDOM))
				t.getContent = () => this.node.content
			else if (!this.contentLost) t.contentElement = this.contentDOM
			else {
				for (let n = this.children.length - 1; n >= 0; n--) {
					let r = this.children[n]
					if (this.dom.contains(r.dom.parentNode)) {
						t.contentElement = r.dom.parentNode
						break
					}
				}
				t.contentElement || (t.getContent = () => ke.empty)
			}
			return t
		}
		matchesNode(t, n, r) {
			return this.dirty == wo && t.eq(this.node) && D2(n, this.outerDeco) && r.eq(this.innerDeco)
		}
		get size() {
			return this.node.nodeSize
		}
		get border() {
			return this.node.isLeaf ? 0 : 1
		}
		updateChildren(t, n) {
			let r = this.node.inlineContent,
				i = n,
				a = t.composing ? this.localCompositionInfo(t, n) : null,
				o = a && a.pos > -1 ? a : null,
				s = a && a.pos < 0,
				l = new Oge(this, o && o.node)
			Mge(
				this.node,
				this.innerDeco,
				(u, d, p) => {
					u.spec.marks
						? l.syncToMarks(u.spec.marks, r, t)
						: u.type.side >= 0 &&
						  !p &&
						  l.syncToMarks(d == this.node.childCount ? tn.none : this.node.child(d).marks, r, t),
						l.placeWidget(u, t, i)
				},
				(u, d, p, m) => {
					l.syncToMarks(u.marks, r, t)
					let v
					l.findNodeMatch(u, d, p, m) ||
						(s &&
							t.state.selection.from > i &&
							t.state.selection.to < i + u.nodeSize &&
							(v = l.findIndexWithChild(a.node)) > -1 &&
							l.updateNodeAt(u, d, p, v, t)) ||
						l.updateNextNode(u, d, p, t, m) ||
						l.addNode(u, d, p, t, i),
						(i += u.nodeSize)
				},
			),
				l.syncToMarks([], r, t),
				this.node.isTextblock && l.addTextblockHacks(),
				l.destroyRest(),
				(l.changed || this.dirty == Ff) &&
					(o && this.protectLocalComposition(t, o),
					aU(this.contentDOM, this.children, t),
					fp && Ige(this.dom))
		}
		localCompositionInfo(t, n) {
			let { from: r, to: i } = t.state.selection
			if (!(t.state.selection instanceof jt) || r < n || i > n + this.node.content.size) return null
			let a = t.domSelection(),
				o = Rge(a.focusNode, a.focusOffset)
			if (!o || !this.dom.contains(o.parentNode)) return null
			if (this.node.inlineContent) {
				let s = o.nodeValue,
					l = Lge(this.node.content, s, r - n, i - n)
				return l < 0 ? null : { node: o, pos: l, text: s }
			} else return { node: o, pos: -1, text: "" }
		}
		protectLocalComposition(t, { node: n, pos: r, text: i }) {
			if (this.getDesc(n)) return
			let a = n
			for (; a.parentNode != this.contentDOM; a = a.parentNode) {
				for (; a.previousSibling; ) a.parentNode.removeChild(a.previousSibling)
				for (; a.nextSibling; ) a.parentNode.removeChild(a.nextSibling)
				a.pmViewDesc && (a.pmViewDesc = void 0)
			}
			let o = new Sge(this, a, n, i)
			t.input.compositionNodes.push(o), (this.children = _2(this.children, r, r + i.length, t, o))
		}
		update(t, n, r, i) {
			return this.dirty == vs || !t.sameMarkup(this.node) ? !1 : (this.updateInner(t, n, r, i), !0)
		}
		updateInner(t, n, r, i) {
			this.updateOuterDeco(n),
				(this.node = t),
				(this.innerDeco = r),
				this.contentDOM && this.updateChildren(i, this.posAtStart),
				(this.dirty = wo)
		}
		updateOuterDeco(t) {
			if (D2(t, this.outerDeco)) return
			let n = this.nodeDOM.nodeType != 1,
				r = this.dom
			;(this.dom = oU(
				this.dom,
				this.nodeDOM,
				S2(this.outerDeco, this.node, n),
				S2(t, this.node, n),
			)),
				this.dom != r && ((r.pmViewDesc = void 0), (this.dom.pmViewDesc = this)),
				(this.outerDeco = t)
		}
		selectNode() {
			this.nodeDOM.nodeType == 1 && this.nodeDOM.classList.add("ProseMirror-selectednode"),
				(this.contentDOM || !this.node.type.spec.draggable) && (this.dom.draggable = !0)
		}
		deselectNode() {
			this.nodeDOM.nodeType == 1 && this.nodeDOM.classList.remove("ProseMirror-selectednode"),
				(this.contentDOM || !this.node.type.spec.draggable) && this.dom.removeAttribute("draggable")
		}
		get domAtom() {
			return this.node.isAtom
		}
	}
	function k3(e, t, n, r, i) {
		return sU(r, t, e), new gd(void 0, e, t, n, r, r, r, i, 0)
	}
	class rw extends gd {
		constructor(t, n, r, i, a, o, s) {
			super(t, n, r, i, a, null, o, s, 0)
		}
		parseRule() {
			let t = this.nodeDOM.parentNode
			for (; t && t != this.dom && !t.pmIsDeco; ) t = t.parentNode
			return { skip: t || !0 }
		}
		update(t, n, r, i) {
			return this.dirty == vs || (this.dirty != wo && !this.inParent()) || !t.sameMarkup(this.node)
				? !1
				: (this.updateOuterDeco(n),
				  (this.dirty != wo || t.text != this.node.text) &&
						t.text != this.nodeDOM.nodeValue &&
						((this.nodeDOM.nodeValue = t.text),
						i.trackWrites == this.nodeDOM && (i.trackWrites = null)),
				  (this.node = t),
				  (this.dirty = wo),
				  !0)
		}
		inParent() {
			let t = this.parent.contentDOM
			for (let n = this.nodeDOM; n; n = n.parentNode) if (n == t) return !0
			return !1
		}
		domFromPos(t) {
			return { node: this.nodeDOM, offset: t }
		}
		localPosFromDOM(t, n, r) {
			return t == this.nodeDOM
				? this.posAtStart + Math.min(n, this.node.text.length)
				: super.localPosFromDOM(t, n, r)
		}
		ignoreMutation(t) {
			return t.type != "characterData" && t.type != "selection"
		}
		slice(t, n, r) {
			let i = this.node.cut(t, n),
				a = document.createTextNode(i.text)
			return new rw(this.parent, i, this.outerDeco, this.innerDeco, a, a, r)
		}
		markDirty(t, n) {
			super.markDirty(t, n),
				this.dom != this.nodeDOM &&
					(t == 0 || n == this.nodeDOM.nodeValue.length) &&
					(this.dirty = vs)
		}
		get domAtom() {
			return !1
		}
	}
	class iU extends fg {
		parseRule() {
			return { ignore: !0 }
		}
		matchesHack(t) {
			return this.dirty == wo && this.dom.nodeName == t
		}
		get domAtom() {
			return !0
		}
		get ignoreForCoords() {
			return this.dom.nodeName == "IMG"
		}
	}
	class Dge extends gd {
		constructor(t, n, r, i, a, o, s, l, u, d) {
			super(t, n, r, i, a, o, s, u, d), (this.spec = l)
		}
		update(t, n, r, i) {
			if (this.dirty == vs) return !1
			if (this.spec.update) {
				let a = this.spec.update(t, n, r)
				return a && this.updateInner(t, n, r, i), a
			} else return !this.contentDOM && !t.isLeaf ? !1 : super.update(t, n, r, i)
		}
		selectNode() {
			this.spec.selectNode ? this.spec.selectNode() : super.selectNode()
		}
		deselectNode() {
			this.spec.deselectNode ? this.spec.deselectNode() : super.deselectNode()
		}
		setSelection(t, n, r, i) {
			this.spec.setSelection ? this.spec.setSelection(t, n, r) : super.setSelection(t, n, r, i)
		}
		destroy() {
			this.spec.destroy && this.spec.destroy(), super.destroy()
		}
		stopEvent(t) {
			return this.spec.stopEvent ? this.spec.stopEvent(t) : !1
		}
		ignoreMutation(t) {
			return this.spec.ignoreMutation ? this.spec.ignoreMutation(t) : super.ignoreMutation(t)
		}
	}
	function aU(e, t, n) {
		let r = e.firstChild,
			i = !1
		for (let a = 0; a < t.length; a++) {
			let o = t[a],
				s = o.dom
			if (s.parentNode == e) {
				for (; s != r; ) (r = S3(r)), (i = !0)
				r = r.nextSibling
			} else (i = !0), e.insertBefore(s, r)
			if (o instanceof vd) {
				let l = r ? r.previousSibling : e.lastChild
				aU(o.contentDOM, o.children, n), (r = l ? l.nextSibling : e.firstChild)
			}
		}
		for (; r; ) (r = S3(r)), (i = !0)
		i && n.trackWrites == e && (n.trackWrites = null)
	}
	const Um = function (e) {
		e && (this.nodeName = e)
	}
	Um.prototype = Object.create(null)
	const Hc = [new Um()]
	function S2(e, t, n) {
		if (e.length == 0) return Hc
		let r = n ? Hc[0] : new Um(),
			i = [r]
		for (let a = 0; a < e.length; a++) {
			let o = e[a].type.attrs
			if (o) {
				o.nodeName && i.push((r = new Um(o.nodeName)))
				for (let s in o) {
					let l = o[s]
					l != null &&
						(n && i.length == 1 && i.push((r = new Um(t.isInline ? "span" : "div"))),
						s == "class"
							? (r.class = (r.class ? r.class + " " : "") + l)
							: s == "style"
							? (r.style = (r.style ? r.style + ";" : "") + l)
							: s != "nodeName" && (r[s] = l))
				}
			}
		}
		return i
	}
	function oU(e, t, n, r) {
		if (n == Hc && r == Hc) return t
		let i = t
		for (let a = 0; a < r.length; a++) {
			let o = r[a],
				s = n[a]
			if (a) {
				let l
				;(s &&
					s.nodeName == o.nodeName &&
					i != e &&
					(l = i.parentNode) &&
					l.nodeName.toLowerCase() == o.nodeName) ||
					((l = document.createElement(o.nodeName)),
					(l.pmIsDeco = !0),
					l.appendChild(i),
					(s = Hc[0])),
					(i = l)
			}
			_ge(i, s || Hc[0], o)
		}
		return i
	}
	function _ge(e, t, n) {
		for (let r in t)
			r != "class" && r != "style" && r != "nodeName" && !(r in n) && e.removeAttribute(r)
		for (let r in n)
			r != "class" && r != "style" && r != "nodeName" && n[r] != t[r] && e.setAttribute(r, n[r])
		if (t.class != n.class) {
			let r = t.class ? t.class.split(" ").filter(Boolean) : [],
				i = n.class ? n.class.split(" ").filter(Boolean) : []
			for (let a = 0; a < r.length; a++) i.indexOf(r[a]) == -1 && e.classList.remove(r[a])
			for (let a = 0; a < i.length; a++) r.indexOf(i[a]) == -1 && e.classList.add(i[a])
			e.classList.length == 0 && e.removeAttribute("class")
		}
		if (t.style != n.style) {
			if (t.style) {
				let r = /\s*([\w\-\xa1-\uffff]+)\s*:(?:"(?:\\.|[^"])*"|'(?:\\.|[^'])*'|\(.*?\)|[^;])*/g,
					i
				for (; (i = r.exec(t.style)); ) e.style.removeProperty(i[1])
			}
			n.style && (e.style.cssText += n.style)
		}
	}
	function sU(e, t, n) {
		return oU(e, e, Hc, S2(t, n, e.nodeType != 1))
	}
	function D2(e, t) {
		if (e.length != t.length) return !1
		for (let n = 0; n < e.length; n++) if (!e[n].type.eq(t[n].type)) return !1
		return !0
	}
	function S3(e) {
		let t = e.nextSibling
		return e.parentNode.removeChild(e), t
	}
	class Oge {
		constructor(t, n) {
			;(this.lock = n),
				(this.index = 0),
				(this.stack = []),
				(this.changed = !1),
				(this.top = t),
				(this.preMatch = Age(t.node.content, t))
		}
		destroyBetween(t, n) {
			if (t != n) {
				for (let r = t; r < n; r++) this.top.children[r].destroy()
				this.top.children.splice(t, n - t), (this.changed = !0)
			}
		}
		destroyRest() {
			this.destroyBetween(this.index, this.top.children.length)
		}
		syncToMarks(t, n, r) {
			let i = 0,
				a = this.stack.length >> 1,
				o = Math.min(a, t.length)
			for (
				;
				i < o &&
				(i == a - 1 ? this.top : this.stack[(i + 1) << 1]).matchesMark(t[i]) &&
				t[i].type.spec.spanning !== !1;

			)
				i++
			for (; i < a; )
				this.destroyRest(),
					(this.top.dirty = wo),
					(this.index = this.stack.pop()),
					(this.top = this.stack.pop()),
					a--
			for (; a < t.length; ) {
				this.stack.push(this.top, this.index + 1)
				let s = -1
				for (let l = this.index; l < Math.min(this.index + 3, this.top.children.length); l++)
					if (this.top.children[l].matchesMark(t[a])) {
						s = l
						break
					}
				if (s > -1)
					s > this.index && ((this.changed = !0), this.destroyBetween(this.index, s)),
						(this.top = this.top.children[this.index])
				else {
					let l = vd.create(this.top, t[a], n, r)
					this.top.children.splice(this.index, 0, l), (this.top = l), (this.changed = !0)
				}
				;(this.index = 0), a++
			}
		}
		findNodeMatch(t, n, r, i) {
			let a = -1,
				o
			if (
				i >= this.preMatch.index &&
				(o = this.preMatch.matches[i - this.preMatch.index]).parent == this.top &&
				o.matchesNode(t, n, r)
			)
				a = this.top.children.indexOf(o, this.index)
			else
				for (let s = this.index, l = Math.min(this.top.children.length, s + 5); s < l; s++) {
					let u = this.top.children[s]
					if (u.matchesNode(t, n, r) && !this.preMatch.matched.has(u)) {
						a = s
						break
					}
				}
			return a < 0 ? !1 : (this.destroyBetween(this.index, a), this.index++, !0)
		}
		updateNodeAt(t, n, r, i, a) {
			let o = this.top.children[i]
			return (
				o.dirty == vs && o.dom == o.contentDOM && (o.dirty = Ff),
				o.update(t, n, r, a) ? (this.destroyBetween(this.index, i), this.index++, !0) : !1
			)
		}
		findIndexWithChild(t) {
			for (;;) {
				let n = t.parentNode
				if (!n) return -1
				if (n == this.top.contentDOM) {
					let r = t.pmViewDesc
					if (r) {
						for (let i = this.index; i < this.top.children.length; i++)
							if (this.top.children[i] == r) return i
					}
					return -1
				}
				t = n
			}
		}
		updateNextNode(t, n, r, i, a) {
			for (let o = this.index; o < this.top.children.length; o++) {
				let s = this.top.children[o]
				if (s instanceof gd) {
					let l = this.preMatch.matched.get(s)
					if (l != null && l != a) return !1
					let u = s.dom
					if (
						!(
							this.lock &&
							(u == this.lock || (u.nodeType == 1 && u.contains(this.lock.parentNode))) &&
							!(
								t.isText &&
								s.node &&
								s.node.isText &&
								s.nodeDOM.nodeValue == t.text &&
								s.dirty != vs &&
								D2(n, s.outerDeco)
							)
						) &&
						s.update(t, n, r, i)
					)
						return (
							this.destroyBetween(this.index, o),
							s.dom != u && (this.changed = !0),
							this.index++,
							!0
						)
					break
				}
			}
			return !1
		}
		addNode(t, n, r, i, a) {
			this.top.children.splice(this.index++, 0, gd.create(this.top, t, n, r, i, a)),
				(this.changed = !0)
		}
		placeWidget(t, n, r) {
			let i = this.index < this.top.children.length ? this.top.children[this.index] : null
			if (i && i.matchesWidget(t) && (t == i.widget || !i.widget.type.toDOM.parentNode))
				this.index++
			else {
				let a = new rU(this.top, t, n, r)
				this.top.children.splice(this.index++, 0, a), (this.changed = !0)
			}
		}
		addTextblockHacks() {
			let t = this.top.children[this.index - 1],
				n = this.top
			for (; t instanceof vd; ) (n = t), (t = n.children[n.children.length - 1])
			;(!t || !(t instanceof rw) || /\n$/.test(t.node.text)) &&
				((Wi || yi) && t && t.dom.contentEditable == "false" && this.addHackNode("IMG", n),
				this.addHackNode("BR", this.top))
		}
		addHackNode(t, n) {
			if (n == this.top && this.index < n.children.length && n.children[this.index].matchesHack(t))
				this.index++
			else {
				let r = document.createElement(t)
				t == "IMG" && ((r.className = "ProseMirror-separator"), (r.alt = "")),
					t == "BR" && (r.className = "ProseMirror-trailingBreak")
				let i = new iU(this.top, [], r, null)
				n != this.top ? n.children.push(i) : n.children.splice(this.index++, 0, i),
					(this.changed = !0)
			}
		}
	}
	function Age(e, t) {
		let n = t,
			r = n.children.length,
			i = e.childCount,
			a = new Map(),
			o = []
		e: for (; i > 0; ) {
			let s
			for (;;)
				if (r) {
					let u = n.children[r - 1]
					if (u instanceof vd) (n = u), (r = u.children.length)
					else {
						;(s = u), r--
						break
					}
				} else {
					if (n == t) break e
					;(r = n.parent.children.indexOf(n)), (n = n.parent)
				}
			let l = s.node
			if (l) {
				if (l != e.child(i - 1)) break
				--i, a.set(s, i), o.push(s)
			}
		}
		return { index: i, matched: a, matches: o.reverse() }
	}
	function Nge(e, t) {
		return e.type.side - t.type.side
	}
	function Mge(e, t, n, r) {
		let i = t.locals(e),
			a = 0
		if (i.length == 0) {
			for (let u = 0; u < e.childCount; u++) {
				let d = e.child(u)
				r(d, i, t.forChild(a, d), u), (a += d.nodeSize)
			}
			return
		}
		let o = 0,
			s = [],
			l = null
		for (let u = 0; ; ) {
			if (o < i.length && i[o].to == a) {
				let y = i[o++],
					b
				for (; o < i.length && i[o].to == a; ) (b || (b = [y])).push(i[o++])
				if (b) {
					b.sort(Nge)
					for (let x = 0; x < b.length; x++) n(b[x], u, !!l)
				} else n(y, u, !!l)
			}
			let d, p
			if (l) (p = -1), (d = l), (l = null)
			else if (u < e.childCount) (p = u), (d = e.child(u++))
			else break
			for (let y = 0; y < s.length; y++) s[y].to <= a && s.splice(y--, 1)
			for (; o < i.length && i[o].from <= a && i[o].to > a; ) s.push(i[o++])
			let m = a + d.nodeSize
			if (d.isText) {
				let y = m
				o < i.length && i[o].from < y && (y = i[o].from)
				for (let b = 0; b < s.length; b++) s[b].to < y && (y = s[b].to)
				y < m && ((l = d.cut(y - a)), (d = d.cut(0, y - a)), (m = y), (p = -1))
			}
			let v = d.isInline && !d.isLeaf ? s.filter((y) => !y.inline) : s.slice()
			r(d, v, t.forChild(a, d), p), (a = m)
		}
	}
	function Ige(e) {
		if (e.nodeName == "UL" || e.nodeName == "OL") {
			let t = e.style.cssText
			;(e.style.cssText = t + "; list-style: square !important"),
				window.getComputedStyle(e).listStyle,
				(e.style.cssText = t)
		}
	}
	function Rge(e, t) {
		for (;;) {
			if (e.nodeType == 3) return e
			if (e.nodeType == 1 && t > 0) {
				if (e.childNodes.length > t && e.childNodes[t].nodeType == 3) return e.childNodes[t]
				;(e = e.childNodes[t - 1]), (t = es(e))
			} else if (e.nodeType == 1 && t < e.childNodes.length) (e = e.childNodes[t]), (t = 0)
			else return null
		}
	}
	function Lge(e, t, n, r) {
		for (let i = 0, a = 0; i < e.childCount && a <= r; ) {
			let o = e.child(i++),
				s = a
			if (((a += o.nodeSize), !o.isText)) continue
			let l = o.text
			for (; i < e.childCount; ) {
				let u = e.child(i++)
				if (((a += u.nodeSize), !u.isText)) break
				l += u.text
			}
			if (a >= n) {
				let u = s < r ? l.lastIndexOf(t, r - s - 1) : -1
				if (u >= 0 && u + t.length + s >= n) return s + u
				if (n == r && l.length >= r + t.length - s && l.slice(r - s, r - s + t.length) == t)
					return r
			}
		}
		return -1
	}
	function _2(e, t, n, r, i) {
		let a = []
		for (let o = 0, s = 0; o < e.length; o++) {
			let l = e[o],
				u = s,
				d = (s += l.size)
			u >= n || d <= t
				? a.push(l)
				: (u < t && a.push(l.slice(0, t - u, r)),
				  i && (a.push(i), (i = void 0)),
				  d > n && a.push(l.slice(n - u, l.size, r)))
		}
		return a
	}
	function lU(e, t = null) {
		let n = e.domSelection(),
			r = e.state.doc
		if (!n.focusNode) return null
		let i = e.docView.nearestDesc(n.focusNode),
			a = i && i.size == 0,
			o = e.docView.posFromDOM(n.focusNode, n.focusOffset, 1)
		if (o < 0) return null
		let s = r.resolve(o),
			l,
			u
		if (EO(n)) {
			for (l = s; i && !i.node; ) i = i.parent
			let d = i.node
			if (
				i &&
				d.isAtom &&
				vt.isSelectable(d) &&
				i.parent &&
				!(d.isInline && uge(n.focusNode, n.focusOffset, i.dom))
			) {
				let p = i.posBefore
				u = new vt(o == p ? s : r.resolve(p))
			}
		} else {
			let d = e.docView.posFromDOM(n.anchorNode, n.anchorOffset, 1)
			if (d < 0) return null
			l = r.resolve(d)
		}
		if (!u) {
			let d = t == "pointer" || (e.state.selection.head < s.pos && !a) ? 1 : -1
			u = TO(e, l, s, d)
		}
		return u
	}
	function uU(e) {
		return e.editable
			? e.hasFocus()
			: dU(e) && document.activeElement && document.activeElement.contains(e.dom)
	}
	function Hu(e, t = !1) {
		let n = e.state.selection
		if ((cU(e, n), !!uU(e))) {
			if (!t && e.input.mouseDown && e.input.mouseDown.allowDefault && yi) {
				let r = e.domSelection(),
					i = e.domObserver.currentSelection
				if (
					r.anchorNode &&
					i.anchorNode &&
					Sv(r.anchorNode, r.anchorOffset, i.anchorNode, i.anchorOffset)
				) {
					;(e.input.mouseDown.delayedSelectionSync = !0), e.domObserver.setCurSelection()
					return
				}
			}
			if ((e.domObserver.disconnectSelection(), e.cursorWrapper)) jge(e)
			else {
				let { anchor: r, head: i } = n,
					a,
					o
				D3 &&
					!(n instanceof jt) &&
					(n.$from.parent.inlineContent || (a = _3(e, n.from)),
					!n.empty && !n.$from.parent.inlineContent && (o = _3(e, n.to))),
					e.docView.setSelection(r, i, e.root, t),
					D3 && (a && O3(a), o && O3(o)),
					n.visible
						? e.dom.classList.remove("ProseMirror-hideselection")
						: (e.dom.classList.add("ProseMirror-hideselection"),
						  "onselectionchange" in document && Pge(e))
			}
			e.domObserver.setCurSelection(), e.domObserver.connectSelection()
		}
	}
	const D3 = Wi || (yi && oge < 63)
	function _3(e, t) {
		let { node: n, offset: r } = e.docView.domFromPos(t, 0),
			i = r < n.childNodes.length ? n.childNodes[r] : null,
			a = r ? n.childNodes[r - 1] : null
		if (Wi && i && i.contentEditable == "false") return ok(i)
		if ((!i || i.contentEditable == "false") && (!a || a.contentEditable == "false")) {
			if (i) return ok(i)
			if (a) return ok(a)
		}
	}
	function ok(e) {
		return (
			(e.contentEditable = "true"),
			Wi && e.draggable && ((e.draggable = !1), (e.wasDraggable = !0)),
			e
		)
	}
	function O3(e) {
		;(e.contentEditable = "false"), e.wasDraggable && ((e.draggable = !0), (e.wasDraggable = null))
	}
	function Pge(e) {
		let t = e.dom.ownerDocument
		t.removeEventListener("selectionchange", e.input.hideSelectionGuard)
		let n = e.domSelection(),
			r = n.anchorNode,
			i = n.anchorOffset
		t.addEventListener(
			"selectionchange",
			(e.input.hideSelectionGuard = () => {
				;(n.anchorNode != r || n.anchorOffset != i) &&
					(t.removeEventListener("selectionchange", e.input.hideSelectionGuard),
					setTimeout(() => {
						;(!uU(e) || e.state.selection.visible) &&
							e.dom.classList.remove("ProseMirror-hideselection")
					}, 20))
			}),
		)
	}
	function jge(e) {
		let t = e.domSelection(),
			n = document.createRange(),
			r = e.cursorWrapper.dom,
			i = r.nodeName == "IMG"
		i ? n.setEnd(r.parentNode, aa(r) + 1) : n.setEnd(r, 0),
			n.collapse(!1),
			t.removeAllRanges(),
			t.addRange(n),
			!i && !e.state.selection.visible && ma && ku <= 11 && ((r.disabled = !0), (r.disabled = !1))
	}
	function cU(e, t) {
		if (t instanceof vt) {
			let n = e.docView.descAt(t.from)
			n != e.lastSelectedViewDesc && (A3(e), n && n.selectNode(), (e.lastSelectedViewDesc = n))
		} else A3(e)
	}
	function A3(e) {
		e.lastSelectedViewDesc &&
			(e.lastSelectedViewDesc.parent && e.lastSelectedViewDesc.deselectNode(),
			(e.lastSelectedViewDesc = void 0))
	}
	function TO(e, t, n, r) {
		return e.someProp("createSelectionBetween", (i) => i(e, t, n)) || jt.between(t, n, r)
	}
	function N3(e) {
		return e.editable && e.root.activeElement != e.dom ? !1 : dU(e)
	}
	function dU(e) {
		let t = e.domSelection()
		if (!t.anchorNode) return !1
		try {
			return (
				e.dom.contains(t.anchorNode.nodeType == 3 ? t.anchorNode.parentNode : t.anchorNode) &&
				(e.editable ||
					e.dom.contains(t.focusNode.nodeType == 3 ? t.focusNode.parentNode : t.focusNode))
			)
		} catch {
			return !1
		}
	}
	function Fge(e) {
		let t = e.docView.domFromPos(e.state.selection.anchor, 0),
			n = e.domSelection()
		return Sv(t.node, t.offset, n.anchorNode, n.anchorOffset)
	}
	function O2(e, t) {
		let { $anchor: n, $head: r } = e.selection,
			i = t > 0 ? n.max(r) : n.min(r),
			a = i.parent.inlineContent
				? i.depth
					? e.doc.resolve(t > 0 ? i.after() : i.before())
					: null
				: i
		return a && _t.findFrom(a, t)
	}
	function Mc(e, t) {
		return e.dispatch(e.state.tr.setSelection(t).scrollIntoView()), !0
	}
	function M3(e, t, n) {
		let r = e.state.selection
		if (r instanceof jt) {
			if (!r.empty || n.indexOf("s") > -1) return !1
			if (e.endOfTextblock(t > 0 ? "right" : "left")) {
				let i = O2(e.state, t)
				return i && i instanceof vt ? Mc(e, i) : !1
			} else if (!(Pa && n.indexOf("m") > -1)) {
				let i = r.$head,
					a = i.textOffset ? null : t < 0 ? i.nodeBefore : i.nodeAfter,
					o
				if (!a || a.isText) return !1
				let s = t < 0 ? i.pos - a.nodeSize : i.pos
				return a.isAtom || ((o = e.docView.descAt(s)) && !o.contentDOM)
					? vt.isSelectable(a)
						? Mc(e, new vt(t < 0 ? e.state.doc.resolve(i.pos - a.nodeSize) : i))
						: nw
						? Mc(e, new jt(e.state.doc.resolve(t < 0 ? s : s + a.nodeSize)))
						: !1
					: !1
			}
		} else {
			if (r instanceof vt && r.node.isInline) return Mc(e, new jt(t > 0 ? r.$to : r.$from))
			{
				let i = O2(e.state, t)
				return i ? Mc(e, i) : !1
			}
		}
	}
	function ub(e) {
		return e.nodeType == 3 ? e.nodeValue.length : e.childNodes.length
	}
	function zm(e) {
		let t = e.pmViewDesc
		return t && t.size == 0 && (e.nextSibling || e.nodeName != "BR")
	}
	function sk(e) {
		let t = e.domSelection(),
			n = t.focusNode,
			r = t.focusOffset
		if (!n) return
		let i,
			a,
			o = !1
		for (ms && n.nodeType == 1 && r < ub(n) && zm(n.childNodes[r]) && (o = !0); ; )
			if (r > 0) {
				if (n.nodeType != 1) break
				{
					let s = n.childNodes[r - 1]
					if (zm(s)) (i = n), (a = --r)
					else if (s.nodeType == 3) (n = s), (r = n.nodeValue.length)
					else break
				}
			} else {
				if (fU(n)) break
				{
					let s = n.previousSibling
					for (; s && zm(s); ) (i = n.parentNode), (a = aa(s)), (s = s.previousSibling)
					if (s) (n = s), (r = ub(n))
					else {
						if (((n = n.parentNode), n == e.dom)) break
						r = 0
					}
				}
			}
		o ? A2(e, t, n, r) : i && A2(e, t, i, a)
	}
	function lk(e) {
		let t = e.domSelection(),
			n = t.focusNode,
			r = t.focusOffset
		if (!n) return
		let i = ub(n),
			a,
			o
		for (;;)
			if (r < i) {
				if (n.nodeType != 1) break
				let s = n.childNodes[r]
				if (zm(s)) (a = n), (o = ++r)
				else break
			} else {
				if (fU(n)) break
				{
					let s = n.nextSibling
					for (; s && zm(s); ) (a = s.parentNode), (o = aa(s) + 1), (s = s.nextSibling)
					if (s) (n = s), (r = 0), (i = ub(n))
					else {
						if (((n = n.parentNode), n == e.dom)) break
						r = i = 0
					}
				}
			}
		a && A2(e, t, a, o)
	}
	function fU(e) {
		let t = e.pmViewDesc
		return t && t.node && t.node.isBlock
	}
	function A2(e, t, n, r) {
		if (EO(t)) {
			let a = document.createRange()
			a.setEnd(n, r), a.setStart(n, r), t.removeAllRanges(), t.addRange(a)
		} else t.extend && t.extend(n, r)
		e.domObserver.setCurSelection()
		let { state: i } = e
		setTimeout(() => {
			e.state == i && Hu(e)
		}, 50)
	}
	function I3(e, t, n) {
		let r = e.state.selection
		if ((r instanceof jt && !r.empty) || n.indexOf("s") > -1 || (Pa && n.indexOf("m") > -1))
			return !1
		let { $from: i, $to: a } = r
		if (!i.parent.inlineContent || e.endOfTextblock(t < 0 ? "up" : "down")) {
			let o = O2(e.state, t)
			if (o && o instanceof vt) return Mc(e, o)
		}
		if (!i.parent.inlineContent) {
			let o = t < 0 ? i : a,
				s = r instanceof wi ? _t.near(o, t) : _t.findFrom(o, t)
			return s ? Mc(e, s) : !1
		}
		return !1
	}
	function R3(e, t) {
		if (!(e.state.selection instanceof jt)) return !0
		let { $head: n, $anchor: r, empty: i } = e.state.selection
		if (!n.sameParent(r)) return !0
		if (!i) return !1
		if (e.endOfTextblock(t > 0 ? "forward" : "backward")) return !0
		let a = !n.textOffset && (t < 0 ? n.nodeBefore : n.nodeAfter)
		if (a && !a.isText) {
			let o = e.state.tr
			return (
				t < 0 ? o.delete(n.pos - a.nodeSize, n.pos) : o.delete(n.pos, n.pos + a.nodeSize),
				e.dispatch(o),
				!0
			)
		}
		return !1
	}
	function L3(e, t, n) {
		e.domObserver.stop(), (t.contentEditable = n), e.domObserver.start()
	}
	function Bge(e) {
		if (!Wi || e.state.selection.$head.parentOffset > 0) return !1
		let { focusNode: t, focusOffset: n } = e.domSelection()
		if (t && t.nodeType == 1 && n == 0 && t.firstChild && t.firstChild.contentEditable == "false") {
			let r = t.firstChild
			L3(e, r, "true"), setTimeout(() => L3(e, r, "false"), 20)
		}
		return !1
	}
	function Hge(e) {
		let t = ""
		return (
			e.ctrlKey && (t += "c"),
			e.metaKey && (t += "m"),
			e.altKey && (t += "a"),
			e.shiftKey && (t += "s"),
			t
		)
	}
	function $ge(e, t) {
		let n = t.keyCode,
			r = Hge(t)
		return n == 8 || (Pa && n == 72 && r == "c")
			? R3(e, -1) || sk(e)
			: n == 46 || (Pa && n == 68 && r == "c")
			? R3(e, 1) || lk(e)
			: n == 13 || n == 27
			? !0
			: n == 37 || (Pa && n == 66 && r == "c")
			? M3(e, -1, r) || sk(e)
			: n == 39 || (Pa && n == 70 && r == "c")
			? M3(e, 1, r) || lk(e)
			: n == 38 || (Pa && n == 80 && r == "c")
			? I3(e, -1, r) || sk(e)
			: n == 40 || (Pa && n == 78 && r == "c")
			? Bge(e) || I3(e, 1, r) || lk(e)
			: r == (Pa ? "m" : "c") && (n == 66 || n == 73 || n == 89 || n == 90)
	}
	function pU(e, t) {
		let n = [],
			{ content: r, openStart: i, openEnd: a } = t
		for (; i > 1 && a > 1 && r.childCount == 1 && r.firstChild.childCount == 1; ) {
			i--, a--
			let v = r.firstChild
			n.push(v.type.name, v.attrs != v.type.defaultAttrs ? v.attrs : null), (r = v.content)
		}
		let o = e.someProp("clipboardSerializer") || al.fromSchema(e.state.schema),
			s = bU(),
			l = s.createElement("div")
		l.appendChild(o.serializeFragment(r, { document: s }))
		let u = l.firstChild,
			d,
			p = 0
		for (; u && u.nodeType == 1 && (d = yU[u.nodeName.toLowerCase()]); ) {
			for (let v = d.length - 1; v >= 0; v--) {
				let y = s.createElement(d[v])
				for (; l.firstChild; ) y.appendChild(l.firstChild)
				l.appendChild(y), p++
			}
			u = l.firstChild
		}
		u &&
			u.nodeType == 1 &&
			u.setAttribute("data-pm-slice", `${i} ${a}${p ? ` -${p}` : ""} ${JSON.stringify(n)}`)
		let m =
			e.someProp("clipboardTextSerializer", (v) => v(t)) ||
			t.content.textBetween(
				0,
				t.content.size,
				`

`,
			)
		return { dom: l, text: m }
	}
	function hU(e, t, n, r, i) {
		let a = i.parent.type.spec.code,
			o,
			s
		if (!n && !t) return null
		let l = t && (r || a || !n)
		if (l) {
			if (
				(e.someProp("transformPastedText", (m) => {
					t = m(t, a || r)
				}),
				a)
			)
				return t
					? new Ue(
							ke.from(
								e.state.schema.text(
									t.replace(
										/\r\n?/g,
										`
`,
									),
								),
							),
							0,
							0,
					  )
					: Ue.empty
			let p = e.someProp("clipboardTextParser", (m) => m(t, i, r))
			if (p) s = p
			else {
				let m = i.marks(),
					{ schema: v } = e.state,
					y = al.fromSchema(v)
				;(o = document.createElement("div")),
					t.split(/(?:\r\n?|\n)+/).forEach((b) => {
						let x = o.appendChild(document.createElement("p"))
						b && x.appendChild(y.serializeNode(v.text(b, m)))
					})
			}
		} else
			e.someProp("transformPastedHTML", (p) => {
				n = p(n)
			}),
				(o = qge(n)),
				nw && Vge(o)
		let u = o && o.querySelector("[data-pm-slice]"),
			d = u && /^(\d+) (\d+)(?: -(\d+))? (.*)/.exec(u.getAttribute("data-pm-slice") || "")
		if (d && d[3]) for (let p = +d[3]; p > 0 && o.firstChild; p--) o = o.firstChild
		if (
			(s ||
				(s = (
					e.someProp("clipboardParser") ||
					e.someProp("domParser") ||
					md.fromSchema(e.state.schema)
				).parseSlice(o, {
					preserveWhitespace: !!(l || d),
					context: i,
					ruleFromNode(m) {
						return m.nodeName == "BR" &&
							!m.nextSibling &&
							m.parentNode &&
							!Uge.test(m.parentNode.nodeName)
							? { ignore: !0 }
							: null
					},
				})),
			d)
		)
			s = Wge(P3(s, +d[1], +d[2]), d[4])
		else if (((s = Ue.maxOpen(zge(s.content, i), !0)), s.openStart || s.openEnd)) {
			let p = 0,
				m = 0
			for (
				let v = s.content.firstChild;
				p < s.openStart && !v.type.spec.isolating;
				p++, v = v.firstChild
			);
			for (
				let v = s.content.lastChild;
				m < s.openEnd && !v.type.spec.isolating;
				m++, v = v.lastChild
			);
			s = P3(s, p, m)
		}
		return (
			e.someProp("transformPasted", (p) => {
				s = p(s)
			}),
			s
		)
	}
	const Uge =
		/^(a|abbr|acronym|b|cite|code|del|em|i|ins|kbd|label|output|q|ruby|s|samp|span|strong|sub|sup|time|u|tt|var)$/i
	function zge(e, t) {
		if (e.childCount < 2) return e
		for (let n = t.depth; n >= 0; n--) {
			let i = t.node(n).contentMatchAt(t.index(n)),
				a,
				o = []
			if (
				(e.forEach((s) => {
					if (!o) return
					let l = i.findWrapping(s.type),
						u
					if (!l) return (o = null)
					if ((u = o.length && a.length && vU(l, a, s, o[o.length - 1], 0))) o[o.length - 1] = u
					else {
						o.length && (o[o.length - 1] = gU(o[o.length - 1], a.length))
						let d = mU(s, l)
						o.push(d), (i = i.matchType(d.type)), (a = l)
					}
				}),
				o)
			)
				return ke.from(o)
		}
		return e
	}
	function mU(e, t, n = 0) {
		for (let r = t.length - 1; r >= n; r--) e = t[r].create(null, ke.from(e))
		return e
	}
	function vU(e, t, n, r, i) {
		if (i < e.length && i < t.length && e[i] == t[i]) {
			let a = vU(e, t, n, r.lastChild, i + 1)
			if (a) return r.copy(r.content.replaceChild(r.childCount - 1, a))
			if (r.contentMatchAt(r.childCount).matchType(i == e.length - 1 ? n.type : e[i + 1]))
				return r.copy(r.content.append(ke.from(mU(n, e, i + 1))))
		}
	}
	function gU(e, t) {
		if (t == 0) return e
		let n = e.content.replaceChild(e.childCount - 1, gU(e.lastChild, t - 1)),
			r = e.contentMatchAt(e.childCount).fillBefore(ke.empty, !0)
		return e.copy(n.append(r))
	}
	function N2(e, t, n, r, i, a) {
		let o = t < 0 ? e.firstChild : e.lastChild,
			s = o.content
		return (
			i < r - 1 && (s = N2(s, t, n, r, i + 1, a)),
			i >= n &&
				(s =
					t < 0
						? o
								.contentMatchAt(0)
								.fillBefore(s, e.childCount > 1 || a <= i)
								.append(s)
						: s.append(o.contentMatchAt(o.childCount).fillBefore(ke.empty, !0))),
			e.replaceChild(t < 0 ? 0 : e.childCount - 1, o.copy(s))
		)
	}
	function P3(e, t, n) {
		return (
			t < e.openStart &&
				(e = new Ue(N2(e.content, -1, t, e.openStart, 0, e.openEnd), t, e.openEnd)),
			n < e.openEnd && (e = new Ue(N2(e.content, 1, n, e.openEnd, 0, 0), e.openStart, n)),
			e
		)
	}
	const yU = {
		thead: ["table"],
		tbody: ["table"],
		tfoot: ["table"],
		caption: ["table"],
		colgroup: ["table"],
		col: ["table", "colgroup"],
		tr: ["table", "tbody"],
		td: ["table", "tbody", "tr"],
		th: ["table", "tbody", "tr"],
	}
	let j3 = null
	function bU() {
		return j3 || (j3 = document.implementation.createHTMLDocument("title"))
	}
	function qge(e) {
		let t = /^(\s*<meta [^>]*>)*/.exec(e)
		t && (e = e.slice(t[0].length))
		let n = bU().createElement("div"),
			r = /<([a-z][^>\s]+)/i.exec(e),
			i
		if (
			((i = r && yU[r[1].toLowerCase()]) &&
				(e =
					i.map((a) => "<" + a + ">").join("") +
					e +
					i
						.map((a) => "</" + a + ">")
						.reverse()
						.join("")),
			(n.innerHTML = e),
			i)
		)
			for (let a = 0; a < i.length; a++) n = n.querySelector(i[a]) || n
		return n
	}
	function Vge(e) {
		let t = e.querySelectorAll(yi ? "span:not([class]):not([style])" : "span.Apple-converted-space")
		for (let n = 0; n < t.length; n++) {
			let r = t[n]
			r.childNodes.length == 1 &&
				r.textContent == "" &&
				r.parentNode &&
				r.parentNode.replaceChild(e.ownerDocument.createTextNode(" "), r)
		}
	}
	function Wge(e, t) {
		if (!e.size) return e
		let n = e.content.firstChild.type.schema,
			r
		try {
			r = JSON.parse(t)
		} catch {
			return e
		}
		let { content: i, openStart: a, openEnd: o } = e
		for (let s = r.length - 2; s >= 0; s -= 2) {
			let l = n.nodes[r[s]]
			if (!l || l.hasRequiredAttrs()) break
			;(i = ke.from(l.create(r[s + 1], i))), a++, o++
		}
		return new Ue(i, a, o)
	}
	const Yi = {}
	let Ei = {}
	class Yge {
		constructor() {
			;(this.shiftKey = !1),
				(this.mouseDown = null),
				(this.lastKeyCode = null),
				(this.lastKeyCodeTime = 0),
				(this.lastClick = { time: 0, x: 0, y: 0, type: "" }),
				(this.lastSelectionOrigin = null),
				(this.lastSelectionTime = 0),
				(this.lastIOSEnter = 0),
				(this.lastIOSEnterFallbackTimeout = -1),
				(this.lastAndroidDelete = 0),
				(this.composing = !1),
				(this.composingTimeout = -1),
				(this.compositionNodes = []),
				(this.compositionEndedAt = -2e8),
				(this.domChangeCount = 0),
				(this.eventHandlers = Object.create(null)),
				(this.hideSelectionGuard = null)
		}
	}
	function Gge(e) {
		for (let t in Yi) {
			let n = Yi[t]
			e.dom.addEventListener(
				t,
				(e.input.eventHandlers[t] = (r) => {
					Qge(e, r) && !kO(e, r) && (e.editable || !(r.type in Ei)) && n(e, r)
				}),
			)
		}
		Wi && e.dom.addEventListener("input", () => null), M2(e)
	}
	function $c(e, t) {
		;(e.input.lastSelectionOrigin = t), (e.input.lastSelectionTime = Date.now())
	}
	function Kge(e) {
		e.domObserver.stop()
		for (let t in e.input.eventHandlers) e.dom.removeEventListener(t, e.input.eventHandlers[t])
		clearTimeout(e.input.composingTimeout), clearTimeout(e.input.lastIOSEnterFallbackTimeout)
	}
	function M2(e) {
		e.someProp("handleDOMEvents", (t) => {
			for (let n in t)
				e.input.eventHandlers[n] ||
					e.dom.addEventListener(n, (e.input.eventHandlers[n] = (r) => kO(e, r)))
		})
	}
	function kO(e, t) {
		return e.someProp("handleDOMEvents", (n) => {
			let r = n[t.type]
			return r ? r(e, t) || t.defaultPrevented : !1
		})
	}
	function Qge(e, t) {
		if (!t.bubbles) return !0
		if (t.defaultPrevented) return !1
		for (let n = t.target; n != e.dom; n = n.parentNode)
			if (!n || n.nodeType == 11 || (n.pmViewDesc && n.pmViewDesc.stopEvent(t))) return !1
		return !0
	}
	function Xge(e, t) {
		!kO(e, t) && Yi[t.type] && (e.editable || !(t.type in Ei)) && Yi[t.type](e, t)
	}
	Ei.keydown = (e, t) => {
		let n = t
		if (
			((e.input.shiftKey = n.keyCode == 16 || n.shiftKey),
			!wU(e, n) &&
				((e.input.lastKeyCode = n.keyCode),
				(e.input.lastKeyCodeTime = Date.now()),
				!(Zo && yi && n.keyCode == 13)))
		)
			if (
				(n.keyCode != 229 && e.domObserver.forceFlush(),
				fp && n.keyCode == 13 && !n.ctrlKey && !n.altKey && !n.metaKey)
			) {
				let r = Date.now()
				;(e.input.lastIOSEnter = r),
					(e.input.lastIOSEnterFallbackTimeout = setTimeout(() => {
						e.input.lastIOSEnter == r &&
							(e.someProp("handleKeyDown", (i) => i(e, jf(13, "Enter"))),
							(e.input.lastIOSEnter = 0))
					}, 200))
			} else
				e.someProp("handleKeyDown", (r) => r(e, n)) || $ge(e, n) ? n.preventDefault() : $c(e, "key")
	}
	Ei.keyup = (e, t) => {
		t.keyCode == 16 && (e.input.shiftKey = !1)
	}
	Ei.keypress = (e, t) => {
		let n = t
		if (wU(e, n) || !n.charCode || (n.ctrlKey && !n.altKey) || (Pa && n.metaKey)) return
		if (e.someProp("handleKeyPress", (i) => i(e, n))) {
			n.preventDefault()
			return
		}
		let r = e.state.selection
		if (!(r instanceof jt) || !r.$from.sameParent(r.$to)) {
			let i = String.fromCharCode(n.charCode)
			e.someProp("handleTextInput", (a) => a(e, r.$from.pos, r.$to.pos, i)) ||
				e.dispatch(e.state.tr.insertText(i).scrollIntoView()),
				n.preventDefault()
		}
	}
	function iw(e) {
		return { left: e.clientX, top: e.clientY }
	}
	function Jge(e, t) {
		let n = t.x - e.clientX,
			r = t.y - e.clientY
		return n * n + r * r < 100
	}
	function SO(e, t, n, r, i) {
		if (r == -1) return !1
		let a = e.state.doc.resolve(r)
		for (let o = a.depth + 1; o > 0; o--)
			if (
				e.someProp(t, (s) =>
					o > a.depth
						? s(e, n, a.nodeAfter, a.before(o), i, !0)
						: s(e, n, a.node(o), a.before(o), i, !1),
				)
			)
				return !0
		return !1
	}
	function Gf(e, t, n) {
		e.focused || e.focus()
		let r = e.state.tr.setSelection(t)
		r.setMeta("pointer", !0), e.dispatch(r)
	}
	function Zge(e, t) {
		if (t == -1) return !1
		let n = e.state.doc.resolve(t),
			r = n.nodeAfter
		return r && r.isAtom && vt.isSelectable(r) ? (Gf(e, new vt(n)), !0) : !1
	}
	function e0e(e, t) {
		if (t == -1) return !1
		let n = e.state.selection,
			r,
			i
		n instanceof vt && (r = n.node)
		let a = e.state.doc.resolve(t)
		for (let o = a.depth + 1; o > 0; o--) {
			let s = o > a.depth ? a.nodeAfter : a.node(o)
			if (vt.isSelectable(s)) {
				r && n.$from.depth > 0 && o >= n.$from.depth && a.before(n.$from.depth + 1) == n.$from.pos
					? (i = a.before(n.$from.depth))
					: (i = a.before(o))
				break
			}
		}
		return i != null ? (Gf(e, vt.create(e.state.doc, i)), !0) : !1
	}
	function t0e(e, t, n, r, i) {
		return (
			SO(e, "handleClickOn", t, n, r) ||
			e.someProp("handleClick", (a) => a(e, t, r)) ||
			(i ? e0e(e, n) : Zge(e, n))
		)
	}
	function n0e(e, t, n, r) {
		return (
			SO(e, "handleDoubleClickOn", t, n, r) || e.someProp("handleDoubleClick", (i) => i(e, t, r))
		)
	}
	function r0e(e, t, n, r) {
		return (
			SO(e, "handleTripleClickOn", t, n, r) ||
			e.someProp("handleTripleClick", (i) => i(e, t, r)) ||
			i0e(e, n, r)
		)
	}
	function i0e(e, t, n) {
		if (n.button != 0) return !1
		let r = e.state.doc
		if (t == -1) return r.inlineContent ? (Gf(e, jt.create(r, 0, r.content.size)), !0) : !1
		let i = r.resolve(t)
		for (let a = i.depth + 1; a > 0; a--) {
			let o = a > i.depth ? i.nodeAfter : i.node(a),
				s = i.before(a)
			if (o.inlineContent) Gf(e, jt.create(r, s + 1, s + 1 + o.content.size))
			else if (vt.isSelectable(o)) Gf(e, vt.create(r, s))
			else continue
			return !0
		}
	}
	function DO(e) {
		return cb(e)
	}
	const xU = Pa ? "metaKey" : "ctrlKey"
	Yi.mousedown = (e, t) => {
		let n = t
		e.input.shiftKey = n.shiftKey
		let r = DO(e),
			i = Date.now(),
			a = "singleClick"
		i - e.input.lastClick.time < 500 &&
			Jge(n, e.input.lastClick) &&
			!n[xU] &&
			(e.input.lastClick.type == "singleClick"
				? (a = "doubleClick")
				: e.input.lastClick.type == "doubleClick" && (a = "tripleClick")),
			(e.input.lastClick = { time: i, x: n.clientX, y: n.clientY, type: a })
		let o = e.posAtCoords(iw(n))
		o &&
			(a == "singleClick"
				? (e.input.mouseDown && e.input.mouseDown.done(),
				  (e.input.mouseDown = new a0e(e, o, n, !!r)))
				: (a == "doubleClick" ? n0e : r0e)(e, o.pos, o.inside, n)
				? n.preventDefault()
				: $c(e, "pointer"))
	}
	class a0e {
		constructor(t, n, r, i) {
			;(this.view = t),
				(this.pos = n),
				(this.event = r),
				(this.flushed = i),
				(this.delayedSelectionSync = !1),
				(this.mightDrag = null),
				(this.startDoc = t.state.doc),
				(this.selectNode = !!r[xU]),
				(this.allowDefault = r.shiftKey)
			let a, o
			if (n.inside > -1) (a = t.state.doc.nodeAt(n.inside)), (o = n.inside)
			else {
				let d = t.state.doc.resolve(n.pos)
				;(a = d.parent), (o = d.depth ? d.before() : 0)
			}
			const s = i ? null : r.target,
				l = s ? t.docView.nearestDesc(s, !0) : null
			this.target = l ? l.dom : null
			let { selection: u } = t.state
			;((r.button == 0 && a.type.spec.draggable && a.type.spec.selectable !== !1) ||
				(u instanceof vt && u.from <= o && u.to > o)) &&
				(this.mightDrag = {
					node: a,
					pos: o,
					addAttr: !!(this.target && !this.target.draggable),
					setUneditable: !!(this.target && ms && !this.target.hasAttribute("contentEditable")),
				}),
				this.target &&
					this.mightDrag &&
					(this.mightDrag.addAttr || this.mightDrag.setUneditable) &&
					(this.view.domObserver.stop(),
					this.mightDrag.addAttr && (this.target.draggable = !0),
					this.mightDrag.setUneditable &&
						setTimeout(() => {
							this.view.input.mouseDown == this &&
								this.target.setAttribute("contentEditable", "false")
						}, 20),
					this.view.domObserver.start()),
				t.root.addEventListener("mouseup", (this.up = this.up.bind(this))),
				t.root.addEventListener("mousemove", (this.move = this.move.bind(this))),
				$c(t, "pointer")
		}
		done() {
			this.view.root.removeEventListener("mouseup", this.up),
				this.view.root.removeEventListener("mousemove", this.move),
				this.mightDrag &&
					this.target &&
					(this.view.domObserver.stop(),
					this.mightDrag.addAttr && this.target.removeAttribute("draggable"),
					this.mightDrag.setUneditable && this.target.removeAttribute("contentEditable"),
					this.view.domObserver.start()),
				this.delayedSelectionSync && setTimeout(() => Hu(this.view)),
				(this.view.input.mouseDown = null)
		}
		up(t) {
			if ((this.done(), !this.view.dom.contains(t.target))) return
			let n = this.pos
			this.view.state.doc != this.startDoc && (n = this.view.posAtCoords(iw(t))),
				this.allowDefault || !n
					? $c(this.view, "pointer")
					: t0e(this.view, n.pos, n.inside, t, this.selectNode)
					? t.preventDefault()
					: t.button == 0 &&
					  (this.flushed ||
							(Wi && this.mightDrag && !this.mightDrag.node.isAtom) ||
							(yi &&
								!(this.view.state.selection instanceof jt) &&
								Math.min(
									Math.abs(n.pos - this.view.state.selection.from),
									Math.abs(n.pos - this.view.state.selection.to),
								) <= 2))
					? (Gf(this.view, _t.near(this.view.state.doc.resolve(n.pos))), t.preventDefault())
					: $c(this.view, "pointer")
		}
		move(t) {
			!this.allowDefault &&
				(Math.abs(this.event.x - t.clientX) > 4 || Math.abs(this.event.y - t.clientY) > 4) &&
				(this.allowDefault = !0),
				$c(this.view, "pointer"),
				t.buttons == 0 && this.done()
		}
	}
	Yi.touchdown = (e) => {
		DO(e), $c(e, "pointer")
	}
	Yi.contextmenu = (e) => DO(e)
	function wU(e, t) {
		return e.composing
			? !0
			: Wi && Math.abs(t.timeStamp - e.input.compositionEndedAt) < 500
			? ((e.input.compositionEndedAt = -2e8), !0)
			: !1
	}
	const o0e = Zo ? 5e3 : -1
	Ei.compositionstart = Ei.compositionupdate = (e) => {
		if (!e.composing) {
			e.domObserver.flush()
			let { state: t } = e,
				n = t.selection.$from
			if (
				t.selection.empty &&
				(t.storedMarks ||
					(!n.textOffset &&
						n.parentOffset &&
						n.nodeBefore.marks.some((r) => r.type.spec.inclusive === !1)))
			)
				(e.markCursor = e.state.storedMarks || n.marks()), cb(e, !0), (e.markCursor = null)
			else if (
				(cb(e),
				ms && t.selection.empty && n.parentOffset && !n.textOffset && n.nodeBefore.marks.length)
			) {
				let r = e.domSelection()
				for (let i = r.focusNode, a = r.focusOffset; i && i.nodeType == 1 && a != 0; ) {
					let o = a < 0 ? i.lastChild : i.childNodes[a - 1]
					if (!o) break
					if (o.nodeType == 3) {
						r.collapse(o, o.nodeValue.length)
						break
					} else (i = o), (a = -1)
				}
			}
			e.input.composing = !0
		}
		EU(e, o0e)
	}
	Ei.compositionend = (e, t) => {
		e.composing && ((e.input.composing = !1), (e.input.compositionEndedAt = t.timeStamp), EU(e, 20))
	}
	function EU(e, t) {
		clearTimeout(e.input.composingTimeout),
			t > -1 && (e.input.composingTimeout = setTimeout(() => cb(e), t))
	}
	function CU(e) {
		for (
			e.composing && ((e.input.composing = !1), (e.input.compositionEndedAt = s0e()));
			e.input.compositionNodes.length > 0;

		)
			e.input.compositionNodes.pop().markParentsDirty()
	}
	function s0e() {
		let e = document.createEvent("Event")
		return e.initEvent("event", !0, !0), e.timeStamp
	}
	function cb(e, t = !1) {
		if (!(Zo && e.domObserver.flushingSoon >= 0)) {
			if ((e.domObserver.forceFlush(), CU(e), t || (e.docView && e.docView.dirty))) {
				let n = lU(e)
				return (
					n && !n.eq(e.state.selection)
						? e.dispatch(e.state.tr.setSelection(n))
						: e.updateState(e.state),
					!0
				)
			}
			return !1
		}
	}
	function l0e(e, t) {
		if (!e.dom.parentNode) return
		let n = e.dom.parentNode.appendChild(document.createElement("div"))
		n.appendChild(t), (n.style.cssText = "position: fixed; left: -10000px; top: 10px")
		let r = getSelection(),
			i = document.createRange()
		i.selectNodeContents(t),
			e.dom.blur(),
			r.removeAllRanges(),
			r.addRange(i),
			setTimeout(() => {
				n.parentNode && n.parentNode.removeChild(n), e.focus()
			}, 50)
	}
	const pp = (ma && ku < 15) || (fp && sge < 604)
	Yi.copy = Ei.cut = (e, t) => {
		let n = t,
			r = e.state.selection,
			i = n.type == "cut"
		if (r.empty) return
		let a = pp ? null : n.clipboardData,
			o = r.content(),
			{ dom: s, text: l } = pU(e, o)
		a
			? (n.preventDefault(),
			  a.clearData(),
			  a.setData("text/html", s.innerHTML),
			  a.setData("text/plain", l))
			: l0e(e, s),
			i && e.dispatch(e.state.tr.deleteSelection().scrollIntoView().setMeta("uiEvent", "cut"))
	}
	function u0e(e) {
		return e.openStart == 0 && e.openEnd == 0 && e.content.childCount == 1
			? e.content.firstChild
			: null
	}
	function c0e(e, t) {
		if (!e.dom.parentNode) return
		let n = e.input.shiftKey || e.state.selection.$from.parent.type.spec.code,
			r = e.dom.parentNode.appendChild(document.createElement(n ? "textarea" : "div"))
		n || (r.contentEditable = "true"),
			(r.style.cssText = "position: fixed; left: -10000px; top: 10px"),
			r.focus(),
			setTimeout(() => {
				e.focus(),
					r.parentNode && r.parentNode.removeChild(r),
					n ? I2(e, r.value, null, t) : I2(e, r.textContent, r.innerHTML, t)
			}, 50)
	}
	function I2(e, t, n, r) {
		let i = hU(e, t, n, e.input.shiftKey, e.state.selection.$from)
		if (e.someProp("handlePaste", (s) => s(e, r, i || Ue.empty))) return !0
		if (!i) return !1
		let a = u0e(i),
			o = a ? e.state.tr.replaceSelectionWith(a, e.input.shiftKey) : e.state.tr.replaceSelection(i)
		return e.dispatch(o.scrollIntoView().setMeta("paste", !0).setMeta("uiEvent", "paste")), !0
	}
	Ei.paste = (e, t) => {
		let n = t
		if (e.composing && !Zo) return
		let r = pp ? null : n.clipboardData
		r && I2(e, r.getData("text/plain"), r.getData("text/html"), n) ? n.preventDefault() : c0e(e, n)
	}
	class d0e {
		constructor(t, n) {
			;(this.slice = t), (this.move = n)
		}
	}
	const TU = Pa ? "altKey" : "ctrlKey"
	Yi.dragstart = (e, t) => {
		let n = t,
			r = e.input.mouseDown
		if ((r && r.done(), !n.dataTransfer)) return
		let i = e.state.selection,
			a = i.empty ? null : e.posAtCoords(iw(n))
		if (!(a && a.pos >= i.from && a.pos <= (i instanceof vt ? i.to - 1 : i.to))) {
			if (r && r.mightDrag)
				e.dispatch(e.state.tr.setSelection(vt.create(e.state.doc, r.mightDrag.pos)))
			else if (n.target && n.target.nodeType == 1) {
				let u = e.docView.nearestDesc(n.target, !0)
				u &&
					u.node.type.spec.draggable &&
					u != e.docView &&
					e.dispatch(e.state.tr.setSelection(vt.create(e.state.doc, u.posBefore)))
			}
		}
		let o = e.state.selection.content(),
			{ dom: s, text: l } = pU(e, o)
		n.dataTransfer.clearData(),
			n.dataTransfer.setData(pp ? "Text" : "text/html", s.innerHTML),
			(n.dataTransfer.effectAllowed = "copyMove"),
			pp || n.dataTransfer.setData("text/plain", l),
			(e.dragging = new d0e(o, !n[TU]))
	}
	Yi.dragend = (e) => {
		let t = e.dragging
		window.setTimeout(() => {
			e.dragging == t && (e.dragging = null)
		}, 50)
	}
	Ei.dragover = Ei.dragenter = (e, t) => t.preventDefault()
	Ei.drop = (e, t) => {
		let n = t,
			r = e.dragging
		if (((e.dragging = null), !n.dataTransfer)) return
		let i = e.posAtCoords(iw(n))
		if (!i) return
		let a = e.state.doc.resolve(i.pos)
		if (!a) return
		let o = r && r.slice
		o
			? e.someProp("transformPasted", (y) => {
					o = y(o)
			  })
			: (o = hU(
					e,
					n.dataTransfer.getData(pp ? "Text" : "text/plain"),
					pp ? null : n.dataTransfer.getData("text/html"),
					!1,
					a,
			  ))
		let s = !!(r && !n[TU])
		if (e.someProp("handleDrop", (y) => y(e, n, o || Ue.empty, s))) {
			n.preventDefault()
			return
		}
		if (!o) return
		n.preventDefault()
		let l = o ? Kve(e.state.doc, a.pos, o) : a.pos
		l == null && (l = a.pos)
		let u = e.state.tr
		s && u.deleteSelection()
		let d = u.mapping.map(l),
			p = o.openStart == 0 && o.openEnd == 0 && o.content.childCount == 1,
			m = u.doc
		if ((p ? u.replaceRangeWith(d, d, o.content.firstChild) : u.replaceRange(d, d, o), u.doc.eq(m)))
			return
		let v = u.doc.resolve(d)
		if (
			p &&
			vt.isSelectable(o.content.firstChild) &&
			v.nodeAfter &&
			v.nodeAfter.sameMarkup(o.content.firstChild)
		)
			u.setSelection(new vt(v))
		else {
			let y = u.mapping.map(l)
			u.mapping.maps[u.mapping.maps.length - 1].forEach((b, x, E, T) => (y = T)),
				u.setSelection(TO(e, v, u.doc.resolve(y)))
		}
		e.focus(), e.dispatch(u.setMeta("uiEvent", "drop"))
	}
	Yi.focus = (e) => {
		e.focused ||
			(e.domObserver.stop(),
			e.dom.classList.add("ProseMirror-focused"),
			e.domObserver.start(),
			(e.focused = !0),
			setTimeout(() => {
				e.docView && e.hasFocus() && !e.domObserver.currentSelection.eq(e.domSelection()) && Hu(e)
			}, 20))
	}
	Yi.blur = (e, t) => {
		let n = t
		e.focused &&
			(e.domObserver.stop(),
			e.dom.classList.remove("ProseMirror-focused"),
			e.domObserver.start(),
			n.relatedTarget && e.dom.contains(n.relatedTarget) && e.domObserver.currentSelection.clear(),
			(e.focused = !1))
	}
	Yi.beforeinput = (e, t) => {
		if (yi && Zo && t.inputType == "deleteContentBackward") {
			e.domObserver.flushSoon()
			let { domChangeCount: r } = e.input
			setTimeout(() => {
				if (
					e.input.domChangeCount != r ||
					(e.dom.blur(), e.focus(), e.someProp("handleKeyDown", (a) => a(e, jf(8, "Backspace"))))
				)
					return
				let { $cursor: i } = e.state.selection
				i && i.pos > 0 && e.dispatch(e.state.tr.delete(i.pos - 1, i.pos).scrollIntoView())
			}, 50)
		}
	}
	for (let e in Ei) Yi[e] = Ei[e]
	function Dv(e, t) {
		if (e == t) return !0
		for (let n in e) if (e[n] !== t[n]) return !1
		for (let n in t) if (!(n in e)) return !1
		return !0
	}
	class _O {
		constructor(t, n) {
			;(this.toDOM = t), (this.spec = n || Zc), (this.side = this.spec.side || 0)
		}
		map(t, n, r, i) {
			let { pos: a, deleted: o } = t.mapResult(n.from + i, this.side < 0 ? -1 : 1)
			return o ? null : new $i(a - r, a - r, this)
		}
		valid() {
			return !0
		}
		eq(t) {
			return (
				this == t ||
				(t instanceof _O &&
					((this.spec.key && this.spec.key == t.spec.key) ||
						(this.toDOM == t.toDOM && Dv(this.spec, t.spec))))
			)
		}
		destroy(t) {
			this.spec.destroy && this.spec.destroy(t)
		}
	}
	class Su {
		constructor(t, n) {
			;(this.attrs = t), (this.spec = n || Zc)
		}
		map(t, n, r, i) {
			let a = t.map(n.from + i, this.spec.inclusiveStart ? -1 : 1) - r,
				o = t.map(n.to + i, this.spec.inclusiveEnd ? 1 : -1) - r
			return a >= o ? null : new $i(a, o, this)
		}
		valid(t, n) {
			return n.from < n.to
		}
		eq(t) {
			return this == t || (t instanceof Su && Dv(this.attrs, t.attrs) && Dv(this.spec, t.spec))
		}
		static is(t) {
			return t.type instanceof Su
		}
		destroy() {}
	}
	class OO {
		constructor(t, n) {
			;(this.attrs = t), (this.spec = n || Zc)
		}
		map(t, n, r, i) {
			let a = t.mapResult(n.from + i, 1)
			if (a.deleted) return null
			let o = t.mapResult(n.to + i, -1)
			return o.deleted || o.pos <= a.pos ? null : new $i(a.pos - r, o.pos - r, this)
		}
		valid(t, n) {
			let { index: r, offset: i } = t.content.findIndex(n.from),
				a
			return i == n.from && !(a = t.child(r)).isText && i + a.nodeSize == n.to
		}
		eq(t) {
			return this == t || (t instanceof OO && Dv(this.attrs, t.attrs) && Dv(this.spec, t.spec))
		}
		destroy() {}
	}
	class $i {
		constructor(t, n, r) {
			;(this.from = t), (this.to = n), (this.type = r)
		}
		copy(t, n) {
			return new $i(t, n, this.type)
		}
		eq(t, n = 0) {
			return this.type.eq(t.type) && this.from + n == t.from && this.to + n == t.to
		}
		map(t, n, r) {
			return this.type.map(t, this, n, r)
		}
		static widget(t, n, r) {
			return new $i(t, t, new _O(n, r))
		}
		static inline(t, n, r, i) {
			return new $i(t, n, new Su(r, i))
		}
		static node(t, n, r, i) {
			return new $i(t, n, new OO(r, i))
		}
		get spec() {
			return this.type.spec
		}
		get inline() {
			return this.type instanceof Su
		}
	}
	const Of = [],
		Zc = {}
	class mr {
		constructor(t, n) {
			;(this.local = t.length ? t : Of), (this.children = n.length ? n : Of)
		}
		static create(t, n) {
			return n.length ? db(n, t, 0, Zc) : Xr
		}
		find(t, n, r) {
			let i = []
			return this.findInner(t ?? 0, n ?? 1e9, i, 0, r), i
		}
		findInner(t, n, r, i, a) {
			for (let o = 0; o < this.local.length; o++) {
				let s = this.local[o]
				s.from <= n && s.to >= t && (!a || a(s.spec)) && r.push(s.copy(s.from + i, s.to + i))
			}
			for (let o = 0; o < this.children.length; o += 3)
				if (this.children[o] < n && this.children[o + 1] > t) {
					let s = this.children[o] + 1
					this.children[o + 2].findInner(t - s, n - s, r, i + s, a)
				}
		}
		map(t, n, r) {
			return this == Xr || t.maps.length == 0 ? this : this.mapInner(t, n, 0, 0, r || Zc)
		}
		mapInner(t, n, r, i, a) {
			let o
			for (let s = 0; s < this.local.length; s++) {
				let l = this.local[s].map(t, r, i)
				l && l.type.valid(n, l)
					? (o || (o = [])).push(l)
					: a.onRemove && a.onRemove(this.local[s].spec)
			}
			return this.children.length
				? f0e(this.children, o || [], t, n, r, i, a)
				: o
				? new mr(o.sort(ed), Of)
				: Xr
		}
		add(t, n) {
			return n.length ? (this == Xr ? mr.create(t, n) : this.addInner(t, n, 0)) : this
		}
		addInner(t, n, r) {
			let i,
				a = 0
			t.forEach((s, l) => {
				let u = l + r,
					d
				if ((d = SU(n, s, u))) {
					for (i || (i = this.children.slice()); a < i.length && i[a] < l; ) a += 3
					i[a] == l
						? (i[a + 2] = i[a + 2].addInner(s, d, u + 1))
						: i.splice(a, 0, l, l + s.nodeSize, db(d, s, u + 1, Zc)),
						(a += 3)
				}
			})
			let o = kU(a ? DU(n) : n, -r)
			for (let s = 0; s < o.length; s++) o[s].type.valid(t, o[s]) || o.splice(s--, 1)
			return new mr(o.length ? this.local.concat(o).sort(ed) : this.local, i || this.children)
		}
		remove(t) {
			return t.length == 0 || this == Xr ? this : this.removeInner(t, 0)
		}
		removeInner(t, n) {
			let r = this.children,
				i = this.local
			for (let a = 0; a < r.length; a += 3) {
				let o,
					s = r[a] + n,
					l = r[a + 1] + n
				for (let d = 0, p; d < t.length; d++)
					(p = t[d]) && p.from > s && p.to < l && ((t[d] = null), (o || (o = [])).push(p))
				if (!o) continue
				r == this.children && (r = this.children.slice())
				let u = r[a + 2].removeInner(o, s + 1)
				u != Xr ? (r[a + 2] = u) : (r.splice(a, 3), (a -= 3))
			}
			if (i.length) {
				for (let a = 0, o; a < t.length; a++)
					if ((o = t[a]))
						for (let s = 0; s < i.length; s++)
							i[s].eq(o, n) && (i == this.local && (i = this.local.slice()), i.splice(s--, 1))
			}
			return r == this.children && i == this.local ? this : i.length || r.length ? new mr(i, r) : Xr
		}
		forChild(t, n) {
			if (this == Xr) return this
			if (n.isLeaf) return mr.empty
			let r, i
			for (let s = 0; s < this.children.length; s += 3)
				if (this.children[s] >= t) {
					this.children[s] == t && (r = this.children[s + 2])
					break
				}
			let a = t + 1,
				o = a + n.content.size
			for (let s = 0; s < this.local.length; s++) {
				let l = this.local[s]
				if (l.from < o && l.to > a && l.type instanceof Su) {
					let u = Math.max(a, l.from) - a,
						d = Math.min(o, l.to) - a
					u < d && (i || (i = [])).push(l.copy(u, d))
				}
			}
			if (i) {
				let s = new mr(i.sort(ed), Of)
				return r ? new mu([s, r]) : s
			}
			return r || Xr
		}
		eq(t) {
			if (this == t) return !0
			if (
				!(t instanceof mr) ||
				this.local.length != t.local.length ||
				this.children.length != t.children.length
			)
				return !1
			for (let n = 0; n < this.local.length; n++) if (!this.local[n].eq(t.local[n])) return !1
			for (let n = 0; n < this.children.length; n += 3)
				if (
					this.children[n] != t.children[n] ||
					this.children[n + 1] != t.children[n + 1] ||
					!this.children[n + 2].eq(t.children[n + 2])
				)
					return !1
			return !0
		}
		locals(t) {
			return AO(this.localsInner(t))
		}
		localsInner(t) {
			if (this == Xr) return Of
			if (t.inlineContent || !this.local.some(Su.is)) return this.local
			let n = []
			for (let r = 0; r < this.local.length; r++)
				this.local[r].type instanceof Su || n.push(this.local[r])
			return n
		}
	}
	mr.empty = new mr([], [])
	mr.removeOverlap = AO
	const Xr = mr.empty
	class mu {
		constructor(t) {
			this.members = t
		}
		map(t, n) {
			const r = this.members.map((i) => i.map(t, n, Zc))
			return mu.from(r)
		}
		forChild(t, n) {
			if (n.isLeaf) return mr.empty
			let r = []
			for (let i = 0; i < this.members.length; i++) {
				let a = this.members[i].forChild(t, n)
				a != Xr && (a instanceof mu ? (r = r.concat(a.members)) : r.push(a))
			}
			return mu.from(r)
		}
		eq(t) {
			if (!(t instanceof mu) || t.members.length != this.members.length) return !1
			for (let n = 0; n < this.members.length; n++) if (!this.members[n].eq(t.members[n])) return !1
			return !0
		}
		locals(t) {
			let n,
				r = !0
			for (let i = 0; i < this.members.length; i++) {
				let a = this.members[i].localsInner(t)
				if (a.length)
					if (!n) n = a
					else {
						r && ((n = n.slice()), (r = !1))
						for (let o = 0; o < a.length; o++) n.push(a[o])
					}
			}
			return n ? AO(r ? n : n.sort(ed)) : Of
		}
		static from(t) {
			switch (t.length) {
				case 0:
					return Xr
				case 1:
					return t[0]
				default:
					return new mu(t)
			}
		}
	}
	function f0e(e, t, n, r, i, a, o) {
		let s = e.slice(),
			l = (d, p, m, v) => {
				for (let y = 0; y < s.length; y += 3) {
					let b = s[y + 1],
						x
					if (b < 0 || d > b + a) continue
					let E = s[y] + a
					p >= E
						? (s[y + 1] = d <= E ? -2 : -1)
						: m >= i && (x = v - m - (p - d)) && ((s[y] += x), (s[y + 1] += x))
				}
			}
		for (let d = 0; d < n.maps.length; d++) n.maps[d].forEach(l)
		let u = !1
		for (let d = 0; d < s.length; d += 3)
			if (s[d + 1] < 0) {
				if (s[d + 1] == -2) {
					;(u = !0), (s[d + 1] = -1)
					continue
				}
				let p = n.map(e[d] + a),
					m = p - i
				if (m < 0 || m >= r.content.size) {
					u = !0
					continue
				}
				let v = n.map(e[d + 1] + a, -1),
					y = v - i,
					{ index: b, offset: x } = r.content.findIndex(m),
					E = r.maybeChild(b)
				if (E && x == m && x + E.nodeSize == y) {
					let T = s[d + 2].mapInner(n, E, p + 1, e[d] + a + 1, o)
					T != Xr ? ((s[d] = m), (s[d + 1] = y), (s[d + 2] = T)) : ((s[d + 1] = -2), (u = !0))
				} else u = !0
			}
		if (u) {
			let d = p0e(s, e, t, n, i, a, o),
				p = db(d, r, 0, o)
			t = p.local
			for (let m = 0; m < s.length; m += 3) s[m + 1] < 0 && (s.splice(m, 3), (m -= 3))
			for (let m = 0, v = 0; m < p.children.length; m += 3) {
				let y = p.children[m]
				for (; v < s.length && s[v] < y; ) v += 3
				s.splice(v, 0, p.children[m], p.children[m + 1], p.children[m + 2])
			}
		}
		return new mr(t.sort(ed), s)
	}
	function kU(e, t) {
		if (!t || !e.length) return e
		let n = []
		for (let r = 0; r < e.length; r++) {
			let i = e[r]
			n.push(new $i(i.from + t, i.to + t, i.type))
		}
		return n
	}
	function p0e(e, t, n, r, i, a, o) {
		function s(l, u) {
			for (let d = 0; d < l.local.length; d++) {
				let p = l.local[d].map(r, i, u)
				p ? n.push(p) : o.onRemove && o.onRemove(l.local[d].spec)
			}
			for (let d = 0; d < l.children.length; d += 3) s(l.children[d + 2], l.children[d] + u + 1)
		}
		for (let l = 0; l < e.length; l += 3) e[l + 1] == -1 && s(e[l + 2], t[l] + a + 1)
		return n
	}
	function SU(e, t, n) {
		if (t.isLeaf) return null
		let r = n + t.nodeSize,
			i = null
		for (let a = 0, o; a < e.length; a++)
			(o = e[a]) && o.from > n && o.to < r && ((i || (i = [])).push(o), (e[a] = null))
		return i
	}
	function DU(e) {
		let t = []
		for (let n = 0; n < e.length; n++) e[n] != null && t.push(e[n])
		return t
	}
	function db(e, t, n, r) {
		let i = [],
			a = !1
		t.forEach((s, l) => {
			let u = SU(e, s, l + n)
			if (u) {
				a = !0
				let d = db(u, s, n + l + 1, r)
				d != Xr && i.push(l, l + s.nodeSize, d)
			}
		})
		let o = kU(a ? DU(e) : e, -n).sort(ed)
		for (let s = 0; s < o.length; s++)
			o[s].type.valid(t, o[s]) || (r.onRemove && r.onRemove(o[s].spec), o.splice(s--, 1))
		return o.length || i.length ? new mr(o, i) : Xr
	}
	function ed(e, t) {
		return e.from - t.from || e.to - t.to
	}
	function AO(e) {
		let t = e
		for (let n = 0; n < t.length - 1; n++) {
			let r = t[n]
			if (r.from != r.to)
				for (let i = n + 1; i < t.length; i++) {
					let a = t[i]
					if (a.from == r.from) {
						a.to != r.to &&
							(t == e && (t = e.slice()),
							(t[i] = a.copy(a.from, r.to)),
							F3(t, i + 1, a.copy(r.to, a.to)))
						continue
					} else {
						a.from < r.to &&
							(t == e && (t = e.slice()),
							(t[n] = r.copy(r.from, a.from)),
							F3(t, i, r.copy(a.from, r.to)))
						break
					}
				}
		}
		return t
	}
	function F3(e, t, n) {
		for (; t < e.length && ed(n, e[t]) > 0; ) t++
		e.splice(t, 0, n)
	}
	function uk(e) {
		let t = []
		return (
			e.someProp("decorations", (n) => {
				let r = n(e.state)
				r && r != Xr && t.push(r)
			}),
			e.cursorWrapper && t.push(mr.create(e.state.doc, [e.cursorWrapper.deco])),
			mu.from(t)
		)
	}
	const h0e = {
			childList: !0,
			characterData: !0,
			characterDataOldValue: !0,
			attributes: !0,
			attributeOldValue: !0,
			subtree: !0,
		},
		m0e = ma && ku <= 11
	class v0e {
		constructor() {
			;(this.anchorNode = null),
				(this.anchorOffset = 0),
				(this.focusNode = null),
				(this.focusOffset = 0)
		}
		set(t) {
			;(this.anchorNode = t.anchorNode),
				(this.anchorOffset = t.anchorOffset),
				(this.focusNode = t.focusNode),
				(this.focusOffset = t.focusOffset)
		}
		clear() {
			this.anchorNode = this.focusNode = null
		}
		eq(t) {
			return (
				t.anchorNode == this.anchorNode &&
				t.anchorOffset == this.anchorOffset &&
				t.focusNode == this.focusNode &&
				t.focusOffset == this.focusOffset
			)
		}
	}
	class g0e {
		constructor(t, n) {
			;(this.view = t),
				(this.handleDOMChange = n),
				(this.queue = []),
				(this.flushingSoon = -1),
				(this.observer = null),
				(this.currentSelection = new v0e()),
				(this.onCharData = null),
				(this.suppressingSelectionUpdates = !1),
				(this.observer =
					window.MutationObserver &&
					new window.MutationObserver((r) => {
						for (let i = 0; i < r.length; i++) this.queue.push(r[i])
						ma &&
						ku <= 11 &&
						r.some(
							(i) =>
								(i.type == "childList" && i.removedNodes.length) ||
								(i.type == "characterData" && i.oldValue.length > i.target.nodeValue.length),
						)
							? this.flushSoon()
							: this.flush()
					})),
				m0e &&
					(this.onCharData = (r) => {
						this.queue.push({ target: r.target, type: "characterData", oldValue: r.prevValue }),
							this.flushSoon()
					}),
				(this.onSelectionChange = this.onSelectionChange.bind(this))
		}
		flushSoon() {
			this.flushingSoon < 0 &&
				(this.flushingSoon = window.setTimeout(() => {
					;(this.flushingSoon = -1), this.flush()
				}, 20))
		}
		forceFlush() {
			this.flushingSoon > -1 &&
				(window.clearTimeout(this.flushingSoon), (this.flushingSoon = -1), this.flush())
		}
		start() {
			this.observer && (this.observer.takeRecords(), this.observer.observe(this.view.dom, h0e)),
				this.onCharData &&
					this.view.dom.addEventListener("DOMCharacterDataModified", this.onCharData),
				this.connectSelection()
		}
		stop() {
			if (this.observer) {
				let t = this.observer.takeRecords()
				if (t.length) {
					for (let n = 0; n < t.length; n++) this.queue.push(t[n])
					window.setTimeout(() => this.flush(), 20)
				}
				this.observer.disconnect()
			}
			this.onCharData &&
				this.view.dom.removeEventListener("DOMCharacterDataModified", this.onCharData),
				this.disconnectSelection()
		}
		connectSelection() {
			this.view.dom.ownerDocument.addEventListener("selectionchange", this.onSelectionChange)
		}
		disconnectSelection() {
			this.view.dom.ownerDocument.removeEventListener("selectionchange", this.onSelectionChange)
		}
		suppressSelectionUpdates() {
			;(this.suppressingSelectionUpdates = !0),
				setTimeout(() => (this.suppressingSelectionUpdates = !1), 50)
		}
		onSelectionChange() {
			if (N3(this.view)) {
				if (this.suppressingSelectionUpdates) return Hu(this.view)
				if (ma && ku <= 11 && !this.view.state.selection.empty) {
					let t = this.view.domSelection()
					if (t.focusNode && Sv(t.focusNode, t.focusOffset, t.anchorNode, t.anchorOffset))
						return this.flushSoon()
				}
				this.flush()
			}
		}
		setCurSelection() {
			this.currentSelection.set(this.view.domSelection())
		}
		ignoreSelectionChange(t) {
			if (t.rangeCount == 0) return !0
			let n = t.getRangeAt(0).commonAncestorContainer,
				r = this.view.docView.nearestDesc(n)
			if (r && r.ignoreMutation({ type: "selection", target: n.nodeType == 3 ? n.parentNode : n }))
				return this.setCurSelection(), !0
		}
		flush() {
			if (!this.view.docView || this.flushingSoon > -1) return
			let t = this.observer ? this.observer.takeRecords() : []
			this.queue.length && ((t = this.queue.concat(t)), (this.queue.length = 0))
			let n = this.view.domSelection(),
				r =
					!this.suppressingSelectionUpdates &&
					!this.currentSelection.eq(n) &&
					N3(this.view) &&
					!this.ignoreSelectionChange(n),
				i = -1,
				a = -1,
				o = !1,
				s = []
			if (this.view.editable)
				for (let l = 0; l < t.length; l++) {
					let u = this.registerMutation(t[l], s)
					u &&
						((i = i < 0 ? u.from : Math.min(u.from, i)),
						(a = a < 0 ? u.to : Math.max(u.to, a)),
						u.typeOver && (o = !0))
				}
			if (ms && s.length > 1) {
				let l = s.filter((u) => u.nodeName == "BR")
				if (l.length == 2) {
					let u = l[0],
						d = l[1]
					u.parentNode && u.parentNode.parentNode == d.parentNode ? d.remove() : u.remove()
				}
			}
			;(i > -1 || r) &&
				(i > -1 && (this.view.docView.markDirty(i, a), y0e(this.view)),
				this.handleDOMChange(i, a, o, s),
				this.view.docView && this.view.docView.dirty
					? this.view.updateState(this.view.state)
					: this.currentSelection.eq(n) || Hu(this.view),
				this.currentSelection.set(n))
		}
		registerMutation(t, n) {
			if (n.indexOf(t.target) > -1) return null
			let r = this.view.docView.nearestDesc(t.target)
			if (
				(t.type == "attributes" &&
					(r == this.view.docView ||
						t.attributeName == "contenteditable" ||
						(t.attributeName == "style" && !t.oldValue && !t.target.getAttribute("style")))) ||
				!r ||
				r.ignoreMutation(t)
			)
				return null
			if (t.type == "childList") {
				for (let d = 0; d < t.addedNodes.length; d++) n.push(t.addedNodes[d])
				if (r.contentDOM && r.contentDOM != r.dom && !r.contentDOM.contains(t.target))
					return { from: r.posBefore, to: r.posAfter }
				let i = t.previousSibling,
					a = t.nextSibling
				if (ma && ku <= 11 && t.addedNodes.length)
					for (let d = 0; d < t.addedNodes.length; d++) {
						let { previousSibling: p, nextSibling: m } = t.addedNodes[d]
						;(!p || Array.prototype.indexOf.call(t.addedNodes, p) < 0) && (i = p),
							(!m || Array.prototype.indexOf.call(t.addedNodes, m) < 0) && (a = m)
					}
				let o = i && i.parentNode == t.target ? aa(i) + 1 : 0,
					s = r.localPosFromDOM(t.target, o, -1),
					l = a && a.parentNode == t.target ? aa(a) : t.target.childNodes.length,
					u = r.localPosFromDOM(t.target, l, 1)
				return { from: s, to: u }
			} else
				return t.type == "attributes"
					? { from: r.posAtStart - r.border, to: r.posAtEnd + r.border }
					: { from: r.posAtStart, to: r.posAtEnd, typeOver: t.target.nodeValue == t.oldValue }
		}
	}
	let B3 = !1
	function y0e(e) {
		B3 ||
			((B3 = !0),
			getComputedStyle(e.dom).whiteSpace == "normal" &&
				console.warn(
					"ProseMirror expects the CSS white-space property to be set, preferably to 'pre-wrap'. It is recommended to load style/prosemirror.css from the prosemirror-view package.",
				))
	}
	function b0e(e, t, n) {
		let { node: r, fromOffset: i, toOffset: a, from: o, to: s } = e.docView.parseRange(t, n),
			l = e.domSelection(),
			u,
			d = l.anchorNode
		if (
			(d &&
				e.dom.contains(d.nodeType == 1 ? d : d.parentNode) &&
				((u = [{ node: d, offset: l.anchorOffset }]),
				EO(l) || u.push({ node: l.focusNode, offset: l.focusOffset })),
			yi && e.input.lastKeyCode === 8)
		)
			for (let x = a; x > i; x--) {
				let E = r.childNodes[x - 1],
					T = E.pmViewDesc
				if (E.nodeName == "BR" && !T) {
					a = x
					break
				}
				if (!T || T.size) break
			}
		let p = e.state.doc,
			m = e.someProp("domParser") || md.fromSchema(e.state.schema),
			v = p.resolve(o),
			y = null,
			b = m.parse(r, {
				topNode: v.parent,
				topMatch: v.parent.contentMatchAt(v.index()),
				topOpen: !0,
				from: i,
				to: a,
				preserveWhitespace: v.parent.type.whitespace == "pre" ? "full" : !0,
				findPositions: u,
				ruleFromNode: x0e,
				context: v,
			})
		if (u && u[0].pos != null) {
			let x = u[0].pos,
				E = u[1] && u[1].pos
			E == null && (E = x), (y = { anchor: x + o, head: E + o })
		}
		return { doc: b, sel: y, from: o, to: s }
	}
	function x0e(e) {
		let t = e.pmViewDesc
		if (t) return t.parseRule()
		if (e.nodeName == "BR" && e.parentNode) {
			if (Wi && /^(ul|ol)$/i.test(e.parentNode.nodeName)) {
				let n = document.createElement("div")
				return n.appendChild(document.createElement("li")), { skip: n }
			} else if (e.parentNode.lastChild == e || (Wi && /^(tr|table)$/i.test(e.parentNode.nodeName)))
				return { ignore: !0 }
		} else if (e.nodeName == "IMG" && e.getAttribute("mark-placeholder")) return { ignore: !0 }
		return null
	}
	function w0e(e, t, n, r, i) {
		if (t < 0) {
			let I = e.input.lastSelectionTime > Date.now() - 50 ? e.input.lastSelectionOrigin : null,
				P = lU(e, I)
			if (P && !e.state.selection.eq(P)) {
				let L = e.state.tr.setSelection(P)
				I == "pointer" ? L.setMeta("pointer", !0) : I == "key" && L.scrollIntoView(), e.dispatch(L)
			}
			return
		}
		let a = e.state.doc.resolve(t),
			o = a.sharedDepth(n)
		;(t = a.before(o + 1)), (n = e.state.doc.resolve(n).after(o + 1))
		let s = e.state.selection,
			l = b0e(e, t, n)
		if (
			yi &&
			e.cursorWrapper &&
			l.sel &&
			l.sel.anchor == e.cursorWrapper.deco.from &&
			l.sel.head == l.sel.anchor
		) {
			let I = e.cursorWrapper.deco.type.toDOM.nextSibling,
				P = I && I.nodeValue ? I.nodeValue.length : 1
			l.sel = { anchor: l.sel.anchor + P, head: l.sel.anchor + P }
		}
		let u = e.state.doc,
			d = u.slice(l.from, l.to),
			p,
			m
		e.input.lastKeyCode === 8 && Date.now() - 100 < e.input.lastKeyCodeTime
			? ((p = e.state.selection.to), (m = "end"))
			: ((p = e.state.selection.from), (m = "start")),
			(e.input.lastKeyCode = null)
		let v = T0e(d.content, l.doc.content, l.from, p, m)
		if (
			((fp && e.input.lastIOSEnter > Date.now() - 225) || Zo) &&
			i.some((I) => I.nodeName == "DIV" || I.nodeName == "P") &&
			(!v || v.endA >= v.endB) &&
			e.someProp("handleKeyDown", (I) => I(e, jf(13, "Enter")))
		) {
			e.input.lastIOSEnter = 0
			return
		}
		if (!v)
			if (
				r &&
				s instanceof jt &&
				!s.empty &&
				s.$head.sameParent(s.$anchor) &&
				!e.composing &&
				!(l.sel && l.sel.anchor != l.sel.head)
			)
				v = { start: s.from, endA: s.to, endB: s.to }
			else {
				if (l.sel) {
					let I = H3(e, e.state.doc, l.sel)
					I && !I.eq(e.state.selection) && e.dispatch(e.state.tr.setSelection(I))
				}
				return
			}
		e.input.domChangeCount++,
			e.state.selection.from < e.state.selection.to &&
				v.start == v.endB &&
				e.state.selection instanceof jt &&
				(v.start > e.state.selection.from &&
				v.start <= e.state.selection.from + 2 &&
				e.state.selection.from >= l.from
					? (v.start = e.state.selection.from)
					: v.endA < e.state.selection.to &&
					  v.endA >= e.state.selection.to - 2 &&
					  e.state.selection.to <= l.to &&
					  ((v.endB += e.state.selection.to - v.endA), (v.endA = e.state.selection.to))),
			ma &&
				ku <= 11 &&
				v.endB == v.start + 1 &&
				v.endA == v.start &&
				v.start > l.from &&
				l.doc.textBetween(v.start - l.from - 1, v.start - l.from + 1) == " " &&
				(v.start--, v.endA--, v.endB--)
		let y = l.doc.resolveNoCache(v.start - l.from),
			b = l.doc.resolveNoCache(v.endB - l.from),
			x = u.resolve(v.start),
			E = y.sameParent(b) && y.parent.inlineContent && x.end() >= v.endA,
			T
		if (
			((fp &&
				e.input.lastIOSEnter > Date.now() - 225 &&
				(!E || i.some((I) => I.nodeName == "DIV" || I.nodeName == "P"))) ||
				(!E &&
					y.pos < l.doc.content.size &&
					(T = _t.findFrom(l.doc.resolve(y.pos + 1), 1, !0)) &&
					T.head == b.pos)) &&
			e.someProp("handleKeyDown", (I) => I(e, jf(13, "Enter")))
		) {
			e.input.lastIOSEnter = 0
			return
		}
		if (
			e.state.selection.anchor > v.start &&
			C0e(u, v.start, v.endA, y, b) &&
			e.someProp("handleKeyDown", (I) => I(e, jf(8, "Backspace")))
		) {
			Zo && yi && e.domObserver.suppressSelectionUpdates()
			return
		}
		yi && Zo && v.endB == v.start && (e.input.lastAndroidDelete = Date.now()),
			Zo &&
				!E &&
				y.start() != b.start() &&
				b.parentOffset == 0 &&
				y.depth == b.depth &&
				l.sel &&
				l.sel.anchor == l.sel.head &&
				l.sel.head == v.endA &&
				((v.endB -= 2),
				(b = l.doc.resolveNoCache(v.endB - l.from)),
				setTimeout(() => {
					e.someProp("handleKeyDown", function (I) {
						return I(e, jf(13, "Enter"))
					})
				}, 20))
		let C = v.start,
			D = v.endA,
			O,
			A,
			N
		if (E) {
			if (y.pos == b.pos)
				ma &&
					ku <= 11 &&
					y.parentOffset == 0 &&
					(e.domObserver.suppressSelectionUpdates(), setTimeout(() => Hu(e), 20)),
					(O = e.state.tr.delete(C, D)),
					(A = u.resolve(v.start).marksAcross(u.resolve(v.endA)))
			else if (
				v.endA == v.endB &&
				(N = E0e(
					y.parent.content.cut(y.parentOffset, b.parentOffset),
					x.parent.content.cut(x.parentOffset, v.endA - x.start()),
				))
			)
				(O = e.state.tr), N.type == "add" ? O.addMark(C, D, N.mark) : O.removeMark(C, D, N.mark)
			else if (
				y.parent.child(y.index()).isText &&
				y.index() == b.index() - (b.textOffset ? 0 : 1)
			) {
				let I = y.parent.textBetween(y.parentOffset, b.parentOffset)
				if (e.someProp("handleTextInput", (P) => P(e, C, D, I))) return
				O = e.state.tr.insertText(I, C, D)
			}
		}
		if (
			(O || (O = e.state.tr.replace(C, D, l.doc.slice(v.start - l.from, v.endB - l.from))), l.sel)
		) {
			let I = H3(e, O.doc, l.sel)
			I &&
				!(
					(yi &&
						Zo &&
						e.composing &&
						I.empty &&
						(v.start != v.endB || e.input.lastAndroidDelete < Date.now() - 100) &&
						(I.head == C || I.head == O.mapping.map(D) - 1)) ||
					(ma && I.empty && I.head == C)
				) &&
				O.setSelection(I)
		}
		A && O.ensureMarks(A), e.dispatch(O.scrollIntoView())
	}
	function H3(e, t, n) {
		return Math.max(n.anchor, n.head) > t.content.size
			? null
			: TO(e, t.resolve(n.anchor), t.resolve(n.head))
	}
	function E0e(e, t) {
		let n = e.firstChild.marks,
			r = t.firstChild.marks,
			i = n,
			a = r,
			o,
			s,
			l
		for (let d = 0; d < r.length; d++) i = r[d].removeFromSet(i)
		for (let d = 0; d < n.length; d++) a = n[d].removeFromSet(a)
		if (i.length == 1 && a.length == 0)
			(s = i[0]), (o = "add"), (l = (d) => d.mark(s.addToSet(d.marks)))
		else if (i.length == 0 && a.length == 1)
			(s = a[0]), (o = "remove"), (l = (d) => d.mark(s.removeFromSet(d.marks)))
		else return null
		let u = []
		for (let d = 0; d < t.childCount; d++) u.push(l(t.child(d)))
		if (ke.from(u).eq(e)) return { mark: s, type: o }
	}
	function C0e(e, t, n, r, i) {
		if (!r.parent.isTextblock || n - t <= i.pos - r.pos || ck(r, !0, !1) < i.pos) return !1
		let a = e.resolve(t)
		if (a.parentOffset < a.parent.content.size || !a.parent.isTextblock) return !1
		let o = e.resolve(ck(a, !0, !0))
		return !o.parent.isTextblock || o.pos > n || ck(o, !0, !1) < n
			? !1
			: r.parent.content.cut(r.parentOffset).eq(o.parent.content)
	}
	function ck(e, t, n) {
		let r = e.depth,
			i = t ? e.end() : e.pos
		for (; r > 0 && (t || e.indexAfter(r) == e.node(r).childCount); ) r--, i++, (t = !1)
		if (n) {
			let a = e.node(r).maybeChild(e.indexAfter(r))
			for (; a && !a.isLeaf; ) (a = a.firstChild), i++
		}
		return i
	}
	function T0e(e, t, n, r, i) {
		let a = e.findDiffStart(t, n)
		if (a == null) return null
		let { a: o, b: s } = e.findDiffEnd(t, n + e.size, n + t.size)
		if (i == "end") {
			let l = Math.max(0, a - Math.min(o, s))
			r -= o + l - a
		}
		if (o < a && e.size < t.size) {
			let l = r <= a && r >= o ? a - r : 0
			;(a -= l), (s = a + (s - o)), (o = a)
		} else if (s < a) {
			let l = r <= a && r >= s ? a - r : 0
			;(a -= l), (o = a + (o - s)), (s = a)
		}
		return { start: a, endA: o, endB: s }
	}
	class NO {
		constructor(t, n) {
			;(this._root = null),
				(this.focused = !1),
				(this.trackWrites = null),
				(this.mounted = !1),
				(this.markCursor = null),
				(this.cursorWrapper = null),
				(this.lastSelectedViewDesc = void 0),
				(this.input = new Yge()),
				(this.prevDirectPlugins = []),
				(this.pluginViews = []),
				(this.dragging = null),
				(this._props = n),
				(this.state = n.state),
				(this.directPlugins = n.plugins || []),
				this.directPlugins.forEach(V3),
				(this.dispatch = this.dispatch.bind(this)),
				(this.dom = (t && t.mount) || document.createElement("div")),
				t &&
					(t.appendChild
						? t.appendChild(this.dom)
						: typeof t == "function"
						? t(this.dom)
						: t.mount && (this.mounted = !0)),
				(this.editable = z3(this)),
				U3(this),
				(this.nodeViews = q3(this)),
				(this.docView = k3(this.state.doc, $3(this), uk(this), this.dom, this)),
				(this.domObserver = new g0e(this, (r, i, a, o) => w0e(this, r, i, a, o))),
				this.domObserver.start(),
				Gge(this),
				this.updatePluginViews()
		}
		get composing() {
			return this.input.composing
		}
		get props() {
			if (this._props.state != this.state) {
				let t = this._props
				this._props = {}
				for (let n in t) this._props[n] = t[n]
				this._props.state = this.state
			}
			return this._props
		}
		update(t) {
			t.handleDOMEvents != this._props.handleDOMEvents && M2(this),
				(this._props = t),
				t.plugins && (t.plugins.forEach(V3), (this.directPlugins = t.plugins)),
				this.updateStateInner(t.state, !0)
		}
		setProps(t) {
			let n = {}
			for (let r in this._props) n[r] = this._props[r]
			n.state = this.state
			for (let r in t) n[r] = t[r]
			this.update(n)
		}
		updateState(t) {
			this.updateStateInner(t, this.state.plugins != t.plugins)
		}
		updateStateInner(t, n) {
			let r = this.state,
				i = !1,
				a = !1
			if ((t.storedMarks && this.composing && (CU(this), (a = !0)), (this.state = t), n)) {
				let p = q3(this)
				S0e(p, this.nodeViews) && ((this.nodeViews = p), (i = !0)), M2(this)
			}
			;(this.editable = z3(this)), U3(this)
			let o = uk(this),
				s = $3(this),
				l = n ? "reset" : t.scrollToSelection > r.scrollToSelection ? "to selection" : "preserve",
				u = i || !this.docView.matchesNode(t.doc, s, o)
			;(u || !t.selection.eq(r.selection)) && (a = !0)
			let d = l == "preserve" && a && this.dom.style.overflowAnchor == null && pge(this)
			if (a) {
				this.domObserver.stop()
				let p =
					u &&
					(ma || yi) &&
					!this.composing &&
					!r.selection.empty &&
					!t.selection.empty &&
					k0e(r.selection, t.selection)
				if (u) {
					let m = yi ? (this.trackWrites = this.domSelection().focusNode) : null
					;(i || !this.docView.update(t.doc, s, o, this)) &&
						(this.docView.updateOuterDeco([]),
						this.docView.destroy(),
						(this.docView = k3(t.doc, s, o, this.dom, this))),
						m && !this.trackWrites && (p = !0)
				}
				p ||
				!(
					this.input.mouseDown &&
					this.domObserver.currentSelection.eq(this.domSelection()) &&
					Fge(this)
				)
					? Hu(this, p)
					: (cU(this, t.selection), this.domObserver.setCurSelection()),
					this.domObserver.start()
			}
			if ((this.updatePluginViews(r), l == "reset")) this.dom.scrollTop = 0
			else if (l == "to selection") {
				let p = this.domSelection().focusNode
				if (!this.someProp("handleScrollToSelection", (m) => m(this)))
					if (t.selection instanceof vt) {
						let m = this.docView.domAfterPos(t.selection.from)
						m.nodeType == 1 && x3(this, m.getBoundingClientRect(), p)
					} else x3(this, this.coordsAtPos(t.selection.head, 1), p)
			} else d && hge(d)
		}
		destroyPluginViews() {
			let t
			for (; (t = this.pluginViews.pop()); ) t.destroy && t.destroy()
		}
		updatePluginViews(t) {
			if (!t || t.plugins != this.state.plugins || this.directPlugins != this.prevDirectPlugins) {
				;(this.prevDirectPlugins = this.directPlugins), this.destroyPluginViews()
				for (let n = 0; n < this.directPlugins.length; n++) {
					let r = this.directPlugins[n]
					r.spec.view && this.pluginViews.push(r.spec.view(this))
				}
				for (let n = 0; n < this.state.plugins.length; n++) {
					let r = this.state.plugins[n]
					r.spec.view && this.pluginViews.push(r.spec.view(this))
				}
			} else
				for (let n = 0; n < this.pluginViews.length; n++) {
					let r = this.pluginViews[n]
					r.update && r.update(this, t)
				}
		}
		someProp(t, n) {
			let r = this._props && this._props[t],
				i
			if (r != null && (i = n ? n(r) : r)) return i
			for (let o = 0; o < this.directPlugins.length; o++) {
				let s = this.directPlugins[o].props[t]
				if (s != null && (i = n ? n(s) : s)) return i
			}
			let a = this.state.plugins
			if (a)
				for (let o = 0; o < a.length; o++) {
					let s = a[o].props[t]
					if (s != null && (i = n ? n(s) : s)) return i
				}
		}
		hasFocus() {
			return this.root.activeElement == this.dom
		}
		focus() {
			this.domObserver.stop(), this.editable && mge(this.dom), Hu(this), this.domObserver.start()
		}
		get root() {
			let t = this._root
			if (t == null) {
				for (let n = this.dom.parentNode; n; n = n.parentNode)
					if (n.nodeType == 9 || (n.nodeType == 11 && n.host))
						return (
							n.getSelection ||
								(Object.getPrototypeOf(n).getSelection = () => n.ownerDocument.getSelection()),
							(this._root = n)
						)
			}
			return t || document
		}
		posAtCoords(t) {
			return xge(this, t)
		}
		coordsAtPos(t, n = 1) {
			return tU(this, t, n)
		}
		domAtPos(t, n = 0) {
			return this.docView.domFromPos(t, n)
		}
		nodeDOM(t) {
			let n = this.docView.descAt(t)
			return n ? n.nodeDOM : null
		}
		posAtDOM(t, n, r = -1) {
			let i = this.docView.posFromDOM(t, n, r)
			if (i == null) throw new RangeError("DOM position not inside the editor")
			return i
		}
		endOfTextblock(t, n) {
			return kge(this, n || this.state, t)
		}
		destroy() {
			this.docView &&
				(Kge(this),
				this.destroyPluginViews(),
				this.mounted
					? (this.docView.update(this.state.doc, [], uk(this), this), (this.dom.textContent = ""))
					: this.dom.parentNode && this.dom.parentNode.removeChild(this.dom),
				this.docView.destroy(),
				(this.docView = null))
		}
		get isDestroyed() {
			return this.docView == null
		}
		dispatchEvent(t) {
			return Xge(this, t)
		}
		dispatch(t) {
			let n = this._props.dispatchTransaction
			n ? n.call(this, t) : this.updateState(this.state.apply(t))
		}
		domSelection() {
			return this.root.getSelection()
		}
	}
	function $3(e) {
		let t = Object.create(null)
		return (
			(t.class = "ProseMirror"),
			(t.contenteditable = String(e.editable)),
			(t.translate = "no"),
			e.someProp("attributes", (n) => {
				if ((typeof n == "function" && (n = n(e.state)), n))
					for (let r in n)
						r == "class" && (t.class += " " + n[r]),
							r == "style"
								? (t.style = (t.style ? t.style + ";" : "") + n[r])
								: !t[r] && r != "contenteditable" && r != "nodeName" && (t[r] = String(n[r]))
			}),
			[$i.node(0, e.state.doc.content.size, t)]
		)
	}
	function U3(e) {
		if (e.markCursor) {
			let t = document.createElement("img")
			;(t.className = "ProseMirror-separator"),
				t.setAttribute("mark-placeholder", "true"),
				t.setAttribute("alt", ""),
				(e.cursorWrapper = {
					dom: t,
					deco: $i.widget(e.state.selection.head, t, { raw: !0, marks: e.markCursor }),
				})
		} else e.cursorWrapper = null
	}
	function z3(e) {
		return !e.someProp("editable", (t) => t(e.state) === !1)
	}
	function k0e(e, t) {
		let n = Math.min(e.$anchor.sharedDepth(e.head), t.$anchor.sharedDepth(t.head))
		return e.$anchor.start(n) != t.$anchor.start(n)
	}
	function q3(e) {
		let t = Object.create(null)
		function n(r) {
			for (let i in r) Object.prototype.hasOwnProperty.call(t, i) || (t[i] = r[i])
		}
		return e.someProp("nodeViews", n), e.someProp("markViews", n), t
	}
	function S0e(e, t) {
		let n = 0,
			r = 0
		for (let i in e) {
			if (e[i] != t[i]) return !0
			n++
		}
		for (let i in t) r++
		return n != r
	}
	function V3(e) {
		if (e.spec.state || e.spec.filterTransaction || e.spec.appendTransaction)
			throw new RangeError("Plugins passed directly to the view must not have a state component")
	}
	var $u = {
			8: "Backspace",
			9: "Tab",
			10: "Enter",
			12: "NumLock",
			13: "Enter",
			16: "Shift",
			17: "Control",
			18: "Alt",
			20: "CapsLock",
			27: "Escape",
			32: " ",
			33: "PageUp",
			34: "PageDown",
			35: "End",
			36: "Home",
			37: "ArrowLeft",
			38: "ArrowUp",
			39: "ArrowRight",
			40: "ArrowDown",
			44: "PrintScreen",
			45: "Insert",
			46: "Delete",
			59: ";",
			61: "=",
			91: "Meta",
			92: "Meta",
			106: "*",
			107: "+",
			108: ",",
			109: "-",
			110: ".",
			111: "/",
			144: "NumLock",
			145: "ScrollLock",
			160: "Shift",
			161: "Shift",
			162: "Control",
			163: "Control",
			164: "Alt",
			165: "Alt",
			173: "-",
			186: ";",
			187: "=",
			188: ",",
			189: "-",
			190: ".",
			191: "/",
			192: "`",
			219: "[",
			220: "\\",
			221: "]",
			222: "'",
			229: "q",
		},
		fb = {
			48: ")",
			49: "!",
			50: "@",
			51: "#",
			52: "$",
			53: "%",
			54: "^",
			55: "&",
			56: "*",
			57: "(",
			59: ":",
			61: "+",
			173: "_",
			186: ":",
			187: "+",
			188: "<",
			189: "_",
			190: ">",
			191: "?",
			192: "~",
			219: "{",
			220: "|",
			221: "}",
			222: '"',
			229: "Q",
		},
		W3 = typeof navigator < "u" && /Chrome\/(\d+)/.exec(navigator.userAgent),
		D0e = typeof navigator < "u" && /Apple Computer/.test(navigator.vendor),
		_0e = typeof navigator < "u" && /Gecko\/\d+/.test(navigator.userAgent),
		Y3 = typeof navigator < "u" && /Mac/.test(navigator.platform),
		O0e =
			typeof navigator < "u" &&
			/MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent),
		A0e = (W3 && (Y3 || +W3[1] < 57)) || (_0e && Y3)
	for (var Hr = 0; Hr < 10; Hr++) $u[48 + Hr] = $u[96 + Hr] = String(Hr)
	for (var Hr = 1; Hr <= 24; Hr++) $u[Hr + 111] = "F" + Hr
	for (var Hr = 65; Hr <= 90; Hr++)
		($u[Hr] = String.fromCharCode(Hr + 32)), (fb[Hr] = String.fromCharCode(Hr))
	for (var dk in $u) fb.hasOwnProperty(dk) || (fb[dk] = $u[dk])
	function N0e(e) {
		var t =
				(A0e && (e.ctrlKey || e.altKey || e.metaKey)) ||
				((D0e || O0e) && e.shiftKey && e.key && e.key.length == 1),
			n = (!t && e.key) || (e.shiftKey ? fb : $u)[e.keyCode] || e.key || "Unidentified"
		return (
			n == "Esc" && (n = "Escape"),
			n == "Del" && (n = "Delete"),
			n == "Left" && (n = "ArrowLeft"),
			n == "Up" && (n = "ArrowUp"),
			n == "Right" && (n = "ArrowRight"),
			n == "Down" && (n = "ArrowDown"),
			n
		)
	}
	const M0e = typeof navigator < "u" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : !1
	function I0e(e) {
		let t = e.split(/-(?!$)/),
			n = t[t.length - 1]
		n == "Space" && (n = " ")
		let r, i, a, o
		for (let s = 0; s < t.length - 1; s++) {
			let l = t[s]
			if (/^(cmd|meta|m)$/i.test(l)) o = !0
			else if (/^a(lt)?$/i.test(l)) r = !0
			else if (/^(c|ctrl|control)$/i.test(l)) i = !0
			else if (/^s(hift)?$/i.test(l)) a = !0
			else if (/^mod$/i.test(l)) M0e ? (o = !0) : (i = !0)
			else throw new Error("Unrecognized modifier name: " + l)
		}
		return (
			r && (n = "Alt-" + n),
			i && (n = "Ctrl-" + n),
			o && (n = "Meta-" + n),
			a && (n = "Shift-" + n),
			n
		)
	}
	function R0e(e) {
		let t = Object.create(null)
		for (let n in e) t[I0e(n)] = e[n]
		return t
	}
	function fk(e, t, n) {
		return (
			t.altKey && (e = "Alt-" + e),
			t.ctrlKey && (e = "Ctrl-" + e),
			t.metaKey && (e = "Meta-" + e),
			n !== !1 && t.shiftKey && (e = "Shift-" + e),
			e
		)
	}
	function _v(e) {
		return new Ki({ props: { handleKeyDown: L0e(e) } })
	}
	function L0e(e) {
		let t = R0e(e)
		return function (n, r) {
			let i = N0e(r),
				a = i.length == 1 && i != " ",
				o,
				s = t[fk(i, r, !a)]
			if (s && s(n.state, n.dispatch, n)) return !0
			if (
				a &&
				(r.shiftKey || r.altKey || r.metaKey || i.charCodeAt(0) > 127) &&
				(o = $u[r.keyCode]) &&
				o != i
			) {
				let l = t[fk(o, r, !0)]
				if (l && l(n.state, n.dispatch, n)) return !0
			} else if (a && r.shiftKey) {
				let l = t[fk(i, r, !0)]
				if (l && l(n.state, n.dispatch, n)) return !0
			}
			return !1
		}
	}
	const MO = (e, t) =>
			e.selection.empty ? !1 : (t && t(e.tr.deleteSelection().scrollIntoView()), !0),
		P0e = (e, t, n) => {
			let { $cursor: r } = e.selection
			if (!r || (n ? !n.endOfTextblock("backward", e) : r.parentOffset > 0)) return !1
			let i = _U(r)
			if (!i) {
				let o = r.blockRange(),
					s = o && ew(o)
				return s == null ? !1 : (t && t(e.tr.lift(o, s).scrollIntoView()), !0)
			}
			let a = i.nodeBefore
			if (!a.type.spec.isolating && IU(e, i, t)) return !0
			if (r.parent.content.size == 0 && (hp(a, "end") || vt.isSelectable(a))) {
				let o = bO(e.doc, r.before(), r.after(), Ue.empty)
				if (o && o.slice.size < o.to - o.from) {
					if (t) {
						let s = e.tr.step(o)
						s.setSelection(
							hp(a, "end")
								? _t.findFrom(s.doc.resolve(s.mapping.map(i.pos, -1)), -1)
								: vt.create(s.doc, i.pos - a.nodeSize),
						),
							t(s.scrollIntoView())
					}
					return !0
				}
			}
			return a.isAtom && i.depth == r.depth - 1
				? (t && t(e.tr.delete(i.pos - a.nodeSize, i.pos).scrollIntoView()), !0)
				: !1
		}
	function hp(e, t, n = !1) {
		for (let r = e; r; r = t == "start" ? r.firstChild : r.lastChild) {
			if (r.isTextblock) return !0
			if (n && r.childCount != 1) return !1
		}
		return !1
	}
	const j0e = (e, t, n) => {
		let { $head: r, empty: i } = e.selection,
			a = r
		if (!i) return !1
		if (r.parent.isTextblock) {
			if (n ? !n.endOfTextblock("backward", e) : r.parentOffset > 0) return !1
			a = _U(r)
		}
		let o = a && a.nodeBefore
		return !o || !vt.isSelectable(o)
			? !1
			: (t && t(e.tr.setSelection(vt.create(e.doc, a.pos - o.nodeSize)).scrollIntoView()), !0)
	}
	function _U(e) {
		if (!e.parent.type.spec.isolating)
			for (let t = e.depth - 1; t >= 0; t--) {
				if (e.index(t) > 0) return e.doc.resolve(e.before(t + 1))
				if (e.node(t).type.spec.isolating) break
			}
		return null
	}
	const OU = (e, t, n) => {
			let { $cursor: r } = e.selection
			if (!r || (n ? !n.endOfTextblock("forward", e) : r.parentOffset < r.parent.content.size))
				return !1
			let i = AU(r)
			if (!i) return !1
			let a = i.nodeAfter
			if (IU(e, i, t)) return !0
			if (r.parent.content.size == 0 && (hp(a, "start") || vt.isSelectable(a))) {
				let o = bO(e.doc, r.before(), r.after(), Ue.empty)
				if (o && o.slice.size < o.to - o.from) {
					if (t) {
						let s = e.tr.step(o)
						s.setSelection(
							hp(a, "start")
								? _t.findFrom(s.doc.resolve(s.mapping.map(i.pos)), 1)
								: vt.create(s.doc, s.mapping.map(i.pos)),
						),
							t(s.scrollIntoView())
					}
					return !0
				}
			}
			return a.isAtom && i.depth == r.depth - 1
				? (t && t(e.tr.delete(i.pos, i.pos + a.nodeSize).scrollIntoView()), !0)
				: !1
		},
		F0e = (e, t, n) => {
			let { $head: r, empty: i } = e.selection,
				a = r
			if (!i) return !1
			if (r.parent.isTextblock) {
				if (n ? !n.endOfTextblock("forward", e) : r.parentOffset < r.parent.content.size) return !1
				a = AU(r)
			}
			let o = a && a.nodeAfter
			return !o || !vt.isSelectable(o)
				? !1
				: (t && t(e.tr.setSelection(vt.create(e.doc, a.pos)).scrollIntoView()), !0)
		}
	function AU(e) {
		if (!e.parent.type.spec.isolating)
			for (let t = e.depth - 1; t >= 0; t--) {
				let n = e.node(t)
				if (e.index(t) + 1 < n.childCount) return e.doc.resolve(e.after(t + 1))
				if (n.type.spec.isolating) break
			}
		return null
	}
	const NU = (e, t) => {
		let { $head: n, $anchor: r } = e.selection
		return !n.parent.type.spec.code || !n.sameParent(r)
			? !1
			: (t &&
					t(
						e.tr
							.insertText(
								`
`,
							)
							.scrollIntoView(),
					),
			  !0)
	}
	function IO(e) {
		for (let t = 0; t < e.edgeCount; t++) {
			let { type: n } = e.edge(t)
			if (n.isTextblock && !n.hasRequiredAttrs()) return n
		}
		return null
	}
	const RO = (e, t) => {
			let { $head: n, $anchor: r } = e.selection
			if (!n.parent.type.spec.code || !n.sameParent(r)) return !1
			let i = n.node(-1),
				a = n.indexAfter(-1),
				o = IO(i.contentMatchAt(a))
			if (!o || !i.canReplaceWith(a, a, o)) return !1
			if (t) {
				let s = n.after(),
					l = e.tr.replaceWith(s, s, o.createAndFill())
				l.setSelection(_t.near(l.doc.resolve(s), 1)), t(l.scrollIntoView())
			}
			return !0
		},
		B0e = (e, t) => {
			let n = e.selection,
				{ $from: r, $to: i } = n
			if (n instanceof wi || r.parent.inlineContent || i.parent.inlineContent) return !1
			let a = IO(i.parent.contentMatchAt(i.indexAfter()))
			if (!a || !a.isTextblock) return !1
			if (t) {
				let o = (!r.parentOffset && i.index() < i.parent.childCount ? r : i).pos,
					s = e.tr.insert(o, a.createAndFill())
				s.setSelection(jt.create(s.doc, o + 1)), t(s.scrollIntoView())
			}
			return !0
		},
		H0e = (e, t) => {
			let { $cursor: n } = e.selection
			if (!n || n.parent.content.size) return !1
			if (n.depth > 1 && n.after() != n.end(-1)) {
				let a = n.before()
				if (Yf(e.doc, a)) return t && t(e.tr.split(a).scrollIntoView()), !0
			}
			let r = n.blockRange(),
				i = r && ew(r)
			return i == null ? !1 : (t && t(e.tr.lift(r, i).scrollIntoView()), !0)
		},
		$0e = (e, t) => {
			let { $from: n, $to: r } = e.selection
			if (e.selection instanceof vt && e.selection.node.isBlock)
				return !n.parentOffset || !Yf(e.doc, n.pos)
					? !1
					: (t && t(e.tr.split(n.pos).scrollIntoView()), !0)
			if (!n.parent.isBlock) return !1
			if (t) {
				let i = r.parentOffset == r.parent.content.size,
					a = e.tr
				;(e.selection instanceof jt || e.selection instanceof wi) && a.deleteSelection()
				let o = n.depth == 0 ? null : IO(n.node(-1).contentMatchAt(n.indexAfter(-1))),
					s = i && o ? [{ type: o }] : void 0,
					l = Yf(a.doc, a.mapping.map(n.pos), 1, s)
				if (
					(!s &&
						!l &&
						Yf(a.doc, a.mapping.map(n.pos), 1, o ? [{ type: o }] : void 0) &&
						(o && (s = [{ type: o }]), (l = !0)),
					l && (a.split(a.mapping.map(n.pos), 1, s), !i && !n.parentOffset && n.parent.type != o))
				) {
					let u = a.mapping.map(n.before()),
						d = a.doc.resolve(u)
					o &&
						n.node(-1).canReplaceWith(d.index(), d.index() + 1, o) &&
						a.setNodeMarkup(a.mapping.map(n.before()), o)
				}
				t(a.scrollIntoView())
			}
			return !0
		},
		MU = (e, t) => (t && t(e.tr.setSelection(new wi(e.doc))), !0)
	function U0e(e, t, n) {
		let r = t.nodeBefore,
			i = t.nodeAfter,
			a = t.index()
		return !r || !i || !r.type.compatibleContent(i.type)
			? !1
			: !r.content.size && t.parent.canReplace(a - 1, a)
			? (n && n(e.tr.delete(t.pos - r.nodeSize, t.pos).scrollIntoView()), !0)
			: !t.parent.canReplace(a, a + 1) || !(i.isTextblock || U7(e.doc, t.pos))
			? !1
			: (n &&
					n(
						e.tr
							.clearIncompatible(t.pos, r.type, r.contentMatchAt(r.childCount))
							.join(t.pos)
							.scrollIntoView(),
					),
			  !0)
	}
	function IU(e, t, n) {
		let r = t.nodeBefore,
			i = t.nodeAfter,
			a,
			o
		if (r.type.spec.isolating || i.type.spec.isolating) return !1
		if (U0e(e, t, n)) return !0
		let s = t.parent.canReplace(t.index(), t.index() + 1)
		if (
			s &&
			(a = (o = r.contentMatchAt(r.childCount)).findWrapping(i.type)) &&
			o.matchType(a[0] || i.type).validEnd
		) {
			if (n) {
				let p = t.pos + i.nodeSize,
					m = ke.empty
				for (let b = a.length - 1; b >= 0; b--) m = ke.from(a[b].create(null, m))
				m = ke.from(r.copy(m))
				let v = e.tr.step(new Ar(t.pos - 1, p, t.pos, p, new Ue(m, 1, 0), a.length, !0)),
					y = p + 2 * a.length
				U7(v.doc, y) && v.join(y), n(v.scrollIntoView())
			}
			return !0
		}
		let l = _t.findFrom(t, 1),
			u = l && l.$from.blockRange(l.$to),
			d = u && ew(u)
		if (d != null && d >= t.depth) return n && n(e.tr.lift(u, d).scrollIntoView()), !0
		if (s && hp(i, "start", !0) && hp(r, "end")) {
			let p = r,
				m = []
			for (; m.push(p), !p.isTextblock; ) p = p.lastChild
			let v = i,
				y = 1
			for (; !v.isTextblock; v = v.firstChild) y++
			if (p.canReplace(p.childCount, p.childCount, v.content)) {
				if (n) {
					let b = ke.empty
					for (let E = m.length - 1; E >= 0; E--) b = ke.from(m[E].copy(b))
					let x = e.tr.step(
						new Ar(
							t.pos - m.length,
							t.pos + i.nodeSize,
							t.pos + y,
							t.pos + i.nodeSize - y,
							new Ue(b, m.length, 0),
							0,
							!0,
						),
					)
					n(x.scrollIntoView())
				}
				return !0
			}
		}
		return !1
	}
	function RU(e) {
		return function (t, n) {
			let r = t.selection,
				i = e < 0 ? r.$from : r.$to,
				a = i.depth
			for (; i.node(a).isInline; ) {
				if (!a) return !1
				a--
			}
			return i.node(a).isTextblock
				? (n && n(t.tr.setSelection(jt.create(t.doc, e < 0 ? i.start(a) : i.end(a)))), !0)
				: !1
		}
	}
	const z0e = RU(-1),
		q0e = RU(1)
	function V0e(e, t = null) {
		return function (n, r) {
			let { $from: i, $to: a } = n.selection,
				o = i.blockRange(a),
				s = o && Fve(o, e, t)
			return s ? (r && r(n.tr.wrap(o, s).scrollIntoView()), !0) : !1
		}
	}
	function LO(e, t = null) {
		return function (n, r) {
			let { from: i, to: a } = n.selection,
				o = !1
			return (
				n.doc.nodesBetween(i, a, (s, l) => {
					if (o) return !1
					if (!(!s.isTextblock || s.hasMarkup(e, t)))
						if (s.type == e) o = !0
						else {
							let u = n.doc.resolve(l),
								d = u.index()
							o = u.parent.canReplaceWith(d, d + 1, e)
						}
				}),
				o ? (r && r(n.tr.setBlockType(i, a, e, t).scrollIntoView()), !0) : !1
			)
		}
	}
	function W0e(e, t, n) {
		for (let r = 0; r < t.length; r++) {
			let { $from: i, $to: a } = t[r],
				o = i.depth == 0 ? e.type.allowsMarkType(n) : !1
			if (
				(e.nodesBetween(i.pos, a.pos, (s) => {
					if (o) return !1
					o = s.inlineContent && s.type.allowsMarkType(n)
				}),
				o)
			)
				return !0
		}
		return !1
	}
	function pg(e, t = null) {
		return function (n, r) {
			let { empty: i, $cursor: a, ranges: o } = n.selection
			if ((i && !a) || !W0e(n.doc, o, e)) return !1
			if (r)
				if (a)
					e.isInSet(n.storedMarks || a.marks())
						? r(n.tr.removeStoredMark(e))
						: r(n.tr.addStoredMark(e.create(t)))
				else {
					let s = !1,
						l = n.tr
					for (let u = 0; !s && u < o.length; u++) {
						let { $from: d, $to: p } = o[u]
						s = n.doc.rangeHasMark(d.pos, p.pos, e)
					}
					for (let u = 0; u < o.length; u++) {
						let { $from: d, $to: p } = o[u]
						if (s) l.removeMark(d.pos, p.pos, e)
						else {
							let m = d.pos,
								v = p.pos,
								y = d.nodeAfter,
								b = p.nodeBefore,
								x = y && y.isText ? /^\s*/.exec(y.text)[0].length : 0,
								E = b && b.isText ? /\s*$/.exec(b.text)[0].length : 0
							m + x < v && ((m += x), (v -= E)), l.addMark(m, v, e.create(t))
						}
					}
					r(l.scrollIntoView())
				}
			return !0
		}
	}
	function aw(...e) {
		return function (t, n, r) {
			for (let i = 0; i < e.length; i++) if (e[i](t, n, r)) return !0
			return !1
		}
	}
	let pk = aw(MO, P0e, j0e),
		G3 = aw(MO, OU, F0e)
	const Xs = {
			Enter: aw(NU, B0e, H0e, $0e),
			"Mod-Enter": RO,
			Backspace: pk,
			"Mod-Backspace": pk,
			"Shift-Backspace": pk,
			Delete: G3,
			"Mod-Delete": G3,
			"Mod-a": MU,
		},
		LU = {
			"Ctrl-h": Xs.Backspace,
			"Alt-Backspace": Xs["Mod-Backspace"],
			"Ctrl-d": Xs.Delete,
			"Ctrl-Alt-Backspace": Xs["Mod-Delete"],
			"Alt-Delete": Xs["Mod-Delete"],
			"Alt-d": Xs["Mod-Delete"],
			"Ctrl-a": z0e,
			"Ctrl-e": q0e,
		}
	for (let e in Xs) LU[e] = Xs[e]
	const Y0e =
			typeof navigator < "u"
				? /Mac|iP(hone|[oa]d)/.test(navigator.platform)
				: typeof os < "u" && os.platform
				? os.platform() == "darwin"
				: !1,
		K3 = Y0e ? LU : Xs
	class PU {
		constructor(t, n) {
			;(this.match = t), (this.match = t), (this.handler = typeof n == "string" ? G0e(n) : n)
		}
	}
	function G0e(e) {
		return function (t, n, r, i) {
			let a = e
			if (n[1]) {
				let o = n[0].lastIndexOf(n[1])
				;(a += n[0].slice(o + n[1].length)), (r += o)
				let s = r - i
				s > 0 && ((a = n[0].slice(o - s, o) + a), (r = i))
			}
			return t.tr.insertText(a, r, i)
		}
	}
	const K0e = 500
	function jU({ rules: e }) {
		let t = new Ki({
			state: {
				init() {
					return null
				},
				apply(n, r) {
					let i = n.getMeta(this)
					return i || (n.selectionSet || n.docChanged ? null : r)
				},
			},
			props: {
				handleTextInput(n, r, i, a) {
					return Q3(n, r, i, a, e, t)
				},
				handleDOMEvents: {
					compositionend: (n) => {
						setTimeout(() => {
							let { $cursor: r } = n.state.selection
							r && Q3(n, r.pos, r.pos, "", e, t)
						})
					},
				},
			},
			isInputRules: !0,
		})
		return t
	}
	function Q3(e, t, n, r, i, a) {
		if (e.composing) return !1
		let o = e.state,
			s = o.doc.resolve(t)
		if (s.parent.type.spec.code) return !1
		let l = s.parent.textBetween(Math.max(0, s.parentOffset - K0e), s.parentOffset, null, "") + r
		for (let u = 0; u < i.length; u++) {
			let d = i[u].match.exec(l),
				p = d && i[u].handler(o, d, t - (d[0].length - r.length), n)
			if (p) return e.dispatch(p.setMeta(a, { transform: p, from: t, to: n, text: r })), !0
		}
		return !1
	}
	const Q0e = (e, t) => {
		let n = e.plugins
		for (let r = 0; r < n.length; r++) {
			let i = n[r],
				a
			if (i.spec.isInputRules && (a = i.getState(e))) {
				if (t) {
					let o = e.tr,
						s = a.transform
					for (let l = s.steps.length - 1; l >= 0; l--) o.step(s.steps[l].invert(s.docs[l]))
					if (a.text) {
						let l = o.doc.resolve(a.from).marks()
						o.replaceWith(a.from, a.to, e.schema.text(a.text, l))
					} else o.delete(a.from, a.to)
					t(o)
				}
				return !0
			}
		}
		return !1
	}
	var pb = 200,
		Ur = function () {}
	Ur.prototype.append = function (t) {
		return t.length
			? ((t = Ur.from(t)),
			  (!this.length && t) ||
					(t.length < pb && this.leafAppend(t)) ||
					(this.length < pb && t.leafPrepend(this)) ||
					this.appendInner(t))
			: this
	}
	Ur.prototype.prepend = function (t) {
		return t.length ? Ur.from(t).append(this) : this
	}
	Ur.prototype.appendInner = function (t) {
		return new X0e(this, t)
	}
	Ur.prototype.slice = function (t, n) {
		return (
			t === void 0 && (t = 0),
			n === void 0 && (n = this.length),
			t >= n ? Ur.empty : this.sliceInner(Math.max(0, t), Math.min(this.length, n))
		)
	}
	Ur.prototype.get = function (t) {
		if (!(t < 0 || t >= this.length)) return this.getInner(t)
	}
	Ur.prototype.forEach = function (t, n, r) {
		n === void 0 && (n = 0),
			r === void 0 && (r = this.length),
			n <= r ? this.forEachInner(t, n, r, 0) : this.forEachInvertedInner(t, n, r, 0)
	}
	Ur.prototype.map = function (t, n, r) {
		n === void 0 && (n = 0), r === void 0 && (r = this.length)
		var i = []
		return (
			this.forEach(
				function (a, o) {
					return i.push(t(a, o))
				},
				n,
				r,
			),
			i
		)
	}
	Ur.from = function (t) {
		return t instanceof Ur ? t : t && t.length ? new FU(t) : Ur.empty
	}
	var FU = (function (e) {
		function t(r) {
			e.call(this), (this.values = r)
		}
		e && (t.__proto__ = e),
			(t.prototype = Object.create(e && e.prototype)),
			(t.prototype.constructor = t)
		var n = { length: { configurable: !0 }, depth: { configurable: !0 } }
		return (
			(t.prototype.flatten = function () {
				return this.values
			}),
			(t.prototype.sliceInner = function (i, a) {
				return i == 0 && a == this.length ? this : new t(this.values.slice(i, a))
			}),
			(t.prototype.getInner = function (i) {
				return this.values[i]
			}),
			(t.prototype.forEachInner = function (i, a, o, s) {
				for (var l = a; l < o; l++) if (i(this.values[l], s + l) === !1) return !1
			}),
			(t.prototype.forEachInvertedInner = function (i, a, o, s) {
				for (var l = a - 1; l >= o; l--) if (i(this.values[l], s + l) === !1) return !1
			}),
			(t.prototype.leafAppend = function (i) {
				if (this.length + i.length <= pb) return new t(this.values.concat(i.flatten()))
			}),
			(t.prototype.leafPrepend = function (i) {
				if (this.length + i.length <= pb) return new t(i.flatten().concat(this.values))
			}),
			(n.length.get = function () {
				return this.values.length
			}),
			(n.depth.get = function () {
				return 0
			}),
			Object.defineProperties(t.prototype, n),
			t
		)
	})(Ur)
	Ur.empty = new FU([])
	var X0e = (function (e) {
			function t(n, r) {
				e.call(this),
					(this.left = n),
					(this.right = r),
					(this.length = n.length + r.length),
					(this.depth = Math.max(n.depth, r.depth) + 1)
			}
			return (
				e && (t.__proto__ = e),
				(t.prototype = Object.create(e && e.prototype)),
				(t.prototype.constructor = t),
				(t.prototype.flatten = function () {
					return this.left.flatten().concat(this.right.flatten())
				}),
				(t.prototype.getInner = function (r) {
					return r < this.left.length ? this.left.get(r) : this.right.get(r - this.left.length)
				}),
				(t.prototype.forEachInner = function (r, i, a, o) {
					var s = this.left.length
					if (
						(i < s && this.left.forEachInner(r, i, Math.min(a, s), o) === !1) ||
						(a > s &&
							this.right.forEachInner(
								r,
								Math.max(i - s, 0),
								Math.min(this.length, a) - s,
								o + s,
							) === !1)
					)
						return !1
				}),
				(t.prototype.forEachInvertedInner = function (r, i, a, o) {
					var s = this.left.length
					if (
						(i > s &&
							this.right.forEachInvertedInner(r, i - s, Math.max(a, s) - s, o + s) === !1) ||
						(a < s && this.left.forEachInvertedInner(r, Math.min(i, s), a, o) === !1)
					)
						return !1
				}),
				(t.prototype.sliceInner = function (r, i) {
					if (r == 0 && i == this.length) return this
					var a = this.left.length
					return i <= a
						? this.left.slice(r, i)
						: r >= a
						? this.right.slice(r - a, i - a)
						: this.left.slice(r, a).append(this.right.slice(0, i - a))
				}),
				(t.prototype.leafAppend = function (r) {
					var i = this.right.leafAppend(r)
					if (i) return new t(this.left, i)
				}),
				(t.prototype.leafPrepend = function (r) {
					var i = this.left.leafPrepend(r)
					if (i) return new t(i, this.right)
				}),
				(t.prototype.appendInner = function (r) {
					return this.left.depth >= Math.max(this.right.depth, r.depth) + 1
						? new t(this.left, new t(this.right, r))
						: new t(this, r)
				}),
				t
			)
		})(Ur),
		BU = Ur
	const J0e = 500
	class po {
		constructor(t, n) {
			;(this.items = t), (this.eventCount = n)
		}
		popEvent(t, n) {
			if (this.eventCount == 0) return null
			let r = this.items.length
			for (; ; r--)
				if (this.items.get(r - 1).selection) {
					--r
					break
				}
			let i, a
			n && ((i = this.remapping(r, this.items.length)), (a = i.maps.length))
			let o = t.tr,
				s,
				l,
				u = [],
				d = []
			return (
				this.items.forEach(
					(p, m) => {
						if (!p.step) {
							i || ((i = this.remapping(r, m + 1)), (a = i.maps.length)), a--, d.push(p)
							return
						}
						if (i) {
							d.push(new qo(p.map))
							let v = p.step.map(i.slice(a)),
								y
							v &&
								o.maybeStep(v).doc &&
								((y = o.mapping.maps[o.mapping.maps.length - 1]),
								u.push(new qo(y, void 0, void 0, u.length + d.length))),
								a--,
								y && i.appendMap(y, a)
						} else o.maybeStep(p.step)
						if (p.selection)
							return (
								(s = i ? p.selection.map(i.slice(a)) : p.selection),
								(l = new po(
									this.items.slice(0, r).append(d.reverse().concat(u)),
									this.eventCount - 1,
								)),
								!1
							)
					},
					this.items.length,
					0,
				),
				{ remaining: l, transform: o, selection: s }
			)
		}
		addTransform(t, n, r, i) {
			let a = [],
				o = this.eventCount,
				s = this.items,
				l = !i && s.length ? s.get(s.length - 1) : null
			for (let d = 0; d < t.steps.length; d++) {
				let p = t.steps[d].invert(t.docs[d]),
					m = new qo(t.mapping.maps[d], p, n),
					v
				;(v = l && l.merge(m)) && ((m = v), d ? a.pop() : (s = s.slice(0, s.length - 1))),
					a.push(m),
					n && (o++, (n = void 0)),
					i || (l = m)
			}
			let u = o - r.depth
			return u > eye && ((s = Z0e(s, u)), (o -= u)), new po(s.append(a), o)
		}
		remapping(t, n) {
			let r = new Wf()
			return (
				this.items.forEach(
					(i, a) => {
						let o =
							i.mirrorOffset != null && a - i.mirrorOffset >= t
								? r.maps.length - i.mirrorOffset
								: void 0
						r.appendMap(i.map, o)
					},
					t,
					n,
				),
				r
			)
		}
		addMaps(t) {
			return this.eventCount == 0
				? this
				: new po(this.items.append(t.map((n) => new qo(n))), this.eventCount)
		}
		rebased(t, n) {
			if (!this.eventCount) return this
			let r = [],
				i = Math.max(0, this.items.length - n),
				a = t.mapping,
				o = t.steps.length,
				s = this.eventCount
			this.items.forEach((m) => {
				m.selection && s--
			}, i)
			let l = n
			this.items.forEach((m) => {
				let v = a.getMirror(--l)
				if (v == null) return
				o = Math.min(o, v)
				let y = a.maps[v]
				if (m.step) {
					let b = t.steps[v].invert(t.docs[v]),
						x = m.selection && m.selection.map(a.slice(l + 1, v))
					x && s++, r.push(new qo(y, b, x))
				} else r.push(new qo(y))
			}, i)
			let u = []
			for (let m = n; m < o; m++) u.push(new qo(a.maps[m]))
			let d = this.items.slice(0, i).append(u).append(r),
				p = new po(d, s)
			return p.emptyItemCount() > J0e && (p = p.compress(this.items.length - r.length)), p
		}
		emptyItemCount() {
			let t = 0
			return (
				this.items.forEach((n) => {
					n.step || t++
				}),
				t
			)
		}
		compress(t = this.items.length) {
			let n = this.remapping(0, t),
				r = n.maps.length,
				i = [],
				a = 0
			return (
				this.items.forEach(
					(o, s) => {
						if (s >= t) i.push(o), o.selection && a++
						else if (o.step) {
							let l = o.step.map(n.slice(r)),
								u = l && l.getMap()
							if ((r--, u && n.appendMap(u, r), l)) {
								let d = o.selection && o.selection.map(n.slice(r))
								d && a++
								let p = new qo(u.invert(), l, d),
									m,
									v = i.length - 1
								;(m = i.length && i[v].merge(p)) ? (i[v] = m) : i.push(p)
							}
						} else o.map && r--
					},
					this.items.length,
					0,
				),
				new po(BU.from(i.reverse()), a)
			)
		}
	}
	po.empty = new po(BU.empty, 0)
	function Z0e(e, t) {
		let n
		return (
			e.forEach((r, i) => {
				if (r.selection && t-- == 0) return (n = i), !1
			}),
			e.slice(n)
		)
	}
	class qo {
		constructor(t, n, r, i) {
			;(this.map = t), (this.step = n), (this.selection = r), (this.mirrorOffset = i)
		}
		merge(t) {
			if (this.step && t.step && !t.selection) {
				let n = t.step.merge(this.step)
				if (n) return new qo(n.getMap().invert(), n, this.selection)
			}
		}
	}
	class hu {
		constructor(t, n, r, i) {
			;(this.done = t), (this.undone = n), (this.prevRanges = r), (this.prevTime = i)
		}
	}
	const eye = 20
	function tye(e, t, n, r) {
		let i = n.getMeta(dl),
			a
		if (i) return i.historyState
		n.getMeta(rye) && (e = new hu(e.done, e.undone, null, 0))
		let o = n.getMeta("appendedTransaction")
		if (n.steps.length == 0) return e
		if (o && o.getMeta(dl))
			return o.getMeta(dl).redo
				? new hu(
						e.done.addTransform(n, void 0, r, c1(t)),
						e.undone,
						X3(n.mapping.maps[n.steps.length - 1]),
						e.prevTime,
				  )
				: new hu(e.done, e.undone.addTransform(n, void 0, r, c1(t)), null, e.prevTime)
		if (n.getMeta("addToHistory") !== !1 && !(o && o.getMeta("addToHistory") === !1)) {
			let s =
					e.prevTime == 0 ||
					(!o && (e.prevTime < (n.time || 0) - r.newGroupDelay || !nye(n, e.prevRanges))),
				l = o ? hk(e.prevRanges, n.mapping) : X3(n.mapping.maps[n.steps.length - 1])
			return new hu(
				e.done.addTransform(n, s ? t.selection.getBookmark() : void 0, r, c1(t)),
				po.empty,
				l,
				n.time,
			)
		} else
			return (a = n.getMeta("rebased"))
				? new hu(
						e.done.rebased(n, a),
						e.undone.rebased(n, a),
						hk(e.prevRanges, n.mapping),
						e.prevTime,
				  )
				: new hu(
						e.done.addMaps(n.mapping.maps),
						e.undone.addMaps(n.mapping.maps),
						hk(e.prevRanges, n.mapping),
						e.prevTime,
				  )
	}
	function nye(e, t) {
		if (!t) return !1
		if (!e.docChanged) return !0
		let n = !1
		return (
			e.mapping.maps[0].forEach((r, i) => {
				for (let a = 0; a < t.length; a += 2) r <= t[a + 1] && i >= t[a] && (n = !0)
			}),
			n
		)
	}
	function X3(e) {
		let t = []
		return e.forEach((n, r, i, a) => t.push(i, a)), t
	}
	function hk(e, t) {
		if (!e) return null
		let n = []
		for (let r = 0; r < e.length; r += 2) {
			let i = t.map(e[r], 1),
				a = t.map(e[r + 1], -1)
			i <= a && n.push(i, a)
		}
		return n
	}
	function HU(e, t, n, r) {
		let i = c1(t),
			a = dl.get(t).spec.config,
			o = (r ? e.undone : e.done).popEvent(t, i)
		if (!o) return
		let s = o.selection.resolve(o.transform.doc),
			l = (r ? e.done : e.undone).addTransform(o.transform, t.selection.getBookmark(), a, i),
			u = new hu(r ? l : o.remaining, r ? o.remaining : l, null, 0)
		n(o.transform.setSelection(s).setMeta(dl, { redo: r, historyState: u }).scrollIntoView())
	}
	let mk = !1,
		J3 = null
	function c1(e) {
		let t = e.plugins
		if (J3 != t) {
			;(mk = !1), (J3 = t)
			for (let n = 0; n < t.length; n++)
				if (t[n].spec.historyPreserveItems) {
					mk = !0
					break
				}
		}
		return mk
	}
	const dl = new dg("history"),
		rye = new dg("closeHistory")
	function $U(e = {}) {
		return (
			(e = { depth: e.depth || 100, newGroupDelay: e.newGroupDelay || 500 }),
			new Ki({
				key: dl,
				state: {
					init() {
						return new hu(po.empty, po.empty, null, 0)
					},
					apply(t, n, r) {
						return tye(n, r, t, e)
					},
				},
				config: e,
				props: {
					handleDOMEvents: {
						beforeinput(t, n) {
							let r = n.inputType,
								i = r == "historyUndo" ? qm : r == "historyRedo" ? PO : null
							return i ? (n.preventDefault(), i(t.state, t.dispatch)) : !1
						},
					},
				},
			})
		)
	}
	const qm = (e, t) => {
			let n = dl.getState(e)
			return !n || n.done.eventCount == 0 ? !1 : (t && HU(n, e, t, !1), !0)
		},
		PO = (e, t) => {
			let n = dl.getState(e)
			return !n || n.undone.eventCount == 0 ? !1 : (t && HU(n, e, t, !0), !0)
		}
	function iye(e) {
		let t = dl.getState(e)
		return t ? t.done.eventCount : 0
	}
	/**
	 * @toast-ui/editor
	 * @version 3.2.2 | Mon Dec 02 2024
	 * @author NHN Cloud FE Development Lab <dl_javascript@nhn.com>
	 * @license MIT
	 */ var R2 = function (e, t) {
		return (
			(R2 =
				Object.setPrototypeOf ||
				({ __proto__: [] } instanceof Array &&
					function (n, r) {
						n.__proto__ = r
					}) ||
				function (n, r) {
					for (var i in r) Object.prototype.hasOwnProperty.call(r, i) && (n[i] = r[i])
				}),
			R2(e, t)
		)
	}
	function Ve(e, t) {
		if (typeof t != "function" && t !== null)
			throw new TypeError("Class extends value " + String(t) + " is not a constructor or null")
		R2(e, t)
		function n() {
			this.constructor = e
		}
		e.prototype = t === null ? Object.create(t) : ((n.prototype = t.prototype), new n())
	}
	var me = function () {
		return (
			(me =
				Object.assign ||
				function (t) {
					for (var n, r = 1, i = arguments.length; r < i; r++) {
						n = arguments[r]
						for (var a in n) Object.prototype.hasOwnProperty.call(n, a) && (t[a] = n[a])
					}
					return t
				}),
			me.apply(this, arguments)
		)
	}
	function Gi(e, t, n) {
		if (arguments.length === 2)
			for (var r = 0, i = t.length, a; r < i; r++)
				(a || !(r in t)) && (a || (a = Array.prototype.slice.call(t, 0, r)), (a[r] = t[r]))
		return e.concat(a || Array.prototype.slice.call(t))
	}
	function Lt(e, t) {
		return Object.defineProperty ? Object.defineProperty(e, "raw", { value: t }) : (e.raw = t), e
	}
	function aye(e, t, n) {
		var r
		n = n || null
		for (r in e) if (e.hasOwnProperty(r) && t.call(n, e[r], r, e) === !1) break
	}
	var mp = aye
	function oye(e, t) {
		var n = Object.prototype.hasOwnProperty,
			r,
			i,
			a,
			o
		for (a = 1, o = arguments.length; a < o; a += 1) {
			r = arguments[a]
			for (i in r) n.call(r, i) && (e[i] = r[i])
		}
		return e
	}
	var jO = oye
	function sye(e) {
		return typeof e == "string" || e instanceof String
	}
	var Nl = sye
	function lye(e) {
		return e instanceof Array
	}
	var th = lye
	function uye(e, t, n) {
		var r = 0,
			i = e.length
		for (n = n || null; r < i && t.call(n, e[r], r, e) !== !1; r += 1);
	}
	var vp = uye,
		cye = th,
		dye = vp,
		fye = mp
	function pye(e, t, n) {
		cye(e) ? dye(e, t, n) : fye(e, t, n)
	}
	var ow = pye,
		hye = Nl,
		mye = ow
	function vye(e, t, n) {
		var r = e.style
		if (hye(t)) {
			r[t] = n
			return
		}
		mye(t, function (i, a) {
			r[a] = i
		})
	}
	var gs = vye,
		gye = th
	function yye(e, t, n) {
		var r, i
		if (((n = n || 0), !gye(t))) return -1
		if (Array.prototype.indexOf) return Array.prototype.indexOf.call(t, e, n)
		for (i = t.length, r = n; n >= 0 && r < i; r += 1) if (t[r] === e) return r
		return -1
	}
	var yd = yye
	function bye(e) {
		return e === void 0
	}
	var Oo = bye,
		xye = Oo
	function wye(e) {
		return !e || !e.className ? "" : xye(e.className.baseVal) ? e.className : e.className.baseVal
	}
	var FO = wye,
		Eye = th,
		Cye = Oo
	function Tye(e, t) {
		if (
			((t = Eye(t) ? t.join(" ") : t),
			(t = t.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "")),
			Cye(e.className.baseVal))
		) {
			e.className = t
			return
		}
		e.className.baseVal = t
	}
	var UU = Tye,
		Z3 = ow,
		kye = yd,
		Sye = FO,
		Dye = UU
	function _ye(e) {
		var t = Array.prototype.slice.call(arguments, 1),
			n = e.classList,
			r = [],
			i
		if (n) {
			Z3(t, function (a) {
				e.classList.add(a)
			})
			return
		}
		;(i = Sye(e)),
			i && (t = [].concat(i.split(/\s+/), t)),
			Z3(t, function (a) {
				kye(a, r) < 0 && r.push(a)
			}),
			Dye(e, r)
	}
	var ss = _ye,
		e4 = vp,
		Oye = yd,
		Aye = FO,
		Nye = UU
	function Mye(e) {
		var t = Array.prototype.slice.call(arguments, 1),
			n = e.classList,
			r,
			i
		if (n) {
			e4(t, function (a) {
				n.remove(a)
			})
			return
		}
		;(r = Aye(e).split(/\s+/)),
			(i = []),
			e4(r, function (a) {
				Oye(a, t) < 0 && i.push(a)
			}),
			Nye(e, i)
	}
	var go = Mye
	function Iye(e) {
		return typeof e == "number" || e instanceof Number
	}
	var Js = Iye
	function Rye(e) {
		return e === null
	}
	var hb = Rye,
		Lye = mp
	function Pye(e, t) {
		var n = document.createElement("img"),
			r = ""
		return (
			Lye(t, function (i, a) {
				r += "&" + a + "=" + i
			}),
			(r = r.substring(1)),
			(n.src = e + "?" + r),
			(n.style.display = "none"),
			document.body.appendChild(n),
			document.body.removeChild(n),
			n
		)
	}
	var jye = Pye,
		Fye = Oo,
		Bye = jye,
		Hye = 7 * 24 * 60 * 60 * 1e3
	function $ye(e) {
		var t = new Date().getTime()
		return t - e > Hye
	}
	function Uye(e, t) {
		var n = "https://www.google-analytics.com/collect",
			r = location.hostname,
			i = "event",
			a = "use",
			o = "TOAST UI " + e + " for " + r + ": Statistics",
			s = window.localStorage.getItem(o)
		;(!Fye(window.tui) && window.tui.usageStatistics === !1) ||
			(s && !$ye(s)) ||
			(window.localStorage.setItem(o, new Date().getTime()),
			setTimeout(function () {
				;(document.readyState === "interactive" || document.readyState === "complete") &&
					Bye(n, { v: 1, t: i, tid: t, cid: r, dp: r, dh: e, el: e, ec: a })
			}, 1e3))
	}
	var zye = Uye,
		qye = /[\u0020]+/g,
		Vye = /[>(){}[\]+-.!#|]/g,
		t4 =
			/<([a-zA-Z_][a-zA-Z0-9\-._]*)(\s|[^\\>])*\/?>|<(\/)([a-zA-Z_][a-zA-Z0-9\-._]*)\s*\/?>|<!--[^-]+-->|<([a-zA-Z_][a-zA-Z0-9\-.:/]*)>/g,
		n4 = /\\[!"#$%&'()*+,-./:;<=>?@[\]^_`{|}~\\]/g,
		Wye = /[*_~`]/g,
		r4 = /!\[.*\]\(.*\)/g,
		Yye = /[[\]]/g,
		i4 = /(?:^|[^\\])\\(?!\\)/g,
		Gye = '[&<>"]',
		a4 = new RegExp(Gye, "g")
	function Kye(e) {
		switch (e) {
			case "&":
				return "&amp;"
			case "<":
				return "&lt;"
			case ">":
				return "&gt;"
			case '"':
				return "&quot;"
			default:
				return e
		}
	}
	function Bf(e) {
		return a4.test(e) ? e.replace(a4, Kye) : e
	}
	function Qye() {
		zye("editor", "UA-129966929-1")
	}
	function Vr(e, t) {
		return e.indexOf(t) !== -1
	}
	var Xye = ["rel", "target", "hreflang", "type"],
		Jye = {
			codeblock: /(^ {4}[^\n]+\n*)+/,
			thematicBreak: /^ *((\* *){3,}|(- *){3,} *|(_ *){3,}) */,
			atxHeading: /^(#{1,6}) +[\s\S]+/,
			seTextheading: /^([^\n]+)\n *(=|-){2,} */,
			blockquote: /^( *>[^\n]+.*)+/,
			list: /^ *(\*+|-+|\d+\.) [\s\S]+/,
			def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +["(]([^\n]+)[")])? */,
			link: /!?\[.*\]\(.*\)/,
			reflink: /!?\[.*\]\s*\[([^\]]*)\]/,
			verticalBar: /\u007C/,
			fencedCodeblock: /^((`|~){3,})/,
		}
	function zU(e) {
		if (!e) return null
		var t = {}
		return (
			Xye.forEach(function (n) {
				Oo(e[n]) || (t[n] = e[n])
			}),
			t
		)
	}
	function mb(e, t) {
		for (var n = "", r = 0; r < t; r += 1) n += e
		return n
	}
	function Zye(e) {
		var t = !1
		return (
			mp(Jye, function (n) {
				return n.test(e) && (t = !0), !t
			}),
			t
		)
	}
	function vb(e) {
		for (var t = [], n = r4.exec(e); n; ) t.push([n.index, n.index + n[0].length]), (n = r4.exec(e))
		return e.replace(Yye, function (r, i) {
			var a = t.some(function (o) {
				return i > o[0] && i < o[1]
			})
			return a ? r : "\\" + r
		})
	}
	function e1e(e) {
		var t = function (i) {
				return "\\" + i
			},
			n = function (i) {
				return i + "\\"
			},
			r = e.replace(qye, " ")
		return (
			n4.test(r) && (r = r.replace(n4, t)),
			i4.test(r) && (r = r.replace(i4, n)),
			(r = r.replace(Wye, t)),
			t4.test(r) && (r = r.replace(t4, t)),
			Zye(r) && (r = r.replace(Vye, t)),
			r
		)
	}
	function t1e(e) {
		var t
		return (
			e.indexOf('"') === -1 ? (t = '""') : (t = e.indexOf("'") === -1 ? "''" : "()"),
			t[0] + e + t[1]
		)
	}
	function L2(e) {
		return hb(e) || Oo(e)
	}
	function BO(e, t) {
		if (e === null && e === t) return !0
		if (typeof e != "object" || typeof t != "object" || L2(e) || L2(t)) return e === t
		for (var n in e) if (e[n] !== t[n]) return !1
		for (var n in t) if (!(n in e)) return !1
		return !0
	}
	function ni(e) {
		return e[e.length - 1]
	}
	function n1e(e, t, n) {
		return e >= t && e <= n
	}
	function HO(e) {
		return typeof e == "object" && e !== null
	}
	function gb(e, t) {
		var n = me({}, e)
		return (
			e &&
				t &&
				Object.keys(t).forEach(function (r) {
					HO(n[r])
						? Array.isArray(t[r])
							? (n[r] = $O(t[r]))
							: n.hasOwnProperty(r)
							? (n[r] = gb(n[r], t[r]))
							: (n[r] = UO(t[r]))
						: (n[r] = t[r])
				}),
			n
		)
	}
	function $O(e) {
		return e.map(function (t) {
			return HO(t) ? (Array.isArray(t) ? $O(t) : UO(t)) : t
		})
	}
	function UO(e) {
		var t = Object.keys(e)
		return t.length
			? t.reduce(function (n, r) {
					return HO(e[r]) ? (n[r] = Array.isArray(e[r]) ? $O(e[r]) : UO(e[r])) : (n[r] = e[r]), n
			  }, {})
			: e
	}
	function zO(e, t) {
		return (
			t === void 0 && (t = {}),
			Object.keys(t).forEach(function (n) {
				e.hasOwnProperty(n) && typeof e[n] == "object"
					? Array.isArray(t[n])
						? (e[n] = t[n])
						: zO(e[n], t[n])
					: (e[n] = t[n])
			}),
			e
		)
	}
	function o4(e, t) {
		return e > t ? [t, e] : [e, t]
	}
	var r1e = vp
	function i1e(e) {
		var t
		try {
			t = Array.prototype.slice.call(e)
		} catch {
			;(t = []),
				r1e(e, function (r) {
					t.push(r)
				})
		}
		return t
	}
	var Ds = i1e
	function yb(e, t) {
		var n = e.nodes.paragraph
		return t ? n.create(null, Nl(t) ? e.text(t) : t) : n.createAndFill()
	}
	function zr(e, t, n) {
		return e.text(t, n)
	}
	function Fn(e, t, n) {
		n === void 0 && (n = t)
		var r = e.doc.content.size,
			i = r > 0 ? r - 1 : 1
		return jt.create(e.doc, Math.min(t, i), Math.min(n, i))
	}
	function qO(e, t, n) {
		var r = t.pos
		return e.replaceWith(r, r, yb(n)), e.setSelection(Fn(e, r + 1))
	}
	function bb(e) {
		for (
			var t = e.state,
				n = e.from,
				r = e.startIndex,
				i = e.endIndex,
				a = e.createText,
				o = t.tr,
				s = t.doc,
				l = t.schema,
				u = r;
			u <= i;
			u += 1
		) {
			var d = s.child(u),
				p = d.nodeSize,
				m = d.textContent,
				v = d.content,
				y = a(m),
				b = y ? zr(l, y) : ke.empty,
				x = o.mapping.map(n),
				E = x + v.size
			o.replaceWith(x, E, b), (n += p)
		}
		return o
	}
	function VO(e, t, n, r) {
		var i = n.length
		e.split(t)
			.delete(t - i, t)
			.insert(e.mapping.map(t), r)
			.setSelection(Fn(e, e.mapping.map(t) - i))
	}
	function hg(e) {
		return e.sourcepos[0][0]
	}
	function sw(e) {
		return e.sourcepos[1][0]
	}
	function lw(e) {
		return e.sourcepos[0][1]
	}
	function Du(e) {
		return e.sourcepos[1][1]
	}
	function a1e(e) {
		var t = e.type
		return t === "htmlBlock" || t === "htmlInline"
	}
	function o1e(e) {
		var t = e.type
		return (
			t === "strike" ||
			t === "strong" ||
			t === "emph" ||
			t === "code" ||
			t === "link" ||
			t === "image"
		)
	}
	function s1e(e) {
		return e && e.type === "codeBlock"
	}
	function bd(e) {
		return e && (e.type === "item" || e.type === "list")
	}
	function qU(e) {
		return bd(e) && e.listData.type === "ordered"
	}
	function l1e(e) {
		return bd(e) && e.listData.type !== "ordered"
	}
	function s4(e) {
		return e && (e.type === "tableCell" || e.type === "tableDelimCell")
	}
	function u1e(e) {
		switch (e.type) {
			case "code":
			case "text":
			case "emph":
			case "strong":
			case "strike":
			case "link":
			case "image":
			case "htmlInline":
			case "linebreak":
			case "softbreak":
			case "customInline":
				return !0
			default:
				return !1
		}
	}
	function gp(e, t, n) {
		for (n === void 0 && (n = !0), e = n ? e : e.parent; e && e.type !== "document"; ) {
			if (t(e)) return e
			e = e.parent
		}
		return null
	}
	function c1e(e, t, n) {
		for (n === void 0 && (n = !0), e = n ? e : e.parent; e && e.type !== "document"; )
			t(e), (e = e.parent)
	}
	function Dr(e, t) {
		return [e[0], e[1] + t]
	}
	function _u(e, t) {
		return [e[0], t]
	}
	function d1e(e) {
		var t = e.firstChild.literal
		switch (e.type) {
			case "emph":
				return "*" + t + "*"
			case "strong":
				return "**" + t + "**"
			case "strike":
				return "~~" + t + "~~"
			case "code":
				return "`" + t + "`"
			case "link":
			case "image":
				var n = e,
					r = n.destination,
					i = n.title,
					a = e.type === "link" ? "" : "!"
				return a + "[" + t + "](" + r + (i ? ' "' + i + '"' : "") + ")"
			default:
				return null
		}
	}
	function f1e(e) {
		switch (e.type) {
			case "document":
			case "blockQuote":
			case "list":
			case "item":
			case "paragraph":
			case "heading":
			case "emph":
			case "strong":
			case "strike":
			case "link":
			case "image":
			case "table":
			case "tableHead":
			case "tableBody":
			case "tableRow":
			case "tableCell":
			case "tableDelimRow":
			case "customInline":
				return !0
			default:
				return !1
		}
	}
	function p1e(e) {
		for (var t = [], n = e.walker(), r = null; (r = n.next()); ) {
			var i = r.node
			i.type === "text" && t.push(i.literal)
		}
		return t.join("")
	}
	var Ov = [],
		VU = {},
		l4 = /\$\$widget\d+\s/
	function uw(e) {
		var t = e.search(l4)
		if (t !== -1) {
			var n = e.substring(t),
				r = n.replace(l4, "").replace("$$", "")
			;(e = e.substring(0, t)), (e += uw(r))
		}
		return e
	}
	function WU(e, t) {
		return "$$" + e + " " + t + "$$"
	}
	function YU(e, t) {
		var n = VU[e],
			r = n.rule,
			i = n.toDOM,
			a = uw(t).match(r)
		return a && (t = a[0]), i(t)
	}
	function h1e() {
		return Ov
	}
	function m1e(e) {
		;(Ov = e),
			Ov.forEach(function (t, n) {
				VU["widget" + n] = t
			})
	}
	function vk(e, t, n, r) {
		return e.concat(td(t, n, r))
	}
	function td(e, t, n) {
		n === void 0 && (n = 0)
		var r = [],
			i = (Ov[n] || {}).rule,
			a = n + 1
		if (((e = uw(e)), i && i.test(e))) {
			for (var o = void 0; (o = e.search(i)) !== -1; ) {
				var s = e.substring(0, o)
				s && (r = vk(r, s, t, a)), (e = e.substring(o))
				var l = e.match(i)[0],
					u = "widget" + n
				r.push(t.nodes.widget.create({ info: u }, t.text(WU(u, l)))), (e = e.substring(l.length))
			}
			e && (r = vk(r, e, t, a))
		} else e && (r = n < Ov.length - 1 ? vk(r, e, t, a) : [t.text(e)])
		return r
	}
	function GU(e) {
		for (var t, n = "", r = e.walker(); (t = r.next()); ) {
			var i = t.node,
				a = t.entering
			a &&
				(i !== e && i.type !== "text"
					? ((n += d1e(i)), r.resumeAt(e, !1), r.next())
					: i.type === "text" && (n += i.literal))
		}
		return n
	}
	function KU() {
		return {
			deleteSelection: function () {
				return MO
			},
			selectAll: function () {
				return MU
			},
			undo: function () {
				return qm
			},
			redo: function () {
				return PO
			},
		}
	}
	function v1e(e) {
		return new Ki({
			props: {
				decorations: function (t) {
					var n = t.doc
					if (
						e.text &&
						n.childCount === 1 &&
						n.firstChild.isTextblock &&
						n.firstChild.content.size === 0
					) {
						var r = document.createElement("span")
						return (
							ss(r, "placeholder"),
							e.className && ss(r, e.className),
							(r.textContent = e.text),
							mr.create(n, [$i.widget(1, r)])
						)
					}
					return null
				},
			},
		})
	}
	var g1e = yd,
		y1e = FO
	function b1e(e, t) {
		var n
		return e.classList ? e.classList.contains(t) : ((n = y1e(e).split(/\s+/)), g1e(t, n) > -1)
	}
	var QU = b1e,
		x1e = yd,
		w1e = Ds,
		iy = Element.prototype,
		E1e =
			iy.matches ||
			iy.webkitMatchesSelector ||
			iy.mozMatchesSelector ||
			iy.msMatchesSelector ||
			function (e) {
				var t = this.document || this.ownerDocument
				return x1e(this, w1e(t.querySelectorAll(e))) > -1
			}
	function C1e(e, t) {
		return E1e.call(e, t)
	}
	var T1e = C1e,
		XU = "[A-Za-z][A-Za-z0-9-]*",
		k1e = "[a-zA-Z_:][a-zA-Z0-9:._-]*",
		S1e = "[^\"'=<>`\\x00-\\x20]+",
		D1e = "'[^']*'",
		_1e = '"[^"]*"',
		O1e = "(?:" + S1e + "|" + D1e + "|" + _1e + ")",
		A1e = "(?:\\s*=\\s*" + O1e + ")",
		JU = "(?:\\s+" + k1e + A1e + "?)",
		ZU = "<(" + XU + ")(" + JU + ")*\\s*/?>",
		N1e = "</(" + XU + ")\\s*[>]",
		ez = "(?:" + ZU + "|" + N1e + ")",
		yp = new RegExp("^" + ez, "i"),
		P2 = /<br\s*\/*>/i,
		M1e = /<! ---->|<!--(?:-?[^>-])(?:-?[^-])*-->/,
		tz = "</p><p>"
	function WO(e, t, n) {
		var r = parseInt(e.left, 10),
			i = parseInt(e.top, 10),
			a = parseInt(e.width, 10) + parseInt(e.paddingLeft, 10) + parseInt(e.paddingRight, 10),
			o = parseInt(e.height, 10) + parseInt(e.paddingTop, 10) + parseInt(e.paddingBottom, 10)
		return t >= r && t <= r + a && n >= i && n <= i + o
	}
	var nz = "toastui-editor-"
	function Qe() {
		for (var e = [], t = 0; t < arguments.length; t++) e[t] = arguments[t]
		for (var n = [], r = 0, i = e; r < i.length; r++) {
			var a = i[r],
				o = void 0
			Array.isArray(a) ? (o = a[0] ? a[1] : null) : (o = a), o && n.push("" + nz + o)
		}
		return n.join(" ")
	}
	function yr() {
		for (var e = [], t = 0; t < arguments.length; t++) e[t] = arguments[t]
		return e
			.map(function (n) {
				return nz + "md-" + n
			})
			.join(" ")
	}
	function I1e(e) {
		return (e == null ? void 0 : e.nodeType) === Node.TEXT_NODE
	}
	function cw(e) {
		return e && e.nodeType === Node.ELEMENT_NODE
	}
	function R1e(e, t) {
		var n = Ds(e.querySelectorAll(t))
		return n.length ? n : []
	}
	function L1e(e, t) {
		;(t = th(t) ? Ds(t) : [t]),
			t.forEach(function (n) {
				e.appendChild(n)
			})
	}
	function P1e(e, t) {
		t.parentNode && t.parentNode.insertBefore(e, t)
	}
	function xd(e) {
		e.parentNode && e.parentNode.removeChild(e)
	}
	function j1e(e) {
		for (var t = []; e.firstChild; )
			t.push(e.firstChild), e.parentNode && e.parentNode.insertBefore(e.firstChild, e)
		return xd(e), t
	}
	function YO(e, t, n) {
		Oo(n) && (n = !QU(e, t))
		var r = n ? ss : go
		r(e, t)
	}
	function rz(e, t) {
		var n = document.createElement("div")
		Nl(e) ? (n.innerHTML = e) : n.appendChild(e)
		var r = n.firstChild
		return t && t.appendChild(r), r
	}
	function GO(e) {
		var t = window.getComputedStyle(e)
		return (
			["margin-left", "margin-right"].reduce(function (n, r) {
				return n + parseInt(t.getPropertyValue(r), 10)
			}, 0) + e.offsetWidth
		)
	}
	function ls(e, t) {
		var n
		for (
			Nl(t)
				? (n = function (r) {
						return T1e(r, t)
				  })
				: (n = function (r) {
						return r === t
				  });
			e && e !== document;

		) {
			if (cw(e) && n(e)) return e
			e = e.parentNode
		}
		return null
	}
	function iz(e, t) {
		for (var n = 0, r = 0; e && e !== t; ) {
			var i = e.offsetTop,
				a = e.offsetLeft,
				o = e.offsetParent
			if (((n += i), (r += a), o === t.offsetParent)) break
			e = e.offsetParent
		}
		return { offsetTop: n, offsetLeft: r }
	}
	function KO(e, t) {
		Object.keys(e).forEach(function (n) {
			L2(e[n]) ? t.removeAttribute(n) : t.setAttribute(n, e[n])
		})
	}
	function F1e(e) {
		var t = e.replace(/<p><br\s*\/*><\/p>/gi, "<p></p>"),
			n = new RegExp(ez, "ig"),
			r = t.match(n)
		return (
			r == null ||
				r.forEach(function (i, a) {
					if (P2.test(i)) {
						var o = tz
						if (a) {
							var s = r[a - 1],
								l = s.match(ZU)
							if (l && !/br/i.test(l[1])) {
								var u = l[1]
								o = "</" + u + "><" + u + ">"
							}
						}
						t = t.replace(P2, o)
					}
				}),
			t
		)
	}
	function QO(e) {
		var t = /<img class="ProseMirror-separator" alt="">/g,
			n = / class="ProseMirror-trailingBreak"/g,
			r = e
		return (r = r.replace(t, "")), (r = r.replace(n, "")), r
	}
	var az = new dg("widget"),
		u4 = 5,
		B1e = (function () {
			function e(t, n) {
				var r = this
				;(this.popup = null),
					(this.removeWidget = function () {
						r.popup && (r.rootEl.removeChild(r.popup), (r.popup = null))
					}),
					(this.rootEl = t.dom.parentElement),
					(this.eventEmitter = n),
					this.eventEmitter.listen("blur", this.removeWidget),
					this.eventEmitter.listen("loadUI", function () {
						r.rootEl = ls(t.dom.parentElement, "." + Qe("defaultUI"))
					}),
					this.eventEmitter.listen("removePopupWidget", this.removeWidget)
			}
			return (
				(e.prototype.update = function (t) {
					var n = az.getState(t.state)
					if ((this.removeWidget(), n)) {
						var r = n.node,
							i = n.style,
							a = t.coordsAtPos(n.pos),
							o = a.top,
							s = a.left,
							l = a.bottom,
							u = l - o,
							d = this.rootEl.getBoundingClientRect(),
							p = o - d.top
						gs(r, { opacity: "0" }),
							this.rootEl.appendChild(r),
							gs(r, {
								position: "absolute",
								left: s - d.left + u4 + "px",
								top: (i === "bottom" ? p + u - u4 : p - u) + "px",
								opacity: "1",
							}),
							(this.popup = r),
							t.focus()
					}
				}),
				(e.prototype.destroy = function () {
					this.eventEmitter.removeEventHandler("blur", this.removeWidget)
				}),
				e
			)
		})()
	function H1e(e) {
		return new Ki({
			key: az,
			state: {
				init: function () {
					return null
				},
				apply: function (t) {
					return t.getMeta("widget")
				},
			},
			view: function (t) {
				return new B1e(t, e)
			},
		})
	}
	function $1e(e) {
		e.listen("addImageBlobHook", function (t, n) {
			var r = new FileReader()
			;(r.onload = function (i) {
				var a = i.target
				return n(a.result)
			}),
				r.readAsDataURL(t)
		})
	}
	function XO(e, t, n) {
		var r = function (i, a) {
			e.emit("command", "addImage", { imageUrl: i, altText: a || t.name || "image" })
		}
		e.emit("addImageBlobHook", t, r, n)
	}
	function oz(e) {
		var t = Ds(e).filter(function (r) {
			var i = r.type
			return i.indexOf("image") !== -1
		})
		if (t.length === 1) {
			var n = t[0]
			if (n) return n.getAsFile()
		}
		return null
	}
	function U1e(e) {
		var t = e.eventEmitter
		return new Ki({
			props: {
				handleDOMEvents: {
					drop: function (n, r) {
						var i,
							a = (i = r.dataTransfer) === null || i === void 0 ? void 0 : i.files
						return (
							a &&
								vp(a, function (o) {
									return o.type.indexOf("image") !== -1
										? (r.preventDefault(), r.stopPropagation(), XO(t, o, r.type), !1)
										: !0
								}),
							!0
						)
					},
				},
			},
		})
	}
	var On = (function () {
		function e() {}
		return (
			Object.defineProperty(e.prototype, "type", {
				get: function () {
					return "node"
				},
				enumerable: !1,
				configurable: !0,
			}),
			(e.prototype.setContext = function (t) {
				this.context = t
			}),
			e
		)
	})()
	function sz(e) {
		var t = document.createElement("span"),
			n = YU(e.attrs.info, e.textContent)
		return (t.className = "tui-widget"), t.appendChild(n), { dom: t }
	}
	function j2(e) {
		return e.type.name === "widget"
	}
	var lz = (function (e) {
			Ve(t, e)
			function t() {
				return (e !== null && e.apply(this, arguments)) || this
			}
			return (
				Object.defineProperty(t.prototype, "name", {
					get: function () {
						return "widget"
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(t.prototype, "schema", {
					get: function () {
						return {
							attrs: { info: { default: null } },
							group: "inline",
							inline: !0,
							content: "text*",
							selectable: !1,
							atom: !0,
							toDOM: function () {
								return ["span", { class: "tui-widget" }, 0]
							},
							parseDOM: [
								{
									tag: "span.tui-widget",
									getAttrs: function (n) {
										var r = n.textContent,
											i = r.match(/\$\$(widget\d+)/),
											a = i[1]
										return { info: a }
									},
								},
							],
						}
					},
					enumerable: !1,
					configurable: !0,
				}),
				t
			)
		})(On),
		uz = (function () {
			function e(t) {
				;(this.timer = null),
					(this.el = document.createElement("div")),
					(this.el.className = "toastui-editor"),
					(this.eventEmitter = t),
					(this.placeholder = { text: "" })
			}
			return (
				(e.prototype.createState = function () {
					return Bc.create({ schema: this.schema, plugins: this.createPlugins() })
				}),
				(e.prototype.initEvent = function () {
					var t = this,
						n = t.eventEmitter,
						r = t.view,
						i = t.editorType
					r.dom.addEventListener("focus", function () {
						return n.emit("focus", i)
					}),
						r.dom.addEventListener("blur", function () {
							return n.emit("blur", i)
						})
				}),
				(e.prototype.emitChangeEvent = function (t) {
					this.eventEmitter.emit("caretChange", this.editorType),
						t.docChanged && this.eventEmitter.emit("change", this.editorType)
				}),
				Object.defineProperty(e.prototype, "defaultPlugins", {
					get: function () {
						var t = this.createInputRules(),
							n = Gi(Gi([], this.keymaps), [
								_v(me({ "Shift-Enter": K3.Enter }, K3)),
								$U(),
								v1e(this.placeholder),
								H1e(this.eventEmitter),
								U1e(this.context),
							])
						return t ? n.concat(t) : n
					},
					enumerable: !1,
					configurable: !0,
				}),
				(e.prototype.createInputRules = function () {
					var t = h1e(),
						n = t.map(function (r) {
							var i = r.rule
							return new PU(i, function (a, o, s, l) {
								var u = a.schema,
									d = a.tr,
									p = a.doc,
									m = o.input.match(new RegExp(i, "g")),
									v = p.resolve(s),
									y = v.parent,
									b = 0
								if (
									(j2(y) && (y = v.node(v.depth - 1)),
									y.forEach(function (T) {
										return j2(T) && (b += 1)
									}),
									m.length > b)
								) {
									var x = ni(m),
										E = td(x, u)
									return d.replaceWith(l - x.length + 1, l, E)
								}
								return null
							})
						})
					return n.length ? jU({ rules: n }) : null
				}),
				(e.prototype.clearTimer = function () {
					this.timer && (clearTimeout(this.timer), (this.timer = null))
				}),
				(e.prototype.createSchema = function () {
					return new R7({ nodes: this.specs.nodes, marks: this.specs.marks })
				}),
				(e.prototype.createKeymaps = function (t) {
					var n = KU(),
						r = n.undo,
						i = n.redo,
						a = this.specs.keymaps(t),
						o = { "Mod-z": r(), "Shift-Mod-z": i() }
					return t ? a.concat(_v(o)) : a
				}),
				(e.prototype.createCommands = function () {
					return this.specs.commands(this.view)
				}),
				(e.prototype.createPluginProps = function () {
					var t = this
					return this.extraPlugins.map(function (n) {
						return n(t.eventEmitter)
					})
				}),
				(e.prototype.focus = function () {
					var t = this
					this.clearTimer(),
						(this.timer = setTimeout(function () {
							t.view.focus(), t.view.dispatch(t.view.state.tr.scrollIntoView())
						}))
				}),
				(e.prototype.blur = function () {
					this.view.dom.blur()
				}),
				(e.prototype.destroy = function () {
					var t = this
					this.clearTimer(),
						this.view.destroy(),
						Object.keys(this).forEach(function (n) {
							delete t[n]
						})
				}),
				(e.prototype.moveCursorToStart = function (t) {
					var n = this.view.state.tr
					this.view.dispatch(n.setSelection(Fn(n, 1)).scrollIntoView()), t && this.focus()
				}),
				(e.prototype.moveCursorToEnd = function (t) {
					var n = this.view.state.tr
					this.view.dispatch(n.setSelection(Fn(n, n.doc.content.size - 1)).scrollIntoView()),
						t && this.focus()
				}),
				(e.prototype.setScrollTop = function (t) {
					this.view.dom.scrollTop = t
				}),
				(e.prototype.getScrollTop = function () {
					return this.view.dom.scrollTop
				}),
				(e.prototype.setPlaceholder = function (t) {
					;(this.placeholder.text = t), this.view.dispatch(this.view.state.tr.scrollIntoView())
				}),
				(e.prototype.setHeight = function (t) {
					gs(this.el, { height: t + "px" })
				}),
				(e.prototype.setMinHeight = function (t) {
					gs(this.el, { minHeight: t + "px" })
				}),
				(e.prototype.getElement = function () {
					return this.el
				}),
				e
			)
		})()
	function z1e(e) {
		return e instanceof Function
	}
	var Ka = z1e,
		q1e = [
			"Enter",
			"Shift-Enter",
			"Mod-Enter",
			"Tab",
			"Shift-Tab",
			"Delete",
			"Backspace",
			"Mod-Delete",
			"Mod-Backspace",
			"ArrowUp",
			"ArrowDown",
			"ArrowLeft",
			"ArrowRight",
			"Mod-d",
			"Mod-D",
			"Alt-ArrowUp",
			"Alt-ArrowDown",
		]
	function ay(e, t, n) {
		return e.focus(), t(n)(e.state, e.dispatch, e)
	}
	var cz = (function () {
		function e(t) {
			this.specs = t
		}
		return (
			Object.defineProperty(e.prototype, "nodes", {
				get: function () {
					return this.specs
						.filter(function (t) {
							return t.type === "node"
						})
						.reduce(function (t, n) {
							var r,
								i = n.name,
								a = n.schema
							return me(me({}, t), ((r = {}), (r[i] = a), r))
						}, {})
				},
				enumerable: !1,
				configurable: !0,
			}),
			Object.defineProperty(e.prototype, "marks", {
				get: function () {
					return this.specs
						.filter(function (t) {
							return t.type === "mark"
						})
						.reduce(function (t, n) {
							var r,
								i = n.name,
								a = n.schema
							return me(me({}, t), ((r = {}), (r[i] = a), r))
						}, {})
				},
				enumerable: !1,
				configurable: !0,
			}),
			(e.prototype.commands = function (t, n) {
				var r = this.specs
						.filter(function (a) {
							var o = a.commands
							return o
						})
						.reduce(function (a, o) {
							var s = {},
								l = o.commands()
							return (
								Ka(l)
									? (s[o.name] = function (u) {
											return ay(t, l, u)
									  })
									: Object.keys(l).forEach(function (u) {
											s[u] = function (d) {
												return ay(t, l[u], d)
											}
									  }),
								me(me({}, a), s)
							)
						}, {}),
					i = KU()
				return (
					Object.keys(i).forEach(function (a) {
						r[a] = function (o) {
							return ay(t, i[a], o)
						}
					}),
					n &&
						Object.keys(n).forEach(function (a) {
							r[a] = function (o) {
								return ay(t, n[a], o)
							}
						}),
					r
				)
			}),
			(e.prototype.keymaps = function (t) {
				var n = this.specs
					.filter(function (r) {
						return r.keymaps
					})
					.map(function (r) {
						return r.keymaps()
					})
				return n.map(function (r) {
					return (
						t ||
							Object.keys(r).forEach(function (i) {
								Vr(q1e, i) || delete r[i]
							}),
						_v(r)
					)
				})
			}),
			(e.prototype.setContext = function (t) {
				this.specs.forEach(function (n) {
					n.setContext(t)
				})
			}),
			e
		)
	})()
	function dz(e) {
		var t = e.from,
			n = e.to
		return e instanceof wi ? [t + 1, n - 1] : [t, n]
	}
	function c4(e) {
		return e.index(0) + 1
	}
	function bp(e, t, n) {
		n === void 0 && (n = 1)
		var r = 0
		return (
			e.forEach(function (i, a) {
				j2(i) && a + 2 < t && (r += 2 * n)
			}),
			r
		)
	}
	function d1(e, t, n) {
		n === void 0 && (n = t)
		var r = t === n,
			i = e.resolve(t),
			a = c4(i),
			o = a,
			s = i.start(1),
			l = s
		if (!r) {
			var u = e.resolve(n === e.content.size ? n - 1 : n)
			;(l = u.start(1)), (o = c4(u)), u.pos === e.content.size && (n = e.content.size - 2)
		}
		var d = Math.max(t - s + 1, 1),
			p = Math.max(n - l + 1, 1)
		return [
			[a, d + bp(e.child(a - 1), d, -1)],
			[o, p + bp(e.child(o - 1), p, -1)],
		]
	}
	function fz(e, t) {
		for (var n = [], r = 0, i = 0; r < t; r += 1) {
			var a = e.child(r)
			;(n[r] = i), (i += a.nodeSize)
		}
		return n
	}
	function Ac(e, t, n) {
		var r = fz(e, n[0]),
			i = t[0] - 1,
			a = n[0] - 1,
			o = e.child(i),
			s = e.child(a),
			l = r[i],
			u = r[a]
		return (
			(l += t[1] + bp(o, t[1] - 1)), (u += n[1] + bp(s, n[1] - 1)), [l, Math.min(u, e.content.size)]
		)
	}
	function vr(e) {
		var t = e.$from,
			n = e.$to,
			r = e.from,
			i = e.to,
			a = t.doc
		return (
			e instanceof wi && ((t = a.resolve(r + 1)), (n = a.resolve(i - 1))),
			t.depth === 0 && ((t = a.resolve(r - 1)), (n = t)),
			{
				startFromOffset: t.start(1),
				endFromOffset: n.start(1),
				startToOffset: t.end(1),
				endToOffset: n.end(1),
				startIndex: t.index(0),
				endIndex: n.index(0),
				from: t.pos,
				to: n.pos,
			}
		)
	}
	function xb(e, t) {
		for (var n = 1, r = 1, i = 0, a = 0; i < e.childCount; i += 1) {
			var o = e.child(i).nodeSize
			if (((n = a + 1), (r = a + o - 1), i === t)) break
			a += o
		}
		return { startOffset: n, endOffset: r }
	}
	var d4 = "heading",
		V1e = "blockQuote",
		W1e = "listItem",
		Y1e = "table",
		G1e = "tableCell",
		K1e = "codeBlock",
		Q1e = "thematicBreak",
		f1 = "link",
		oy = "code",
		dw = "meta",
		wd = "delimiter",
		X1e = "taskDelimiter",
		JO = "markedText",
		J1e = "html",
		Z1e = "customBlock",
		f4 = { strong: 2, emph: 1, strike: 2 }
	function Qt(e, t, n, r) {
		return { start: e, end: t, spec: { type: n, attrs: r } }
	}
	function ebe(e, t, n) {
		var r = e.level,
			i = e.headingType,
			a = [Qt(t, n, d4, { level: r })]
		return (
			i === "atx" ? a.push(Qt(t, Dr(t, r), wd)) : a.push(Qt(_u(n, 0), n, d4, { seText: !0 })), a
		)
	}
	function gk(e, t, n) {
		var r = e.type,
			i = Dr(t, f4[r]),
			a = Dr(n, -f4[r])
		return [Qt(i, a, r), Qt(t, i, wd), Qt(a, n, wd)]
	}
	function pz(e, t, n, r) {
		return [
			Qt(e, t, f1),
			Qt(_u(e, n[1] + 1), _u(t, r), f1, { desc: !0 }),
			Qt(_u(t, r + 2), Dr(t, -1), f1, { url: !0 }),
		]
	}
	function tbe(e, t, n) {
		var r = e.lastChild,
			i = r ? Du(r) + 1 : 3,
			a = Dr(t, 1)
		return Gi([Qt(t, a, dw)], pz(t, n, a, i))
	}
	function nbe(e, t, n) {
		var r = e.lastChild,
			i = e.extendedAutolink,
			a = r ? Du(r) + 1 : 2
		return i ? [Qt(t, n, f1, { desc: !0 })] : pz(t, n, t, a)
	}
	function rbe(e, t, n) {
		var r = e.tickCount,
			i = Dr(t, r),
			a = Dr(n, -r)
		return [
			Qt(t, n, oy),
			Qt(t, i, oy, { start: !0 }),
			Qt(i, a, oy, { marked: !0 }),
			Qt(a, n, oy, { end: !0 }),
		]
	}
	function hz(e, t, n, r) {
		var i = {
			start: t,
			end: n,
			spec: { attrs: { className: r + "-line-background", codeStart: t[0], codeEnd: n[0] } },
			lineBackground: !0,
		}
		return e.type !== "item" && e.type !== "blockQuote"
			? [
					me(me({}, i), { end: t, spec: { attrs: { className: r + "-line-background start" } } }),
					me(me({}, i), { start: [Math.min(t[0] + 1, n[0]), t[1]] }),
			  ]
			: null
	}
	function ibe(e, t, n, r) {
		var i = e.fenceOffset,
			a = e.fenceLength,
			o = e.fenceChar,
			s = e.info,
			l = e.infoPadding,
			u = e.parent,
			d = i + a,
			p = [Qt(_u(t, 1), n, K1e)]
		o && p.push(Qt(t, Dr(t, d), wd)), s && p.push(Qt(Dr(t, a), Dr(t, a + l + s.length), dw))
		var m = "^(\\s{0,4})(" + o + "{" + a + ",})",
			v = new RegExp(m)
		v.test(r) && p.push(Qt(_u(n, 1), n, wd))
		var y = hz(u, t, n, "code-block")
		return y ? p.concat(y) : p
	}
	function abe(e, t, n) {
		var r = e,
			i = r.offset,
			a = r.syntaxLength,
			o = r.info,
			s = r.parent,
			l = i + a,
			u = [Qt(_u(t, 1), n, Z1e)]
		u.push(Qt(t, Dr(t, l), wd)),
			o && u.push(Qt(Dr(t, l), Dr(t, a + o.length), dw)),
			u.push(Qt(_u(n, 1), n, wd))
		var d = hz(s, t, n, "custom-block")
		return d ? u.concat(d) : u
	}
	function mz(e, t) {
		for (var n = []; e; ) {
			var r = e.type
			;(r === "paragraph" || r === "codeBlock") &&
				n.push(Qt([hg(e), lw(e) - 1], [sw(e), Du(e) + 1], t)),
				(e = e.next)
		}
		return n
	}
	function obe(e) {
		for (var t = []; e; ) t.push(Qt([hg(e), lw(e)], [sw(e), Du(e) + 1], JO)), (e = e.next)
		return t
	}
	function sbe(e, t, n) {
		var r = e.parent && e.parent.type !== "blockQuote" ? [Qt(t, n, V1e)] : []
		if (e.firstChild) {
			var i = []
			e.firstChild.type === "paragraph"
				? (i = obe(e.firstChild.firstChild))
				: e.firstChild.type === "list" && (i = mz(e.firstChild, JO)),
				(r = Gi(Gi([], r), i))
		}
		return r
	}
	function lbe(e) {
		for (var t = 0; e.parent.parent && e.parent.parent.type === "item"; )
			(e = e.parent.parent), (t += 1)
		var n = [{ odd: !0 }, { even: !0 }][t % 2]
		return [W1e, me(me({}, n), { listStyle: !0 })]
	}
	function ube(e, t) {
		var n = e.listData,
			r = n.padding,
			i = n.task,
			a = lbe(e),
			o = [Qt.apply(void 0, Gi([t, Dr(t, r)], a))]
		return (
			i && (o.push(Qt(Dr(t, r), Dr(t, r + 3), X1e)), o.push(Qt(Dr(t, r + 1), Dr(t, r + 2), dw))),
			o.concat(mz(e.firstChild, JO))
		)
	}
	var p4 = {
			heading: ebe,
			strong: gk,
			emph: gk,
			strike: gk,
			link: nbe,
			image: tbe,
			code: rbe,
			codeBlock: ibe,
			blockQuote: sbe,
			item: ube,
			customBlock: abe,
		},
		h4 = { thematicBreak: Q1e, table: Y1e, tableCell: G1e, htmlInline: J1e }
	function cbe(e, t, n, r) {
		var i = e.type
		return Ka(p4[i]) ? p4[i](e, t, n, r) : h4[i] ? [Qt(t, n, h4[i])] : null
	}
	var Av = {}
	function dbe(e) {
		var t = e.schema,
			n = e.toastMark
		return new Ki({
			appendTransaction: function (r, i, a) {
				var o = r[0],
					s = a.tr
				if (o.docChanged) {
					var l = [],
						u = o.getMeta("editResult")
					u.forEach(function (d) {
						var p = d.nodes,
							m = d.removedNodeRange
						if (p.length) {
							l = l.concat(gbe(s, p))
							for (var v = 0, y = p; v < y.length; v++)
								for (var b = y[v], x = b.walker(), E = x.next(); E; ) {
									var T = E.node,
										C = E.entering
									C && (l = l.concat(ybe(T, n))), (E = x.next())
								}
						} else if (m) for (var D = s.doc.childCount - 1, O = m.line, A = O[0], N = O[1], I = Math.min(A, D), P = Math.min(N, D), L = I; L <= P; L += 1) Av[L] = !0
					}),
						hbe(s, t, l)
				}
				return s.setMeta("widget", o.getMeta("widget"))
			},
		})
	}
	function fbe(e, t, n) {
		return Object.keys(n).some(function (r) {
			return n[r] !== e.child(t).attrs[r]
		})
	}
	function pbe(e, t, n, r, i) {
		i === void 0 && (i = {})
		for (var a = r.startIndex, o = r.endIndex, s = r.from, l = r.to, u = !1, d = a; d <= o; d += 1)
			delete Av[d], (u = fbe(t, d, i))
		u && e.setBlockType(s, l, n, i)
	}
	function hbe(e, t, n) {
		var r = e.doc,
			i = t.nodes.paragraph,
			a = fz(r, r.childCount)
		n.forEach(function (o) {
			var s = o.start,
				l = o.end,
				u = o.spec,
				d = o.lineBackground,
				p = Math.min(s[0], r.childCount) - 1,
				m = Math.min(l[0], r.childCount) - 1,
				v = r.child(p),
				y = r.child(m),
				b = a[p],
				x = a[m]
			if (((b += s[1] + bp(v, s[1] - 1)), (x += l[1] + bp(y, l[1] - 1)), u))
				if (d) {
					var E = { from: b, to: x, startIndex: p, endIndex: m }
					pbe(e, r, i, E, u.attrs)
				} else e.addMark(b, x, t.mark(u.type, u.attrs))
			else e.removeMark(b, x)
		}),
			mbe(e, a, i)
	}
	function mbe(e, t, n) {
		Object.keys(Av).forEach(function (r) {
			var i = Number(r),
				a = Math.min(Number(r) + 1, e.doc.childCount - 1),
				o = t[i],
				s = t[a] - 1
			i === a && (s += 2), e.setBlockType(o, s, n)
		})
	}
	function vbe(e, t, n) {
		var r = []
		Av = {}
		for (var i = t[0] - 1; i < n[0]; i += 1) {
			var a = e.child(i),
				o = a.attrs.codeEnd,
				s = a.attrs.codeStart
			if (s && o && !Vr(r, s)) {
				r.push(s), (o = Math.min(o, e.childCount))
				for (var l = s - 1, u = n[0], d = l; d < u; d += 1) Av[d] = !0
			}
		}
	}
	function gbe(e, t) {
		var n = e.doc,
			r = t[0].sourcepos[0],
			i = ni(t).sourcepos,
			a = i[1],
			o = [r[0], r[1]],
			s = [a[0], a[1] + 1],
			l = []
		return vbe(n, r, a), l.push({ start: o, end: s }), l
	}
	function ybe(e, t) {
		var n = t.getLineTexts(),
			r = [hg(e), lw(e)],
			i = [sw(e), Du(e) + 1],
			a = cbe(e, r, i, n[i[0] - 1])
		return a ?? []
	}
	var bbe = [
		"taskList",
		"orderedList",
		"bulletList",
		"table",
		"strong",
		"emph",
		"strike",
		"heading",
		"thematicBreak",
		"blockQuote",
		"code",
		"codeBlock",
		"indent",
		"outdent",
	]
	function xbe(e) {
		var t = e.type
		return bd(e)
			? e.listData.task
				? "taskList"
				: e.listData.type === "ordered"
				? "orderedList"
				: "bulletList"
			: t.indexOf("table") !== -1
			? "table"
			: Vr(bbe, t)
			? t
			: null
	}
	function wbe(e) {
		var t = { indent: { active: !1, disabled: !0 }, outdent: { active: !1, disabled: !0 } },
			n = !0
		return (
			c1e(e, function (r) {
				var i = xbe(r)
				i &&
					(i === "bulletList" || i === "orderedList"
						? n &&
						  ((t[i] = { active: !0 }),
						  (t.indent.disabled = !1),
						  (t.outdent.disabled = !1),
						  (n = !1))
						: (t[i] = { active: !0 }))
			}),
			t
		)
	}
	function Ebe(e) {
		var t = e.toastMark,
			n = e.eventEmitter
		return new Ki({
			view: function () {
				return {
					update: function (r, i) {
						var a = r.state,
							o = a.doc,
							s = a.selection
						if (!(i && i.doc.eq(o) && i.selection.eq(s))) {
							var l = s.from,
								u = a.doc.resolve(l).start(),
								d = a.doc.content.findIndex(l).index + 1,
								p = l - u
							l === u && (p += 1)
							var m = [d, p],
								v = t.findNodeAtPosition(m),
								y = wbe(v)
							n.emit("changeToolbarState", { cursorPos: m, mdNode: v, toolbarState: y }),
								n.emit("setFocusedNode", v)
						}
					},
				}
			},
		})
	}
	var Cbe = (function (e) {
			Ve(t, e)
			function t() {
				return (e !== null && e.apply(this, arguments)) || this
			}
			return (
				Object.defineProperty(t.prototype, "name", {
					get: function () {
						return "doc"
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(t.prototype, "schema", {
					get: function () {
						return { content: "block+" }
					},
					enumerable: !1,
					configurable: !0,
				}),
				t
			)
		})(On),
		Bn = (function () {
			function e() {}
			return (
				Object.defineProperty(e.prototype, "type", {
					get: function () {
						return "mark"
					},
					enumerable: !1,
					configurable: !0,
				}),
				(e.prototype.setContext = function (t) {
					this.context = t
				}),
				e
			)
		})()
	function oa(e, t) {
		return Uu(e, t - 1)
	}
	function Uu(e, t) {
		return e.child(t).textContent
	}
	var Cm = /^\s*> ?/,
		Tbe = (function (e) {
			Ve(t, e)
			function t() {
				return (e !== null && e.apply(this, arguments)) || this
			}
			return (
				Object.defineProperty(t.prototype, "name", {
					get: function () {
						return "blockQuote"
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(t.prototype, "schema", {
					get: function () {
						return {
							toDOM: function () {
								return ["span", { class: yr("block-quote") }, 0]
							},
						}
					},
					enumerable: !1,
					configurable: !0,
				}),
				(t.prototype.createBlockQuoteText = function (n, r) {
					return r ? n.replace(Cm, "").trim() : "> " + n.trim()
				}),
				(t.prototype.extendBlockQuote = function () {
					var n = this
					return function (r, i) {
						var a = r.selection,
							o = r.doc,
							s = r.tr,
							l = r.schema,
							u = vr(a),
							d = u.endFromOffset,
							p = u.endToOffset,
							m = u.endIndex,
							v = u.to,
							y = Uu(o, m),
							b = Cm.test(y)
						if (b && v > d && a.empty) {
							var x = !y.replace(Cm, "").trim()
							if (x) s.deleteRange(d, p).split(s.mapping.map(p))
							else {
								var E = y.slice(v - d).trim(),
									T = zr(l, n.createBlockQuoteText(E))
								VO(s, p, E, T)
							}
							return i(s), !0
						}
						return !1
					}
				}),
				(t.prototype.commands = function () {
					var n = this
					return function () {
						return function (r, i) {
							var a = r.selection,
								o = r.doc,
								s = vr(a),
								l = s.startFromOffset,
								u = s.endToOffset,
								d = s.startIndex,
								p = s.endIndex,
								m = Cm.test(Uu(o, d)),
								v = bb({
									state: r,
									startIndex: d,
									endIndex: p,
									from: l,
									createText: function (y) {
										return n.createBlockQuoteText(y, m)
									},
								})
							return i(v.setSelection(Fn(v, v.mapping.map(u)))), !0
						}
					}
				}),
				(t.prototype.keymaps = function () {
					var n = this.commands()()
					return { "alt-q": n, "alt-Q": n, Enter: this.extendBlockQuote() }
				}),
				t
			)
		})(Bn),
		Ed = /(^\s*)([-*+] |[\d]+\. )/,
		ZO = /(^\s*)([\d])+\.( \[[ xX]])? /,
		fl = /^(\s*)((\d+)([.)]\s(?:\[(?:x|\s)\]\s)?))(.*)/,
		wb = /(^\s*)([-*+]|[\d]+\.)( \[[ xX]])? /,
		kbe = /^(\s*)([-*+]+(\s(?:\[(?:x|\s)\]\s)?))(.*)/,
		Sbe = /(^\s*)([-*+] |[\d]+\. )(\[[ xX]] )/,
		Dbe = /(^\s*)([-*+])( \[[ xX]]) /
	function eA(e) {
		return ZO.test(e) ? "ordered" : "bullet"
	}
	function tA(e) {
		for (var t = 0; e && e.type !== "document"; ) e.type === "list" && (t += 1), (e = e.parent)
		return t
	}
	function F2(e, t, n, r) {
		for (var i = e.getLineTexts(), a = i.length, o = [], s = t; r ? s < a : s > 1; ) {
			s = r ? s + 1 : s - 1
			var l = e.findFirstNodeAtLine(s),
				u = tA(l)
			if (u === n) o.push({ line: s, depth: n, mdNode: l })
			else if (u < n) break
		}
		return o
	}
	function _be(e) {
		var t = e.toastMark,
			n = e.mdNode,
			r = e.line,
			i = tA(n),
			a = F2(t, r, i, !1).reverse(),
			o = F2(t, r, i, !0)
		return a.concat([{ line: r, depth: i, mdNode: n }]).concat(o)
	}
	function Obe(e) {
		if (!Ed.test(e)) return "* " + e
		var t = eA(e)
		return (
			t === "bullet" && wb.test(e)
				? (e = e.replace(Dbe, "$1$2 "))
				: t === "ordered" && (e = e.replace(ZO, "$1* ")),
			e
		)
	}
	function Abe(e, t) {
		if (!Ed.test(e)) return t + ". " + e
		var n = eA(e)
		if (n === "bullet" || (n === "ordered" && wb.test(e))) e = e.replace(wb, "$1" + t + ". ")
		else if (n === "ordered") {
			var r = fl.exec(e)[3]
			Number(r) !== t && (e = e.replace(ZO, "$1" + t + ". "))
		}
		return e
	}
	function vz(e, t, n, r) {
		r === void 0 && (r = 0)
		var i = Number.MAX_VALUE,
			a = 0,
			o = t.map(function (s, l) {
				var u = s.line
				;(i = Math.min(u - 1, i)), (a = Math.max(u - 1, a))
				var d = oa(e, u)
				return (d = n === "bullet" ? Obe(d) : Abe(d, l + 1 + r)), { text: d, line: u }
			})
		return { changedResults: o, firstIndex: i, lastIndex: a }
	}
	function m4(e, t) {
		var n = _be(t)
		return vz(t.doc, n, e)
	}
	var Nbe = {
			bullet: function (e) {
				return m4("bullet", e)
			},
			ordered: function (e) {
				return m4("ordered", e)
			},
			task: function (e) {
				var t = e.mdNode,
					n = e.doc,
					r = e.line,
					i = oa(n, r)
				return (
					t.listData.task ? (i = i.replace(Sbe, "$1$2")) : bd(t) && (i = i.replace(Ed, "$1$2[ ] ")),
					{ changedResults: [{ text: i, line: r }] }
				)
			},
		},
		Mbe = {
			bullet: function (e) {
				var t = e.doc,
					n = e.line,
					r = oa(t, n),
					i = [{ text: "* " + r, line: n }]
				return { changedResults: i }
			},
			ordered: function (e) {
				for (
					var t = e.toastMark,
						n = e.doc,
						r = e.line,
						i = e.startLine,
						a = oa(n, r),
						o = 1,
						s = i,
						l = 0,
						u = i - 1;
					u > 0;
					u -= 1
				) {
					var d = t.findFirstNodeAtLine(u),
						p = oa(n, u),
						m =
							p &&
							!!gp(d, function (C) {
								return bd(C)
							}),
						v = fl.exec(oa(n, u))
					if (!v && !m) break
					if (!v && m) {
						l += 1
						continue
					}
					var y = v,
						b = y[1],
						x = y[3]
					if (!b) {
						;(o = Number(x)), (s = u)
						break
					}
				}
				var E = o + r - s - l,
					T = [{ text: E + ". " + a, line: r }]
				return { changedResults: T }
			},
			task: function (e) {
				var t = e.doc,
					n = e.line,
					r = oa(t, n),
					i = [{ text: "* [ ] " + r, line: n }]
				return { changedResults: i }
			},
		},
		Ibe = {
			bullet: function (e) {
				var t = e.line,
					n = e.doc,
					r = oa(n, t),
					i = kbe.exec(r),
					a = i[1],
					o = i[2]
				return { listSyntax: "" + a + o }
			},
			ordered: function (e) {
				var t = e.toastMark,
					n = e.line,
					r = e.mdNode,
					i = e.doc,
					a = tA(r),
					o = oa(i, n),
					s = fl.exec(o),
					l = s[1],
					u = s[3],
					d = s[4],
					p = Number(u) + 1,
					m = "" + l + p + d,
					v = F2(t, n, a, !0),
					y = v.filter(function (b) {
						var x = fl.exec(oa(i, b.line))
						return (
							x &&
							x[1].length === l.length &&
							!!gp(b.mdNode, function (E) {
								return qU(E)
							})
						)
					})
				return me({ listSyntax: m }, vz(i, y, "ordered", p))
			},
		}
	function gz(e, t, n, r, i) {
		for (var a = [], o = oa(e, n), s = fl.exec(o); s; ) {
			var l = s[1],
				u = s[4],
				d = s[5],
				p = l.length
			if (p === i) a.push(zr(t, "" + l + r + u + d)), (r += 1), (n += 1)
			else if (p > i) {
				var m = gz(e, t, n, 1, p)
				;(n = m.line), (a = a.concat(m.nodes))
			}
			if (p < i || n > e.childCount) break
			;(o = oa(e, n)), (s = fl.exec(o))
		}
		return { nodes: a, line: n }
	}
	var v4 = /(^\s{1,4})(.*)/
	function g4(e, t, n) {
		return e < t || Ed.test(n) || Cm.test(n)
	}
	function y4(e, t, n) {
		var r = n.$from
		r.depth === 0 && (r = e.resolve(r.pos - 1))
		var i = r.node(1),
			a = r.start(1),
			o = i.content.size
		return i.rangeHasMark(0, o, t.marks.table) && r.pos - a !== o && r.pos !== a
	}
	function b4(e, t) {
		var n = t.from,
			r = t.to
		if (t.type === "indent") {
			var i = 4
			;(n += i), (r += (t.lineLen + 1) * i)
		} else {
			var a = t.spaceLenList
			n -= a[0]
			for (var o = 0; o < a.length; o += 1) r -= a[o]
		}
		return Fn(e, n, r)
	}
	var Rbe = (function (e) {
			Ve(t, e)
			function t() {
				return (e !== null && e.apply(this, arguments)) || this
			}
			return (
				Object.defineProperty(t.prototype, "name", {
					get: function () {
						return "paragraph"
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(t.prototype, "schema", {
					get: function () {
						return {
							content: "inline*",
							attrs: {
								className: { default: null },
								codeStart: { default: null },
								codeEnd: { default: null },
							},
							selectable: !1,
							group: "block",
							parseDOM: [{ tag: "div" }],
							toDOM: function (n) {
								var r = n.attrs
								return r.className ? ["div", { class: yr(r.className) }, 0] : ["div", 0]
							},
						}
					},
					enumerable: !1,
					configurable: !0,
				}),
				(t.prototype.reorderList = function (n, r) {
					for (
						var i = this.context,
							a = i.view,
							o = i.toastMark,
							s = i.schema,
							l = a.state,
							u = l.tr,
							d = l.selection,
							p = l.doc,
							m = o.findFirstNodeAtLine(n),
							v = m;
						m && !l1e(m) && m.parent.type !== "document";

					)
						if (((m = m.parent), qU(m))) {
							v = m
							break
						}
					v && (n = v.sourcepos[0][0])
					var y = fl.exec(oa(p, n)),
						b = y[1],
						x = y[3],
						E = b.length,
						T = gz(p, s, n, Number(x), E),
						C = T.line,
						D = T.nodes
					r = Math.max(r, C - 1)
					for (var O = xb(p, n - 1).startOffset, A = n - 1; A <= r - 1; A += 1) {
						var N = p.child(A),
							I = N.nodeSize,
							P = N.content,
							L = u.mapping.map(O),
							B = L + P.size
						u.replaceWith(L, B, D[A - n + 1]), (O += I)
					}
					var z = Fn(u, d.from, d.to)
					a.dispatch(u.setSelection(z))
				}),
				(t.prototype.indent = function (n) {
					var r = this
					return (
						n === void 0 && (n = !1),
						function () {
							return function (i, a) {
								var o = i.schema,
									s = i.selection,
									l = i.doc,
									u = vr(s),
									d = u.from,
									p = u.to,
									m = u.startFromOffset,
									v = u.startIndex,
									y = u.endIndex
								if (n && y4(l, o, s)) return !1
								var b = Uu(l, v)
								if ((n && g4(d, p, b)) || (!n && Ed.test(b))) {
									var x = bb({
											state: i,
											from: m,
											startIndex: v,
											endIndex: y,
											createText: function (T) {
												return "    " + T
											},
										}),
										E = { type: "indent", from: d, to: p, lineLen: y - v }
									a(x.setSelection(b4(x, E))), fl.test(b) && r.reorderList(v + 1, y + 1)
								} else n && a(i.tr.insert(p, zr(o, "    ")))
								return !0
							}
						}
					)
				}),
				(t.prototype.outdent = function (n) {
					var r = this
					return (
						n === void 0 && (n = !1),
						function () {
							return function (i, a) {
								var o = i.selection,
									s = i.doc,
									l = i.schema,
									u = vr(o),
									d = u.from,
									p = u.to,
									m = u.startFromOffset,
									v = u.startIndex,
									y = u.endIndex
								if (n && y4(s, l, o)) return !1
								var b = Uu(s, v)
								if ((n && g4(d, p, b)) || (!n && Ed.test(b))) {
									var x = [],
										E = bb({
											state: i,
											from: m,
											startIndex: v,
											endIndex: y,
											createText: function (A) {
												var N = v4.exec(A)
												return x.push(N ? N[1].length : 0), A.replace(v4, "$2")
											},
										}),
										T = { type: "outdent", from: d, to: p, spaceLenList: x }
									a(E.setSelection(b4(E, T))), fl.test(b) && r.reorderList(v + 1, y + 1)
								} else if (n) {
									var C = b.slice(0, p - m),
										D = C.replace(/\s{1,4}$/, ""),
										O = p - (C.length - D.length)
									a(i.tr.delete(O, p))
								}
								return !0
							}
						}
					)
				}),
				(t.prototype.deleteLines = function () {
					var n = this
					return function (r, i) {
						var a = n.context.view,
							o = vr(r.selection),
							s = o.startFromOffset,
							l = o.endToOffset,
							u = function () {
								return i(r.tr.deleteRange(s, l)), !0
							}
						return aw(u, OU)(r, i, a)
					}
				}),
				(t.prototype.moveDown = function () {
					return function (n, r) {
						var i = n.doc,
							a = n.tr,
							o = n.selection,
							s = n.schema,
							l = vr(o),
							u = l.startFromOffset,
							d = l.endToOffset,
							p = l.endIndex
						if (p < i.content.childCount - 1) {
							var m = i.child(p + 1),
								v = m.nodeSize,
								y = m.textContent
							return (
								a
									.delete(d, d + v)
									.split(u)
									.insert(a.mapping.map(u) - 2, zr(s, y)),
								r(a),
								!0
							)
						}
						return !1
					}
				}),
				(t.prototype.moveUp = function () {
					return function (n, r) {
						var i = n.tr,
							a = n.doc,
							o = n.selection,
							s = n.schema,
							l = vr(o),
							u = l.startFromOffset,
							d = l.endToOffset,
							p = l.startIndex
						if (p > 0) {
							var m = a.child(p - 1),
								v = m.nodeSize,
								y = m.textContent
							return (
								i
									.delete(u - v, u)
									.split(i.mapping.map(d))
									.insert(i.mapping.map(d), zr(s, y)),
								r(i),
								!0
							)
						}
						return !1
					}
				}),
				(t.prototype.commands = function () {
					return { indent: this.indent(), outdent: this.outdent() }
				}),
				(t.prototype.keymaps = function () {
					return {
						Tab: this.indent(!0)(),
						"Shift-Tab": this.outdent(!0)(),
						"Mod-d": this.deleteLines(),
						"Mod-D": this.deleteLines(),
						"Alt-ArrowUp": this.moveUp(),
						"Alt-ArrowDown": this.moveDown(),
					}
				}),
				t
			)
		})(On),
		Lbe = (function (e) {
			Ve(t, e)
			function t() {
				return (e !== null && e.apply(this, arguments)) || this
			}
			return (
				Object.defineProperty(t.prototype, "name", {
					get: function () {
						return "text"
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(t.prototype, "schema", {
					get: function () {
						return { group: "inline" }
					},
					enumerable: !1,
					configurable: !0,
				}),
				t
			)
		})(On),
		Pbe = /^#{1,6}\s/,
		jbe = (function (e) {
			Ve(t, e)
			function t() {
				return (e !== null && e.apply(this, arguments)) || this
			}
			return (
				Object.defineProperty(t.prototype, "name", {
					get: function () {
						return "heading"
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(t.prototype, "schema", {
					get: function () {
						return {
							attrs: { level: { default: 1 }, seText: { default: !1 } },
							toDOM: function (n) {
								var r = n.attrs,
									i = r.level,
									a = r.seText,
									o = "heading|heading" + i
								return (
									a && (o += "|delimiter|setext"),
									["span", { class: yr.apply(void 0, o.split("|")) }, 0]
								)
							},
						}
					},
					enumerable: !1,
					configurable: !0,
				}),
				(t.prototype.createHeadingText = function (n, r, i) {
					for (var a = r.replace(i, "").trim(), o = ""; n > 0; ) (o += "#"), (n -= 1)
					return o + " " + a
				}),
				(t.prototype.commands = function () {
					var n = this
					return function (r) {
						return function (i, a) {
							var o = r.level,
								s = vr(i.selection),
								l = s.startFromOffset,
								u = s.endToOffset,
								d = s.startIndex,
								p = s.endIndex,
								m = bb({
									state: i,
									from: l,
									startIndex: d,
									endIndex: p,
									createText: function (v) {
										var y = v.match(Pbe),
											b = y ? y[0] : ""
										return n.createHeadingText(o, v, b)
									},
								})
							return a(m.setSelection(Fn(m, m.mapping.map(u)))), !0
						}
					}
				}),
				t
			)
		})(Bn),
		yk = "```",
		Fbe = (function (e) {
			Ve(t, e)
			function t() {
				return (e !== null && e.apply(this, arguments)) || this
			}
			return (
				Object.defineProperty(t.prototype, "name", {
					get: function () {
						return "codeBlock"
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(t.prototype, "schema", {
					get: function () {
						return {
							toDOM: function () {
								return ["span", { class: yr("code-block") }, 0]
							},
						}
					},
					enumerable: !1,
					configurable: !0,
				}),
				(t.prototype.commands = function () {
					return function () {
						return function (n, r) {
							var i = n.selection,
								a = n.schema,
								o = n.tr,
								s = vr(i),
								l = s.startFromOffset,
								u = s.endToOffset,
								d = zr(a, yk)
							return (
								o.insert(l, d).split(l + yk.length),
								o.split(o.mapping.map(u)).insert(o.mapping.map(u), d),
								r(o.setSelection(Fn(o, o.mapping.map(u) - (yk.length + 2)))),
								!0
							)
						}
					}
				}),
				(t.prototype.keepIndentation = function () {
					var n = this
					return function (r, i) {
						var a = r.selection,
							o = r.tr,
							s = r.doc,
							l = r.schema,
							u = n.context.toastMark,
							d = vr(a),
							p = d.startFromOffset,
							m = d.endToOffset,
							v = d.endIndex,
							y = d.from,
							b = d.to,
							x = Uu(s, v)
						if (y === b && x.trim()) {
							var E = x.match(/^\s+/),
								T = u.findFirstNodeAtLine(v + 1)
							if (s1e(T) && E) {
								var C = E[0],
									D = x.slice(b - p),
									O = zr(l, C + D)
								return VO(o, m, D, O), i(o), !0
							}
						}
						return !1
					}
				}),
				(t.prototype.keymaps = function () {
					var n = this.commands()()
					return { "Shift-Mod-p": n, "Shift-Mod-P": n, Enter: this.keepIndentation() }
				}),
				t
			)
		})(Bn),
		Bbe = /\||\s/g
	function Hbe(e) {
		return [Eb(e), Eb(e, !0)]
	}
	function $be(e, t) {
		for (var n = [], r = 0; r < t; r += 1) n.push(Eb(e))
		return n
	}
	function Eb(e, t) {
		for (var n = "|", r = 0; r < e; r += 1) n += t ? " --- |" : "  |"
		return n
	}
	function Ube(e) {
		return e
			? { type: "next", parentType: "tableHead", childType: "firstChild" }
			: { type: "prev", parentType: "tableBody", childType: "lastChild" }
	}
	var zbe = (function (e) {
			Ve(t, e)
			function t() {
				return (e !== null && e.apply(this, arguments)) || this
			}
			return (
				Object.defineProperty(t.prototype, "name", {
					get: function () {
						return "table"
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(t.prototype, "schema", {
					get: function () {
						return {
							toDOM: function () {
								return ["span", { class: yr("table") }, 0]
							},
						}
					},
					enumerable: !1,
					configurable: !0,
				}),
				(t.prototype.extendTable = function () {
					var n = this
					return function (r, i) {
						var a = r.selection,
							o = r.doc,
							s = r.tr,
							l = r.schema
						if (!a.empty) return !1
						var u = vr(a),
							d = u.endFromOffset,
							p = u.endToOffset,
							m = u.endIndex,
							v = u.to,
							y = Uu(o, m),
							b = [m + 1, v - d + 1],
							x = n.context.toastMark.findNodeAtPosition(b),
							E = gp(x, function (A) {
								return (
									s4(A) &&
									(A.parent.type === "tableDelimRow" || A.parent.parent.type === "tableBody")
								)
							})
						if (E) {
							var T = !y.replace(Bbe, "").trim(),
								C = E.parent,
								D = C.parent.parent.columns.length,
								O = Eb(D)
							return (
								T
									? s.deleteRange(d, p).split(s.mapping.map(p))
									: s
											.split(p)
											.insert(s.mapping.map(p), zr(l, O))
											.setSelection(Fn(s, s.mapping.map(p) - 2)),
								i(s),
								!0
							)
						}
						return !1
					}
				}),
				(t.prototype.moveTableCell = function (n) {
					var r = this
					return function (i, a) {
						var o = i.selection,
							s = i.tr,
							l = vr(o),
							u = l.endFromOffset,
							d = l.endIndex,
							p = l.to,
							m = [d + 1, p - u],
							v = r.context.toastMark.findNodeAtPosition(m),
							y = gp(v, function (N) {
								return s4(N)
							})
						if (y) {
							var b = y.parent,
								x = Ube(n),
								E = x.type,
								T = x.parentType,
								C = x.childType,
								D = Du(y)
							if (y[E]) D = Du(y[E]) - 1
							else {
								var O = !b[E] && b.parent.type === T ? b.parent[E][C] : b[E]
								if (E === "next") {
									var A = O ? Du(O[C]) : 0
									D += A + 2
								} else E === "prev" && (D = O ? -4 : 0)
							}
							return a(s.setSelection(Fn(s, u + D))), !0
						}
						return !1
					}
				}),
				(t.prototype.addTable = function () {
					return function (n) {
						return function (r, i) {
							var a = r.selection,
								o = r.tr,
								s = r.schema,
								l = n,
								u = l.columnCount,
								d = l.rowCount,
								p = vr(a).endToOffset,
								m = Hbe(u),
								v = $be(u, d - 1),
								y = Gi(Gi([], m), v)
							return (
								y.forEach(function (b) {
									o.split(o.mapping.map(p)).insert(o.mapping.map(p), zr(s, b))
								}),
								i(o.setSelection(Fn(o, p + 4))),
								!0
							)
						}
					}
				}),
				(t.prototype.commands = function () {
					return { addTable: this.addTable() }
				}),
				(t.prototype.keymaps = function () {
					return {
						Enter: this.extendTable(),
						Tab: this.moveTableCell(!0),
						"Shift-Tab": this.moveTableCell(!1),
					}
				}),
				t
			)
		})(Bn),
		qbe = "***",
		Vbe = (function (e) {
			Ve(t, e)
			function t() {
				return (e !== null && e.apply(this, arguments)) || this
			}
			return (
				Object.defineProperty(t.prototype, "name", {
					get: function () {
						return "thematicBreak"
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(t.prototype, "schema", {
					get: function () {
						return {
							toDOM: function () {
								return ["span", { class: yr("thematic-break") }, 0]
							},
						}
					},
					enumerable: !1,
					configurable: !0,
				}),
				(t.prototype.hr = function () {
					return function () {
						return function (n, r) {
							var i = n.selection,
								a = n.schema,
								o = n.tr,
								s = vr(i),
								l = s.from,
								u = s.to,
								d = s.endToOffset,
								p = zr(a, qbe)
							return (
								o
									.split(l)
									.replaceWith(o.mapping.map(l), o.mapping.map(u), p)
									.split(o.mapping.map(u))
									.setSelection(Fn(o, o.mapping.map(d))),
								r(o),
								!0
							)
						}
					}
				}),
				(t.prototype.commands = function () {
					return { hr: this.hr() }
				}),
				(t.prototype.keymaps = function () {
					var n = this.hr()()
					return { "Mod-l": n, "Mod-L": n }
				}),
				t
			)
		})(Bn)
	function Wbe(e, t) {
		var n = e.type,
			r = e.sourcepos,
			i = r[0][0]
		return t <= i && (n === "codeBlock" || n === "heading" || n.match("table"))
	}
	var Ybe = (function (e) {
		Ve(t, e)
		function t() {
			return (e !== null && e.apply(this, arguments)) || this
		}
		return (
			Object.defineProperty(t.prototype, "name", {
				get: function () {
					return "listItem"
				},
				enumerable: !1,
				configurable: !0,
			}),
			Object.defineProperty(t.prototype, "schema", {
				get: function () {
					return {
						attrs: { odd: { default: !1 }, even: { default: !1 }, listStyle: { default: !1 } },
						toDOM: function (n) {
							var r = n.attrs,
								i = r.odd,
								a = r.even,
								o = r.listStyle,
								s = "list-item"
							return (
								o && (s += "|list-item-style"),
								i && (s += "|list-item-odd"),
								a && (s += "|list-item-even"),
								["span", { class: yr.apply(void 0, s.split("|")) }, 0]
							)
						},
					}
				},
				enumerable: !1,
				configurable: !0,
			}),
			(t.prototype.extendList = function () {
				var n = this
				return function (r, i) {
					var a = r.selection,
						o = r.doc,
						s = r.schema,
						l = r.tr,
						u = n.context.toastMark,
						d = vr(a),
						p = d.to,
						m = d.startFromOffset,
						v = d.endFromOffset,
						y = d.endIndex,
						b = d.endToOffset,
						x = Uu(o, y),
						E = Ed.test(x)
					if (!E || a.from === m || !a.empty) return !1
					var T = !x.replace(wb, "").trim()
					if (T) l.deleteRange(v, b).split(l.mapping.map(b))
					else {
						var C = eA(x),
							D = u.findFirstNodeAtLine(y + 1),
							O = x.slice(p - v),
							A = { toastMark: u, mdNode: D, doc: o, line: y + 1 },
							N = Ibe[C](A),
							I = N.listSyntax,
							P = N.changedResults
						if (P != null && P.length) {
							l.split(p),
								P.unshift({ text: I + O, line: y + 1 }),
								n.changeToListPerLine(l, P, { from: p, startLine: P[0].line, endLine: ni(P).line })
							var L = l.mapping.map(b) - O.length
							l.setSelection(Fn(l, L))
						} else {
							var B = zr(s, I + O)
							VO(l, b, O, B)
						}
					}
					return i(l), !0
				}
			}),
			(t.prototype.toList = function (n) {
				var r = this
				return function () {
					return function (i, a) {
						for (
							var o = i.doc,
								s = i.tr,
								l = i.selection,
								u = r.context.toastMark,
								d = vr(l),
								p = d.startIndex + 1,
								m = d.endIndex + 1,
								v = d.endToOffset,
								y = [],
								b = p;
							b <= m;
							b += 1
						) {
							var x = u.findFirstNodeAtLine(b)
							if (x && Wbe(x, b)) break
							if (y.indexOf(b) === -1) {
								var E = { toastMark: u, mdNode: x, doc: o, line: b, startLine: p },
									T = (bd(x) ? Nbe[n](E) : Mbe[n](E)).changedResults,
									C = r.changeToListPerLine(s, T, {
										from: xb(o, T[0].line - 1).startOffset,
										startLine: T[0].line,
										endLine: ni(T).line,
										indexDiff: 1,
									})
								;(v = Math.max(C, v)),
									T &&
										(y = y.concat(
											T.map(function (D) {
												return D.line
											}),
										))
							}
						}
						return a(s.setSelection(Fn(s, s.mapping.map(v)))), !0
					}
				}
			}),
			(t.prototype.changeToListPerLine = function (n, r, i) {
				for (
					var a = i.from,
						o = i.startLine,
						s = i.endLine,
						l = i.indexDiff,
						u = l === void 0 ? 0 : l,
						d = 0,
						p = function (y) {
							var b = n.doc.child(y),
								x = b.nodeSize,
								E = b.content,
								T = n.mapping.map(a),
								C = T + E.size,
								D = r.filter(function (O) {
									return O.line - u === y
								})[0]
							D &&
								(n.replaceWith(T, C, zr(m.context.schema, D.text)), (d = Math.max(d, a + E.size))),
								(a += x)
						},
						m = this,
						v = o - u;
					v <= s - u;
					v += 1
				)
					p(v)
				return d
			}),
			(t.prototype.toggleTask = function () {
				var n = this
				return function (r, i) {
					for (
						var a = r.selection,
							o = r.tr,
							s = r.doc,
							l = r.schema,
							u = n.context.toastMark,
							d = vr(a),
							p = d.startIndex,
							m = d.endIndex,
							v = null,
							y = p;
						y <= m;
						y += 1
					) {
						var b = u.findFirstNodeAtLine(y + 1)
						if (bd(b) && b.listData.task) {
							var x = b.listData,
								E = x.checked,
								T = x.padding,
								C = E ? " " : "x",
								D = b.sourcepos[0],
								O = xb(s, D[0] - 1).startOffset
							;(O += D[1] + T), (v = o.replaceWith(O, O + 1, l.text(C)))
						}
					}
					return v ? (i(v), !0) : !1
				}
			}),
			(t.prototype.commands = function () {
				return {
					bulletList: this.toList("bullet"),
					orderedList: this.toList("ordered"),
					taskList: this.toList("task"),
				}
			}),
			(t.prototype.keymaps = function () {
				var n = this.toList("bullet")(),
					r = this.toList("ordered")(),
					i = this.toList("task")(),
					a = this.toggleTask()
				return {
					"Mod-u": n,
					"Mod-U": n,
					"Mod-o": r,
					"Mod-O": r,
					"alt-t": i,
					"alt-T": i,
					"Shift-Ctrl-x": a,
					"Shift-Ctrl-X": a,
					Enter: this.extendList(),
				}
			}),
			t
		)
	})(Bn)
	function fw(e, t) {
		return function () {
			return function (n, r) {
				var i = n.tr,
					a = n.selection,
					o = Ka(e)
						? e
						: function (C) {
								return e.test(C)
						  },
					s = t.length,
					l = i.doc,
					u = dz(a),
					d = u[0],
					p = u[1],
					m = Math.max(d - s, 1),
					v = Math.min(p + s, l.content.size - 1),
					y = a.content(),
					b = y.content.textBetween(
						0,
						y.content.size,
						`
`,
					),
					x = l.textBetween(
						m,
						d,
						`
`,
					),
					E = l.textBetween(
						p,
						v,
						`
`,
					)
				if (((b = "" + x + b + E), x && E && o(b))) i.delete(v - s, v).delete(m, m + s)
				else {
					i.insertText(t, p).insertText(t, d)
					var T = a.empty ? Fn(i, d + s) : Fn(i, d + s, p + s)
					i.setSelection(T)
				}
				return r(i), !0
			}
		}
	}
	var Gbe = /^(\*{2}|_{2}).*([\s\S]*)\1$/m,
		Kbe = "**",
		Qbe = (function (e) {
			Ve(t, e)
			function t() {
				return (e !== null && e.apply(this, arguments)) || this
			}
			return (
				Object.defineProperty(t.prototype, "name", {
					get: function () {
						return "strong"
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(t.prototype, "schema", {
					get: function () {
						return {
							toDOM: function () {
								return ["span", { class: yr("strong") }, 0]
							},
						}
					},
					enumerable: !1,
					configurable: !0,
				}),
				(t.prototype.bold = function () {
					return fw(Gbe, Kbe)
				}),
				(t.prototype.commands = function () {
					return { bold: this.bold() }
				}),
				(t.prototype.keymaps = function () {
					var n = this.bold()()
					return { "Mod-b": n, "Mod-B": n }
				}),
				t
			)
		})(Bn),
		Xbe = /^(~{2}).*([\s\S]*)\1$/m,
		Jbe = "~~",
		Zbe = (function (e) {
			Ve(t, e)
			function t() {
				return (e !== null && e.apply(this, arguments)) || this
			}
			return (
				Object.defineProperty(t.prototype, "name", {
					get: function () {
						return "strike"
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(t.prototype, "schema", {
					get: function () {
						return {
							toDOM: function () {
								return ["span", { class: yr("strike") }, 0]
							},
						}
					},
					enumerable: !1,
					configurable: !0,
				}),
				(t.prototype.commands = function () {
					return fw(Xbe, Jbe)
				}),
				(t.prototype.keymaps = function () {
					var n = this.commands()()
					return { "Mod-s": n, "Mod-S": n }
				}),
				t
			)
		})(Bn),
		exe = /^(\*|_).*([\s\S]*)\1$/m,
		txe = "*",
		nxe = (function (e) {
			Ve(t, e)
			function t() {
				return (e !== null && e.apply(this, arguments)) || this
			}
			return (
				Object.defineProperty(t.prototype, "name", {
					get: function () {
						return "emph"
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(t.prototype, "schema", {
					get: function () {
						return {
							toDOM: function () {
								return ["span", { class: yr("emph") }, 0]
							},
						}
					},
					enumerable: !1,
					configurable: !0,
				}),
				(t.prototype.italic = function () {
					return fw(exe, txe)
				}),
				(t.prototype.commands = function () {
					return { italic: this.italic() }
				}),
				(t.prototype.keymaps = function () {
					var n = this.italic()()
					return { "Mod-i": n, "Mod-I": n }
				}),
				t
			)
		})(Bn),
		rxe = /^(`).*([\s\S]*)\1$/m,
		ixe = "`",
		axe = (function (e) {
			Ve(t, e)
			function t() {
				return (e !== null && e.apply(this, arguments)) || this
			}
			return (
				Object.defineProperty(t.prototype, "name", {
					get: function () {
						return "code"
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(t.prototype, "schema", {
					get: function () {
						return {
							attrs: { start: { default: !1 }, end: { default: !1 }, marked: { default: !1 } },
							toDOM: function (n) {
								var r = n.attrs,
									i = r.start,
									a = r.end,
									o = r.marked,
									s = "code"
								return (
									i && (s += "|delimiter|start"),
									a && (s += "|delimiter|end"),
									o && (s += "|marked-text"),
									["span", { class: yr.apply(void 0, s.split("|")) }, 0]
								)
							},
						}
					},
					enumerable: !1,
					configurable: !0,
				}),
				(t.prototype.commands = function () {
					return fw(rxe, ixe)
				}),
				(t.prototype.keymaps = function () {
					var n = this.commands()()
					return { "Shift-Mod-c": n, "Shift-Mod-C": n }
				}),
				t
			)
		})(Bn),
		oxe = (function (e) {
			Ve(t, e)
			function t() {
				return (e !== null && e.apply(this, arguments)) || this
			}
			return (
				Object.defineProperty(t.prototype, "name", {
					get: function () {
						return "link"
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(t.prototype, "schema", {
					get: function () {
						return {
							attrs: { url: { default: !1 }, desc: { default: !1 } },
							toDOM: function (n) {
								var r = n.attrs,
									i = r.url,
									a = r.desc,
									o = "link"
								return (
									i && (o += "|link-url|marked-text"),
									a && (o += "|link-desc|marked-text"),
									["span", { class: yr.apply(void 0, o.split("|")) }, 0]
								)
							},
						}
					},
					enumerable: !1,
					configurable: !0,
				}),
				(t.prototype.addLinkOrImage = function (n) {
					return function (r) {
						return function (i, a) {
							var o = i.selection,
								s = i.tr,
								l = i.schema,
								u = dz(o),
								d = u[0],
								p = u[1],
								m = r,
								v = m.linkText,
								y = m.altText,
								b = m.linkUrl,
								x = m.imageUrl,
								E = v,
								T = b,
								C = ""
							return (
								n === "image" && ((E = y), (T = x), (C = "!")),
								(E = vb(E)),
								(C += "[" + E + "](" + T + ")"),
								a(s.replaceWith(d, p, zr(l, C))),
								!0
							)
						}
					}
				}),
				(t.prototype.commands = function () {
					return { addImage: this.addLinkOrImage("image"), addLink: this.addLinkOrImage("link") }
				}),
				t
			)
		})(Bn),
		sxe = (function (e) {
			Ve(t, e)
			function t() {
				return (e !== null && e.apply(this, arguments)) || this
			}
			return (
				Object.defineProperty(t.prototype, "name", {
					get: function () {
						return "taskDelimiter"
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(t.prototype, "schema", {
					get: function () {
						return {
							toDOM: function () {
								return ["span", { class: yr("delimiter", "list-item") }, 0]
							},
						}
					},
					enumerable: !1,
					configurable: !0,
				}),
				t
			)
		})(Bn),
		lxe = (function (e) {
			Ve(t, e)
			function t() {
				return (e !== null && e.apply(this, arguments)) || this
			}
			return (
				Object.defineProperty(t.prototype, "name", {
					get: function () {
						return "delimiter"
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(t.prototype, "schema", {
					get: function () {
						return {
							toDOM: function () {
								return ["span", { class: yr("delimiter") }, 0]
							},
						}
					},
					enumerable: !1,
					configurable: !0,
				}),
				t
			)
		})(Bn),
		uxe = (function (e) {
			Ve(t, e)
			function t() {
				return (e !== null && e.apply(this, arguments)) || this
			}
			return (
				Object.defineProperty(t.prototype, "name", {
					get: function () {
						return "meta"
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(t.prototype, "schema", {
					get: function () {
						return {
							toDOM: function () {
								return ["span", { class: yr("meta") }, 0]
							},
						}
					},
					enumerable: !1,
					configurable: !0,
				}),
				t
			)
		})(Bn),
		cxe = (function (e) {
			Ve(t, e)
			function t() {
				return (e !== null && e.apply(this, arguments)) || this
			}
			return (
				Object.defineProperty(t.prototype, "name", {
					get: function () {
						return "markedText"
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(t.prototype, "schema", {
					get: function () {
						return {
							toDOM: function () {
								return ["span", { class: yr("marked-text") }, 0]
							},
						}
					},
					enumerable: !1,
					configurable: !0,
				}),
				t
			)
		})(Bn),
		dxe = (function (e) {
			Ve(t, e)
			function t() {
				return (e !== null && e.apply(this, arguments)) || this
			}
			return (
				Object.defineProperty(t.prototype, "name", {
					get: function () {
						return "tableCell"
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(t.prototype, "schema", {
					get: function () {
						return {
							toDOM: function () {
								return ["span", { class: yr("table-cell") }, 0]
							},
						}
					},
					enumerable: !1,
					configurable: !0,
				}),
				t
			)
		})(Bn),
		fxe = (function (e) {
			Ve(t, e)
			function t() {
				return (e !== null && e.apply(this, arguments)) || this
			}
			return (
				Object.defineProperty(t.prototype, "name", {
					get: function () {
						return "html"
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(t.prototype, "schema", {
					get: function () {
						return {
							toDOM: function () {
								return ["span", { class: yr("html") }, 0]
							},
						}
					},
					enumerable: !1,
					configurable: !0,
				}),
				t
			)
		})(Bn),
		bk = "$$",
		pxe = (function (e) {
			Ve(t, e)
			function t() {
				return (e !== null && e.apply(this, arguments)) || this
			}
			return (
				Object.defineProperty(t.prototype, "name", {
					get: function () {
						return "customBlock"
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(t.prototype, "schema", {
					get: function () {
						return {
							toDOM: function () {
								return ["span", { class: yr("custom-block") }, 0]
							},
						}
					},
					enumerable: !1,
					configurable: !0,
				}),
				(t.prototype.commands = function () {
					return function (n) {
						return function (r, i) {
							var a = r.selection,
								o = r.schema,
								s = r.tr,
								l = vr(a),
								u = l.startFromOffset,
								d = l.endToOffset
							if (!(n != null && n.info)) return !1
							var p = "" + bk + n.info,
								m = zr(o, p),
								v = zr(o, bk)
							return (
								s.insert(u, m).split(u + p.length),
								s.split(s.mapping.map(d)).insert(s.mapping.map(d), v),
								i(s.setSelection(Fn(s, s.mapping.map(d) - (bk.length + 2)))),
								!0
							)
						}
					}
				}),
				t
			)
		})(Bn),
		hxe = /x|backspace/i,
		mxe = /^\[(\s*)(x?)(\s*)\](?:\s+)/i
	function vxe(e) {
		var t = e.schema,
			n = e.toastMark
		return new Ki({
			props: {
				handleDOMEvents: {
					keyup: function (r, i) {
						var a,
							o = r.state,
							s = o.doc,
							l = o.tr,
							u = o.selection
						if (u.empty && hxe.test(i.key)) {
							var d = vr(u),
								p = d.startIndex,
								m = d.startFromOffset,
								v = d.from,
								y = [p + 1, v - m + 1],
								b = n.findNodeAtPosition(y),
								x = gp(b, function (B) {
									var z
									return (
										B.type === "paragraph" &&
										((z = B.parent) === null || z === void 0 ? void 0 : z.type) === "item"
									)
								})
							if (
								!((a = x == null ? void 0 : x.firstChild) === null || a === void 0) &&
								a.literal
							) {
								var E = x.firstChild,
									T = E.literal.match(mxe)
								if (T) {
									var C = E.sourcepos[0],
										D = T[1],
										O = T[2],
										A = T[3],
										N = D.length + A.length,
										I = xb(s, C[0] - 1).startOffset,
										P = C[1] + I
									if (O) {
										var L = N ? N + 1 : 0
										l.replaceWith(P, L + P, t.text(O)), r.dispatch(l)
									} else N || (l.insertText(" ", P), r.dispatch(l))
								}
							}
						}
						return !1
					},
				},
			},
		})
	}
	var xk = "cut",
		x4 = /\r\n|\n|\r/,
		gxe = (function (e) {
			Ve(t, e)
			function t(n, r) {
				var i = e.call(this, n) || this,
					a = r.toastMark,
					o = r.useCommandShortcut,
					s = o === void 0 ? !0 : o,
					l = r.mdPlugins,
					u = l === void 0 ? [] : l
				return (
					(i.editorType = "markdown"),
					i.el.classList.add("md-mode"),
					(i.toastMark = a),
					(i.extraPlugins = u),
					(i.specs = i.createSpecs()),
					(i.schema = i.createSchema()),
					(i.context = i.createContext()),
					(i.keymaps = i.createKeymaps(s)),
					(i.view = i.createView()),
					(i.commands = i.createCommands()),
					i.specs.setContext(me(me({}, i.context), { view: i.view })),
					i.createClipboard(),
					i.eventEmitter.listen("changePreviewTabWrite", function (d) {
						return i.toggleActive(!0, d)
					}),
					i.eventEmitter.listen("changePreviewTabPreview", function () {
						return i.toggleActive(!1)
					}),
					i.initEvent(),
					i
				)
			}
			return (
				(t.prototype.toggleActive = function (n, r) {
					YO(this.el, "active", n), n ? r || this.focus() : this.blur()
				}),
				(t.prototype.createClipboard = function () {
					var n = this
					;(this.clipboard = document.createElement("textarea")),
						(this.clipboard.className = Qe("pseudo-clipboard")),
						this.clipboard.addEventListener("paste", function (r) {
							var i = r.clipboardData || window.clipboardData,
								a = i && i.items
							if (a) {
								var o = Ds(a).some(function (l) {
									return l.kind === "string" && l.type === "text/rtf"
								})
								if (!o) {
									var s = oz(a)
									s && (r.preventDefault(), XO(n.eventEmitter, s, r.type))
								}
							}
						}),
						this.clipboard.addEventListener("input", function (r) {
							var i = r.target.value
							n.replaceSelection(i), r.preventDefault(), (r.target.value = "")
						}),
						this.el.insertBefore(this.clipboard, this.view.dom)
				}),
				(t.prototype.createContext = function () {
					return { toastMark: this.toastMark, schema: this.schema, eventEmitter: this.eventEmitter }
				}),
				(t.prototype.createSpecs = function () {
					return new cz([
						new Cbe(),
						new Rbe(),
						new lz(),
						new Lbe(),
						new jbe(),
						new Tbe(),
						new Fbe(),
						new pxe(),
						new zbe(),
						new dxe(),
						new Vbe(),
						new Ybe(),
						new Qbe(),
						new Zbe(),
						new nxe(),
						new axe(),
						new oxe(),
						new lxe(),
						new sxe(),
						new cxe(),
						new uxe(),
						new fxe(),
					])
				}),
				(t.prototype.createPlugins = function () {
					return Gi(
						[dbe(this.context), Ebe(this.context), vxe(this.context)],
						this.createPluginProps(),
					).concat(this.defaultPlugins)
				}),
				(t.prototype.createView = function () {
					var n = this
					return new NO(this.el, {
						state: this.createState(),
						dispatchTransaction: function (r) {
							n.updateMarkdown(r)
							var i = n.view.state.applyTransaction(r).state
							n.view.updateState(i), n.emitChangeEvent(r)
						},
						handleKeyDown: function (r, i) {
							return (
								(i.metaKey || i.ctrlKey) && i.key.toUpperCase() === "V" && n.clipboard.focus(),
								n.eventEmitter.emit("keydown", n.editorType, i),
								!1
							)
						},
						handleDOMEvents: {
							copy: function (r, i) {
								return n.captureCopy(i)
							},
							cut: function (r, i) {
								return n.captureCopy(i, xk)
							},
							scroll: function () {
								return n.eventEmitter.emit("scroll", "editor"), !0
							},
							keyup: function (r, i) {
								return n.eventEmitter.emit("keyup", n.editorType, i), !1
							},
						},
						nodeViews: { widget: sz },
					})
				}),
				(t.prototype.createCommands = function () {
					return this.specs.commands(this.view)
				}),
				(t.prototype.captureCopy = function (n, r) {
					n.preventDefault()
					var i = this.view.state,
						a = i.selection,
						o = i.tr
					if (a.empty) return !0
					var s = this.getChanged(a.content())
					return (
						n.clipboardData
							? n.clipboardData.setData("text/plain", s)
							: window.clipboardData.setData("Text", s),
						r === xk &&
							this.view.dispatch(o.deleteSelection().scrollIntoView().setMeta("uiEvent", xk)),
						!0
					)
				}),
				(t.prototype.updateMarkdown = function (n) {
					var r = this
					n.docChanged &&
						n.steps.forEach(function (i, a) {
							if (i.slice && !(i instanceof Ar)) {
								var o = n.docs[a],
									s = [i.from, i.to],
									l = s[0],
									u = s[1],
									d = d1(o, l, u),
									p = d[0],
									m = d[1],
									v = r.getChanged(i.slice)
								p[0] === m[0] &&
									p[1] === m[1] &&
									v === "" &&
									(v = `
`)
								var y = r.toastMark.editMarkdown(p, m, v)
								r.eventEmitter.emit("updatePreview", y), n.setMeta("editResult", y).scrollIntoView()
							}
						})
				}),
				(t.prototype.getChanged = function (n) {
					var r = "",
						i = 0,
						a = n.content.size
					return (
						n.content.nodesBetween(i, a, function (o, s) {
							o.isText
								? (r += o.text.slice(Math.max(i, s) - s, a - s))
								: o.isBlock &&
								  s > 0 &&
								  (r += `
`)
						}),
						r
					)
				}),
				(t.prototype.setSelection = function (n, r) {
					r === void 0 && (r = n)
					var i = this.view.state.tr,
						a = Ac(i.doc, n, r),
						o = a[0],
						s = a[1]
					this.view.dispatch(i.setSelection(Fn(i, o, s)).scrollIntoView())
				}),
				(t.prototype.replaceSelection = function (n, r, i) {
					var a,
						o = this.view.state,
						s = o.tr,
						l = o.schema,
						u = o.doc,
						d = n.split(x4),
						p = d.map(function (x) {
							return yb(l, td(x, l))
						}),
						m = new Ue(ke.from(p), 1, 1)
					if ((this.focus(), r && i)) {
						var v = Ac(u, r, i),
							y = v[0],
							b = v[1]
						a = s.replaceRange(y, b, m)
					} else a = s.replaceSelection(m)
					this.view.dispatch(a.scrollIntoView())
				}),
				(t.prototype.deleteSelection = function (n, r) {
					var i,
						a = this.view.state,
						o = a.tr,
						s = a.doc
					if (n && r) {
						var l = Ac(s, n, r),
							u = l[0],
							d = l[1]
						i = o.deleteRange(u, d)
					} else i = o.deleteSelection()
					this.view.dispatch(i.scrollIntoView())
				}),
				(t.prototype.getSelectedText = function (n, r) {
					var i = this.view.state,
						a = i.doc,
						o = i.selection,
						s = o.from,
						l = o.to
					if (n && r) {
						var u = Ac(a, n, r)
						;(s = u[0]), (l = u[1])
					}
					return a.textBetween(
						s,
						l,
						`
`,
					)
				}),
				(t.prototype.getSelection = function () {
					var n = this.view.state.selection,
						r = n.from,
						i = n.to
					return d1(this.view.state.tr.doc, r, i)
				}),
				(t.prototype.setMarkdown = function (n, r) {
					r === void 0 && (r = !0)
					var i = n.split(x4),
						a = this.view.state,
						o = a.tr,
						s = a.doc,
						l = a.schema,
						u = i.map(function (d) {
							return yb(l, td(d, l))
						})
					this.view.dispatch(o.replaceWith(0, s.content.size, u)), r && this.moveCursorToEnd(!0)
				}),
				(t.prototype.addWidget = function (n, r, i) {
					var a = this.view.state,
						o = a.tr,
						s = a.doc,
						l = a.selection,
						u = i ? Ac(s, i, i)[0] : l.to
					this.view.dispatch(o.setMeta("widget", { pos: u, node: n, style: r }))
				}),
				(t.prototype.replaceWithWidget = function (n, r, i) {
					var a = this.view.state,
						o = a.tr,
						s = a.schema,
						l = a.doc,
						u = Ac(l, n, r),
						d = td(i, s)
					this.view.dispatch(o.replaceWith(u[0], u[1], d))
				}),
				(t.prototype.getRangeInfoOfNode = function (n) {
					var r = this.view.state,
						i = r.doc,
						a = r.selection,
						o = n || d1(i, a.from)[0],
						s = this.toastMark.findNodeAtPosition(o)
					return (
						s.type === "text" && s.parent.type !== "paragraph" && (s = s.parent),
						(s.sourcepos[1][1] += 1),
						{ range: s.sourcepos, type: s.type }
					)
				}),
				(t.prototype.getMarkdown = function () {
					return this.toastMark.getLineTexts().map(function (n) {
						return uw(n)
					}).join(`
`)
				}),
				(t.prototype.getToastMark = function () {
					return this.toastMark
				}),
				t
			)
		})(uz),
		w4 = "_feEventKey"
	function yxe(e, t) {
		var n = e[w4],
			r
		return n || (n = e[w4] = {}), (r = n[t]), r || (r = n[t] = []), r
	}
	var yz = yxe,
		bxe = Nl,
		Cb = ow,
		xxe = yz
	function wxe(e, t, n) {
		if (bxe(t)) {
			Cb(t.split(/\s+/g), function (r) {
				E4(e, r, n)
			})
			return
		}
		Cb(t, function (r, i) {
			E4(e, i, r)
		})
	}
	function E4(e, t, n) {
		var r = xxe(e, t),
			i
		n
			? (Cb(r, function (a, o) {
					return n === a.handler ? (C4(e, t, a.wrappedHandler), (i = o), !1) : !0
			  }),
			  r.splice(i, 1))
			: (Cb(r, function (a) {
					C4(e, t, a.wrappedHandler)
			  }),
			  r.splice(0, r.length))
	}
	function C4(e, t, n) {
		"removeEventListener" in e
			? e.removeEventListener(t, n)
			: "detachEvent" in e && e.detachEvent("on" + t, n)
	}
	var bz = wxe,
		Exe = Nl,
		B2 = ow,
		Cxe = yz
	function Txe(e, t, n, r) {
		if (Exe(t)) {
			B2(t.split(/\s+/g), function (i) {
				T4(e, i, n, r)
			})
			return
		}
		B2(t, function (i, a) {
			T4(e, a, i, n)
		})
	}
	function T4(e, t, n, r) {
		function i(a) {
			n.call(r || e, a || window.event)
		}
		"addEventListener" in e
			? e.addEventListener(t, i)
			: "attachEvent" in e && e.attachEvent("on" + t, i),
			kxe(e, t, n, i)
	}
	function kxe(e, t, n, r) {
		var i = Cxe(e, t),
			a = !1
		B2(i, function (o) {
			return o.handler === n ? ((a = !0), !1) : !0
		}),
			a || i.push({ handler: n, wrappedHandler: r })
	}
	var xz = Txe,
		H2 = function (e, t) {
			return (
				(H2 =
					Object.setPrototypeOf ||
					({ __proto__: [] } instanceof Array &&
						function (n, r) {
							n.__proto__ = r
						}) ||
					function (n, r) {
						for (var i in r) Object.prototype.hasOwnProperty.call(r, i) && (n[i] = r[i])
					}),
				H2(e, t)
			)
		}
	function eo(e, t) {
		if (typeof t != "function" && t !== null)
			throw new TypeError("Class extends value " + String(t) + " is not a constructor or null")
		H2(e, t)
		function n() {
			this.constructor = e
		}
		e.prototype = t === null ? Object.create(t) : ((n.prototype = t.prototype), new n())
	}
	var Br = function () {
		return (
			(Br =
				Object.assign ||
				function (t) {
					for (var n, r = 1, i = arguments.length; r < i; r++) {
						n = arguments[r]
						for (var a in n) Object.prototype.hasOwnProperty.call(n, a) && (t[a] = n[a])
					}
					return t
				}),
			Br.apply(this, arguments)
		)
	}
	function $2(e, t, n) {
		if (arguments.length === 2)
			for (var r = 0, i = t.length, a; r < i; r++)
				(a || !(r in t)) && (a || (a = Array.prototype.slice.call(t, 0, r)), (a[r] = t[r]))
		return e.concat(a || Array.prototype.slice.call(t))
	}
	var xp =
			typeof globalThis < "u"
				? globalThis
				: typeof window < "u"
				? window
				: typeof global < "u"
				? global
				: typeof self < "u"
				? self
				: {},
		k4 = {}
	function Sxe(e) {
		var t,
			n,
			r = k4[e]
		if (r) return r
		for (r = k4[e] = [], t = 0; t < 128; t++)
			(n = String.fromCharCode(t)),
				/^[0-9a-z]$/i.test(n)
					? r.push(n)
					: r.push("%" + ("0" + t.toString(16).toUpperCase()).slice(-2))
		for (t = 0; t < e.length; t++) r[e.charCodeAt(t)] = e[t]
		return r
	}
	function pw(e, t, n) {
		var r,
			i,
			a,
			o,
			s,
			l = ""
		for (
			typeof t != "string" && ((n = t), (t = pw.defaultChars)),
				typeof n > "u" && (n = !0),
				s = Sxe(t),
				r = 0,
				i = e.length;
			r < i;
			r++
		) {
			if (
				((a = e.charCodeAt(r)),
				n && a === 37 && r + 2 < i && /^[0-9a-f]{2}$/i.test(e.slice(r + 1, r + 3)))
			) {
				;(l += e.slice(r, r + 3)), (r += 2)
				continue
			}
			if (a < 128) {
				l += s[a]
				continue
			}
			if (a >= 55296 && a <= 57343) {
				if (
					a >= 55296 &&
					a <= 56319 &&
					r + 1 < i &&
					((o = e.charCodeAt(r + 1)), o >= 56320 && o <= 57343)
				) {
					;(l += encodeURIComponent(e[r] + e[r + 1])), r++
					continue
				}
				l += "%EF%BF%BD"
				continue
			}
			l += encodeURIComponent(e[r])
		}
		return l
	}
	pw.defaultChars = ";/?:@&=+$,-_.!~*'()#"
	pw.componentChars = "-_.!~*'()"
	var Dxe = pw,
		nA = {},
		pl = {},
		_xe = "",
		Oxe = "",
		Axe = "",
		Nxe = "",
		Mxe = "",
		Ixe = "",
		Rxe = "",
		Lxe = "",
		Pxe = "",
		jxe = "",
		Fxe = "",
		Bxe = "",
		Hxe = "",
		$xe = "",
		Uxe = "",
		zxe = "",
		qxe = "",
		Vxe = "",
		Wxe = "",
		Yxe = "",
		Gxe = "",
		Kxe = "",
		Qxe = "",
		Xxe = "",
		Jxe = "",
		Zxe = "",
		ewe = "&",
		twe = "&",
		nwe = "",
		rwe = "",
		iwe = "",
		awe = "",
		owe = "",
		swe = "",
		lwe = "",
		uwe = "",
		cwe = "",
		dwe = "",
		fwe = "",
		pwe = "",
		hwe = "",
		mwe = "",
		vwe = "",
		gwe = "",
		ywe = "",
		bwe = "",
		xwe = "",
		wwe = "",
		Ewe = "",
		Cwe = "",
		Twe = "",
		kwe = "",
		Swe = "",
		Dwe = "",
		_we = "",
		Owe = "",
		Awe = "",
		Nwe = "",
		Mwe = "",
		Iwe = "",
		Rwe = "",
		Lwe = "'",
		Pwe = "",
		jwe = "",
		Fwe = "",
		Bwe = "",
		Hwe = "",
		$we = "",
		Uwe = "",
		zwe = "",
		qwe = "*",
		Vwe = "",
		Wwe = "",
		Ywe = "",
		Gwe = "",
		Kwe = "",
		Qwe = "",
		Xwe = "",
		Jwe = "",
		Zwe = "",
		eEe = "",
		tEe = "",
		nEe = "",
		rEe = "",
		iEe = "",
		aEe = "",
		oEe = "",
		sEe = "",
		lEe = "",
		uEe = "",
		cEe = "",
		dEe = "",
		fEe = "",
		pEe = "",
		hEe = "",
		mEe = "",
		vEe = "",
		gEe = "",
		yEe = "",
		bEe = "",
		xEe = "",
		wEe = "",
		EEe = "",
		CEe = "",
		TEe = "",
		kEe = "",
		SEe = "",
		DEe = "",
		_Ee = "",
		OEe = "",
		AEe = "",
		NEe = "",
		MEe = "",
		IEe = "",
		REe = "",
		LEe = "",
		PEe = "",
		jEe = "",
		FEe = "",
		BEe = "",
		HEe = "",
		$Ee = "",
		UEe = "",
		zEe = "",
		qEe = "",
		VEe = "",
		WEe = "",
		YEe = "",
		GEe = "",
		KEe = "",
		QEe = "",
		XEe = "",
		JEe = "",
		ZEe = "",
		eCe = "=",
		tCe = "",
		nCe = "",
		rCe = "",
		iCe = "",
		aCe = "",
		oCe = "",
		sCe = "",
		lCe = "",
		uCe = "",
		cCe = "",
		dCe = "",
		fCe = "",
		pCe = "",
		hCe = "",
		mCe = "",
		vCe = "",
		gCe = "",
		yCe = "",
		bCe = "",
		xCe = "",
		wCe = "",
		ECe = "",
		CCe = "",
		TCe = "",
		kCe = "",
		SCe = "",
		DCe = "",
		_Ce = "",
		OCe = "",
		ACe = "",
		NCe = "",
		MCe = "",
		ICe = "",
		RCe = "",
		LCe = "",
		PCe = "",
		jCe = "",
		FCe = "",
		BCe = "",
		HCe = "",
		$Ce = "",
		UCe = "",
		zCe = "",
		qCe = "",
		VCe = "",
		WCe = "",
		YCe = "",
		GCe = "",
		KCe = "",
		QCe = "",
		XCe = "",
		JCe = "",
		ZCe = "",
		eTe = "",
		tTe = "",
		nTe = "",
		rTe = "",
		iTe = "",
		aTe = "",
		oTe = "",
		sTe = "",
		lTe = "",
		uTe = "\\",
		cTe = "",
		dTe = "",
		fTe = "",
		pTe = "",
		hTe = "",
		mTe = "",
		vTe = "",
		gTe = "",
		yTe = "",
		bTe = "",
		xTe = "",
		wTe = "",
		ETe = "",
		CTe = "",
		TTe = "",
		kTe = "",
		STe = "",
		DTe = "",
		_Te = "",
		OTe = "",
		ATe = "",
		NTe = "",
		MTe = "",
		ITe = "",
		RTe = "",
		LTe = "",
		PTe = "",
		jTe = "",
		FTe = "",
		BTe = "",
		HTe = "",
		$Te = "",
		UTe = "",
		zTe = "",
		qTe = "",
		VTe = "",
		WTe = "",
		YTe = "",
		GTe = "",
		KTe = "",
		QTe = "",
		XTe = "",
		JTe = "",
		ZTe = "",
		eke = "",
		tke = "",
		nke = "",
		rke = "",
		ike = "",
		ake = "",
		oke = "",
		ske = "",
		lke = "",
		uke = "",
		cke = "",
		dke = "",
		fke = "",
		pke = "",
		hke = "",
		mke = "",
		vke = "",
		gke = "",
		yke = "",
		bke = "",
		xke = "",
		wke = "",
		Eke = "",
		Cke = "",
		Tke = "",
		kke = "",
		Ske = "",
		Dke = "",
		_ke = ":",
		Oke = "",
		Ake = "",
		Nke = "",
		Mke = "",
		Ike = ",",
		Rke = "@",
		Lke = "",
		Pke = "",
		jke = "",
		Fke = "",
		Bke = "",
		Hke = "",
		$ke = "",
		Uke = "",
		zke = "",
		qke = "",
		Vke = "",
		Wke = "",
		Yke = "",
		Gke = "",
		Kke = "",
		Qke = "",
		Xke = "",
		Jke = "",
		Zke = "",
		eSe = "",
		tSe = "",
		nSe = "",
		rSe = "",
		iSe = "",
		aSe = "",
		oSe = "",
		sSe = "",
		lSe = "",
		uSe = "",
		cSe = "",
		dSe = "",
		fSe = "",
		pSe = "",
		hSe = "",
		mSe = "",
		vSe = "",
		gSe = "",
		ySe = "",
		bSe = "",
		xSe = "",
		wSe = "",
		ESe = "",
		CSe = "",
		TSe = "",
		kSe = "",
		SSe = "",
		DSe = "",
		_Se = "",
		OSe = "",
		ASe = "",
		NSe = "",
		MSe = "",
		ISe = "",
		RSe = "",
		LSe = "",
		PSe = "",
		jSe = "",
		FSe = "",
		BSe = "",
		HSe = "",
		$Se = "",
		USe = "",
		zSe = "",
		qSe = "",
		VSe = "",
		WSe = "",
		YSe = "",
		GSe = "",
		KSe = "",
		QSe = "",
		XSe = "",
		JSe = "",
		ZSe = "",
		e2e = "",
		t2e = "",
		n2e = "",
		r2e = "",
		i2e = "",
		a2e = "",
		o2e = "",
		s2e = "",
		l2e = "",
		u2e = "",
		c2e = "",
		d2e = "",
		f2e = "",
		p2e = "",
		h2e = "",
		m2e = "",
		v2e = "",
		g2e = "",
		y2e = "",
		b2e = "`",
		x2e = "",
		w2e = "",
		E2e = "",
		C2e = "",
		T2e = "",
		k2e = "",
		S2e = "",
		D2e = "",
		_2e = "",
		O2e = "",
		A2e = "",
		N2e = "",
		M2e = "",
		I2e = "",
		R2e = "",
		L2e = "",
		P2e = "",
		j2e = "",
		F2e = "$",
		B2e = "",
		H2e = "",
		$2e = "",
		U2e = "",
		z2e = "",
		q2e = "",
		V2e = "",
		W2e = "",
		Y2e = "",
		G2e = "",
		K2e = "",
		Q2e = "",
		X2e = "",
		J2e = "",
		Z2e = "",
		eDe = "",
		tDe = "",
		nDe = "",
		rDe = "",
		iDe = "",
		aDe = "",
		oDe = "",
		sDe = "",
		lDe = "",
		uDe = "",
		cDe = "",
		dDe = "",
		fDe = "",
		pDe = "",
		hDe = "",
		mDe = "",
		vDe = "",
		gDe = "",
		yDe = "",
		bDe = "",
		xDe = "",
		wDe = "",
		EDe = "",
		CDe = "",
		TDe = "",
		kDe = "",
		SDe = "",
		DDe = "",
		_De = "",
		ODe = "",
		ADe = "",
		NDe = "",
		MDe = "",
		IDe = "",
		RDe = "",
		LDe = "",
		PDe = "",
		jDe = "",
		FDe = "",
		BDe = "",
		HDe = "",
		$De = "",
		UDe = "",
		zDe = "",
		qDe = "",
		VDe = "",
		WDe = "",
		YDe = "",
		GDe = "",
		KDe = "",
		QDe = "",
		XDe = "",
		JDe = "",
		ZDe = "",
		e_e = "",
		t_e = "",
		n_e = "",
		r_e = "",
		i_e = "",
		a_e = "",
		o_e = "",
		s_e = "",
		l_e = "",
		u_e = "",
		c_e = "",
		d_e = "",
		f_e = "",
		p_e = "",
		h_e = "",
		m_e = "",
		v_e = "",
		g_e = "",
		y_e = "",
		b_e = "",
		x_e = "",
		w_e = "",
		E_e = "",
		C_e = "",
		T_e = "",
		k_e = "",
		S_e = "",
		D_e = "",
		__e = "",
		O_e = "",
		A_e = "",
		N_e = "",
		M_e = "",
		I_e = "",
		R_e = "",
		L_e = "",
		P_e = "",
		j_e = "",
		F_e = "",
		B_e = "",
		H_e = "",
		$_e = "",
		U_e = "",
		z_e = "",
		q_e = "",
		V_e = "",
		W_e = "",
		Y_e = "",
		G_e = "",
		K_e = "",
		Q_e = "",
		X_e = "",
		J_e = "",
		Z_e = "",
		eOe = "=",
		tOe = "",
		nOe = "",
		rOe = "",
		iOe = "",
		aOe = "",
		oOe = "",
		sOe = "",
		lOe = "",
		uOe = "",
		cOe = "",
		dOe = "",
		fOe = "",
		pOe = "",
		hOe = "",
		mOe = "",
		vOe = "",
		gOe = "",
		yOe = "",
		bOe = "",
		xOe = "",
		wOe = "!",
		EOe = "",
		COe = "",
		TOe = "",
		kOe = "",
		SOe = "",
		DOe = "",
		_Oe = "",
		OOe = "",
		AOe = "",
		NOe = "",
		MOe = "",
		IOe = "",
		ROe = "",
		LOe = "",
		POe = "",
		jOe = "",
		FOe = "",
		BOe = "fj",
		HOe = "",
		$Oe = "",
		UOe = "",
		zOe = "",
		qOe = "",
		VOe = "",
		WOe = "",
		YOe = "",
		GOe = "",
		KOe = "",
		QOe = "",
		XOe = "",
		JOe = "",
		ZOe = "",
		eAe = "",
		tAe = "",
		nAe = "",
		rAe = "",
		iAe = "",
		aAe = "",
		oAe = "",
		sAe = "",
		lAe = "",
		uAe = "",
		cAe = "",
		dAe = "",
		fAe = "",
		pAe = "",
		hAe = "",
		mAe = "",
		vAe = "",
		gAe = "",
		yAe = "",
		bAe = "",
		xAe = "",
		wAe = "",
		EAe = "",
		CAe = "",
		TAe = "",
		kAe = "",
		SAe = "",
		DAe = "",
		_Ae = "",
		OAe = "",
		AAe = "",
		NAe = "",
		MAe = "",
		IAe = "",
		RAe = "",
		LAe = "",
		PAe = "",
		jAe = "",
		FAe = "",
		BAe = "",
		HAe = "",
		$Ae = "",
		UAe = "",
		zAe = "",
		qAe = "",
		VAe = "",
		WAe = "",
		YAe = "",
		GAe = "",
		KAe = "",
		QAe = "",
		XAe = "",
		JAe = "",
		ZAe = "",
		eNe = "",
		tNe = "",
		nNe = "",
		rNe = "",
		iNe = "",
		aNe = "",
		oNe = "",
		sNe = "",
		lNe = "",
		uNe = "",
		cNe = "",
		dNe = "",
		fNe = "",
		pNe = "`",
		hNe = "",
		mNe = "",
		vNe = "",
		gNe = "",
		yNe = "",
		bNe = "",
		xNe = "",
		wNe = "",
		ENe = "",
		CNe = "",
		TNe = "",
		kNe = "",
		SNe = "",
		DNe = "",
		_Ne = ">",
		ONe = ">",
		ANe = "",
		NNe = "",
		MNe = "",
		INe = "",
		RNe = "",
		LNe = "",
		PNe = "",
		jNe = "",
		FNe = "",
		BNe = "",
		HNe = "",
		$Ne = "",
		UNe = "",
		zNe = "",
		qNe = "",
		VNe = "",
		WNe = "",
		YNe = "",
		GNe = "",
		KNe = "",
		QNe = "",
		XNe = "",
		JNe = "",
		ZNe = "^",
		eMe = "",
		tMe = "",
		nMe = "",
		rMe = "",
		iMe = "",
		aMe = "",
		oMe = "",
		sMe = "",
		lMe = "",
		uMe = "",
		cMe = "",
		dMe = "",
		fMe = "",
		pMe = "",
		hMe = "",
		mMe = "",
		vMe = "",
		gMe = "",
		yMe = "",
		bMe = "",
		xMe = "",
		wMe = "",
		EMe = "",
		CMe = "",
		TMe = "",
		kMe = "",
		SMe = "",
		DMe = "",
		_Me = "",
		OMe = "",
		AMe = "",
		NMe = "",
		MMe = "",
		IMe = "",
		RMe = "",
		LMe = "",
		PMe = "",
		jMe = "",
		FMe = "",
		BMe = "",
		HMe = "",
		$Me = "",
		UMe = "",
		zMe = "",
		qMe = "",
		VMe = "",
		WMe = "",
		YMe = "",
		GMe = "",
		KMe = "",
		QMe = "",
		XMe = "",
		JMe = "",
		ZMe = "",
		eIe = "",
		tIe = "",
		nIe = "",
		rIe = "",
		iIe = "",
		aIe = "",
		oIe = "",
		sIe = "",
		lIe = "",
		uIe = "",
		cIe = "",
		dIe = "",
		fIe = "",
		pIe = "",
		hIe = "",
		mIe = "",
		vIe = "",
		gIe = "",
		yIe = "",
		bIe = "",
		xIe = "",
		wIe = "",
		EIe = "",
		CIe = "",
		TIe = "",
		kIe = "",
		SIe = "",
		DIe = "",
		_Ie = "",
		OIe = "",
		AIe = "",
		NIe = "",
		MIe = "",
		IIe = "",
		RIe = "",
		LIe = "",
		PIe = "",
		jIe = "",
		FIe = "",
		BIe = "",
		HIe = "",
		$Ie = "",
		UIe = "",
		zIe = "",
		qIe = "",
		VIe = "",
		WIe = "",
		YIe = "",
		GIe = "",
		KIe = "",
		QIe = "",
		XIe = "",
		JIe = "",
		ZIe = "",
		eRe = "",
		tRe = "",
		nRe = "",
		rRe = "",
		iRe = "",
		aRe = "",
		oRe = "",
		sRe = "",
		lRe = "",
		uRe = "",
		cRe = "",
		dRe = "",
		fRe = "",
		pRe = "",
		hRe = "",
		mRe = "",
		vRe = "",
		gRe = "",
		yRe = "",
		bRe = "",
		xRe = "",
		wRe = "",
		ERe = "",
		CRe = "",
		TRe = "",
		kRe = "",
		SRe = "",
		DRe = "",
		_Re = "",
		ORe = "",
		ARe = "",
		NRe = "",
		MRe = "",
		IRe = "",
		RRe = "",
		LRe = "",
		PRe = "",
		jRe = "",
		FRe = "",
		BRe = "",
		HRe = "",
		$Re = "",
		URe = "",
		zRe = "",
		qRe = "",
		VRe = "",
		WRe = "",
		YRe = "",
		GRe = "",
		KRe = "",
		QRe = "",
		XRe = "",
		JRe = "",
		ZRe = "",
		eLe = "",
		tLe = "",
		nLe = "",
		rLe = "",
		iLe = "",
		aLe = "",
		oLe = "",
		sLe = "{",
		lLe = "[",
		uLe = "",
		cLe = "",
		dLe = "",
		fLe = "",
		pLe = "",
		hLe = "",
		mLe = "",
		vLe = "",
		gLe = "{",
		yLe = "",
		bLe = "",
		xLe = "",
		wLe = "",
		ELe = "",
		CLe = "",
		TLe = "",
		kLe = "",
		SLe = "",
		DLe = "",
		_Le = "",
		OLe = "",
		ALe = "",
		NLe = "",
		MLe = "",
		ILe = "",
		RLe = "",
		LLe = "",
		PLe = "",
		jLe = "",
		FLe = "",
		BLe = "",
		HLe = "",
		$Le = "",
		ULe = "",
		zLe = "",
		qLe = "",
		VLe = "",
		WLe = "",
		YLe = "",
		GLe = "",
		KLe = "",
		QLe = "",
		XLe = "",
		JLe = "",
		ZLe = "",
		ePe = "",
		tPe = "",
		nPe = "",
		rPe = "",
		iPe = "",
		aPe = "",
		oPe = "",
		sPe = "",
		lPe = "",
		uPe = "",
		cPe = "",
		dPe = "",
		fPe = "",
		pPe = "",
		hPe = "",
		mPe = "",
		vPe = "",
		gPe = "",
		yPe = "",
		bPe = "",
		xPe = "",
		wPe = "",
		EPe = "",
		CPe = "",
		TPe = "",
		kPe = "",
		SPe = "",
		DPe = "",
		_Pe = "",
		OPe = "",
		APe = "",
		NPe = "",
		MPe = "",
		IPe = "",
		RPe = "",
		LPe = "",
		PPe = "",
		jPe = "",
		FPe = "",
		BPe = "",
		HPe = "",
		$Pe = "",
		UPe = "",
		zPe = "",
		qPe = "",
		VPe = "",
		WPe = "",
		YPe = "",
		GPe = "",
		KPe = "",
		QPe = "",
		XPe = "",
		JPe = "",
		ZPe = "",
		e3e = "",
		t3e = "",
		n3e = "",
		r3e = "",
		i3e = "",
		a3e = "",
		o3e = "",
		s3e = "",
		l3e = "",
		u3e = "",
		c3e = "",
		d3e = "",
		f3e = "",
		p3e = "",
		h3e = "",
		m3e = "",
		v3e = "",
		g3e = "",
		y3e = "",
		b3e = "",
		x3e = "",
		w3e = "",
		E3e = "",
		C3e = "",
		T3e = "",
		k3e = "",
		S3e = "",
		D3e = "",
		_3e = "",
		O3e = "",
		A3e = "",
		N3e = "",
		M3e = "_",
		I3e = "",
		R3e = "",
		L3e = "",
		P3e = "",
		j3e = "",
		F3e = "(",
		B3e = "",
		H3e = "",
		$3e = "",
		U3e = "",
		z3e = "",
		q3e = "",
		V3e = "",
		W3e = "",
		Y3e = "",
		G3e = "",
		K3e = "",
		Q3e = "",
		X3e = "",
		J3e = "",
		Z3e = "",
		e4e = "[",
		t4e = "",
		n4e = "",
		r4e = "",
		i4e = "",
		a4e = "",
		o4e = "",
		s4e = "<",
		l4e = "<",
		u4e = "",
		c4e = "",
		d4e = "",
		f4e = "",
		p4e = "",
		h4e = "",
		m4e = "",
		v4e = "",
		g4e = "",
		y4e = "",
		b4e = "",
		x4e = "",
		w4e = "",
		E4e = "",
		C4e = "",
		T4e = "",
		k4e = "",
		S4e = "",
		D4e = "",
		_4e = "",
		O4e = "",
		A4e = "",
		N4e = "",
		M4e = "",
		I4e = "",
		R4e = "",
		L4e = "",
		P4e = "",
		j4e = "",
		F4e = "",
		B4e = "",
		H4e = "",
		$4e = "",
		U4e = "",
		z4e = "",
		q4e = "",
		V4e = "*",
		W4e = "",
		Y4e = "",
		G4e = "",
		K4e = "",
		Q4e = "",
		X4e = "",
		J4e = "",
		Z4e = "",
		eje = "",
		tje = "",
		nje = "",
		rje = "",
		ije = "",
		aje = "",
		oje = "",
		sje = "",
		lje = "",
		uje = "",
		cje = "",
		dje = "",
		fje = "",
		pje = "",
		hje = "",
		mje = "",
		vje = "",
		gje = "",
		yje = "",
		bje = "",
		xje = "",
		wje = "",
		Eje = "",
		Cje = "",
		Tje = "",
		kje = "",
		Sje = "",
		Dje = "",
		_je = "",
		Oje = "",
		Aje = "",
		Nje = "",
		Mje = "",
		Ije = "",
		Rje = "",
		Lje = "",
		Pje = "",
		jje = "",
		Fje = "",
		Bje = "",
		Hje = "",
		$je = "",
		Uje = "",
		zje = "",
		qje = "",
		Vje = "",
		Wje = "",
		Yje = "",
		Gje = "",
		Kje = "",
		Qje = "",
		Xje = "",
		Jje = "",
		Zje = "",
		e6e = "",
		t6e = `
`,
		n6e = "",
		r6e = "",
		i6e = "",
		a6e = "",
		o6e = "",
		s6e = "",
		l6e = "",
		u6e = "",
		c6e = "",
		d6e = "",
		f6e = "",
		p6e = "",
		h6e = "",
		m6e = "",
		v6e = "",
		g6e = "",
		y6e = "",
		b6e = "",
		x6e = "",
		w6e = "",
		E6e = "",
		C6e = "",
		T6e = "",
		k6e = "",
		S6e = "",
		D6e = "",
		_6e = "",
		O6e = "",
		A6e = "",
		N6e = "",
		M6e = "",
		I6e = "",
		R6e = "",
		L6e = "",
		P6e = "",
		j6e = "",
		F6e = "",
		B6e = "",
		H6e = "",
		$6e = "",
		U6e = "",
		z6e = "",
		q6e = "",
		V6e = "",
		W6e = "",
		Y6e = "",
		G6e = "",
		K6e = "",
		Q6e = "",
		X6e = "",
		J6e = "",
		Z6e = "",
		eFe = "",
		tFe = "",
		nFe = "",
		rFe = "",
		iFe = "",
		aFe = "",
		oFe = "",
		sFe = "",
		lFe = "",
		uFe = "",
		cFe = "",
		dFe = "",
		fFe = "",
		pFe = "",
		hFe = "",
		mFe = "",
		vFe = "",
		gFe = "",
		yFe = "",
		bFe = "",
		xFe = "",
		wFe = "",
		EFe = "",
		CFe = "",
		TFe = "",
		kFe = "",
		SFe = "",
		DFe = "",
		_Fe = "",
		OFe = "",
		AFe = "",
		NFe = "",
		MFe = "",
		IFe = "",
		RFe = "",
		LFe = "",
		PFe = "",
		jFe = "",
		FFe = "",
		BFe = "",
		HFe = "",
		$Fe = "",
		UFe = "",
		zFe = "",
		qFe = "",
		VFe = "",
		WFe = "",
		YFe = "",
		GFe = "",
		KFe = "",
		QFe = "",
		XFe = "",
		JFe = "",
		ZFe = "",
		e5e = "",
		t5e = "",
		n5e = "",
		r5e = "",
		i5e = "",
		a5e = "",
		o5e = "",
		s5e = "",
		l5e = "",
		u5e = "",
		c5e = "",
		d5e = "",
		f5e = "",
		p5e = "",
		h5e = "",
		m5e = "",
		v5e = "",
		g5e = "",
		y5e = "",
		b5e = "",
		x5e = "",
		w5e = "",
		E5e = "",
		C5e = "",
		T5e = "",
		k5e = "",
		S5e = "",
		D5e = "",
		_5e = "",
		O5e = "",
		A5e = "",
		N5e = "",
		M5e = "",
		I5e = "",
		R5e = "",
		L5e = "",
		P5e = "",
		j5e = "",
		F5e = "",
		B5e = "",
		H5e = "",
		$5e = "",
		U5e = "",
		z5e = "",
		q5e = "",
		V5e = "",
		W5e = "",
		Y5e = "",
		G5e = "",
		K5e = "",
		Q5e = "",
		X5e = "",
		J5e = "",
		Z5e = "",
		e8e = "",
		t8e = "",
		n8e = "",
		r8e = "",
		i8e = "",
		a8e = "",
		o8e = "",
		s8e = "",
		l8e = "",
		u8e = "",
		c8e = "#",
		d8e = "",
		f8e = "",
		p8e = "",
		h8e = "",
		m8e = "",
		v8e = "",
		g8e = "",
		y8e = "",
		b8e = ">",
		x8e = "",
		w8e = "",
		E8e = "",
		C8e = "",
		T8e = "<",
		k8e = "",
		S8e = "",
		D8e = "",
		_8e = "",
		O8e = "",
		A8e = "",
		N8e = "",
		M8e = "",
		I8e = "",
		R8e = "",
		L8e = "",
		P8e = "",
		j8e = "",
		F8e = "",
		B8e = "",
		H8e = "",
		$8e = "",
		U8e = "",
		z8e = "",
		q8e = "",
		V8e = "",
		W8e = "",
		Y8e = "",
		G8e = "",
		K8e = "",
		Q8e = "",
		X8e = "",
		J8e = "",
		Z8e = "",
		eBe = "",
		tBe = "",
		nBe = "",
		rBe = "",
		iBe = "",
		aBe = "",
		oBe = "",
		sBe = "",
		lBe = "",
		uBe = "",
		cBe = "",
		dBe = "",
		fBe = "",
		pBe = "",
		hBe = "",
		mBe = "",
		vBe = "",
		gBe = "",
		yBe = "",
		bBe = "",
		xBe = "",
		wBe = "",
		EBe = "",
		CBe = "",
		TBe = "",
		kBe = "",
		SBe = "",
		DBe = "",
		_Be = "",
		OBe = "",
		ABe = "",
		NBe = "",
		MBe = "",
		IBe = "",
		RBe = "",
		LBe = "",
		PBe = "",
		jBe = "",
		FBe = "",
		BBe = "",
		HBe = "",
		$Be = "",
		UBe = "",
		zBe = "",
		qBe = "",
		VBe = "",
		WBe = "",
		YBe = "",
		GBe = "",
		KBe = "",
		QBe = "",
		XBe = "",
		JBe = "",
		ZBe = "",
		e9e = "",
		t9e = "",
		n9e = "",
		r9e = "",
		i9e = "",
		a9e = "",
		o9e = "",
		s9e = "",
		l9e = "",
		u9e = "",
		c9e = "",
		d9e = "%",
		f9e = ".",
		p9e = "",
		h9e = "",
		m9e = "",
		v9e = "",
		g9e = "",
		y9e = "",
		b9e = "",
		x9e = "",
		w9e = "",
		E9e = "",
		C9e = "",
		T9e = "",
		k9e = "",
		S9e = "",
		D9e = "",
		_9e = "",
		O9e = "",
		A9e = "",
		N9e = "",
		M9e = "",
		I9e = "+",
		R9e = "",
		L9e = "",
		P9e = "",
		j9e = "",
		F9e = "",
		B9e = "",
		H9e = "",
		$9e = "",
		U9e = "",
		z9e = "",
		q9e = "",
		V9e = "",
		W9e = "",
		Y9e = "",
		G9e = "",
		K9e = "",
		Q9e = "",
		X9e = "",
		J9e = "",
		Z9e = "",
		eHe = "",
		tHe = "",
		nHe = "",
		rHe = "",
		iHe = "",
		aHe = "",
		oHe = "",
		sHe = "",
		lHe = "",
		uHe = "",
		cHe = "",
		dHe = "",
		fHe = "",
		pHe = "",
		hHe = "",
		mHe = "",
		vHe = "",
		gHe = "",
		yHe = "",
		bHe = "",
		xHe = "",
		wHe = "",
		EHe = "",
		CHe = "",
		THe = "",
		kHe = "",
		SHe = "",
		DHe = "",
		_He = "",
		OHe = "",
		AHe = "",
		NHe = "",
		MHe = "",
		IHe = "",
		RHe = "",
		LHe = "",
		PHe = "",
		jHe = "",
		FHe = "",
		BHe = "",
		HHe = "",
		$He = "",
		UHe = "",
		zHe = "?",
		qHe = "",
		VHe = '"',
		WHe = '"',
		YHe = "",
		GHe = "",
		KHe = "",
		QHe = "",
		XHe = "",
		JHe = "",
		ZHe = "",
		e$e = "",
		t$e = "",
		n$e = "",
		r$e = "",
		i$e = "",
		a$e = "",
		o$e = "",
		s$e = "",
		l$e = "",
		u$e = "",
		c$e = "",
		d$e = "",
		f$e = "",
		p$e = "",
		h$e = "",
		m$e = "",
		v$e = "",
		g$e = "",
		y$e = "",
		b$e = "",
		x$e = "",
		w$e = "",
		E$e = "",
		C$e = "",
		T$e = "",
		k$e = "",
		S$e = "",
		D$e = "",
		_$e = "}",
		O$e = "]",
		A$e = "",
		N$e = "",
		M$e = "",
		I$e = "",
		R$e = "",
		L$e = "",
		P$e = "",
		j$e = "",
		F$e = "}",
		B$e = "",
		H$e = "",
		$$e = "",
		U$e = "",
		z$e = "",
		q$e = "",
		V$e = "",
		W$e = "",
		Y$e = "",
		G$e = "",
		K$e = "",
		Q$e = "",
		X$e = "",
		J$e = "",
		Z$e = "",
		e7e = "",
		t7e = "",
		n7e = "",
		r7e = "",
		i7e = "",
		a7e = "",
		o7e = "",
		s7e = "",
		l7e = "",
		u7e = "",
		c7e = "",
		d7e = "",
		f7e = "",
		p7e = "",
		h7e = "",
		m7e = "",
		v7e = "",
		g7e = "",
		y7e = "",
		b7e = "",
		x7e = "",
		w7e = "",
		E7e = "",
		C7e = "",
		T7e = "",
		k7e = "",
		S7e = "",
		D7e = "",
		_7e = "",
		O7e = "",
		A7e = "",
		N7e = "",
		M7e = "",
		I7e = "",
		R7e = "",
		L7e = "",
		P7e = "",
		j7e = "",
		F7e = "",
		B7e = "",
		H7e = "",
		$7e = "",
		U7e = "",
		z7e = "",
		q7e = "",
		V7e = "",
		W7e = "",
		Y7e = "",
		G7e = "",
		K7e = "",
		Q7e = "",
		X7e = "",
		J7e = "",
		Z7e = "",
		eUe = "",
		tUe = "",
		nUe = "",
		rUe = "",
		iUe = "",
		aUe = "",
		oUe = "",
		sUe = "",
		lUe = "",
		uUe = ")",
		cUe = "",
		dUe = "",
		fUe = "",
		pUe = "",
		hUe = "",
		mUe = "",
		vUe = "",
		gUe = "",
		yUe = "",
		bUe = "]",
		xUe = "",
		wUe = "",
		EUe = "",
		CUe = "",
		TUe = "",
		kUe = "",
		SUe = "",
		DUe = "",
		_Ue = "",
		OUe = "",
		AUe = "",
		NUe = "",
		MUe = "",
		IUe = "",
		RUe = "",
		LUe = "",
		PUe = "",
		jUe = "",
		FUe = "",
		BUe = "",
		HUe = "",
		$Ue = "",
		UUe = "",
		zUe = "",
		qUe = "",
		VUe = "",
		WUe = "",
		YUe = "",
		GUe = "",
		KUe = "",
		QUe = "",
		XUe = "",
		JUe = "",
		ZUe = "",
		eze = "",
		tze = "",
		nze = "",
		rze = "",
		ize = "",
		aze = "",
		oze = "",
		sze = ";",
		lze = "",
		uze = "",
		cze = "",
		dze = "",
		fze = "",
		pze = "",
		hze = "",
		mze = "",
		vze = "",
		gze = "",
		yze = "",
		bze = "",
		xze = "",
		wze = "",
		Eze = "",
		Cze = "",
		Tze = "",
		kze = "",
		Sze = "",
		Dze = "",
		_ze = "",
		Oze = "",
		Aze = "",
		Nze = "",
		Mze = "",
		Ize = "",
		Rze = "",
		Lze = "",
		Pze = "",
		jze = "",
		Fze = "",
		Bze = "",
		Hze = "",
		$ze = "",
		Uze = "",
		zze = "",
		qze = "",
		Vze = "",
		Wze = "",
		Yze = "",
		Gze = "",
		Kze = "",
		Qze = "",
		Xze = "",
		Jze = "",
		Zze = "",
		eqe = "",
		tqe = "",
		nqe = "/",
		rqe = "",
		iqe = "",
		aqe = "",
		oqe = "",
		sqe = "",
		lqe = "",
		uqe = "",
		cqe = "",
		dqe = "",
		fqe = "",
		pqe = "",
		hqe = "",
		mqe = "",
		vqe = "",
		gqe = "",
		yqe = "",
		bqe = "",
		xqe = "",
		wqe = "",
		Eqe = "",
		Cqe = "",
		Tqe = "",
		kqe = "",
		Sqe = "",
		Dqe = "",
		_qe = "",
		Oqe = "",
		Aqe = "",
		Nqe = "",
		Mqe = "",
		Iqe = "",
		Rqe = "",
		Lqe = "",
		Pqe = "",
		jqe = "",
		Fqe = "",
		Bqe = "",
		Hqe = "",
		$qe = "",
		Uqe = "",
		zqe = "",
		qqe = "",
		Vqe = "",
		Wqe = "",
		Yqe = "",
		Gqe = "",
		Kqe = "",
		Qqe = "",
		Xqe = "",
		Jqe = "",
		Zqe = "",
		eVe = "",
		tVe = "",
		nVe = "",
		rVe = "",
		iVe = "",
		aVe = "",
		oVe = "",
		sVe = "",
		lVe = "",
		uVe = "",
		cVe = "",
		dVe = "",
		fVe = "",
		pVe = "",
		hVe = "",
		mVe = "",
		vVe = "",
		gVe = "",
		yVe = "",
		bVe = "",
		xVe = "",
		wVe = "",
		EVe = "",
		CVe = "",
		TVe = "",
		kVe = "",
		SVe = "",
		DVe = "",
		_Ve = "",
		OVe = "",
		AVe = "",
		NVe = "",
		MVe = "",
		IVe = "",
		RVe = "",
		LVe = "",
		PVe = "",
		jVe = "",
		FVe = "",
		BVe = "",
		HVe = "",
		$Ve = "",
		UVe = "",
		zVe = "",
		qVe = "",
		VVe = "",
		WVe = "",
		YVe = "",
		GVe = "",
		KVe = "",
		QVe = "",
		XVe = "",
		JVe = "",
		ZVe = "",
		eWe = "",
		tWe = "",
		nWe = "",
		rWe = "",
		iWe = "",
		aWe = "",
		oWe = "",
		sWe = "	",
		lWe = "",
		uWe = "",
		cWe = "",
		dWe = "",
		fWe = "",
		pWe = "",
		hWe = "",
		mWe = "",
		vWe = "",
		gWe = "",
		yWe = "",
		bWe = "",
		xWe = "",
		wWe = "",
		EWe = "",
		CWe = "",
		TWe = "",
		kWe = "",
		SWe = "",
		DWe = "",
		_We = "",
		OWe = "",
		AWe = "",
		NWe = "",
		MWe = "",
		IWe = "",
		RWe = "",
		LWe = "",
		PWe = "",
		jWe = "",
		FWe = "",
		BWe = "",
		HWe = "",
		$We = "",
		UWe = "",
		zWe = "",
		qWe = "",
		VWe = "",
		WWe = "",
		YWe = "",
		GWe = "",
		KWe = "",
		QWe = "",
		XWe = "",
		JWe = "",
		ZWe = "",
		eYe = "",
		tYe = "",
		nYe = "",
		rYe = "",
		iYe = "",
		aYe = "",
		oYe = "",
		sYe = "",
		lYe = "",
		uYe = "",
		cYe = "",
		dYe = "",
		fYe = "",
		pYe = "",
		hYe = "",
		mYe = "",
		vYe = "",
		gYe = "",
		yYe = "",
		bYe = "",
		xYe = "",
		wYe = "",
		EYe = "",
		CYe = "",
		TYe = "",
		kYe = "",
		SYe = "",
		DYe = "",
		_Ye = "",
		OYe = "",
		AYe = "",
		NYe = "",
		MYe = "",
		IYe = "",
		RYe = "",
		LYe = "",
		PYe = "",
		jYe = "",
		FYe = "",
		BYe = "",
		HYe = "",
		$Ye = "",
		UYe = "",
		zYe = "",
		qYe = "",
		VYe = "",
		WYe = "",
		YYe = "",
		GYe = "",
		KYe = "",
		QYe = "",
		XYe = "",
		JYe = "",
		ZYe = "",
		eGe = "",
		tGe = "",
		nGe = "",
		rGe = "",
		iGe = "",
		aGe = "",
		oGe = "",
		sGe = "",
		lGe = "",
		uGe = "",
		cGe = "",
		dGe = "_",
		fGe = "",
		pGe = "",
		hGe = "",
		mGe = "",
		vGe = "",
		gGe = "",
		yGe = "",
		bGe = "",
		xGe = "",
		wGe = "",
		EGe = "",
		CGe = "",
		TGe = "",
		kGe = "",
		SGe = "",
		DGe = "",
		_Ge = "",
		OGe = "",
		AGe = "",
		NGe = "",
		MGe = "",
		IGe = "",
		RGe = "",
		LGe = "",
		PGe = "",
		jGe = "",
		FGe = "",
		BGe = "",
		HGe = "",
		$Ge = "",
		UGe = "",
		zGe = "",
		qGe = "",
		VGe = "",
		WGe = "",
		YGe = "",
		GGe = "",
		KGe = "",
		QGe = "",
		XGe = "",
		JGe = "",
		ZGe = "",
		eKe = "",
		tKe = "",
		nKe = "",
		rKe = "",
		iKe = "",
		aKe = "",
		oKe = "",
		sKe = "",
		lKe = "",
		uKe = "",
		cKe = "",
		dKe = "",
		fKe = "",
		pKe = "",
		hKe = "",
		mKe = "",
		vKe = "",
		gKe = "",
		yKe = "",
		bKe = "",
		xKe = "",
		wKe = "",
		EKe = "",
		CKe = "",
		TKe = "",
		kKe = "",
		SKe = "",
		DKe = "",
		_Ke = "",
		OKe = "",
		AKe = "",
		NKe = "",
		MKe = "",
		IKe = "",
		RKe = "",
		LKe = "",
		PKe = "",
		jKe = "",
		FKe = "",
		BKe = "|",
		HKe = "",
		$Ke = "|",
		UKe = "",
		zKe = "",
		qKe = "|",
		VKe = "",
		WKe = "",
		YKe = "",
		GKe = "",
		KKe = "",
		QKe = "",
		XKe = "",
		JKe = "",
		ZKe = "",
		eQe = "",
		tQe = "",
		nQe = "",
		rQe = "",
		iQe = "",
		aQe = "",
		oQe = "",
		sQe = "",
		lQe = "",
		uQe = "",
		cQe = "",
		dQe = "",
		fQe = "",
		pQe = "",
		hQe = "",
		mQe = "",
		vQe = "",
		gQe = "",
		yQe = "",
		bQe = "",
		xQe = "",
		wQe = "",
		EQe = "",
		CQe = "",
		TQe = "",
		kQe = "",
		SQe = "",
		DQe = "",
		_Qe = "",
		OQe = "",
		AQe = "",
		NQe = "",
		MQe = "",
		IQe = "",
		RQe = "",
		LQe = "",
		PQe = "",
		jQe = "",
		FQe = "",
		BQe = "",
		HQe = "",
		$Qe = "",
		UQe = "",
		zQe = "",
		qQe = "",
		VQe = "",
		WQe = "",
		YQe = "",
		GQe = "",
		KQe = "",
		QQe = "",
		XQe = "",
		JQe = "",
		ZQe = "",
		eXe = "",
		tXe = "",
		nXe = "",
		rXe = "",
		iXe = "",
		aXe = "",
		oXe = "",
		sXe = "",
		lXe = "",
		uXe = "",
		cXe = "",
		dXe = "",
		fXe = "",
		pXe = "",
		hXe = "",
		mXe = "",
		vXe = "",
		gXe = "",
		yXe = "",
		bXe = "",
		xXe = "",
		wXe = "",
		EXe = "",
		CXe = "",
		TXe = "",
		kXe = "",
		SXe = "",
		DXe = "",
		_Xe = "",
		OXe = "",
		AXe = "",
		NXe = "",
		MXe = "",
		IXe = "",
		RXe = "",
		LXe = "",
		PXe = "",
		jXe = "",
		FXe = "",
		BXe = "",
		HXe = "",
		$Xe = "",
		UXe = "",
		zXe = "",
		qXe = "",
		wz = {
			Aacute: _xe,
			aacute: Oxe,
			Abreve: Axe,
			abreve: Nxe,
			ac: Mxe,
			acd: Ixe,
			acE: Rxe,
			Acirc: Lxe,
			acirc: Pxe,
			acute: jxe,
			Acy: Fxe,
			acy: Bxe,
			AElig: Hxe,
			aelig: $xe,
			af: Uxe,
			Afr: zxe,
			afr: qxe,
			Agrave: Vxe,
			agrave: Wxe,
			alefsym: Yxe,
			aleph: Gxe,
			Alpha: Kxe,
			alpha: Qxe,
			Amacr: Xxe,
			amacr: Jxe,
			amalg: Zxe,
			amp: ewe,
			AMP: twe,
			andand: nwe,
			And: rwe,
			and: iwe,
			andd: awe,
			andslope: owe,
			andv: swe,
			ang: lwe,
			ange: uwe,
			angle: cwe,
			angmsdaa: dwe,
			angmsdab: fwe,
			angmsdac: pwe,
			angmsdad: hwe,
			angmsdae: mwe,
			angmsdaf: vwe,
			angmsdag: gwe,
			angmsdah: ywe,
			angmsd: bwe,
			angrt: xwe,
			angrtvb: wwe,
			angrtvbd: Ewe,
			angsph: Cwe,
			angst: Twe,
			angzarr: kwe,
			Aogon: Swe,
			aogon: Dwe,
			Aopf: _we,
			aopf: Owe,
			apacir: Awe,
			ap: Nwe,
			apE: Mwe,
			ape: Iwe,
			apid: Rwe,
			apos: Lwe,
			ApplyFunction: Pwe,
			approx: jwe,
			approxeq: Fwe,
			Aring: Bwe,
			aring: Hwe,
			Ascr: $we,
			ascr: Uwe,
			Assign: zwe,
			ast: qwe,
			asymp: Vwe,
			asympeq: Wwe,
			Atilde: Ywe,
			atilde: Gwe,
			Auml: Kwe,
			auml: Qwe,
			awconint: Xwe,
			awint: Jwe,
			backcong: Zwe,
			backepsilon: eEe,
			backprime: tEe,
			backsim: nEe,
			backsimeq: rEe,
			Backslash: iEe,
			Barv: aEe,
			barvee: oEe,
			barwed: sEe,
			Barwed: lEe,
			barwedge: uEe,
			bbrk: cEe,
			bbrktbrk: dEe,
			bcong: fEe,
			Bcy: pEe,
			bcy: hEe,
			bdquo: mEe,
			becaus: vEe,
			because: gEe,
			Because: yEe,
			bemptyv: bEe,
			bepsi: xEe,
			bernou: wEe,
			Bernoullis: EEe,
			Beta: CEe,
			beta: TEe,
			beth: kEe,
			between: SEe,
			Bfr: DEe,
			bfr: _Ee,
			bigcap: OEe,
			bigcirc: AEe,
			bigcup: NEe,
			bigodot: MEe,
			bigoplus: IEe,
			bigotimes: REe,
			bigsqcup: LEe,
			bigstar: PEe,
			bigtriangledown: jEe,
			bigtriangleup: FEe,
			biguplus: BEe,
			bigvee: HEe,
			bigwedge: $Ee,
			bkarow: UEe,
			blacklozenge: zEe,
			blacksquare: qEe,
			blacktriangle: VEe,
			blacktriangledown: WEe,
			blacktriangleleft: YEe,
			blacktriangleright: GEe,
			blank: KEe,
			blk12: QEe,
			blk14: XEe,
			blk34: JEe,
			block: ZEe,
			bne: eCe,
			bnequiv: tCe,
			bNot: nCe,
			bnot: rCe,
			Bopf: iCe,
			bopf: aCe,
			bot: oCe,
			bottom: sCe,
			bowtie: lCe,
			boxbox: uCe,
			boxdl: cCe,
			boxdL: dCe,
			boxDl: fCe,
			boxDL: pCe,
			boxdr: hCe,
			boxdR: mCe,
			boxDr: vCe,
			boxDR: gCe,
			boxh: yCe,
			boxH: bCe,
			boxhd: xCe,
			boxHd: wCe,
			boxhD: ECe,
			boxHD: CCe,
			boxhu: TCe,
			boxHu: kCe,
			boxhU: SCe,
			boxHU: DCe,
			boxminus: _Ce,
			boxplus: OCe,
			boxtimes: ACe,
			boxul: NCe,
			boxuL: MCe,
			boxUl: ICe,
			boxUL: RCe,
			boxur: LCe,
			boxuR: PCe,
			boxUr: jCe,
			boxUR: FCe,
			boxv: BCe,
			boxV: HCe,
			boxvh: $Ce,
			boxvH: UCe,
			boxVh: zCe,
			boxVH: qCe,
			boxvl: VCe,
			boxvL: WCe,
			boxVl: YCe,
			boxVL: GCe,
			boxvr: KCe,
			boxvR: QCe,
			boxVr: XCe,
			boxVR: JCe,
			bprime: ZCe,
			breve: eTe,
			Breve: tTe,
			brvbar: nTe,
			bscr: rTe,
			Bscr: iTe,
			bsemi: aTe,
			bsim: oTe,
			bsime: sTe,
			bsolb: lTe,
			bsol: uTe,
			bsolhsub: cTe,
			bull: dTe,
			bullet: fTe,
			bump: pTe,
			bumpE: hTe,
			bumpe: mTe,
			Bumpeq: vTe,
			bumpeq: gTe,
			Cacute: yTe,
			cacute: bTe,
			capand: xTe,
			capbrcup: wTe,
			capcap: ETe,
			cap: CTe,
			Cap: TTe,
			capcup: kTe,
			capdot: STe,
			CapitalDifferentialD: DTe,
			caps: _Te,
			caret: OTe,
			caron: ATe,
			Cayleys: NTe,
			ccaps: MTe,
			Ccaron: ITe,
			ccaron: RTe,
			Ccedil: LTe,
			ccedil: PTe,
			Ccirc: jTe,
			ccirc: FTe,
			Cconint: BTe,
			ccups: HTe,
			ccupssm: $Te,
			Cdot: UTe,
			cdot: zTe,
			cedil: qTe,
			Cedilla: VTe,
			cemptyv: WTe,
			cent: YTe,
			centerdot: GTe,
			CenterDot: KTe,
			cfr: QTe,
			Cfr: XTe,
			CHcy: JTe,
			chcy: ZTe,
			check: eke,
			checkmark: tke,
			Chi: nke,
			chi: rke,
			circ: ike,
			circeq: ake,
			circlearrowleft: oke,
			circlearrowright: ske,
			circledast: lke,
			circledcirc: uke,
			circleddash: cke,
			CircleDot: dke,
			circledR: fke,
			circledS: pke,
			CircleMinus: hke,
			CirclePlus: mke,
			CircleTimes: vke,
			cir: gke,
			cirE: yke,
			cire: bke,
			cirfnint: xke,
			cirmid: wke,
			cirscir: Eke,
			ClockwiseContourIntegral: Cke,
			CloseCurlyDoubleQuote: Tke,
			CloseCurlyQuote: kke,
			clubs: Ske,
			clubsuit: Dke,
			colon: _ke,
			Colon: Oke,
			Colone: Ake,
			colone: Nke,
			coloneq: Mke,
			comma: Ike,
			commat: Rke,
			comp: Lke,
			compfn: Pke,
			complement: jke,
			complexes: Fke,
			cong: Bke,
			congdot: Hke,
			Congruent: $ke,
			conint: Uke,
			Conint: zke,
			ContourIntegral: qke,
			copf: Vke,
			Copf: Wke,
			coprod: Yke,
			Coproduct: Gke,
			copy: Kke,
			COPY: Qke,
			copysr: Xke,
			CounterClockwiseContourIntegral: Jke,
			crarr: Zke,
			cross: eSe,
			Cross: tSe,
			Cscr: nSe,
			cscr: rSe,
			csub: iSe,
			csube: aSe,
			csup: oSe,
			csupe: sSe,
			ctdot: lSe,
			cudarrl: uSe,
			cudarrr: cSe,
			cuepr: dSe,
			cuesc: fSe,
			cularr: pSe,
			cularrp: hSe,
			cupbrcap: mSe,
			cupcap: vSe,
			CupCap: gSe,
			cup: ySe,
			Cup: bSe,
			cupcup: xSe,
			cupdot: wSe,
			cupor: ESe,
			cups: CSe,
			curarr: TSe,
			curarrm: kSe,
			curlyeqprec: SSe,
			curlyeqsucc: DSe,
			curlyvee: _Se,
			curlywedge: OSe,
			curren: ASe,
			curvearrowleft: NSe,
			curvearrowright: MSe,
			cuvee: ISe,
			cuwed: RSe,
			cwconint: LSe,
			cwint: PSe,
			cylcty: jSe,
			dagger: FSe,
			Dagger: BSe,
			daleth: HSe,
			darr: $Se,
			Darr: USe,
			dArr: zSe,
			dash: qSe,
			Dashv: VSe,
			dashv: WSe,
			dbkarow: YSe,
			dblac: GSe,
			Dcaron: KSe,
			dcaron: QSe,
			Dcy: XSe,
			dcy: JSe,
			ddagger: ZSe,
			ddarr: e2e,
			DD: t2e,
			dd: n2e,
			DDotrahd: r2e,
			ddotseq: i2e,
			deg: a2e,
			Del: o2e,
			Delta: s2e,
			delta: l2e,
			demptyv: u2e,
			dfisht: c2e,
			Dfr: d2e,
			dfr: f2e,
			dHar: p2e,
			dharl: h2e,
			dharr: m2e,
			DiacriticalAcute: v2e,
			DiacriticalDot: g2e,
			DiacriticalDoubleAcute: y2e,
			DiacriticalGrave: b2e,
			DiacriticalTilde: x2e,
			diam: w2e,
			diamond: E2e,
			Diamond: C2e,
			diamondsuit: T2e,
			diams: k2e,
			die: S2e,
			DifferentialD: D2e,
			digamma: _2e,
			disin: O2e,
			div: A2e,
			divide: N2e,
			divideontimes: M2e,
			divonx: I2e,
			DJcy: R2e,
			djcy: L2e,
			dlcorn: P2e,
			dlcrop: j2e,
			dollar: F2e,
			Dopf: B2e,
			dopf: H2e,
			Dot: $2e,
			dot: U2e,
			DotDot: z2e,
			doteq: q2e,
			doteqdot: V2e,
			DotEqual: W2e,
			dotminus: Y2e,
			dotplus: G2e,
			dotsquare: K2e,
			doublebarwedge: Q2e,
			DoubleContourIntegral: X2e,
			DoubleDot: J2e,
			DoubleDownArrow: Z2e,
			DoubleLeftArrow: eDe,
			DoubleLeftRightArrow: tDe,
			DoubleLeftTee: nDe,
			DoubleLongLeftArrow: rDe,
			DoubleLongLeftRightArrow: iDe,
			DoubleLongRightArrow: aDe,
			DoubleRightArrow: oDe,
			DoubleRightTee: sDe,
			DoubleUpArrow: lDe,
			DoubleUpDownArrow: uDe,
			DoubleVerticalBar: cDe,
			DownArrowBar: dDe,
			downarrow: fDe,
			DownArrow: pDe,
			Downarrow: hDe,
			DownArrowUpArrow: mDe,
			DownBreve: vDe,
			downdownarrows: gDe,
			downharpoonleft: yDe,
			downharpoonright: bDe,
			DownLeftRightVector: xDe,
			DownLeftTeeVector: wDe,
			DownLeftVectorBar: EDe,
			DownLeftVector: CDe,
			DownRightTeeVector: TDe,
			DownRightVectorBar: kDe,
			DownRightVector: SDe,
			DownTeeArrow: DDe,
			DownTee: _De,
			drbkarow: ODe,
			drcorn: ADe,
			drcrop: NDe,
			Dscr: MDe,
			dscr: IDe,
			DScy: RDe,
			dscy: LDe,
			dsol: PDe,
			Dstrok: jDe,
			dstrok: FDe,
			dtdot: BDe,
			dtri: HDe,
			dtrif: $De,
			duarr: UDe,
			duhar: zDe,
			dwangle: qDe,
			DZcy: VDe,
			dzcy: WDe,
			dzigrarr: YDe,
			Eacute: GDe,
			eacute: KDe,
			easter: QDe,
			Ecaron: XDe,
			ecaron: JDe,
			Ecirc: ZDe,
			ecirc: e_e,
			ecir: t_e,
			ecolon: n_e,
			Ecy: r_e,
			ecy: i_e,
			eDDot: a_e,
			Edot: o_e,
			edot: s_e,
			eDot: l_e,
			ee: u_e,
			efDot: c_e,
			Efr: d_e,
			efr: f_e,
			eg: p_e,
			Egrave: h_e,
			egrave: m_e,
			egs: v_e,
			egsdot: g_e,
			el: y_e,
			Element: b_e,
			elinters: x_e,
			ell: w_e,
			els: E_e,
			elsdot: C_e,
			Emacr: T_e,
			emacr: k_e,
			empty: S_e,
			emptyset: D_e,
			EmptySmallSquare: __e,
			emptyv: O_e,
			EmptyVerySmallSquare: A_e,
			emsp13: N_e,
			emsp14: M_e,
			emsp: I_e,
			ENG: R_e,
			eng: L_e,
			ensp: P_e,
			Eogon: j_e,
			eogon: F_e,
			Eopf: B_e,
			eopf: H_e,
			epar: $_e,
			eparsl: U_e,
			eplus: z_e,
			epsi: q_e,
			Epsilon: V_e,
			epsilon: W_e,
			epsiv: Y_e,
			eqcirc: G_e,
			eqcolon: K_e,
			eqsim: Q_e,
			eqslantgtr: X_e,
			eqslantless: J_e,
			Equal: Z_e,
			equals: eOe,
			EqualTilde: tOe,
			equest: nOe,
			Equilibrium: rOe,
			equiv: iOe,
			equivDD: aOe,
			eqvparsl: oOe,
			erarr: sOe,
			erDot: lOe,
			escr: uOe,
			Escr: cOe,
			esdot: dOe,
			Esim: fOe,
			esim: pOe,
			Eta: hOe,
			eta: mOe,
			ETH: vOe,
			eth: gOe,
			Euml: yOe,
			euml: bOe,
			euro: xOe,
			excl: wOe,
			exist: EOe,
			Exists: COe,
			expectation: TOe,
			exponentiale: kOe,
			ExponentialE: SOe,
			fallingdotseq: DOe,
			Fcy: _Oe,
			fcy: OOe,
			female: AOe,
			ffilig: NOe,
			fflig: MOe,
			ffllig: IOe,
			Ffr: ROe,
			ffr: LOe,
			filig: POe,
			FilledSmallSquare: jOe,
			FilledVerySmallSquare: FOe,
			fjlig: BOe,
			flat: HOe,
			fllig: $Oe,
			fltns: UOe,
			fnof: zOe,
			Fopf: qOe,
			fopf: VOe,
			forall: WOe,
			ForAll: YOe,
			fork: GOe,
			forkv: KOe,
			Fouriertrf: QOe,
			fpartint: XOe,
			frac12: JOe,
			frac13: ZOe,
			frac14: eAe,
			frac15: tAe,
			frac16: nAe,
			frac18: rAe,
			frac23: iAe,
			frac25: aAe,
			frac34: oAe,
			frac35: sAe,
			frac38: lAe,
			frac45: uAe,
			frac56: cAe,
			frac58: dAe,
			frac78: fAe,
			frasl: pAe,
			frown: hAe,
			fscr: mAe,
			Fscr: vAe,
			gacute: gAe,
			Gamma: yAe,
			gamma: bAe,
			Gammad: xAe,
			gammad: wAe,
			gap: EAe,
			Gbreve: CAe,
			gbreve: TAe,
			Gcedil: kAe,
			Gcirc: SAe,
			gcirc: DAe,
			Gcy: _Ae,
			gcy: OAe,
			Gdot: AAe,
			gdot: NAe,
			ge: MAe,
			gE: IAe,
			gEl: RAe,
			gel: LAe,
			geq: PAe,
			geqq: jAe,
			geqslant: FAe,
			gescc: BAe,
			ges: HAe,
			gesdot: $Ae,
			gesdoto: UAe,
			gesdotol: zAe,
			gesl: qAe,
			gesles: VAe,
			Gfr: WAe,
			gfr: YAe,
			gg: GAe,
			Gg: KAe,
			ggg: QAe,
			gimel: XAe,
			GJcy: JAe,
			gjcy: ZAe,
			gla: eNe,
			gl: tNe,
			glE: nNe,
			glj: rNe,
			gnap: iNe,
			gnapprox: aNe,
			gne: oNe,
			gnE: sNe,
			gneq: lNe,
			gneqq: uNe,
			gnsim: cNe,
			Gopf: dNe,
			gopf: fNe,
			grave: pNe,
			GreaterEqual: hNe,
			GreaterEqualLess: mNe,
			GreaterFullEqual: vNe,
			GreaterGreater: gNe,
			GreaterLess: yNe,
			GreaterSlantEqual: bNe,
			GreaterTilde: xNe,
			Gscr: wNe,
			gscr: ENe,
			gsim: CNe,
			gsime: TNe,
			gsiml: kNe,
			gtcc: SNe,
			gtcir: DNe,
			gt: _Ne,
			GT: ONe,
			Gt: ANe,
			gtdot: NNe,
			gtlPar: MNe,
			gtquest: INe,
			gtrapprox: RNe,
			gtrarr: LNe,
			gtrdot: PNe,
			gtreqless: jNe,
			gtreqqless: FNe,
			gtrless: BNe,
			gtrsim: HNe,
			gvertneqq: $Ne,
			gvnE: UNe,
			Hacek: zNe,
			hairsp: qNe,
			half: VNe,
			hamilt: WNe,
			HARDcy: YNe,
			hardcy: GNe,
			harrcir: KNe,
			harr: QNe,
			hArr: XNe,
			harrw: JNe,
			Hat: ZNe,
			hbar: eMe,
			Hcirc: tMe,
			hcirc: nMe,
			hearts: rMe,
			heartsuit: iMe,
			hellip: aMe,
			hercon: oMe,
			hfr: sMe,
			Hfr: lMe,
			HilbertSpace: uMe,
			hksearow: cMe,
			hkswarow: dMe,
			hoarr: fMe,
			homtht: pMe,
			hookleftarrow: hMe,
			hookrightarrow: mMe,
			hopf: vMe,
			Hopf: gMe,
			horbar: yMe,
			HorizontalLine: bMe,
			hscr: xMe,
			Hscr: wMe,
			hslash: EMe,
			Hstrok: CMe,
			hstrok: TMe,
			HumpDownHump: kMe,
			HumpEqual: SMe,
			hybull: DMe,
			hyphen: _Me,
			Iacute: OMe,
			iacute: AMe,
			ic: NMe,
			Icirc: MMe,
			icirc: IMe,
			Icy: RMe,
			icy: LMe,
			Idot: PMe,
			IEcy: jMe,
			iecy: FMe,
			iexcl: BMe,
			iff: HMe,
			ifr: $Me,
			Ifr: UMe,
			Igrave: zMe,
			igrave: qMe,
			ii: VMe,
			iiiint: WMe,
			iiint: YMe,
			iinfin: GMe,
			iiota: KMe,
			IJlig: QMe,
			ijlig: XMe,
			Imacr: JMe,
			imacr: ZMe,
			image: eIe,
			ImaginaryI: tIe,
			imagline: nIe,
			imagpart: rIe,
			imath: iIe,
			Im: aIe,
			imof: oIe,
			imped: sIe,
			Implies: lIe,
			incare: uIe,
			in: "",
			infin: cIe,
			infintie: dIe,
			inodot: fIe,
			intcal: pIe,
			int: hIe,
			Int: mIe,
			integers: vIe,
			Integral: gIe,
			intercal: yIe,
			Intersection: bIe,
			intlarhk: xIe,
			intprod: wIe,
			InvisibleComma: EIe,
			InvisibleTimes: CIe,
			IOcy: TIe,
			iocy: kIe,
			Iogon: SIe,
			iogon: DIe,
			Iopf: _Ie,
			iopf: OIe,
			Iota: AIe,
			iota: NIe,
			iprod: MIe,
			iquest: IIe,
			iscr: RIe,
			Iscr: LIe,
			isin: PIe,
			isindot: jIe,
			isinE: FIe,
			isins: BIe,
			isinsv: HIe,
			isinv: $Ie,
			it: UIe,
			Itilde: zIe,
			itilde: qIe,
			Iukcy: VIe,
			iukcy: WIe,
			Iuml: YIe,
			iuml: GIe,
			Jcirc: KIe,
			jcirc: QIe,
			Jcy: XIe,
			jcy: JIe,
			Jfr: ZIe,
			jfr: eRe,
			jmath: tRe,
			Jopf: nRe,
			jopf: rRe,
			Jscr: iRe,
			jscr: aRe,
			Jsercy: oRe,
			jsercy: sRe,
			Jukcy: lRe,
			jukcy: uRe,
			Kappa: cRe,
			kappa: dRe,
			kappav: fRe,
			Kcedil: pRe,
			kcedil: hRe,
			Kcy: mRe,
			kcy: vRe,
			Kfr: gRe,
			kfr: yRe,
			kgreen: bRe,
			KHcy: xRe,
			khcy: wRe,
			KJcy: ERe,
			kjcy: CRe,
			Kopf: TRe,
			kopf: kRe,
			Kscr: SRe,
			kscr: DRe,
			lAarr: _Re,
			Lacute: ORe,
			lacute: ARe,
			laemptyv: NRe,
			lagran: MRe,
			Lambda: IRe,
			lambda: RRe,
			lang: LRe,
			Lang: PRe,
			langd: jRe,
			langle: FRe,
			lap: BRe,
			Laplacetrf: HRe,
			laquo: $Re,
			larrb: URe,
			larrbfs: zRe,
			larr: qRe,
			Larr: VRe,
			lArr: WRe,
			larrfs: YRe,
			larrhk: GRe,
			larrlp: KRe,
			larrpl: QRe,
			larrsim: XRe,
			larrtl: JRe,
			latail: ZRe,
			lAtail: eLe,
			lat: tLe,
			late: nLe,
			lates: rLe,
			lbarr: iLe,
			lBarr: aLe,
			lbbrk: oLe,
			lbrace: sLe,
			lbrack: lLe,
			lbrke: uLe,
			lbrksld: cLe,
			lbrkslu: dLe,
			Lcaron: fLe,
			lcaron: pLe,
			Lcedil: hLe,
			lcedil: mLe,
			lceil: vLe,
			lcub: gLe,
			Lcy: yLe,
			lcy: bLe,
			ldca: xLe,
			ldquo: wLe,
			ldquor: ELe,
			ldrdhar: CLe,
			ldrushar: TLe,
			ldsh: kLe,
			le: SLe,
			lE: DLe,
			LeftAngleBracket: _Le,
			LeftArrowBar: OLe,
			leftarrow: ALe,
			LeftArrow: NLe,
			Leftarrow: MLe,
			LeftArrowRightArrow: ILe,
			leftarrowtail: RLe,
			LeftCeiling: LLe,
			LeftDoubleBracket: PLe,
			LeftDownTeeVector: jLe,
			LeftDownVectorBar: FLe,
			LeftDownVector: BLe,
			LeftFloor: HLe,
			leftharpoondown: $Le,
			leftharpoonup: ULe,
			leftleftarrows: zLe,
			leftrightarrow: qLe,
			LeftRightArrow: VLe,
			Leftrightarrow: WLe,
			leftrightarrows: YLe,
			leftrightharpoons: GLe,
			leftrightsquigarrow: KLe,
			LeftRightVector: QLe,
			LeftTeeArrow: XLe,
			LeftTee: JLe,
			LeftTeeVector: ZLe,
			leftthreetimes: ePe,
			LeftTriangleBar: tPe,
			LeftTriangle: nPe,
			LeftTriangleEqual: rPe,
			LeftUpDownVector: iPe,
			LeftUpTeeVector: aPe,
			LeftUpVectorBar: oPe,
			LeftUpVector: sPe,
			LeftVectorBar: lPe,
			LeftVector: uPe,
			lEg: cPe,
			leg: dPe,
			leq: fPe,
			leqq: pPe,
			leqslant: hPe,
			lescc: mPe,
			les: vPe,
			lesdot: gPe,
			lesdoto: yPe,
			lesdotor: bPe,
			lesg: xPe,
			lesges: wPe,
			lessapprox: EPe,
			lessdot: CPe,
			lesseqgtr: TPe,
			lesseqqgtr: kPe,
			LessEqualGreater: SPe,
			LessFullEqual: DPe,
			LessGreater: _Pe,
			lessgtr: OPe,
			LessLess: APe,
			lesssim: NPe,
			LessSlantEqual: MPe,
			LessTilde: IPe,
			lfisht: RPe,
			lfloor: LPe,
			Lfr: PPe,
			lfr: jPe,
			lg: FPe,
			lgE: BPe,
			lHar: HPe,
			lhard: $Pe,
			lharu: UPe,
			lharul: zPe,
			lhblk: qPe,
			LJcy: VPe,
			ljcy: WPe,
			llarr: YPe,
			ll: GPe,
			Ll: KPe,
			llcorner: QPe,
			Lleftarrow: XPe,
			llhard: JPe,
			lltri: ZPe,
			Lmidot: e3e,
			lmidot: t3e,
			lmoustache: n3e,
			lmoust: r3e,
			lnap: i3e,
			lnapprox: a3e,
			lne: o3e,
			lnE: s3e,
			lneq: l3e,
			lneqq: u3e,
			lnsim: c3e,
			loang: d3e,
			loarr: f3e,
			lobrk: p3e,
			longleftarrow: h3e,
			LongLeftArrow: m3e,
			Longleftarrow: v3e,
			longleftrightarrow: g3e,
			LongLeftRightArrow: y3e,
			Longleftrightarrow: b3e,
			longmapsto: x3e,
			longrightarrow: w3e,
			LongRightArrow: E3e,
			Longrightarrow: C3e,
			looparrowleft: T3e,
			looparrowright: k3e,
			lopar: S3e,
			Lopf: D3e,
			lopf: _3e,
			loplus: O3e,
			lotimes: A3e,
			lowast: N3e,
			lowbar: M3e,
			LowerLeftArrow: I3e,
			LowerRightArrow: R3e,
			loz: L3e,
			lozenge: P3e,
			lozf: j3e,
			lpar: F3e,
			lparlt: B3e,
			lrarr: H3e,
			lrcorner: $3e,
			lrhar: U3e,
			lrhard: z3e,
			lrm: q3e,
			lrtri: V3e,
			lsaquo: W3e,
			lscr: Y3e,
			Lscr: G3e,
			lsh: K3e,
			Lsh: Q3e,
			lsim: X3e,
			lsime: J3e,
			lsimg: Z3e,
			lsqb: e4e,
			lsquo: t4e,
			lsquor: n4e,
			Lstrok: r4e,
			lstrok: i4e,
			ltcc: a4e,
			ltcir: o4e,
			lt: s4e,
			LT: l4e,
			Lt: u4e,
			ltdot: c4e,
			lthree: d4e,
			ltimes: f4e,
			ltlarr: p4e,
			ltquest: h4e,
			ltri: m4e,
			ltrie: v4e,
			ltrif: g4e,
			ltrPar: y4e,
			lurdshar: b4e,
			luruhar: x4e,
			lvertneqq: w4e,
			lvnE: E4e,
			macr: C4e,
			male: T4e,
			malt: k4e,
			maltese: S4e,
			Map: "",
			map: D4e,
			mapsto: _4e,
			mapstodown: O4e,
			mapstoleft: A4e,
			mapstoup: N4e,
			marker: M4e,
			mcomma: I4e,
			Mcy: R4e,
			mcy: L4e,
			mdash: P4e,
			mDDot: j4e,
			measuredangle: F4e,
			MediumSpace: B4e,
			Mellintrf: H4e,
			Mfr: $4e,
			mfr: U4e,
			mho: z4e,
			micro: q4e,
			midast: V4e,
			midcir: W4e,
			mid: Y4e,
			middot: G4e,
			minusb: K4e,
			minus: Q4e,
			minusd: X4e,
			minusdu: J4e,
			MinusPlus: Z4e,
			mlcp: eje,
			mldr: tje,
			mnplus: nje,
			models: rje,
			Mopf: ije,
			mopf: aje,
			mp: oje,
			mscr: sje,
			Mscr: lje,
			mstpos: uje,
			Mu: cje,
			mu: dje,
			multimap: fje,
			mumap: pje,
			nabla: hje,
			Nacute: mje,
			nacute: vje,
			nang: gje,
			nap: yje,
			napE: bje,
			napid: xje,
			napos: wje,
			napprox: Eje,
			natural: Cje,
			naturals: Tje,
			natur: kje,
			nbsp: Sje,
			nbump: Dje,
			nbumpe: _je,
			ncap: Oje,
			Ncaron: Aje,
			ncaron: Nje,
			Ncedil: Mje,
			ncedil: Ije,
			ncong: Rje,
			ncongdot: Lje,
			ncup: Pje,
			Ncy: jje,
			ncy: Fje,
			ndash: Bje,
			nearhk: Hje,
			nearr: $je,
			neArr: Uje,
			nearrow: zje,
			ne: qje,
			nedot: Vje,
			NegativeMediumSpace: Wje,
			NegativeThickSpace: Yje,
			NegativeThinSpace: Gje,
			NegativeVeryThinSpace: Kje,
			nequiv: Qje,
			nesear: Xje,
			nesim: Jje,
			NestedGreaterGreater: Zje,
			NestedLessLess: e6e,
			NewLine: t6e,
			nexist: n6e,
			nexists: r6e,
			Nfr: i6e,
			nfr: a6e,
			ngE: o6e,
			nge: s6e,
			ngeq: l6e,
			ngeqq: u6e,
			ngeqslant: c6e,
			nges: d6e,
			nGg: f6e,
			ngsim: p6e,
			nGt: h6e,
			ngt: m6e,
			ngtr: v6e,
			nGtv: g6e,
			nharr: y6e,
			nhArr: b6e,
			nhpar: x6e,
			ni: w6e,
			nis: E6e,
			nisd: C6e,
			niv: T6e,
			NJcy: k6e,
			njcy: S6e,
			nlarr: D6e,
			nlArr: _6e,
			nldr: O6e,
			nlE: A6e,
			nle: N6e,
			nleftarrow: M6e,
			nLeftarrow: I6e,
			nleftrightarrow: R6e,
			nLeftrightarrow: L6e,
			nleq: P6e,
			nleqq: j6e,
			nleqslant: F6e,
			nles: B6e,
			nless: H6e,
			nLl: $6e,
			nlsim: U6e,
			nLt: z6e,
			nlt: q6e,
			nltri: V6e,
			nltrie: W6e,
			nLtv: Y6e,
			nmid: G6e,
			NoBreak: K6e,
			NonBreakingSpace: Q6e,
			nopf: X6e,
			Nopf: J6e,
			Not: Z6e,
			not: eFe,
			NotCongruent: tFe,
			NotCupCap: nFe,
			NotDoubleVerticalBar: rFe,
			NotElement: iFe,
			NotEqual: aFe,
			NotEqualTilde: oFe,
			NotExists: sFe,
			NotGreater: lFe,
			NotGreaterEqual: uFe,
			NotGreaterFullEqual: cFe,
			NotGreaterGreater: dFe,
			NotGreaterLess: fFe,
			NotGreaterSlantEqual: pFe,
			NotGreaterTilde: hFe,
			NotHumpDownHump: mFe,
			NotHumpEqual: vFe,
			notin: gFe,
			notindot: yFe,
			notinE: bFe,
			notinva: xFe,
			notinvb: wFe,
			notinvc: EFe,
			NotLeftTriangleBar: CFe,
			NotLeftTriangle: TFe,
			NotLeftTriangleEqual: kFe,
			NotLess: SFe,
			NotLessEqual: DFe,
			NotLessGreater: _Fe,
			NotLessLess: OFe,
			NotLessSlantEqual: AFe,
			NotLessTilde: NFe,
			NotNestedGreaterGreater: MFe,
			NotNestedLessLess: IFe,
			notni: RFe,
			notniva: LFe,
			notnivb: PFe,
			notnivc: jFe,
			NotPrecedes: FFe,
			NotPrecedesEqual: BFe,
			NotPrecedesSlantEqual: HFe,
			NotReverseElement: $Fe,
			NotRightTriangleBar: UFe,
			NotRightTriangle: zFe,
			NotRightTriangleEqual: qFe,
			NotSquareSubset: VFe,
			NotSquareSubsetEqual: WFe,
			NotSquareSuperset: YFe,
			NotSquareSupersetEqual: GFe,
			NotSubset: KFe,
			NotSubsetEqual: QFe,
			NotSucceeds: XFe,
			NotSucceedsEqual: JFe,
			NotSucceedsSlantEqual: ZFe,
			NotSucceedsTilde: e5e,
			NotSuperset: t5e,
			NotSupersetEqual: n5e,
			NotTilde: r5e,
			NotTildeEqual: i5e,
			NotTildeFullEqual: a5e,
			NotTildeTilde: o5e,
			NotVerticalBar: s5e,
			nparallel: l5e,
			npar: u5e,
			nparsl: c5e,
			npart: d5e,
			npolint: f5e,
			npr: p5e,
			nprcue: h5e,
			nprec: m5e,
			npreceq: v5e,
			npre: g5e,
			nrarrc: y5e,
			nrarr: b5e,
			nrArr: x5e,
			nrarrw: w5e,
			nrightarrow: E5e,
			nRightarrow: C5e,
			nrtri: T5e,
			nrtrie: k5e,
			nsc: S5e,
			nsccue: D5e,
			nsce: _5e,
			Nscr: O5e,
			nscr: A5e,
			nshortmid: N5e,
			nshortparallel: M5e,
			nsim: I5e,
			nsime: R5e,
			nsimeq: L5e,
			nsmid: P5e,
			nspar: j5e,
			nsqsube: F5e,
			nsqsupe: B5e,
			nsub: H5e,
			nsubE: $5e,
			nsube: U5e,
			nsubset: z5e,
			nsubseteq: q5e,
			nsubseteqq: V5e,
			nsucc: W5e,
			nsucceq: Y5e,
			nsup: G5e,
			nsupE: K5e,
			nsupe: Q5e,
			nsupset: X5e,
			nsupseteq: J5e,
			nsupseteqq: Z5e,
			ntgl: e8e,
			Ntilde: t8e,
			ntilde: n8e,
			ntlg: r8e,
			ntriangleleft: i8e,
			ntrianglelefteq: a8e,
			ntriangleright: o8e,
			ntrianglerighteq: s8e,
			Nu: l8e,
			nu: u8e,
			num: c8e,
			numero: d8e,
			numsp: f8e,
			nvap: p8e,
			nvdash: h8e,
			nvDash: m8e,
			nVdash: v8e,
			nVDash: g8e,
			nvge: y8e,
			nvgt: b8e,
			nvHarr: x8e,
			nvinfin: w8e,
			nvlArr: E8e,
			nvle: C8e,
			nvlt: T8e,
			nvltrie: k8e,
			nvrArr: S8e,
			nvrtrie: D8e,
			nvsim: _8e,
			nwarhk: O8e,
			nwarr: A8e,
			nwArr: N8e,
			nwarrow: M8e,
			nwnear: I8e,
			Oacute: R8e,
			oacute: L8e,
			oast: P8e,
			Ocirc: j8e,
			ocirc: F8e,
			ocir: B8e,
			Ocy: H8e,
			ocy: $8e,
			odash: U8e,
			Odblac: z8e,
			odblac: q8e,
			odiv: V8e,
			odot: W8e,
			odsold: Y8e,
			OElig: G8e,
			oelig: K8e,
			ofcir: Q8e,
			Ofr: X8e,
			ofr: J8e,
			ogon: Z8e,
			Ograve: eBe,
			ograve: tBe,
			ogt: nBe,
			ohbar: rBe,
			ohm: iBe,
			oint: aBe,
			olarr: oBe,
			olcir: sBe,
			olcross: lBe,
			oline: uBe,
			olt: cBe,
			Omacr: dBe,
			omacr: fBe,
			Omega: pBe,
			omega: hBe,
			Omicron: mBe,
			omicron: vBe,
			omid: gBe,
			ominus: yBe,
			Oopf: bBe,
			oopf: xBe,
			opar: wBe,
			OpenCurlyDoubleQuote: EBe,
			OpenCurlyQuote: CBe,
			operp: TBe,
			oplus: kBe,
			orarr: SBe,
			Or: DBe,
			or: _Be,
			ord: OBe,
			order: ABe,
			orderof: NBe,
			ordf: MBe,
			ordm: IBe,
			origof: RBe,
			oror: LBe,
			orslope: PBe,
			orv: jBe,
			oS: FBe,
			Oscr: BBe,
			oscr: HBe,
			Oslash: $Be,
			oslash: UBe,
			osol: zBe,
			Otilde: qBe,
			otilde: VBe,
			otimesas: WBe,
			Otimes: YBe,
			otimes: GBe,
			Ouml: KBe,
			ouml: QBe,
			ovbar: XBe,
			OverBar: JBe,
			OverBrace: ZBe,
			OverBracket: e9e,
			OverParenthesis: t9e,
			para: n9e,
			parallel: r9e,
			par: i9e,
			parsim: a9e,
			parsl: o9e,
			part: s9e,
			PartialD: l9e,
			Pcy: u9e,
			pcy: c9e,
			percnt: d9e,
			period: f9e,
			permil: p9e,
			perp: h9e,
			pertenk: m9e,
			Pfr: v9e,
			pfr: g9e,
			Phi: y9e,
			phi: b9e,
			phiv: x9e,
			phmmat: w9e,
			phone: E9e,
			Pi: C9e,
			pi: T9e,
			pitchfork: k9e,
			piv: S9e,
			planck: D9e,
			planckh: _9e,
			plankv: O9e,
			plusacir: A9e,
			plusb: N9e,
			pluscir: M9e,
			plus: I9e,
			plusdo: R9e,
			plusdu: L9e,
			pluse: P9e,
			PlusMinus: j9e,
			plusmn: F9e,
			plussim: B9e,
			plustwo: H9e,
			pm: $9e,
			Poincareplane: U9e,
			pointint: z9e,
			popf: q9e,
			Popf: V9e,
			pound: W9e,
			prap: Y9e,
			Pr: G9e,
			pr: K9e,
			prcue: Q9e,
			precapprox: X9e,
			prec: J9e,
			preccurlyeq: Z9e,
			Precedes: eHe,
			PrecedesEqual: tHe,
			PrecedesSlantEqual: nHe,
			PrecedesTilde: rHe,
			preceq: iHe,
			precnapprox: aHe,
			precneqq: oHe,
			precnsim: sHe,
			pre: lHe,
			prE: uHe,
			precsim: cHe,
			prime: dHe,
			Prime: fHe,
			primes: pHe,
			prnap: hHe,
			prnE: mHe,
			prnsim: vHe,
			prod: gHe,
			Product: yHe,
			profalar: bHe,
			profline: xHe,
			profsurf: wHe,
			prop: EHe,
			Proportional: CHe,
			Proportion: THe,
			propto: kHe,
			prsim: SHe,
			prurel: DHe,
			Pscr: _He,
			pscr: OHe,
			Psi: AHe,
			psi: NHe,
			puncsp: MHe,
			Qfr: IHe,
			qfr: RHe,
			qint: LHe,
			qopf: PHe,
			Qopf: jHe,
			qprime: FHe,
			Qscr: BHe,
			qscr: HHe,
			quaternions: $He,
			quatint: UHe,
			quest: zHe,
			questeq: qHe,
			quot: VHe,
			QUOT: WHe,
			rAarr: YHe,
			race: GHe,
			Racute: KHe,
			racute: QHe,
			radic: XHe,
			raemptyv: JHe,
			rang: ZHe,
			Rang: e$e,
			rangd: t$e,
			range: n$e,
			rangle: r$e,
			raquo: i$e,
			rarrap: a$e,
			rarrb: o$e,
			rarrbfs: s$e,
			rarrc: l$e,
			rarr: u$e,
			Rarr: c$e,
			rArr: d$e,
			rarrfs: f$e,
			rarrhk: p$e,
			rarrlp: h$e,
			rarrpl: m$e,
			rarrsim: v$e,
			Rarrtl: g$e,
			rarrtl: y$e,
			rarrw: b$e,
			ratail: x$e,
			rAtail: w$e,
			ratio: E$e,
			rationals: C$e,
			rbarr: T$e,
			rBarr: k$e,
			RBarr: S$e,
			rbbrk: D$e,
			rbrace: _$e,
			rbrack: O$e,
			rbrke: A$e,
			rbrksld: N$e,
			rbrkslu: M$e,
			Rcaron: I$e,
			rcaron: R$e,
			Rcedil: L$e,
			rcedil: P$e,
			rceil: j$e,
			rcub: F$e,
			Rcy: B$e,
			rcy: H$e,
			rdca: $$e,
			rdldhar: U$e,
			rdquo: z$e,
			rdquor: q$e,
			rdsh: V$e,
			real: W$e,
			realine: Y$e,
			realpart: G$e,
			reals: K$e,
			Re: Q$e,
			rect: X$e,
			reg: J$e,
			REG: Z$e,
			ReverseElement: e7e,
			ReverseEquilibrium: t7e,
			ReverseUpEquilibrium: n7e,
			rfisht: r7e,
			rfloor: i7e,
			rfr: a7e,
			Rfr: o7e,
			rHar: s7e,
			rhard: l7e,
			rharu: u7e,
			rharul: c7e,
			Rho: d7e,
			rho: f7e,
			rhov: p7e,
			RightAngleBracket: h7e,
			RightArrowBar: m7e,
			rightarrow: v7e,
			RightArrow: g7e,
			Rightarrow: y7e,
			RightArrowLeftArrow: b7e,
			rightarrowtail: x7e,
			RightCeiling: w7e,
			RightDoubleBracket: E7e,
			RightDownTeeVector: C7e,
			RightDownVectorBar: T7e,
			RightDownVector: k7e,
			RightFloor: S7e,
			rightharpoondown: D7e,
			rightharpoonup: _7e,
			rightleftarrows: O7e,
			rightleftharpoons: A7e,
			rightrightarrows: N7e,
			rightsquigarrow: M7e,
			RightTeeArrow: I7e,
			RightTee: R7e,
			RightTeeVector: L7e,
			rightthreetimes: P7e,
			RightTriangleBar: j7e,
			RightTriangle: F7e,
			RightTriangleEqual: B7e,
			RightUpDownVector: H7e,
			RightUpTeeVector: $7e,
			RightUpVectorBar: U7e,
			RightUpVector: z7e,
			RightVectorBar: q7e,
			RightVector: V7e,
			ring: W7e,
			risingdotseq: Y7e,
			rlarr: G7e,
			rlhar: K7e,
			rlm: Q7e,
			rmoustache: X7e,
			rmoust: J7e,
			rnmid: Z7e,
			roang: eUe,
			roarr: tUe,
			robrk: nUe,
			ropar: rUe,
			ropf: iUe,
			Ropf: aUe,
			roplus: oUe,
			rotimes: sUe,
			RoundImplies: lUe,
			rpar: uUe,
			rpargt: cUe,
			rppolint: dUe,
			rrarr: fUe,
			Rrightarrow: pUe,
			rsaquo: hUe,
			rscr: mUe,
			Rscr: vUe,
			rsh: gUe,
			Rsh: yUe,
			rsqb: bUe,
			rsquo: xUe,
			rsquor: wUe,
			rthree: EUe,
			rtimes: CUe,
			rtri: TUe,
			rtrie: kUe,
			rtrif: SUe,
			rtriltri: DUe,
			RuleDelayed: _Ue,
			ruluhar: OUe,
			rx: AUe,
			Sacute: NUe,
			sacute: MUe,
			sbquo: IUe,
			scap: RUe,
			Scaron: LUe,
			scaron: PUe,
			Sc: jUe,
			sc: FUe,
			sccue: BUe,
			sce: HUe,
			scE: $Ue,
			Scedil: UUe,
			scedil: zUe,
			Scirc: qUe,
			scirc: VUe,
			scnap: WUe,
			scnE: YUe,
			scnsim: GUe,
			scpolint: KUe,
			scsim: QUe,
			Scy: XUe,
			scy: JUe,
			sdotb: ZUe,
			sdot: eze,
			sdote: tze,
			searhk: nze,
			searr: rze,
			seArr: ize,
			searrow: aze,
			sect: oze,
			semi: sze,
			seswar: lze,
			setminus: uze,
			setmn: cze,
			sext: dze,
			Sfr: fze,
			sfr: pze,
			sfrown: hze,
			sharp: mze,
			SHCHcy: vze,
			shchcy: gze,
			SHcy: yze,
			shcy: bze,
			ShortDownArrow: xze,
			ShortLeftArrow: wze,
			shortmid: Eze,
			shortparallel: Cze,
			ShortRightArrow: Tze,
			ShortUpArrow: kze,
			shy: Sze,
			Sigma: Dze,
			sigma: _ze,
			sigmaf: Oze,
			sigmav: Aze,
			sim: Nze,
			simdot: Mze,
			sime: Ize,
			simeq: Rze,
			simg: Lze,
			simgE: Pze,
			siml: jze,
			simlE: Fze,
			simne: Bze,
			simplus: Hze,
			simrarr: $ze,
			slarr: Uze,
			SmallCircle: zze,
			smallsetminus: qze,
			smashp: Vze,
			smeparsl: Wze,
			smid: Yze,
			smile: Gze,
			smt: Kze,
			smte: Qze,
			smtes: Xze,
			SOFTcy: Jze,
			softcy: Zze,
			solbar: eqe,
			solb: tqe,
			sol: nqe,
			Sopf: rqe,
			sopf: iqe,
			spades: aqe,
			spadesuit: oqe,
			spar: sqe,
			sqcap: lqe,
			sqcaps: uqe,
			sqcup: cqe,
			sqcups: dqe,
			Sqrt: fqe,
			sqsub: pqe,
			sqsube: hqe,
			sqsubset: mqe,
			sqsubseteq: vqe,
			sqsup: gqe,
			sqsupe: yqe,
			sqsupset: bqe,
			sqsupseteq: xqe,
			square: wqe,
			Square: Eqe,
			SquareIntersection: Cqe,
			SquareSubset: Tqe,
			SquareSubsetEqual: kqe,
			SquareSuperset: Sqe,
			SquareSupersetEqual: Dqe,
			SquareUnion: _qe,
			squarf: Oqe,
			squ: Aqe,
			squf: Nqe,
			srarr: Mqe,
			Sscr: Iqe,
			sscr: Rqe,
			ssetmn: Lqe,
			ssmile: Pqe,
			sstarf: jqe,
			Star: Fqe,
			star: Bqe,
			starf: Hqe,
			straightepsilon: $qe,
			straightphi: Uqe,
			strns: zqe,
			sub: qqe,
			Sub: Vqe,
			subdot: Wqe,
			subE: Yqe,
			sube: Gqe,
			subedot: Kqe,
			submult: Qqe,
			subnE: Xqe,
			subne: Jqe,
			subplus: Zqe,
			subrarr: eVe,
			subset: tVe,
			Subset: nVe,
			subseteq: rVe,
			subseteqq: iVe,
			SubsetEqual: aVe,
			subsetneq: oVe,
			subsetneqq: sVe,
			subsim: lVe,
			subsub: uVe,
			subsup: cVe,
			succapprox: dVe,
			succ: fVe,
			succcurlyeq: pVe,
			Succeeds: hVe,
			SucceedsEqual: mVe,
			SucceedsSlantEqual: vVe,
			SucceedsTilde: gVe,
			succeq: yVe,
			succnapprox: bVe,
			succneqq: xVe,
			succnsim: wVe,
			succsim: EVe,
			SuchThat: CVe,
			sum: TVe,
			Sum: kVe,
			sung: SVe,
			sup1: DVe,
			sup2: _Ve,
			sup3: OVe,
			sup: AVe,
			Sup: NVe,
			supdot: MVe,
			supdsub: IVe,
			supE: RVe,
			supe: LVe,
			supedot: PVe,
			Superset: jVe,
			SupersetEqual: FVe,
			suphsol: BVe,
			suphsub: HVe,
			suplarr: $Ve,
			supmult: UVe,
			supnE: zVe,
			supne: qVe,
			supplus: VVe,
			supset: WVe,
			Supset: YVe,
			supseteq: GVe,
			supseteqq: KVe,
			supsetneq: QVe,
			supsetneqq: XVe,
			supsim: JVe,
			supsub: ZVe,
			supsup: eWe,
			swarhk: tWe,
			swarr: nWe,
			swArr: rWe,
			swarrow: iWe,
			swnwar: aWe,
			szlig: oWe,
			Tab: sWe,
			target: lWe,
			Tau: uWe,
			tau: cWe,
			tbrk: dWe,
			Tcaron: fWe,
			tcaron: pWe,
			Tcedil: hWe,
			tcedil: mWe,
			Tcy: vWe,
			tcy: gWe,
			tdot: yWe,
			telrec: bWe,
			Tfr: xWe,
			tfr: wWe,
			there4: EWe,
			therefore: CWe,
			Therefore: TWe,
			Theta: kWe,
			theta: SWe,
			thetasym: DWe,
			thetav: _We,
			thickapprox: OWe,
			thicksim: AWe,
			ThickSpace: NWe,
			ThinSpace: MWe,
			thinsp: IWe,
			thkap: RWe,
			thksim: LWe,
			THORN: PWe,
			thorn: jWe,
			tilde: FWe,
			Tilde: BWe,
			TildeEqual: HWe,
			TildeFullEqual: $We,
			TildeTilde: UWe,
			timesbar: zWe,
			timesb: qWe,
			times: VWe,
			timesd: WWe,
			tint: YWe,
			toea: GWe,
			topbot: KWe,
			topcir: QWe,
			top: XWe,
			Topf: JWe,
			topf: ZWe,
			topfork: eYe,
			tosa: tYe,
			tprime: nYe,
			trade: rYe,
			TRADE: iYe,
			triangle: aYe,
			triangledown: oYe,
			triangleleft: sYe,
			trianglelefteq: lYe,
			triangleq: uYe,
			triangleright: cYe,
			trianglerighteq: dYe,
			tridot: fYe,
			trie: pYe,
			triminus: hYe,
			TripleDot: mYe,
			triplus: vYe,
			trisb: gYe,
			tritime: yYe,
			trpezium: bYe,
			Tscr: xYe,
			tscr: wYe,
			TScy: EYe,
			tscy: CYe,
			TSHcy: TYe,
			tshcy: kYe,
			Tstrok: SYe,
			tstrok: DYe,
			twixt: _Ye,
			twoheadleftarrow: OYe,
			twoheadrightarrow: AYe,
			Uacute: NYe,
			uacute: MYe,
			uarr: IYe,
			Uarr: RYe,
			uArr: LYe,
			Uarrocir: PYe,
			Ubrcy: jYe,
			ubrcy: FYe,
			Ubreve: BYe,
			ubreve: HYe,
			Ucirc: $Ye,
			ucirc: UYe,
			Ucy: zYe,
			ucy: qYe,
			udarr: VYe,
			Udblac: WYe,
			udblac: YYe,
			udhar: GYe,
			ufisht: KYe,
			Ufr: QYe,
			ufr: XYe,
			Ugrave: JYe,
			ugrave: ZYe,
			uHar: eGe,
			uharl: tGe,
			uharr: nGe,
			uhblk: rGe,
			ulcorn: iGe,
			ulcorner: aGe,
			ulcrop: oGe,
			ultri: sGe,
			Umacr: lGe,
			umacr: uGe,
			uml: cGe,
			UnderBar: dGe,
			UnderBrace: fGe,
			UnderBracket: pGe,
			UnderParenthesis: hGe,
			Union: mGe,
			UnionPlus: vGe,
			Uogon: gGe,
			uogon: yGe,
			Uopf: bGe,
			uopf: xGe,
			UpArrowBar: wGe,
			uparrow: EGe,
			UpArrow: CGe,
			Uparrow: TGe,
			UpArrowDownArrow: kGe,
			updownarrow: SGe,
			UpDownArrow: DGe,
			Updownarrow: _Ge,
			UpEquilibrium: OGe,
			upharpoonleft: AGe,
			upharpoonright: NGe,
			uplus: MGe,
			UpperLeftArrow: IGe,
			UpperRightArrow: RGe,
			upsi: LGe,
			Upsi: PGe,
			upsih: jGe,
			Upsilon: FGe,
			upsilon: BGe,
			UpTeeArrow: HGe,
			UpTee: $Ge,
			upuparrows: UGe,
			urcorn: zGe,
			urcorner: qGe,
			urcrop: VGe,
			Uring: WGe,
			uring: YGe,
			urtri: GGe,
			Uscr: KGe,
			uscr: QGe,
			utdot: XGe,
			Utilde: JGe,
			utilde: ZGe,
			utri: eKe,
			utrif: tKe,
			uuarr: nKe,
			Uuml: rKe,
			uuml: iKe,
			uwangle: aKe,
			vangrt: oKe,
			varepsilon: sKe,
			varkappa: lKe,
			varnothing: uKe,
			varphi: cKe,
			varpi: dKe,
			varpropto: fKe,
			varr: pKe,
			vArr: hKe,
			varrho: mKe,
			varsigma: vKe,
			varsubsetneq: gKe,
			varsubsetneqq: yKe,
			varsupsetneq: bKe,
			varsupsetneqq: xKe,
			vartheta: wKe,
			vartriangleleft: EKe,
			vartriangleright: CKe,
			vBar: TKe,
			Vbar: kKe,
			vBarv: SKe,
			Vcy: DKe,
			vcy: _Ke,
			vdash: OKe,
			vDash: AKe,
			Vdash: NKe,
			VDash: MKe,
			Vdashl: IKe,
			veebar: RKe,
			vee: LKe,
			Vee: PKe,
			veeeq: jKe,
			vellip: FKe,
			verbar: BKe,
			Verbar: HKe,
			vert: $Ke,
			Vert: UKe,
			VerticalBar: zKe,
			VerticalLine: qKe,
			VerticalSeparator: VKe,
			VerticalTilde: WKe,
			VeryThinSpace: YKe,
			Vfr: GKe,
			vfr: KKe,
			vltri: QKe,
			vnsub: XKe,
			vnsup: JKe,
			Vopf: ZKe,
			vopf: eQe,
			vprop: tQe,
			vrtri: nQe,
			Vscr: rQe,
			vscr: iQe,
			vsubnE: aQe,
			vsubne: oQe,
			vsupnE: sQe,
			vsupne: lQe,
			Vvdash: uQe,
			vzigzag: cQe,
			Wcirc: dQe,
			wcirc: fQe,
			wedbar: pQe,
			wedge: hQe,
			Wedge: mQe,
			wedgeq: vQe,
			weierp: gQe,
			Wfr: yQe,
			wfr: bQe,
			Wopf: xQe,
			wopf: wQe,
			wp: EQe,
			wr: CQe,
			wreath: TQe,
			Wscr: kQe,
			wscr: SQe,
			xcap: DQe,
			xcirc: _Qe,
			xcup: OQe,
			xdtri: AQe,
			Xfr: NQe,
			xfr: MQe,
			xharr: IQe,
			xhArr: RQe,
			Xi: LQe,
			xi: PQe,
			xlarr: jQe,
			xlArr: FQe,
			xmap: BQe,
			xnis: HQe,
			xodot: $Qe,
			Xopf: UQe,
			xopf: zQe,
			xoplus: qQe,
			xotime: VQe,
			xrarr: WQe,
			xrArr: YQe,
			Xscr: GQe,
			xscr: KQe,
			xsqcup: QQe,
			xuplus: XQe,
			xutri: JQe,
			xvee: ZQe,
			xwedge: eXe,
			Yacute: tXe,
			yacute: nXe,
			YAcy: rXe,
			yacy: iXe,
			Ycirc: aXe,
			ycirc: oXe,
			Ycy: sXe,
			ycy: lXe,
			yen: uXe,
			Yfr: cXe,
			yfr: dXe,
			YIcy: fXe,
			yicy: pXe,
			Yopf: hXe,
			yopf: mXe,
			Yscr: vXe,
			yscr: gXe,
			YUcy: yXe,
			yucy: bXe,
			yuml: xXe,
			Yuml: wXe,
			Zacute: EXe,
			zacute: CXe,
			Zcaron: TXe,
			zcaron: kXe,
			Zcy: SXe,
			zcy: DXe,
			Zdot: _Xe,
			zdot: OXe,
			zeetrf: AXe,
			ZeroWidthSpace: NXe,
			Zeta: MXe,
			zeta: IXe,
			zfr: RXe,
			Zfr: LXe,
			ZHcy: PXe,
			zhcy: jXe,
			zigrarr: FXe,
			zopf: BXe,
			Zopf: HXe,
			Zscr: $Xe,
			zscr: UXe,
			zwj: zXe,
			zwnj: qXe,
		},
		VXe = "",
		WXe = "",
		YXe = "",
		GXe = "",
		KXe = "",
		QXe = "",
		XXe = "",
		JXe = "",
		ZXe = "",
		eJe = "&",
		tJe = "&",
		nJe = "",
		rJe = "",
		iJe = "",
		aJe = "",
		oJe = "",
		sJe = "",
		lJe = "",
		uJe = "",
		cJe = "",
		dJe = "",
		fJe = "",
		pJe = "",
		hJe = "",
		mJe = "",
		vJe = "",
		gJe = "",
		yJe = "",
		bJe = "",
		xJe = "",
		wJe = "",
		EJe = "",
		CJe = "",
		TJe = "",
		kJe = "",
		SJe = "",
		DJe = "",
		_Je = "",
		OJe = "",
		AJe = "",
		NJe = ">",
		MJe = ">",
		IJe = "",
		RJe = "",
		LJe = "",
		PJe = "",
		jJe = "",
		FJe = "",
		BJe = "",
		HJe = "",
		$Je = "",
		UJe = "",
		zJe = "",
		qJe = "<",
		VJe = "<",
		WJe = "",
		YJe = "",
		GJe = "",
		KJe = "",
		QJe = "",
		XJe = "",
		JJe = "",
		ZJe = "",
		eZe = "",
		tZe = "",
		nZe = "",
		rZe = "",
		iZe = "",
		aZe = "",
		oZe = "",
		sZe = "",
		lZe = "",
		uZe = "",
		cZe = "",
		dZe = "",
		fZe = "",
		pZe = "",
		hZe = "",
		mZe = "",
		vZe = '"',
		gZe = '"',
		yZe = "",
		bZe = "",
		xZe = "",
		wZe = "",
		EZe = "",
		CZe = "",
		TZe = "",
		kZe = "",
		SZe = "",
		DZe = "",
		_Ze = "",
		OZe = "",
		AZe = "",
		NZe = "",
		MZe = "",
		IZe = "",
		RZe = "",
		LZe = "",
		PZe = "",
		jZe = "",
		FZe = "",
		BZe = "",
		HZe = "",
		$Ze = "",
		UZe = "",
		zZe = {
			Aacute: VXe,
			aacute: WXe,
			Acirc: YXe,
			acirc: GXe,
			acute: KXe,
			AElig: QXe,
			aelig: XXe,
			Agrave: JXe,
			agrave: ZXe,
			amp: eJe,
			AMP: tJe,
			Aring: nJe,
			aring: rJe,
			Atilde: iJe,
			atilde: aJe,
			Auml: oJe,
			auml: sJe,
			brvbar: lJe,
			Ccedil: uJe,
			ccedil: cJe,
			cedil: dJe,
			cent: fJe,
			copy: pJe,
			COPY: hJe,
			curren: mJe,
			deg: vJe,
			divide: gJe,
			Eacute: yJe,
			eacute: bJe,
			Ecirc: xJe,
			ecirc: wJe,
			Egrave: EJe,
			egrave: CJe,
			ETH: TJe,
			eth: kJe,
			Euml: SJe,
			euml: DJe,
			frac12: _Je,
			frac14: OJe,
			frac34: AJe,
			gt: NJe,
			GT: MJe,
			Iacute: IJe,
			iacute: RJe,
			Icirc: LJe,
			icirc: PJe,
			iexcl: jJe,
			Igrave: FJe,
			igrave: BJe,
			iquest: HJe,
			Iuml: $Je,
			iuml: UJe,
			laquo: zJe,
			lt: qJe,
			LT: VJe,
			macr: WJe,
			micro: YJe,
			middot: GJe,
			nbsp: KJe,
			not: QJe,
			Ntilde: XJe,
			ntilde: JJe,
			Oacute: ZJe,
			oacute: eZe,
			Ocirc: tZe,
			ocirc: nZe,
			Ograve: rZe,
			ograve: iZe,
			ordf: aZe,
			ordm: oZe,
			Oslash: sZe,
			oslash: lZe,
			Otilde: uZe,
			otilde: cZe,
			Ouml: dZe,
			ouml: fZe,
			para: pZe,
			plusmn: hZe,
			pound: mZe,
			quot: vZe,
			QUOT: gZe,
			raquo: yZe,
			reg: bZe,
			REG: xZe,
			sect: wZe,
			shy: EZe,
			sup1: CZe,
			sup2: TZe,
			sup3: kZe,
			szlig: SZe,
			THORN: DZe,
			thorn: _Ze,
			times: OZe,
			Uacute: AZe,
			uacute: NZe,
			Ucirc: MZe,
			ucirc: IZe,
			Ugrave: RZe,
			ugrave: LZe,
			uml: PZe,
			Uuml: jZe,
			uuml: FZe,
			Yacute: BZe,
			yacute: HZe,
			yen: $Ze,
			yuml: UZe,
		},
		qZe = "&",
		VZe = "'",
		WZe = ">",
		YZe = "<",
		GZe = '"',
		Ez = { amp: qZe, apos: VZe, gt: WZe, lt: YZe, quot: GZe },
		rA = {},
		KZe = {
			0: 65533,
			128: 8364,
			130: 8218,
			131: 402,
			132: 8222,
			133: 8230,
			134: 8224,
			135: 8225,
			136: 710,
			137: 8240,
			138: 352,
			139: 8249,
			140: 338,
			142: 381,
			145: 8216,
			146: 8217,
			147: 8220,
			148: 8221,
			149: 8226,
			150: 8211,
			151: 8212,
			152: 732,
			153: 8482,
			154: 353,
			155: 8250,
			156: 339,
			158: 382,
			159: 376,
		},
		QZe =
			(xp && xp.__importDefault) ||
			function (e) {
				return e && e.__esModule ? e : { default: e }
			}
	Object.defineProperty(rA, "__esModule", { value: !0 })
	var S4 = QZe(KZe),
		XZe =
			String.fromCodePoint ||
			function (e) {
				var t = ""
				return (
					e > 65535 &&
						((e -= 65536),
						(t += String.fromCharCode(((e >>> 10) & 1023) | 55296)),
						(e = 56320 | (e & 1023))),
					(t += String.fromCharCode(e)),
					t
				)
			}
	function JZe(e) {
		return (e >= 55296 && e <= 57343) || e > 1114111
			? ""
			: (e in S4.default && (e = S4.default[e]), XZe(e))
	}
	rA.default = JZe
	var hw =
		(xp && xp.__importDefault) ||
		function (e) {
			return e && e.__esModule ? e : { default: e }
		}
	Object.defineProperty(pl, "__esModule", { value: !0 })
	pl.decodeHTML = pl.decodeHTMLStrict = pl.decodeXML = void 0
	var U2 = hw(wz),
		ZZe = hw(zZe),
		eet = hw(Ez),
		D4 = hw(rA),
		tet = /&(?:[a-zA-Z0-9]+|#[xX][\da-fA-F]+|#\d+);/g
	pl.decodeXML = Cz(eet.default)
	pl.decodeHTMLStrict = Cz(U2.default)
	function Cz(e) {
		var t = Tz(e)
		return function (n) {
			return String(n).replace(tet, t)
		}
	}
	var _4 = function (e, t) {
		return e < t ? 1 : -1
	}
	pl.decodeHTML = (function () {
		for (
			var e = Object.keys(ZZe.default).sort(_4), t = Object.keys(U2.default).sort(_4), n = 0, r = 0;
			n < t.length;
			n++
		)
			e[r] === t[n] ? ((t[n] += ";?"), r++) : (t[n] += ";")
		var i = new RegExp("&(?:" + t.join("|") + "|#[xX][\\da-fA-F]+;?|#\\d+;?)", "g"),
			a = Tz(U2.default)
		function o(s) {
			return s.substr(-1) !== ";" && (s += ";"), a(s)
		}
		return function (s) {
			return String(s).replace(i, o)
		}
	})()
	function Tz(e) {
		return function (n) {
			if (n.charAt(1) === "#") {
				var r = n.charAt(2)
				return r === "X" || r === "x"
					? D4.default(parseInt(n.substr(3), 16))
					: D4.default(parseInt(n.substr(2), 10))
			}
			return e[n.slice(1, -1)] || n
		}
	}
	var sa = {},
		kz =
			(xp && xp.__importDefault) ||
			function (e) {
				return e && e.__esModule ? e : { default: e }
			}
	Object.defineProperty(sa, "__esModule", { value: !0 })
	sa.escapeUTF8 = sa.escape = sa.encodeNonAsciiHTML = sa.encodeHTML = sa.encodeXML = void 0
	var net = kz(Ez),
		Sz = _z(net.default),
		Dz = Oz(Sz)
	sa.encodeXML = Mz(Sz)
	var ret = kz(wz),
		iA = _z(ret.default),
		iet = Oz(iA)
	sa.encodeHTML = oet(iA, iet)
	sa.encodeNonAsciiHTML = Mz(iA)
	function _z(e) {
		return Object.keys(e)
			.sort()
			.reduce(function (t, n) {
				return (t[e[n]] = "&" + n + ";"), t
			}, {})
	}
	function Oz(e) {
		for (var t = [], n = [], r = 0, i = Object.keys(e); r < i.length; r++) {
			var a = i[r]
			a.length === 1 ? t.push("\\" + a) : n.push(a)
		}
		t.sort()
		for (var o = 0; o < t.length - 1; o++) {
			for (var s = o; s < t.length - 1 && t[s].charCodeAt(1) + 1 === t[s + 1].charCodeAt(1); )
				s += 1
			var l = 1 + s - o
			l < 3 || t.splice(o, l, t[o] + "-" + t[s])
		}
		return n.unshift("[" + t.join("") + "]"), new RegExp(n.join("|"), "g")
	}
	var Az =
			/(?:[\x80-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/g,
		aet =
			String.prototype.codePointAt != null
				? function (e) {
						return e.codePointAt(0)
				  }
				: function (e) {
						return (e.charCodeAt(0) - 55296) * 1024 + e.charCodeAt(1) - 56320 + 65536
				  }
	function mw(e) {
		return "&#x" + (e.length > 1 ? aet(e) : e.charCodeAt(0)).toString(16).toUpperCase() + ";"
	}
	function oet(e, t) {
		return function (n) {
			return n
				.replace(t, function (r) {
					return e[r]
				})
				.replace(Az, mw)
		}
	}
	var Nz = new RegExp(Dz.source + "|" + Az.source, "g")
	function set(e) {
		return e.replace(Nz, mw)
	}
	sa.escape = set
	function uet(e) {
		return e.replace(Dz, mw)
	}
	sa.escapeUTF8 = uet
	function Mz(e) {
		return function (t) {
			return t.replace(Nz, function (n) {
				return e[n] || mw(n)
			})
		}
	}
	;(function (e) {
		Object.defineProperty(e, "__esModule", { value: !0 }),
			(e.decodeXMLStrict =
				e.decodeHTML5Strict =
				e.decodeHTML4Strict =
				e.decodeHTML5 =
				e.decodeHTML4 =
				e.decodeHTMLStrict =
				e.decodeHTML =
				e.decodeXML =
				e.encodeHTML5 =
				e.encodeHTML4 =
				e.escapeUTF8 =
				e.escape =
				e.encodeNonAsciiHTML =
				e.encodeHTML =
				e.encodeXML =
				e.encode =
				e.decodeStrict =
				e.decode =
					void 0)
		var t = pl,
			n = sa
		function r(l, u) {
			return (!u || u <= 0 ? t.decodeXML : t.decodeHTML)(l)
		}
		e.decode = r
		function i(l, u) {
			return (!u || u <= 0 ? t.decodeXML : t.decodeHTMLStrict)(l)
		}
		e.decodeStrict = i
		function a(l, u) {
			return (!u || u <= 0 ? n.encodeXML : n.encodeHTML)(l)
		}
		e.encode = a
		var o = sa
		Object.defineProperty(e, "encodeXML", {
			enumerable: !0,
			get: function () {
				return o.encodeXML
			},
		}),
			Object.defineProperty(e, "encodeHTML", {
				enumerable: !0,
				get: function () {
					return o.encodeHTML
				},
			}),
			Object.defineProperty(e, "encodeNonAsciiHTML", {
				enumerable: !0,
				get: function () {
					return o.encodeNonAsciiHTML
				},
			}),
			Object.defineProperty(e, "escape", {
				enumerable: !0,
				get: function () {
					return o.escape
				},
			}),
			Object.defineProperty(e, "escapeUTF8", {
				enumerable: !0,
				get: function () {
					return o.escapeUTF8
				},
			}),
			Object.defineProperty(e, "encodeHTML4", {
				enumerable: !0,
				get: function () {
					return o.encodeHTML
				},
			}),
			Object.defineProperty(e, "encodeHTML5", {
				enumerable: !0,
				get: function () {
					return o.encodeHTML
				},
			})
		var s = pl
		Object.defineProperty(e, "decodeXML", {
			enumerable: !0,
			get: function () {
				return s.decodeXML
			},
		}),
			Object.defineProperty(e, "decodeHTML", {
				enumerable: !0,
				get: function () {
					return s.decodeHTML
				},
			}),
			Object.defineProperty(e, "decodeHTMLStrict", {
				enumerable: !0,
				get: function () {
					return s.decodeHTMLStrict
				},
			}),
			Object.defineProperty(e, "decodeHTML4", {
				enumerable: !0,
				get: function () {
					return s.decodeHTML
				},
			}),
			Object.defineProperty(e, "decodeHTML5", {
				enumerable: !0,
				get: function () {
					return s.decodeHTML
				},
			}),
			Object.defineProperty(e, "decodeHTML4Strict", {
				enumerable: !0,
				get: function () {
					return s.decodeHTMLStrict
				},
			}),
			Object.defineProperty(e, "decodeHTML5Strict", {
				enumerable: !0,
				get: function () {
					return s.decodeHTMLStrict
				},
			}),
			Object.defineProperty(e, "decodeXMLStrict", {
				enumerable: !0,
				get: function () {
					return s.decodeXML
				},
			})
	})(nA)
	var Iz = "&(?:#x[a-f0-9]{1,6}|#[0-9]{1,7}|[a-z][a-z0-9]{1,31});",
		cet = 92,
		det = /[\\&]/,
		aA = "[!\"#$%&'()*+,./:;<=>?@[\\\\\\]^_`{|}~-]",
		fet = new RegExp("\\\\" + aA + "|" + Iz, "gi"),
		pet = '[&<>"]',
		O4 = new RegExp(pet, "g"),
		het = function (e) {
			return e.charCodeAt(0) === cet ? e.charAt(1) : nA.decodeHTML(e)
		}
	function Vm(e) {
		return det.test(e) ? e.replace(fet, het) : e
	}
	function sy(e) {
		try {
			return Dxe(e)
		} catch {
			return e
		}
	}
	function met(e) {
		switch (e) {
			case "&":
				return "&amp;"
			case "<":
				return "&lt;"
			case ">":
				return "&gt;"
			case '"':
				return "&quot;"
			default:
				return e
		}
	}
	function Af(e) {
		return O4.test(e) ? e.replace(O4, met) : e
	}
	function z2(e, t) {
		for (var n = [], r = 0; r < t; r++) n.push(e)
		return n.join("")
	}
	function A4(e) {
		return e ? !/[^ \t]+/.test(e) : !0
	}
	var vet = (function () {
		function e(t) {
			;(this.current = t), (this.root = t), (this.entering = !0)
		}
		return (
			(e.prototype.next = function () {
				var t = this.current,
					n = this.entering
				if (t === null) return null
				var r = oA(t)
				return (
					n && r
						? t.firstChild
							? ((this.current = t.firstChild), (this.entering = !0))
							: (this.entering = !1)
						: t === this.root
						? (this.current = null)
						: t.next === null
						? ((this.current = t.parent), (this.entering = !1))
						: ((this.current = t.next), (this.entering = !0)),
					{ entering: n, node: t }
				)
			}),
			(e.prototype.resumeAt = function (t, n) {
				;(this.current = t), (this.entering = n === !0)
			}),
			e
		)
	})()
	function oA(e) {
		switch (e.type) {
			case "document":
			case "blockQuote":
			case "list":
			case "item":
			case "paragraph":
			case "heading":
			case "emph":
			case "strong":
			case "strike":
			case "link":
			case "image":
			case "table":
			case "tableHead":
			case "tableBody":
			case "tableRow":
			case "tableCell":
			case "tableDelimRow":
			case "customInline":
				return !0
			default:
				return !1
		}
	}
	var get = 1,
		vw = {}
	function yet(e) {
		return vw[e]
	}
	function q2(e) {
		delete vw[e]
	}
	function bet() {
		vw = {}
	}
	var mg = (function () {
			function e(t, n) {
				;(this.parent = null),
					(this.prev = null),
					(this.next = null),
					(this.firstChild = null),
					(this.lastChild = null),
					(this.literal = null),
					t === "document" ? (this.id = -1) : (this.id = get++),
					(this.type = t),
					(this.sourcepos = n),
					(vw[this.id] = this)
			}
			return (
				(e.prototype.isContainer = function () {
					return oA(this)
				}),
				(e.prototype.unlink = function () {
					this.prev
						? (this.prev.next = this.next)
						: this.parent && (this.parent.firstChild = this.next),
						this.next
							? (this.next.prev = this.prev)
							: this.parent && (this.parent.lastChild = this.prev),
						(this.parent = null),
						(this.next = null),
						(this.prev = null)
				}),
				(e.prototype.replaceWith = function (t) {
					this.insertBefore(t), this.unlink()
				}),
				(e.prototype.insertAfter = function (t) {
					t.unlink(),
						(t.next = this.next),
						t.next && (t.next.prev = t),
						(t.prev = this),
						(this.next = t),
						this.parent && ((t.parent = this.parent), t.next || (t.parent.lastChild = t))
				}),
				(e.prototype.insertBefore = function (t) {
					t.unlink(),
						(t.prev = this.prev),
						t.prev && (t.prev.next = t),
						(t.next = this),
						(this.prev = t),
						(t.parent = this.parent),
						t.prev || (t.parent.firstChild = t)
				}),
				(e.prototype.appendChild = function (t) {
					t.unlink(),
						(t.parent = this),
						this.lastChild
							? ((this.lastChild.next = t), (t.prev = this.lastChild), (this.lastChild = t))
							: ((this.firstChild = t), (this.lastChild = t))
				}),
				(e.prototype.prependChild = function (t) {
					t.unlink(),
						(t.parent = this),
						this.firstChild
							? ((this.firstChild.prev = t), (t.next = this.firstChild), (this.firstChild = t))
							: ((this.firstChild = t), (this.lastChild = t))
				}),
				(e.prototype.walker = function () {
					return new vet(this)
				}),
				e
			)
		})(),
		Ml = (function (e) {
			eo(t, e)
			function t(n, r) {
				var i = e.call(this, n, r) || this
				return (
					(i.open = !0),
					(i.lineOffsets = null),
					(i.stringContent = null),
					(i.lastLineBlank = !1),
					(i.lastLineChecked = !1),
					(i.type = n),
					i
				)
			}
			return t
		})(mg),
		xet = (function (e) {
			eo(t, e)
			function t() {
				var n = (e !== null && e.apply(this, arguments)) || this
				return (n.listData = null), n
			}
			return t
		})(Ml),
		wet = (function (e) {
			eo(t, e)
			function t() {
				var n = (e !== null && e.apply(this, arguments)) || this
				return (n.level = 0), (n.headingType = "atx"), n
			}
			return t
		})(Ml),
		Eet = (function (e) {
			eo(t, e)
			function t() {
				var n = (e !== null && e.apply(this, arguments)) || this
				return (
					(n.isFenced = !1),
					(n.fenceChar = null),
					(n.fenceLength = 0),
					(n.fenceOffset = -1),
					(n.info = null),
					(n.infoPadding = 0),
					n
				)
			}
			return t
		})(Ml),
		Cet = (function (e) {
			eo(t, e)
			function t() {
				var n = (e !== null && e.apply(this, arguments)) || this
				return (n.columns = []), n
			}
			return t
		})(Ml),
		Tet = (function (e) {
			eo(t, e)
			function t() {
				var n = (e !== null && e.apply(this, arguments)) || this
				return (
					(n.startIdx = 0),
					(n.endIdx = 0),
					(n.paddingLeft = 0),
					(n.paddingRight = 0),
					(n.ignored = !1),
					n
				)
			}
			return t
		})(Ml),
		ket = (function (e) {
			eo(t, e)
			function t() {
				var n = (e !== null && e.apply(this, arguments)) || this
				return (n.title = ""), (n.dest = ""), (n.label = ""), n
			}
			return t
		})(Ml),
		Det = (function (e) {
			eo(t, e)
			function t() {
				var n = (e !== null && e.apply(this, arguments)) || this
				return (n.syntaxLength = 0), (n.offset = -1), (n.info = ""), n
			}
			return t
		})(Ml),
		_et = (function (e) {
			eo(t, e)
			function t() {
				var n = (e !== null && e.apply(this, arguments)) || this
				return (n.htmlBlockType = -1), n
			}
			return t
		})(Ml),
		Oet = (function (e) {
			eo(t, e)
			function t() {
				var n = (e !== null && e.apply(this, arguments)) || this
				return (n.destination = null), (n.title = null), (n.extendedAutolink = !1), n
			}
			return t
		})(mg),
		Aet = (function (e) {
			eo(t, e)
			function t() {
				var n = (e !== null && e.apply(this, arguments)) || this
				return (n.tickCount = 0), n
			}
			return t
		})(mg),
		Net = (function (e) {
			eo(t, e)
			function t() {
				var n = (e !== null && e.apply(this, arguments)) || this
				return (n.info = ""), n
			}
			return t
		})(mg)
	function Xn(e, t) {
		switch (e) {
			case "heading":
				return new wet(e, t)
			case "list":
			case "item":
				return new xet(e, t)
			case "link":
			case "image":
				return new Oet(e, t)
			case "codeBlock":
				return new Eet(e, t)
			case "htmlBlock":
				return new _et(e, t)
			case "table":
				return new Cet(e, t)
			case "tableCell":
				return new Tet(e, t)
			case "document":
			case "paragraph":
			case "blockQuote":
			case "thematicBreak":
			case "tableRow":
			case "tableBody":
			case "tableHead":
			case "frontMatter":
				return new Ml(e, t)
			case "code":
				return new Aet(e, t)
			case "refDef":
				return new ket(e, t)
			case "customBlock":
				return new Det(e, t)
			case "customInline":
				return new Net(e, t)
			default:
				return new mg(e, t)
		}
	}
	function Rz(e) {
		return e.type === "codeBlock"
	}
	function Met(e) {
		return e.type === "htmlBlock"
	}
	function Iet(e) {
		return e.type === "heading"
	}
	function N4(e) {
		return e.type === "list"
	}
	function Ret(e) {
		return e.type === "table"
	}
	function xf(e) {
		return e.type === "refDef"
	}
	function Lz(e) {
		return e.type === "customBlock"
	}
	function Let(e) {
		return e.type === "customInline"
	}
	function hr(e, t) {
		var n = Xn("text", t)
		return (n.literal = e), n
	}
	var Pz = "[A-Za-z][A-Za-z0-9-]*",
		Pet = "[a-zA-Z_:][a-zA-Z0-9:._-]*",
		jet = "[^\"'=<>`\\x00-\\x20]+",
		Fet = "'[^']*'",
		Bet = '"[^"]*"',
		Het = "(?:" + jet + "|" + Fet + "|" + Bet + ")",
		$et = "(?:\\s*=\\s*" + Het + ")",
		Uet = "(?:\\s+" + Pet + $et + "?)",
		jz = "<" + Pz + Uet + "*\\s*/?>",
		Fz = "</" + Pz + "\\s*[>]",
		zet = "<!---->|<!--(?:-?[^>-])(?:-?[^-])*-->",
		qet = "[<][?].*?[?][>]",
		Vet = "<![A-Z]+\\s+[^>]*>",
		Wet = "<!\\[CDATA\\[[\\s\\S]*?\\]\\]>",
		Yet = "(?:" + jz + "|" + Fz + "|" + zet + "|" + qet + "|" + Vet + "|" + Wet + ")",
		Get = new RegExp("^" + Yet, "i")
	/*! http://mths.be/fromcodepoint v0.2.1 by @mathias */ var V2
	if (String.fromCodePoint)
		V2 = function (e) {
			try {
				return String.fromCodePoint(e)
			} catch (t) {
				if (t instanceof RangeError) return ""
				throw t
			}
		}
	else {
		var Ket = String.fromCharCode,
			Qet = Math.floor
		V2 = function () {
			for (var e = [], t = 0; t < arguments.length; t++) e[t] = arguments[t]
			var n = 16384,
				r = [],
				i,
				a,
				o = -1,
				s = e.length
			if (!s) return ""
			for (var l = ""; ++o < s; ) {
				var u = Number(e[o])
				if (!isFinite(u) || u < 0 || u > 1114111 || Qet(u) !== u) return ""
				u <= 65535
					? r.push(u)
					: ((u -= 65536), (i = (u >> 10) + 55296), (a = (u % 1024) + 56320), r.push(i, a)),
					(o + 1 === s || r.length > n) && ((l += Ket.apply(void 0, r)), (r.length = 0))
			}
			return l
		}
	}
	var wk = V2,
		Xet = "(?:[w-]+.)*[A-Za-z0-9-]+.[A-Za-z0-9-]+",
		Jet = "[^<\\s]*[^<?!.,:*_?~\\s]",
		Zet = "[\\w.+-]+@(?:[\\w-]+\\.)+[\\w-]+"
	function ett(e) {
		var t = /\)+$/.exec(e)
		if (t) {
			for (var n = 0, r = 0, i = e; r < i.length; r++) {
				var a = i[r]
				a === "(" ? (n < 0 ? (n = 1) : (n += 1)) : a === ")" && (n -= 1)
			}
			if (n < 0) {
				var o = Math.min(-n, t[0].length)
				return e.substring(0, e.length - o)
			}
		}
		return e
	}
	function ttt(e) {
		return e.replace(/&[A-Za-z0-9]+;$/, "")
	}
	function ntt(e) {
		for (var t = new RegExp(Zet, "g"), n = [], r; (r = t.exec(e)); ) {
			var i = r[0]
			;/[_-]+$/.test(i) ||
				n.push({ text: i, range: [r.index, r.index + i.length - 1], url: "mailto:" + i })
		}
		return n
	}
	function rtt(e) {
		for (var t = new RegExp("(www|https?://)." + Xet + Jet, "g"), n = [], r; (r = t.exec(e)); ) {
			var i = ttt(ett(r[0])),
				a = r[1] === "www" ? "http://" : ""
			n.push({ text: i, range: [r.index, r.index + i.length - 1], url: "" + a + i })
		}
		return n
	}
	function itt(e) {
		return $2($2([], rtt(e)), ntt(e)).sort(function (t, n) {
			return t.range[0] - n.range[0]
		})
	}
	function att(e, t) {
		typeof t == "boolean" && (t = itt)
		for (
			var n,
				r = function () {
					var i = n.entering,
						a = n.node
					if (i && a.type === "text" && a.parent.type !== "link") {
						var o = a.literal,
							s = t(o)
						if (!s || !s.length) return "continue"
						for (
							var l = 0,
								u = a.sourcepos[0],
								d = u[0],
								p = u[1],
								m = function (I, P) {
									return [
										[d, p + I],
										[d, p + P],
									]
								},
								v = [],
								y = 0,
								b = s;
							y < b.length;
							y++
						) {
							var x = b[y],
								E = x.range,
								T = x.url,
								C = x.text
							E[0] > l && v.push(hr(o.substring(l, E[0]), m(l, E[0] - 1)))
							var D = Xn("link", m.apply(void 0, E))
							D.appendChild(hr(C, m.apply(void 0, E))),
								(D.destination = T),
								(D.extendedAutolink = !0),
								v.push(D),
								(l = E[1] + 1)
						}
						l < o.length && v.push(hr(o.substring(l), m(l, o.length - 1)))
						for (var O = 0, A = v; O < A.length; O++) {
							var N = A[O]
							a.insertBefore(N)
						}
						a.unlink()
					}
				};
			(n = e.next());

		)
			r()
	}
	function Tb(e) {
		return e[e.length - 1]
	}
	function M4(e) {
		return e
			.slice(1, e.length - 1)
			.trim()
			.replace(/[ \t\r\n]+/, " ")
			.toLowerCase()
			.toUpperCase()
	}
	function ly(e, t) {
		Object.keys(e).forEach(function (n) {
			t(n, e[n])
		})
	}
	function ott(e) {
		for (var t = [], n = 1; n < arguments.length; n++) t[n - 1] = arguments[n]
		var r = Br({}, e)
		return (
			t.forEach(function (i) {
				delete r[i]
			}),
			r
		)
	}
	function wf(e) {
		return !Object.keys(e).length
	}
	function stt(e) {
		Object.keys(e).forEach(function (t) {
			delete e[t]
		})
	}
	var W2 = 10,
		Ek = 42,
		uy = 95,
		ltt = 96,
		I4 = 91,
		utt = 93,
		cy = 126,
		R4 = 60,
		ctt = 33,
		L4 = 92,
		dtt = 38,
		P4 = 40,
		Ck = 41,
		ftt = 58,
		Ec = 39,
		Cc = 34,
		Tc = 36,
		Tk = "\\\\" + aA,
		j4 = new RegExp(
			/[!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u0AF0\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166D\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E42\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]|\uD800[\uDD00-\uDD02\uDF9F\uDFD0]|\uD801\uDD6F|\uD802[\uDC57\uDD1F\uDD3F\uDE50-\uDE58\uDE7F\uDEF0-\uDEF6\uDF39-\uDF3F\uDF99-\uDF9C]|\uD804[\uDC47-\uDC4D\uDCBB\uDCBC\uDCBE-\uDCC1\uDD40-\uDD43\uDD74\uDD75\uDDC5-\uDDC9\uDDCD\uDDDB\uDDDD-\uDDDF\uDE38-\uDE3D\uDEA9]|\uD805[\uDCC6\uDDC1-\uDDD7\uDE41-\uDE43\uDF3C-\uDF3E]|\uD809[\uDC70-\uDC74]|\uD81A[\uDE6E\uDE6F\uDEF5\uDF37-\uDF3B\uDF44]|\uD82F\uDC9F|\uD836[\uDE87-\uDE8B]/,
		),
		ptt = new RegExp(
			'^(?:"(' +
				Tk +
				'|[^"\\x00])*"|' +
				("'(" + Tk + "|[^'\\x00])*'") +
				"|" +
				("\\((" + Tk + "|[^()\\x00])*\\))"),
		),
		htt = /^(?:<(?:[^<>\n\\\x00]|\\.)*>)/,
		F4 = new RegExp("^" + aA),
		mtt = new RegExp("^" + Iz, "i"),
		vtt = /`+/,
		gtt = /^`+/,
		ytt = /\.\.\./g,
		btt = /--+/g,
		xtt =
			/^<([a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*)>/,
		wtt = /^<[A-Za-z][A-Za-z0-9.+-]{1,31}:[^<>\x00-\x20]*>/i,
		Ett = /^ *(?:\n *)?/,
		kk = /^[ \t\n\x0b\x0c\x0d]/,
		B4 = /^\s/,
		Ctt = / *$/,
		Ttt = /^ */,
		H4 = /^ *(?:\n|$)/,
		ktt = /^\[(?:[^\\\[\]]|\\.){0,1000}\]/,
		Stt = /^[^\n`\[\]\\!<&*_'"~$]+/m,
		Dtt = (function () {
			function e(t) {
				;(this.subject = ""),
					(this.delimiters = null),
					(this.brackets = null),
					(this.pos = 0),
					(this.lineStartNum = 0),
					(this.lineIdx = 0),
					(this.lineOffsets = [0]),
					(this.linePosOffset = 0),
					(this.refMap = {}),
					(this.refLinkCandidateMap = {}),
					(this.refDefCandidateMap = {}),
					(this.options = t)
			}
			return (
				(e.prototype.sourcepos = function (t, n) {
					var r = this.linePosOffset + this.lineOffsets[this.lineIdx],
						i = this.lineStartNum + this.lineIdx,
						a = [i, t + r]
					return typeof n == "number" ? [a, [i, n + r]] : a
				}),
				(e.prototype.nextLine = function () {
					;(this.lineIdx += 1), (this.linePosOffset = -this.pos)
				}),
				(e.prototype.match = function (t) {
					var n = t.exec(this.subject.slice(this.pos))
					return n === null ? null : ((this.pos += n.index + n[0].length), n[0])
				}),
				(e.prototype.peek = function () {
					return this.pos < this.subject.length ? this.subject.charCodeAt(this.pos) : -1
				}),
				(e.prototype.spnl = function () {
					return this.match(Ett), !0
				}),
				(e.prototype.parseBackticks = function (t) {
					var n = this.pos + 1,
						r = this.match(gtt)
					if (r === null) return !1
					for (var i = this.pos, a; (a = this.match(vtt)) !== null; )
						if (a === r) {
							var o = this.subject.slice(i, this.pos - r.length),
								s = this.sourcepos(n, this.pos),
								l = o.split(`
`)
							if (l.length > 1) {
								var u = Tb(l)
								;(this.lineIdx += l.length - 1),
									(this.linePosOffset = -(this.pos - u.length - r.length)),
									(s[1] = this.sourcepos(this.pos)),
									(o = l.join(" "))
							}
							var d = Xn("code", s)
							return (
								o.length > 0 && o.match(/[^ ]/) !== null && o[0] == " " && o[o.length - 1] == " "
									? (d.literal = o.slice(1, o.length - 1))
									: (d.literal = o),
								(d.tickCount = r.length),
								t.appendChild(d),
								!0
							)
						}
					return (this.pos = i), t.appendChild(hr(r, this.sourcepos(n, this.pos - 1))), !0
				}),
				(e.prototype.parseBackslash = function (t) {
					var n = this.subject,
						r
					this.pos += 1
					var i = this.pos
					return (
						this.peek() === W2
							? ((this.pos += 1),
							  (r = Xn("linebreak", this.sourcepos(this.pos - 1, this.pos))),
							  t.appendChild(r),
							  this.nextLine())
							: F4.test(n.charAt(this.pos))
							? (t.appendChild(hr(n.charAt(this.pos), this.sourcepos(i, this.pos))),
							  (this.pos += 1))
							: t.appendChild(hr("\\", this.sourcepos(i, i))),
						!0
					)
				}),
				(e.prototype.parseAutolink = function (t) {
					var n,
						r,
						i,
						a = this.pos + 1
					return (n = this.match(xtt))
						? ((r = n.slice(1, n.length - 1)),
						  (i = Xn("link", this.sourcepos(a, this.pos))),
						  (i.destination = sy("mailto:" + r)),
						  (i.title = ""),
						  i.appendChild(hr(r, this.sourcepos(a + 1, this.pos - 1))),
						  t.appendChild(i),
						  !0)
						: (n = this.match(wtt))
						? ((r = n.slice(1, n.length - 1)),
						  (i = Xn("link", this.sourcepos(a, this.pos))),
						  (i.destination = sy(r)),
						  (i.title = ""),
						  i.appendChild(hr(r, this.sourcepos(a + 1, this.pos - 1))),
						  t.appendChild(i),
						  !0)
						: !1
				}),
				(e.prototype.parseHtmlTag = function (t) {
					var n = this.pos + 1,
						r = this.match(Get)
					if (r === null) return !1
					var i = Xn("htmlInline", this.sourcepos(n, this.pos))
					return (i.literal = r), t.appendChild(i), !0
				}),
				(e.prototype.scanDelims = function (t) {
					var n = 0,
						r = this.pos
					if (t === Ec || t === Cc) n++, this.pos++
					else for (; this.peek() === t; ) n++, this.pos++
					if (n === 0 || (n < 2 && (t === cy || t === Tc))) return (this.pos = r), null
					var i =
							r === 0
								? `
`
								: this.subject.charAt(r - 1),
						a = this.peek(),
						o
					a === -1
						? (o = `
`)
						: (o = wk(a))
					var s = B4.test(o),
						l = j4.test(o),
						u = B4.test(i),
						d = j4.test(i),
						p = !s && (!l || u || d),
						m = !u && (!d || s || l),
						v,
						y
					return (
						t === uy
							? ((v = p && (!m || d)), (y = m && (!p || l)))
							: t === Ec || t === Cc
							? ((v = p && !m), (y = m))
							: t === Tc
							? ((v = !s), (y = !u))
							: ((v = p), (y = m)),
						(this.pos = r),
						{ numdelims: n, canOpen: v, canClose: y }
					)
				}),
				(e.prototype.handleDelim = function (t, n) {
					var r = this.scanDelims(t)
					if (!r) return !1
					var i = r.numdelims,
						a = this.pos + 1,
						o
					;(this.pos += i),
						t === Ec ? (o = "") : t === Cc ? (o = "") : (o = this.subject.slice(a - 1, this.pos))
					var s = hr(o, this.sourcepos(a, this.pos))
					return (
						n.appendChild(s),
						(r.canOpen || r.canClose) &&
							(this.options.smart || (t !== Ec && t !== Cc)) &&
							((this.delimiters = {
								cc: t,
								numdelims: i,
								origdelims: i,
								node: s,
								previous: this.delimiters,
								next: null,
								canOpen: r.canOpen,
								canClose: r.canClose,
							}),
							this.delimiters.previous && (this.delimiters.previous.next = this.delimiters)),
						!0
					)
				}),
				(e.prototype.removeDelimiter = function (t) {
					t.previous !== null && (t.previous.next = t.next),
						t.next === null ? (this.delimiters = t.previous) : (t.next.previous = t.previous)
				}),
				(e.prototype.removeDelimitersBetween = function (t, n) {
					t.next !== n && ((t.next = n), (n.previous = t))
				}),
				(e.prototype.processEmphasis = function (t) {
					var n,
						r,
						i,
						a,
						o,
						s,
						l,
						u = !1,
						d =
							((n = {}),
							(n[uy] = [t, t, t]),
							(n[Ek] = [t, t, t]),
							(n[Ec] = [t]),
							(n[Cc] = [t]),
							(n[cy] = [t]),
							(n[Tc] = [t]),
							n)
					for (i = this.delimiters; i !== null && i.previous !== t; ) i = i.previous
					for (; i !== null; ) {
						var p = i.cc,
							m = p === uy || p === Ek
						if (!i.canClose) i = i.next
						else {
							for (
								r = i.previous, l = !1;
								r !== null && r !== t && r !== d[p][m ? i.origdelims % 3 : 0];

							) {
								if (
									((u =
										m &&
										(i.canOpen || r.canClose) &&
										i.origdelims % 3 !== 0 &&
										(r.origdelims + i.origdelims) % 3 === 0),
									r.cc === i.cc && r.canOpen && !u)
								) {
									l = !0
									break
								}
								r = r.previous
							}
							if (((a = i), m || p === cy || p === Tc)) {
								if (!l) i = i.next
								else if (r) {
									var v = i.numdelims >= 2 && r.numdelims >= 2 ? 2 : 1,
										y = m ? 0 : 1
									;(o = r.node), (s = i.node)
									var b = m ? (v === 1 ? "emph" : "strong") : "strike"
									p === Tc && (b = "customInline")
									var x = Xn(b),
										E = o.sourcepos[1],
										T = s.sourcepos[0]
									;(x.sourcepos = [
										[E[0], E[1] - v + 1],
										[T[0], T[1] + v - 1],
									]),
										(o.sourcepos[1][1] -= v),
										(s.sourcepos[0][1] += v),
										(o.literal = o.literal.slice(v)),
										(s.literal = s.literal.slice(v)),
										(r.numdelims -= v),
										(i.numdelims -= v)
									for (var C = o.next, D = void 0; C && C !== s; )
										(D = C.next), C.unlink(), x.appendChild(C), (C = D)
									if (p === Tc) {
										var O = x.firstChild,
											A = O.literal || "",
											N = A.split(/\s/)[0]
										;(x.info = N),
											A.length <= N.length
												? O.unlink()
												: ((O.sourcepos[0][1] += N.length), (O.literal = A.replace(N + " ", "")))
									}
									if (
										(o.insertAfter(x),
										this.removeDelimitersBetween(r, i),
										r.numdelims <= y && (r.numdelims === 0 && o.unlink(), this.removeDelimiter(r)),
										i.numdelims <= y)
									) {
										i.numdelims === 0 && s.unlink()
										var I = i.next
										this.removeDelimiter(i), (i = I)
									}
								}
							} else
								p === Ec
									? ((i.node.literal = ""), l && (r.node.literal = ""), (i = i.next))
									: p === Cc && ((i.node.literal = ""), l && (r.node.literal = ""), (i = i.next))
							l ||
								((d[p][m ? a.origdelims % 3 : 0] = a.previous),
								a.canOpen || this.removeDelimiter(a))
						}
					}
					for (; this.delimiters !== null && this.delimiters !== t; )
						this.removeDelimiter(this.delimiters)
				}),
				(e.prototype.parseLinkTitle = function () {
					var t = this.match(ptt)
					return t === null ? null : Vm(t.substr(1, t.length - 2))
				}),
				(e.prototype.parseLinkDestination = function () {
					var t = this.match(htt)
					if (t === null) {
						if (this.peek() === R4) return null
						for (var n = this.pos, r = 0, i = void 0; (i = this.peek()) !== -1; )
							if (i === L4 && F4.test(this.subject.charAt(this.pos + 1)))
								(this.pos += 1), this.peek() !== -1 && (this.pos += 1)
							else if (i === P4) (this.pos += 1), (r += 1)
							else if (i === Ck) {
								if (r < 1) break
								;(this.pos += 1), (r -= 1)
							} else {
								if (kk.exec(wk(i)) !== null) break
								this.pos += 1
							}
						return (this.pos === n && i !== Ck) || r !== 0
							? null
							: ((t = this.subject.substr(n, this.pos - n)), sy(Vm(t)))
					}
					return sy(Vm(t.substr(1, t.length - 2)))
				}),
				(e.prototype.parseLinkLabel = function () {
					var t = this.match(ktt)
					return t === null || t.length > 1001 ? 0 : t.length
				}),
				(e.prototype.parseOpenBracket = function (t) {
					var n = this.pos
					this.pos += 1
					var r = hr("[", this.sourcepos(this.pos, this.pos))
					return t.appendChild(r), this.addBracket(r, n, !1), !0
				}),
				(e.prototype.parseBang = function (t) {
					var n = this.pos
					if (((this.pos += 1), this.peek() === I4)) {
						this.pos += 1
						var r = hr("![", this.sourcepos(this.pos - 1, this.pos))
						t.appendChild(r), this.addBracket(r, n + 1, !0)
					} else {
						var r = hr("!", this.sourcepos(this.pos, this.pos))
						t.appendChild(r)
					}
					return !0
				}),
				(e.prototype.parseCloseBracket = function (t) {
					var n = null,
						r = null,
						i = !1
					this.pos += 1
					var a = this.pos,
						o = this.brackets
					if (o === null) return t.appendChild(hr("]", this.sourcepos(a, a))), !0
					if (!o.active)
						return t.appendChild(hr("]", this.sourcepos(a, a))), this.removeBracket(), !0
					var s = o.image,
						l = this.pos
					this.peek() === P4 &&
						(this.pos++,
						this.spnl() &&
						(n = this.parseLinkDestination()) !== null &&
						this.spnl() &&
						((kk.test(this.subject.charAt(this.pos - 1)) && (r = this.parseLinkTitle())) || !0) &&
						this.spnl() &&
						this.peek() === Ck
							? ((this.pos += 1), (i = !0))
							: (this.pos = l))
					var u = ""
					if (!i) {
						var d = this.pos,
							p = this.parseLinkLabel()
						if (
							(p > 2
								? (u = this.subject.slice(d, d + p))
								: o.bracketAfter || (u = this.subject.slice(o.index, a)),
							p === 0 && (this.pos = l),
							u)
						) {
							u = M4(u)
							var m = this.refMap[u]
							m && ((n = m.destination), (r = m.title), (i = !0))
						}
					}
					if (i) {
						var v = Xn(s ? "image" : "link")
						;(v.destination = n),
							(v.title = r || ""),
							(v.sourcepos = [o.startpos, this.sourcepos(this.pos)])
						for (var y = o.node.next, b = void 0; y; )
							(b = y.next), y.unlink(), v.appendChild(y), (y = b)
						if (
							(t.appendChild(v),
							this.processEmphasis(o.previousDelimiter),
							this.removeBracket(),
							o.node.unlink(),
							!s)
						)
							for (o = this.brackets; o !== null; ) o.image || (o.active = !1), (o = o.previous)
						return (
							this.options.referenceDefinition &&
								(this.refLinkCandidateMap[t.id] = { node: t, refLabel: u }),
							!0
						)
					}
					return (
						this.removeBracket(),
						(this.pos = a),
						t.appendChild(hr("]", this.sourcepos(a, a))),
						this.options.referenceDefinition &&
							(this.refLinkCandidateMap[t.id] = { node: t, refLabel: u }),
						!0
					)
				}),
				(e.prototype.addBracket = function (t, n, r) {
					this.brackets !== null && (this.brackets.bracketAfter = !0),
						(this.brackets = {
							node: t,
							startpos: this.sourcepos(n + (r ? 0 : 1)),
							previous: this.brackets,
							previousDelimiter: this.delimiters,
							index: n,
							image: r,
							active: !0,
						})
				}),
				(e.prototype.removeBracket = function () {
					this.brackets && (this.brackets = this.brackets.previous)
				}),
				(e.prototype.parseEntity = function (t) {
					var n,
						r = this.pos + 1
					return (n = this.match(mtt))
						? (t.appendChild(hr(nA.decodeHTML(n), this.sourcepos(r, this.pos))), !0)
						: !1
				}),
				(e.prototype.parseString = function (t) {
					var n,
						r = this.pos + 1
					if ((n = this.match(Stt))) {
						if (this.options.smart) {
							var i = n.replace(ytt, "").replace(btt, function (o) {
								var s = 0,
									l = 0
								return (
									o.length % 3 === 0
										? (l = o.length / 3)
										: o.length % 2 === 0
										? (s = o.length / 2)
										: o.length % 3 === 2
										? ((s = 1), (l = (o.length - 2) / 3))
										: ((s = 2), (l = (o.length - 4) / 3)),
									z2("", l) + z2("", s)
								)
							})
							t.appendChild(hr(i, this.sourcepos(r, this.pos)))
						} else {
							var a = hr(n, this.sourcepos(r, this.pos))
							t.appendChild(a)
						}
						return !0
					}
					return !1
				}),
				(e.prototype.parseNewline = function (t) {
					this.pos += 1
					var n = t.lastChild
					if (n && n.type === "text" && n.literal[n.literal.length - 1] === " ") {
						var r = n.literal[n.literal.length - 2] === " ",
							i = n.literal.length
						n.literal = n.literal.replace(Ctt, "")
						var a = i - n.literal.length
						;(n.sourcepos[1][1] -= a),
							t.appendChild(
								Xn(r ? "linebreak" : "softbreak", this.sourcepos(this.pos - a, this.pos)),
							)
					} else t.appendChild(Xn("softbreak", this.sourcepos(this.pos, this.pos)))
					return this.nextLine(), this.match(Ttt), !0
				}),
				(e.prototype.parseReference = function (t, n) {
					if (!this.options.referenceDefinition) return 0
					;(this.subject = t.stringContent), (this.pos = 0)
					var r = null,
						i = this.pos,
						a = this.parseLinkLabel()
					if (a === 0) return 0
					var o = this.subject.substr(0, a)
					if (this.peek() === ftt) this.pos++
					else return (this.pos = i), 0
					this.spnl()
					var s = this.parseLinkDestination()
					if (s === null) return (this.pos = i), 0
					var l = this.pos
					this.spnl(),
						this.pos !== l && (r = this.parseLinkTitle()),
						r === null && ((r = ""), (this.pos = l))
					var u = !0
					if (
						(this.match(H4) === null &&
							(r === "" ? (u = !1) : ((r = ""), (this.pos = l), (u = this.match(H4) !== null))),
						!u)
					)
						return (this.pos = i), 0
					var d = M4(o)
					if (d === "") return (this.pos = i), 0
					var p = this.getReferenceDefSourcepos(t)
					t.sourcepos[0][0] = p[1][0] + 1
					var m = Xn("refDef", p)
					return (
						(m.title = r),
						(m.dest = s),
						(m.label = d),
						t.insertBefore(m),
						n[d] ? (this.refDefCandidateMap[m.id] = m) : (n[d] = K2(m)),
						this.pos - i
					)
				}),
				(e.prototype.mergeTextNodes = function (t) {
					for (var n, r = []; (n = t.next()); ) {
						var i = n.entering,
							a = n.node
						if (i && a.type === "text") r.push(a)
						else if (r.length === 1) r = []
						else if (r.length > 1) {
							var o = r[0],
								s = r[r.length - 1]
							o.sourcepos && s.sourcepos && (o.sourcepos[1] = s.sourcepos[1]),
								(o.next = s.next),
								o.next && (o.next.prev = o)
							for (var l = 1; l < r.length; l += 1) (o.literal += r[l].literal), r[l].unlink()
							r = []
						}
					}
				}),
				(e.prototype.getReferenceDefSourcepos = function (t) {
					for (
						var n = t.stringContent.split(/\n|\r\n/), r = !1, i = 0, a = { line: 0, ch: 0 }, o = 0;
						o < n.length;
						o += 1
					) {
						var s = n[o]
						if (kk.test(s)) break
						if (/\:/.test(s) && i === 0) {
							if (r) break
							var l = s.indexOf(":") === s.length - 1 ? o + 1 : o
							;(a = { line: l, ch: n[l].length }), (r = !0)
						}
						var u = s.match(/'|"/g)
						if ((u && (i += u.length), i === 2)) {
							a = { line: o, ch: s.length }
							break
						}
					}
					return [
						[t.sourcepos[0][0], t.sourcepos[0][1]],
						[t.sourcepos[0][0] + a.line, a.ch],
					]
				}),
				(e.prototype.parseInline = function (t) {
					var n,
						r = !1,
						i = this.peek()
					if (i === -1) return !1
					switch (i) {
						case W2:
							r = this.parseNewline(t)
							break
						case L4:
							r = this.parseBackslash(t)
							break
						case ltt:
							r = this.parseBackticks(t)
							break
						case Ek:
						case uy:
						case cy:
						case Tc:
							r = this.handleDelim(i, t)
							break
						case Ec:
						case Cc:
							r =
								!!(!((n = this.options) === null || n === void 0) && n.smart) &&
								this.handleDelim(i, t)
							break
						case I4:
							r = this.parseOpenBracket(t)
							break
						case ctt:
							r = this.parseBang(t)
							break
						case utt:
							r = this.parseCloseBracket(t)
							break
						case R4:
							r = this.parseAutolink(t) || this.parseHtmlTag(t)
							break
						case dtt:
							t.disabledEntityParse || (r = this.parseEntity(t))
							break
						default:
							r = this.parseString(t)
							break
					}
					return (
						r ||
							((this.pos += 1), t.appendChild(hr(wk(i), this.sourcepos(this.pos, this.pos + 1)))),
						!0
					)
				}),
				(e.prototype.parse = function (t) {
					for (
						this.subject = t.stringContent.trim(),
							this.pos = 0,
							this.delimiters = null,
							this.brackets = null,
							this.lineOffsets = t.lineOffsets || [0],
							this.lineIdx = 0,
							this.linePosOffset = 0,
							this.lineStartNum = t.sourcepos[0][0],
							Iet(t) && (this.lineOffsets[0] += t.level + 1);
						this.parseInline(t);

					);
					;(t.stringContent = null), this.processEmphasis(null), this.mergeTextNodes(t.walker())
					var n = this.options,
						r = n.extendedAutolinks,
						i = n.customParser
					if ((r && att(t.walker(), r), i && t.firstChild))
						for (var a, o = t.firstChild.walker(); (a = o.next()); ) {
							var s = a.node,
								l = a.entering
							i[s.type] && i[s.type](s, { entering: l, options: this.options })
						}
				}),
				e
			)
		})(),
		_tt = /^\[([ \txX])\][ \t]+/
	function Ott(e, t) {
		if (t.firstChild && t.firstChild.type === "paragraph") {
			var n = t.firstChild,
				r = n.stringContent.match(_tt)
			if (r) {
				var i = r[0].length
				;(n.stringContent = n.stringContent.substring(i - 1)),
					(n.sourcepos[0][1] += i),
					(n.lineOffsets[0] += i),
					(t.listData.task = !0),
					(t.listData.checked = /[xX]/.test(r[1]))
			}
		}
	}
	var Att = {
			continue: function () {
				return 0
			},
			finalize: function () {},
			canContain: function (e) {
				return e === "tableHead" || e === "tableBody"
			},
			acceptsLines: !1,
		},
		Ntt = {
			continue: function () {
				return 0
			},
			finalize: function () {},
			canContain: function (e) {
				return e === "tableRow"
			},
			acceptsLines: !1,
		},
		Mtt = {
			continue: function () {
				return 1
			},
			finalize: function () {},
			canContain: function (e) {
				return e === "tableRow" || e === "tableDelimRow"
			},
			acceptsLines: !1,
		},
		Itt = {
			continue: function () {
				return 1
			},
			finalize: function () {},
			canContain: function (e) {
				return e === "tableDelimCell"
			},
			acceptsLines: !1,
		},
		Rtt = {
			continue: function () {
				return 1
			},
			finalize: function () {},
			canContain: function () {
				return !1
			},
			acceptsLines: !1,
		},
		Ltt = {
			continue: function () {
				return 1
			},
			finalize: function () {},
			canContain: function (e) {
				return e === "tableCell"
			},
			acceptsLines: !1,
		},
		Ptt = {
			continue: function () {
				return 1
			},
			finalize: function () {},
			canContain: function () {
				return !1
			},
			acceptsLines: !1,
		},
		kb = 4,
		Bz = 9,
		Hz = 62,
		jtt = 60,
		$z = 32,
		Uz = 91,
		zz = /[^ \t\f\v\r\n]/,
		Ftt = /^(?:`{3,}|~{3,})(?= *$)/
	function $4(e) {
		for (var t = e; t; ) {
			if (t.lastLineBlank) return !0
			var n = t.type
			if (!t.lastLineChecked && (n === "list" || n === "item"))
				(t.lastLineChecked = !0), (t = t.lastChild)
			else {
				t.lastLineChecked = !0
				break
			}
		}
		return !1
	}
	function fa(e, t) {
		return t < e.length ? e.charCodeAt(t) : -1
	}
	function qz(e) {
		return !zz.test(e)
	}
	function wp(e) {
		return e === $z || e === Bz
	}
	var Btt = /^\$\$$/,
		Htt = {
			continue: function (e, t) {
				var n = e.currentLine,
					r = n.match(Btt)
				if (r) return (e.lastLineLength = r[0].length), e.finalize(t, e.lineNumber), 2
				for (var i = t.offset; i > 0 && wp(fa(n, e.offset)); ) e.advanceOffset(1, !0), i--
				return 0
			},
			finalize: function (e, t) {
				if (t.stringContent !== null) {
					var n = t.stringContent,
						r = n.indexOf(`
`),
						i = n.slice(0, r),
						a = n.slice(r + 1),
						o = i.match(/^(\s*)(.*)/)
					;(t.info = Vm(o[2].trim())), (t.literal = a), (t.stringContent = null)
				}
			},
			canContain: function () {
				return !1
			},
			acceptsLines: !0,
		},
		Vz = {
			continue: function () {
				return 1
			},
			finalize: function () {},
			canContain: function () {
				return !1
			},
			acceptsLines: !0,
		},
		$tt = {
			continue: function () {
				return 0
			},
			finalize: function () {},
			canContain: function (e) {
				return e !== "item"
			},
			acceptsLines: !1,
		},
		Utt = {
			continue: function () {
				return 0
			},
			finalize: function (e, t) {
				for (var n = t.firstChild; n; ) {
					if ($4(n) && n.next) {
						t.listData.tight = !1
						break
					}
					for (var r = n.firstChild; r; ) {
						if ($4(r) && (n.next || r.next)) {
							t.listData.tight = !1
							break
						}
						r = r.next
					}
					n = n.next
				}
			},
			canContain: function (e) {
				return e === "item"
			},
			acceptsLines: !1,
		},
		ztt = {
			continue: function (e) {
				var t = e.currentLine
				if (!e.indented && fa(t, e.nextNonspace) === Hz)
					e.advanceNextNonspace(),
						e.advanceOffset(1, !1),
						wp(fa(t, e.offset)) && e.advanceOffset(1, !0)
				else return 1
				return 0
			},
			finalize: function () {},
			canContain: function (e) {
				return e !== "item"
			},
			acceptsLines: !1,
		},
		qtt = {
			continue: function (e, t) {
				if (e.blank) {
					if (t.firstChild === null) return 1
					e.advanceNextNonspace()
				} else if (e.indent >= t.listData.markerOffset + t.listData.padding)
					e.advanceOffset(t.listData.markerOffset + t.listData.padding, !0)
				else return 1
				return 0
			},
			finalize: Ott,
			canContain: function (e) {
				return e !== "item"
			},
			acceptsLines: !1,
		},
		Vtt = {
			continue: function () {
				return 1
			},
			finalize: function () {},
			canContain: function () {
				return !1
			},
			acceptsLines: !1,
		},
		Wtt = {
			continue: function () {
				return 1
			},
			finalize: function () {},
			canContain: function () {
				return !1
			},
			acceptsLines: !1,
		},
		Ytt = {
			continue: function (e, t) {
				var n = e.currentLine,
					r = e.indent
				if (t.isFenced) {
					var i =
						r <= 3 && n.charAt(e.nextNonspace) === t.fenceChar && n.slice(e.nextNonspace).match(Ftt)
					if (i && i[0].length >= t.fenceLength)
						return (e.lastLineLength = e.offset + r + i[0].length), e.finalize(t, e.lineNumber), 2
					for (var a = t.fenceOffset; a > 0 && wp(fa(n, e.offset)); ) e.advanceOffset(1, !0), a--
				} else if (r >= kb) e.advanceOffset(kb, !0)
				else if (e.blank) e.advanceNextNonspace()
				else return 1
				return 0
			},
			finalize: function (e, t) {
				var n
				if (t.stringContent !== null) {
					if (t.isFenced) {
						var r = t.stringContent,
							i = r.indexOf(`
`),
							a = r.slice(0, i),
							o = r.slice(i + 1),
							s = a.match(/^(\s*)(.*)/)
						;(t.infoPadding = s[1].length), (t.info = Vm(s[2].trim())), (t.literal = o)
					} else
						t.literal =
							(n = t.stringContent) === null || n === void 0
								? void 0
								: n.replace(
										/(\n *)+$/,
										`
`,
								  )
					t.stringContent = null
				}
			},
			canContain: function () {
				return !1
			},
			acceptsLines: !0,
		},
		Gtt = {
			continue: function (e, t) {
				return e.blank && (t.htmlBlockType === 6 || t.htmlBlockType === 7) ? 1 : 0
			},
			finalize: function (e, t) {
				var n
				;(t.literal =
					((n = t.stringContent) === null || n === void 0 ? void 0 : n.replace(/(\n *)+$/, "")) ||
					null),
					(t.stringContent = null)
			},
			canContain: function () {
				return !1
			},
			acceptsLines: !0,
		},
		Ktt = {
			continue: function (e) {
				return e.blank ? 1 : 0
			},
			finalize: function (e, t) {
				if (t.stringContent !== null) {
					for (
						var n, r = !1;
						fa(t.stringContent, 0) === Uz && (n = e.inlineParser.parseReference(t, e.refMap));

					)
						(t.stringContent = t.stringContent.slice(n)), (r = !0)
					r && qz(t.stringContent) && t.unlink()
				}
			},
			canContain: function () {
				return !1
			},
			acceptsLines: !0,
		},
		Qtt = Vz,
		Xtt = Vz,
		Ef = {
			document: $tt,
			list: Utt,
			blockQuote: ztt,
			item: qtt,
			heading: Vtt,
			thematicBreak: Wtt,
			codeBlock: Ytt,
			htmlBlock: Gtt,
			paragraph: Ktt,
			table: Att,
			tableBody: Ntt,
			tableHead: Mtt,
			tableRow: Ltt,
			tableCell: Ptt,
			tableDelimRow: Itt,
			tableDelimCell: Rtt,
			refDef: Qtt,
			customBlock: Htt,
			frontMatter: Xtt,
		}
	function Y2(e) {
		for (var t = 0, n = 0, r = [], i = 0; i < e.length; i += 1)
			if (e[i] === "|" && e[i - 1] !== "\\") {
				var a = e.substring(t, i)
				t === 0 && A4(a) ? (n = i + 1) : r.push(a), (t = i + 1)
			}
		if (t < e.length) {
			var a = e.substring(t, e.length)
			A4(a) || r.push(a)
		}
		return [n, r]
	}
	function G2(e, t, n, r) {
		for (var i = [], a = 0, o = t; a < o.length; a++) {
			var s = o[a],
				l = s.match(/^[ \t]+/),
				u = l ? l[0].length : 0,
				d = void 0,
				p = void 0
			if (u === s.length) (u = 0), (d = 0), (p = "")
			else {
				var m = s.match(/[ \t]+$/)
				;(d = m ? m[0].length : 0), (p = s.slice(u, s.length - d))
			}
			var v = r + u,
				y = Xn(e, [
					[n, r],
					[n, r + s.length - 1],
				])
			;(y.stringContent = p.replace(/\\\|/g, "|")),
				(y.startIdx = i.length),
				(y.endIdx = i.length),
				(y.lineOffsets = [v - 1]),
				(y.paddingLeft = u),
				(y.paddingRight = d),
				i.push(y),
				(r += s.length + 1)
		}
		return i
	}
	function Jtt(e) {
		var t = null,
			n = e.stringContent,
			r = n[0],
			i = n[n.length - 1]
		return (
			i === ":" ? (t = r === ":" ? "center" : "right") : r === ":" && (t = "left"), { align: t }
		)
	}
	var Ztt = function (e, t) {
			var n = t.stringContent
			if (t.type === "paragraph" && !e.indented && !e.blank) {
				var r = n.length - 1,
					i =
						n.lastIndexOf(
							`
`,
							r - 1,
						) + 1,
					a = n.slice(i, r),
					o = e.currentLine.slice(e.nextNonspace),
					s = Y2(a),
					l = s[0],
					u = s[1],
					d = Y2(o),
					p = d[0],
					m = d[1],
					v = /^[ \t]*:?-+:?[ \t]*$/
				if (
					!u.length ||
					!m.length ||
					m.some(function (I) {
						return !v.test(I)
					}) ||
					(m.length === 1 && o.indexOf("|") !== 0)
				)
					return 0
				var y = t.lineOffsets,
					b = e.lineNumber - 1,
					x = Tb(y) + 1,
					E = Xn("table", [
						[b, x],
						[e.lineNumber, e.offset],
					])
				if (
					((E.columns = m.map(function () {
						return { align: null }
					})),
					t.insertAfter(E),
					y.length === 1)
				)
					t.unlink()
				else {
					t.stringContent = n.slice(0, i)
					var T =
							n.lastIndexOf(
								`
`,
								i - 2,
							) + 1,
						C = i - T - 1
					;(e.lastLineLength = y[y.length - 2] + C), e.finalize(t, b - 1)
				}
				e.advanceOffset(e.currentLine.length - e.offset, !1)
				var D = Xn("tableHead", [
					[b, x],
					[e.lineNumber, e.offset],
				])
				E.appendChild(D)
				var O = Xn("tableRow", [
						[b, x],
						[b, x + a.length - 1],
					]),
					A = Xn("tableDelimRow", [
						[e.lineNumber, e.nextNonspace + 1],
						[e.lineNumber, e.offset],
					])
				D.appendChild(O),
					D.appendChild(A),
					G2("tableCell", u, b, x + l).forEach(function (I) {
						O.appendChild(I)
					})
				var N = G2("tableDelimCell", m, e.lineNumber, e.nextNonspace + 1 + p)
				return (
					N.forEach(function (I) {
						A.appendChild(I)
					}),
					(E.columns = N.map(Jtt)),
					(e.tip = E),
					2
				)
			}
			return 0
		},
		ent = function (e, t) {
			if (
				(t.type !== "table" && t.type !== "tableBody") ||
				(!e.blank && e.currentLine.indexOf("|") === -1)
			)
				return 0
			if ((e.advanceOffset(e.currentLine.length - e.offset, !1), e.blank)) {
				var n = t
				return (
					t.type === "tableBody" && ((n = t.parent), e.finalize(t, e.lineNumber - 1)),
					e.finalize(n, e.lineNumber - 1),
					0
				)
			}
			var r = t
			t.type === "table" &&
				((r = e.addChild("tableBody", e.nextNonspace)), (r.stringContent = null))
			var i = Xn("tableRow", [
				[e.lineNumber, e.nextNonspace + 1],
				[e.lineNumber, e.currentLine.length],
			])
			r.appendChild(i)
			var a = r.parent,
				o = e.currentLine.slice(e.nextNonspace),
				s = Y2(o),
				l = s[0],
				u = s[1]
			return (
				G2("tableCell", u, e.lineNumber, e.nextNonspace + 1 + l).forEach(function (d, p) {
					p >= a.columns.length && (d.ignored = !0), i.appendChild(d)
				}),
				2
			)
		},
		tnt = /^(\$\$)(\s*[a-zA-Z])+/,
		nnt = /^(\$\$)(\s*[a-zA-Z])+.*(\$\$)/,
		rnt = function (e) {
			var t
			if (!e.indented && !nnt.test(e.currentLine) && (t = e.currentLine.match(tnt))) {
				var n = t[1].length
				e.closeUnmatchedBlocks()
				var r = e.addChild("customBlock", e.nextNonspace)
				return (
					(r.syntaxLength = n),
					(r.offset = e.indent),
					e.advanceNextNonspace(),
					e.advanceOffset(n, !1),
					2
				)
			}
			return 0
		},
		int = /^`{3,}(?!.*`)|^~{3,}/,
		ant = [
			/./,
			/^<(?:script|pre|style)(?:\s|>|$)/i,
			/^<!--/,
			/^<[?]/,
			/^<![A-Z]/,
			/^<!\[CDATA\[/,
			/^<[/]?(?:address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[123456]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|nav|noframes|ol|optgroup|option|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul)(?:\s|[/]?[>]|$)/i,
			new RegExp("^(?:" + jz + "|" + Fz + ")\\s*$", "i"),
		],
		ont = /^(?:=+|-+)[ \t]*$/,
		snt = /^#{1,6}(?:[ \t]+|$)/,
		lnt = /^(?:(?:\*[ \t]*){3,}|(?:_[ \t]*){3,}|(?:-[ \t]*){3,})[ \t]*$/,
		Wz = /^[*+-]/,
		Yz = /^(\d{1,9})([.)])/
	function unt(e, t) {
		var n = e.currentLine.slice(e.nextNonspace),
			r,
			i,
			a = {
				type: "bullet",
				tight: !0,
				bulletChar: "",
				start: 0,
				delimiter: "",
				padding: 0,
				markerOffset: e.indent,
				task: !1,
				checked: !1,
			}
		if (e.indent >= 4) return null
		if ((r = n.match(Wz))) (a.type = "bullet"), (a.bulletChar = r[0][0])
		else if ((r = n.match(Yz)) && (t.type !== "paragraph" || r[1] === "1"))
			(a.type = "ordered"), (a.start = parseInt(r[1], 10)), (a.delimiter = r[2])
		else return null
		if (
			((i = fa(e.currentLine, e.nextNonspace + r[0].length)),
			!(i === -1 || i === Bz || i === $z) ||
				(t.type === "paragraph" && !e.currentLine.slice(e.nextNonspace + r[0].length).match(zz)))
		)
			return null
		e.advanceNextNonspace(), e.advanceOffset(r[0].length, !0)
		var o = e.column,
			s = e.offset
		do e.advanceOffset(1, !0), (i = fa(e.currentLine, e.offset))
		while (e.column - o < 5 && wp(i))
		var l = fa(e.currentLine, e.offset) === -1,
			u = e.column - o
		return (
			u >= 5 || u < 1 || l
				? ((a.padding = r[0].length + 1),
				  (e.column = o),
				  (e.offset = s),
				  wp(fa(e.currentLine, e.offset)) && e.advanceOffset(1, !0))
				: (a.padding = r[0].length + u),
			a
		)
	}
	function cnt(e, t) {
		return e.type === t.type && e.delimiter === t.delimiter && e.bulletChar === t.bulletChar
	}
	function Gz(e, t) {
		return e.options.disallowDeepHeading && (t.type === "blockQuote" || t.type === "item")
	}
	var dnt = function (e) {
			return !e.indented && fa(e.currentLine, e.nextNonspace) === Hz
				? (e.advanceNextNonspace(),
				  e.advanceOffset(1, !1),
				  wp(fa(e.currentLine, e.offset)) && e.advanceOffset(1, !0),
				  e.closeUnmatchedBlocks(),
				  e.addChild("blockQuote", e.nextNonspace),
				  1)
				: 0
		},
		fnt = function (e, t) {
			var n
			if (!e.indented && !Gz(e, t) && (n = e.currentLine.slice(e.nextNonspace).match(snt))) {
				e.advanceNextNonspace(), e.advanceOffset(n[0].length, !1), e.closeUnmatchedBlocks()
				var r = e.addChild("heading", e.nextNonspace)
				return (
					(r.level = n[0].trim().length),
					(r.headingType = "atx"),
					(r.stringContent = e.currentLine
						.slice(e.offset)
						.replace(/^[ \t]*#+[ \t]*$/, "")
						.replace(/[ \t]+#+[ \t]*$/, "")),
					e.advanceOffset(e.currentLine.length - e.offset),
					2
				)
			}
			return 0
		},
		pnt = function (e) {
			var t
			if (!e.indented && (t = e.currentLine.slice(e.nextNonspace).match(int))) {
				var n = t[0].length
				e.closeUnmatchedBlocks()
				var r = e.addChild("codeBlock", e.nextNonspace)
				return (
					(r.isFenced = !0),
					(r.fenceLength = n),
					(r.fenceChar = t[0][0]),
					(r.fenceOffset = e.indent),
					e.advanceNextNonspace(),
					e.advanceOffset(n, !1),
					2
				)
			}
			return 0
		},
		hnt = function (e, t) {
			if (!e.indented && fa(e.currentLine, e.nextNonspace) === jtt) {
				var n = e.currentLine.slice(e.nextNonspace),
					r = e.options.disallowedHtmlBlockTags,
					i = void 0
				for (i = 1; i <= 7; i++) {
					var a = n.match(ant[i])
					if (a) {
						if (i === 7) {
							if (t.type === "paragraph") return 0
							if (r.length > 0) {
								var o = new RegExp("</?(?:" + r.join("|") + ")", "i")
								if (o.test(a[0])) return 0
							}
						}
						e.closeUnmatchedBlocks()
						var s = e.addChild("htmlBlock", e.offset)
						return (s.htmlBlockType = i), 2
					}
				}
			}
			return 0
		},
		mnt = function (e, t) {
			var n
			if (
				t.stringContent !== null &&
				!e.indented &&
				t.type === "paragraph" &&
				!Gz(e, t.parent) &&
				(n = e.currentLine.slice(e.nextNonspace).match(ont))
			) {
				e.closeUnmatchedBlocks()
				for (
					var r = void 0;
					fa(t.stringContent, 0) === Uz && (r = e.inlineParser.parseReference(t, e.refMap));

				)
					t.stringContent = t.stringContent.slice(r)
				if (t.stringContent.length > 0) {
					var i = Xn("heading", t.sourcepos)
					return (
						(i.level = n[0][0] === "=" ? 1 : 2),
						(i.headingType = "setext"),
						(i.stringContent = t.stringContent),
						t.insertAfter(i),
						t.unlink(),
						(e.tip = i),
						e.advanceOffset(e.currentLine.length - e.offset, !1),
						2
					)
				}
				return 0
			}
			return 0
		},
		vnt = function (e) {
			return !e.indented && lnt.test(e.currentLine.slice(e.nextNonspace))
				? (e.closeUnmatchedBlocks(),
				  e.addChild("thematicBreak", e.nextNonspace),
				  e.advanceOffset(e.currentLine.length - e.offset, !1),
				  2)
				: 0
		},
		gnt = function (e, t) {
			var n,
				r = t
			return (!e.indented || t.type === "list") && (n = unt(e, r))
				? (e.closeUnmatchedBlocks(),
				  (e.tip.type !== "list" || !cnt(r.listData, n)) &&
						((r = e.addChild("list", e.nextNonspace)), (r.listData = n)),
				  (r = e.addChild("item", e.nextNonspace)),
				  (r.listData = n),
				  1)
				: 0
		},
		ynt = function (e) {
			return e.indented && e.tip.type !== "paragraph" && !e.blank
				? (e.advanceOffset(kb, !0), e.closeUnmatchedBlocks(), e.addChild("codeBlock", e.offset), 2)
				: 0
		},
		Sk = [dnt, fnt, pnt, hnt, mnt, vnt, gnt, ynt, Ztt, ent, rnt],
		Kz = /^(-{3}|\+{3}|;{3})$/,
		bnt = function (e, t) {
			var n = e.currentLine,
				r = e.lineNumber,
				i = e.indented
			if (r === 1 && !i && t.type === "document" && Kz.test(n)) {
				e.closeUnmatchedBlocks()
				var a = e.addChild("frontMatter", e.nextNonspace)
				return (a.stringContent = n), e.advanceNextNonspace(), e.advanceOffset(n.length, !1), 2
			}
			return 0
		},
		xnt = {
			continue: function (e, t) {
				var n = e.currentLine,
					r = n.match(Kz)
				return t.type === "frontMatter" && r
					? ((t.stringContent += n),
					  (e.lastLineLength = r[0].length),
					  e.finalize(t, e.lineNumber),
					  2)
					: 0
			},
			finalize: function (e, t) {
				t.stringContent !== null && ((t.literal = t.stringContent), (t.stringContent = null))
			},
			canContain: function () {
				return !1
			},
			acceptsLines: !0,
		},
		wnt = [/./, /<\/(?:script|pre|style)>/i, /-->/, /\?>/, />/, /\]\]>/],
		Ent = /^[#`~*+_=<>0-9-;$]/,
		Cnt = /\r\n|\n|\r/
	function Dk() {
		return Xn("document", [
			[1, 1],
			[0, 0],
		])
	}
	var Tnt = {
			smart: !1,
			tagFilter: !1,
			extendedAutolinks: !1,
			disallowedHtmlBlockTags: [],
			referenceDefinition: !1,
			disallowDeepHeading: !1,
			customParser: null,
			frontMatter: !1,
		},
		knt = (function () {
			function e(t) {
				;(this.options = Br(Br({}, Tnt), t)),
					(this.doc = Dk()),
					(this.tip = this.doc),
					(this.oldtip = this.doc),
					(this.lineNumber = 0),
					(this.offset = 0),
					(this.column = 0),
					(this.nextNonspace = 0),
					(this.nextNonspaceColumn = 0),
					(this.indent = 0),
					(this.currentLine = ""),
					(this.indented = !1),
					(this.blank = !1),
					(this.partiallyConsumedTab = !1),
					(this.allClosed = !0),
					(this.lastMatchedContainer = this.doc),
					(this.refMap = {}),
					(this.refLinkCandidateMap = {}),
					(this.refDefCandidateMap = {}),
					(this.lastLineLength = 0),
					(this.lines = []),
					this.options.frontMatter && ((Ef.frontMatter = xnt), Sk.unshift(bnt)),
					(this.inlineParser = new Dtt(this.options))
			}
			return (
				(e.prototype.advanceOffset = function (t, n) {
					n === void 0 && (n = !1)
					for (var r = this.currentLine, i, a, o; t > 0 && (o = r[this.offset]); )
						o === "	"
							? ((i = 4 - (this.column % 4)),
							  n
									? ((this.partiallyConsumedTab = i > t),
									  (a = i > t ? t : i),
									  (this.column += a),
									  (this.offset += this.partiallyConsumedTab ? 0 : 1),
									  (t -= a))
									: ((this.partiallyConsumedTab = !1),
									  (this.column += i),
									  (this.offset += 1),
									  (t -= 1)))
							: ((this.partiallyConsumedTab = !1), (this.offset += 1), (this.column += 1), (t -= 1))
				}),
				(e.prototype.advanceNextNonspace = function () {
					;(this.offset = this.nextNonspace),
						(this.column = this.nextNonspaceColumn),
						(this.partiallyConsumedTab = !1)
				}),
				(e.prototype.findNextNonspace = function () {
					for (
						var t = this.currentLine, n = this.offset, r = this.column, i;
						(i = t.charAt(n)) !== "";

					)
						if (i === " ") n++, r++
						else if (i === "	") n++, (r += 4 - (r % 4))
						else break
					;(this.blank =
						i ===
							`
` ||
						i === "\r" ||
						i === ""),
						(this.nextNonspace = n),
						(this.nextNonspaceColumn = r),
						(this.indent = this.nextNonspaceColumn - this.column),
						(this.indented = this.indent >= kb)
				}),
				(e.prototype.addLine = function () {
					if (this.partiallyConsumedTab) {
						this.offset += 1
						var t = 4 - (this.column % 4)
						this.tip.stringContent += z2(" ", t)
					}
					this.tip.lineOffsets
						? this.tip.lineOffsets.push(this.offset)
						: (this.tip.lineOffsets = [this.offset]),
						(this.tip.stringContent +=
							this.currentLine.slice(this.offset) +
							`
`)
				}),
				(e.prototype.addChild = function (t, n) {
					for (; !Ef[this.tip.type].canContain(t); ) this.finalize(this.tip, this.lineNumber - 1)
					var r = n + 1,
						i = Xn(t, [
							[this.lineNumber, r],
							[0, 0],
						])
					return (i.stringContent = ""), this.tip.appendChild(i), (this.tip = i), i
				}),
				(e.prototype.closeUnmatchedBlocks = function () {
					if (!this.allClosed) {
						for (; this.oldtip !== this.lastMatchedContainer; ) {
							var t = this.oldtip.parent
							this.finalize(this.oldtip, this.lineNumber - 1), (this.oldtip = t)
						}
						this.allClosed = !0
					}
				}),
				(e.prototype.finalize = function (t, n) {
					var r = t.parent
					;(t.open = !1),
						(t.sourcepos[1] = [n, this.lastLineLength]),
						Ef[t.type].finalize(this, t),
						(this.tip = r)
				}),
				(e.prototype.processInlines = function (t) {
					var n,
						r = this.options.customParser,
						i = t.walker()
					for (
						this.inlineParser.refMap = this.refMap,
							this.inlineParser.refLinkCandidateMap = this.refLinkCandidateMap,
							this.inlineParser.refDefCandidateMap = this.refDefCandidateMap,
							this.inlineParser.options = this.options;
						(n = i.next());

					) {
						var a = n.node,
							o = n.entering,
							s = a.type
						r && r[s] && r[s](a, { entering: o, options: this.options }),
							!o &&
								(s === "paragraph" || s === "heading" || (s === "tableCell" && !a.ignored)) &&
								this.inlineParser.parse(a)
					}
				}),
				(e.prototype.incorporateLine = function (t) {
					var n = this.doc
					;(this.oldtip = this.tip),
						(this.offset = 0),
						(this.column = 0),
						(this.blank = !1),
						(this.partiallyConsumedTab = !1),
						(this.lineNumber += 1),
						t.indexOf("\0") !== -1 && (t = t.replace(/\0/g, "")),
						(this.currentLine = t)
					for (var r = !0, i; (i = n.lastChild) && i.open; ) {
						switch (((n = i), this.findNextNonspace(), Ef[n.type].continue(this, n))) {
							case 0:
								break
							case 1:
								r = !1
								break
							case 2:
								this.lastLineLength = t.length
								return
							default:
								throw new Error("continue returned illegal value, must be 0, 1, or 2")
						}
						if (!r) {
							n = n.parent
							break
						}
					}
					;(this.allClosed = n === this.oldtip), (this.lastMatchedContainer = n)
					for (var a = n.type !== "paragraph" && Ef[n.type].acceptsLines, o = Sk.length; !a; ) {
						if (
							(this.findNextNonspace(),
							n.type !== "table" &&
								n.type !== "tableBody" &&
								n.type !== "paragraph" &&
								!this.indented &&
								!Ent.test(t.slice(this.nextNonspace)))
						) {
							this.advanceNextNonspace()
							break
						}
						for (var s = 0; s < o; ) {
							var l = Sk[s](this, n)
							if (l === 1) {
								n = this.tip
								break
							} else if (l === 2) {
								;(n = this.tip), (a = !0)
								break
							} else s++
						}
						if (s === o) {
							this.advanceNextNonspace()
							break
						}
					}
					if (!this.allClosed && !this.blank && this.tip.type === "paragraph") this.addLine()
					else {
						this.closeUnmatchedBlocks(),
							this.blank && n.lastChild && (n.lastChild.lastLineBlank = !0)
						for (
							var u = n.type,
								d =
									this.blank &&
									!(
										u === "blockQuote" ||
										(Rz(n) && n.isFenced) ||
										(u === "item" && !n.firstChild && n.sourcepos[0][0] === this.lineNumber)
									),
								p = n;
							p;

						)
							(p.lastLineBlank = d), (p = p.parent)
						Ef[u].acceptsLines
							? (this.addLine(),
							  Met(n) &&
									n.htmlBlockType >= 1 &&
									n.htmlBlockType <= 5 &&
									wnt[n.htmlBlockType].test(this.currentLine.slice(this.offset)) &&
									((this.lastLineLength = t.length), this.finalize(n, this.lineNumber)))
							: this.offset < t.length &&
							  !this.blank &&
							  ((n = this.addChild("paragraph", this.offset)),
							  this.advanceNextNonspace(),
							  this.addLine())
					}
					this.lastLineLength = t.length
				}),
				(e.prototype.parse = function (t, n) {
					;(this.doc = Dk()),
						(this.tip = this.doc),
						(this.lineNumber = 0),
						(this.lastLineLength = 0),
						(this.offset = 0),
						(this.column = 0),
						(this.lastMatchedContainer = this.doc),
						(this.currentLine = "")
					var r = t.split(Cnt),
						i = r.length
					;(this.lines = n || r),
						this.options.referenceDefinition && this.clearRefMaps(),
						t.charCodeAt(t.length - 1) === W2 && (i -= 1)
					for (var a = 0; a < i; a++) this.incorporateLine(r[a])
					for (; this.tip; ) this.finalize(this.tip, i)
					return this.processInlines(this.doc), this.doc
				}),
				(e.prototype.partialParseStart = function (t, n) {
					;(this.doc = Dk()),
						(this.tip = this.doc),
						(this.lineNumber = t - 1),
						(this.lastLineLength = 0),
						(this.offset = 0),
						(this.column = 0),
						(this.lastMatchedContainer = this.doc),
						(this.currentLine = "")
					for (var r = n.length, i = 0; i < r; i++) this.incorporateLine(n[i])
					return this.doc
				}),
				(e.prototype.partialParseExtends = function (t) {
					for (var n = 0; n < t.length; n++) this.incorporateLine(t[n])
				}),
				(e.prototype.partialParseFinish = function () {
					for (; this.tip; ) this.finalize(this.tip, this.lineNumber)
					this.processInlines(this.doc)
				}),
				(e.prototype.setRefMaps = function (t, n, r) {
					;(this.refMap = t), (this.refLinkCandidateMap = n), (this.refDefCandidateMap = r)
				}),
				(e.prototype.clearRefMaps = function () {
					;[this.refMap, this.refLinkCandidateMap, this.refDefCandidateMap].forEach(function (t) {
						stt(t)
					})
				}),
				e
			)
		})()
	function U4(e, t) {
		return e[0] < t[0] ? 1 : e[0] > t[0] ? -1 : e[1] < t[1] ? 1 : e[1] > t[1] ? -1 : 0
	}
	function Snt(e, t) {
		var n = e[0],
			r = e[1]
		return U4(r, t) === 1 ? 1 : U4(n, t) === -1 ? -1 : 0
	}
	function Dnt(e, t) {
		if (!(e.parent !== t.parent || e === t)) {
			for (var n = e.next; n && n !== t; ) {
				for (var r = n.next, i = 0, a = ["parent", "prev", "next"]; i < a.length; i++) {
					var o = a[i]
					n[o] && (q2(n[o].id), (n[o] = null))
				}
				n = r
			}
			;(e.next = t.next), t.next ? (t.next.prev = e) : (e.parent.lastChild = e)
		}
	}
	function _nt(e) {
		for (var t = [], n = e.firstChild; n; ) t.push(n), (n = n.next)
		return t
	}
	function z4(e, t) {
		for (var n = 0, r = t; n < r.length; n++) {
			var i = r[n]
			e.insertBefore(i)
		}
	}
	function Ont(e, t) {
		for (var n = t.length - 1; n >= 0; n -= 1) e.prependChild(t[n])
	}
	function Ant(e, t) {
		if (!(!e || !e.parent || t === 0)) {
			var n = e.parent.walker()
			n.resumeAt(e, !0)
			for (var r; (r = n.next()); ) {
				var i = r.node,
					a = r.entering
				a && ((i.sourcepos[0][0] += t), (i.sourcepos[1][0] += t))
			}
		}
	}
	function Qz(e, t) {
		var n = e[0],
			r = e[1]
		return r[0] < t ? 1 : n[0] > t ? -1 : 0
	}
	function dy(e, t) {
		for (var n = e.firstChild; n; ) {
			var r = Qz(n.sourcepos, t)
			if (r === 0) return n
			if (r === -1) return n.prev || n
			n = n.next
		}
		return e.lastChild
	}
	function Nnt(e) {
		for (; e.lastChild; ) e = e.lastChild
		return e
	}
	function Mnt(e) {
		for (
			;
			e.parent && e.parent.type !== "document" && e.parent.sourcepos[0][0] === e.sourcepos[0][0];

		)
			e = e.parent
		return e
	}
	function Int(e, t) {
		for (var n = e.firstChild, r = null; n; ) {
			var i = Qz(n.sourcepos, t)
			if (i === 0) {
				if (n.sourcepos[0][0] === t || !n.firstChild) return n
				;(r = n), (n = n.firstChild)
			} else {
				if (i === -1) break
				;(r = n), (n = n.next)
			}
		}
		return r ? Mnt(Nnt(r)) : null
	}
	function Rnt(e, t) {
		for (var n = e, r = null; n; ) {
			var i = Snt(n.sourcepos, t)
			if (i === 0)
				if (n.firstChild) (r = n), (n = n.firstChild)
				else return n
			else {
				if (i === -1) return r
				if (n.next) n = n.next
				else return r
			}
		}
		return n
	}
	function Xz(e) {
		return yet(e) || null
	}
	function _k(e, t, n) {
		if ((n === void 0 && (n = null), t))
			for (var r = t.walker(); t && t !== n; ) {
				e(t)
				var i = r.next()
				if (i) t = i.node
				else break
			}
	}
	function Lnt(e) {
		var t = Xz(e)
		if (!t) return !0
		for (; t && t.type !== "document"; ) {
			if (!t.parent && !t.prev && !t.next) return !0
			t = t.parent
		}
		return !1
	}
	var q4 = /\r\n|\n|\r/
	function Pnt(e) {
		var t = e.match(/^[ \t]+/)
		if (t && (t[0].length >= 2 || /\t/.test(t[0]))) return !0
		var n = t ? e.slice(t.length) : e
		return Wz.test(n) || Yz.test(n)
	}
	function jnt(e) {
		return !qz(e) && e.indexOf("|") !== -1
	}
	function K2(e) {
		var t = e.id,
			n = e.title,
			r = e.sourcepos,
			i = e.dest
		return { id: t, title: n, sourcepos: r, unlinked: !1, destination: i }
	}
	var Jz = (function () {
			function e(t, n) {
				;(this.refMap = {}),
					(this.refLinkCandidateMap = {}),
					(this.refDefCandidateMap = {}),
					(this.referenceDefinition = !!(n != null && n.referenceDefinition)),
					(this.parser = new knt(n)),
					this.parser.setRefMaps(this.refMap, this.refLinkCandidateMap, this.refDefCandidateMap),
					(this.eventHandlerMap = { change: [] }),
					(t = t || ""),
					(this.lineTexts = t.split(q4)),
					(this.root = this.parser.parse(t, this.lineTexts))
			}
			return (
				(e.prototype.updateLineTexts = function (t, n, r) {
					var i,
						a = t[0],
						o = t[1],
						s = n[0],
						l = n[1],
						u = r.split(q4),
						d = u.length,
						p = this.lineTexts[a - 1],
						m = this.lineTexts[s - 1]
					;(u[0] = p.slice(0, o - 1) + u[0]), (u[d - 1] = u[d - 1] + m.slice(l - 1))
					var v = s - a + 1
					return (i = this.lineTexts).splice.apply(i, $2([a - 1, v], u)), d - v
				}),
				(e.prototype.updateRootNodeState = function () {
					if (this.lineTexts.length === 1 && this.lineTexts[0] === "") {
						;(this.root.lastLineBlank = !0),
							(this.root.sourcepos = [
								[1, 1],
								[1, 0],
							])
						return
					}
					this.root.lastChild && (this.root.lastLineBlank = this.root.lastChild.lastLineBlank)
					for (var t = this.lineTexts, n = t.length - 1; t[n] === ""; ) n -= 1
					t.length - 2 > n && (n += 1), (this.root.sourcepos[1] = [n + 1, t[n].length])
				}),
				(e.prototype.replaceRangeNodes = function (t, n, r) {
					t
						? (z4(t, r),
						  Dnt(t, n),
						  [t.id, n.id].forEach(function (i) {
								return q2(i)
						  }),
						  t.unlink())
						: n
						? (z4(n, r), q2(n.id), n.unlink())
						: Ont(this.root, r)
				}),
				(e.prototype.getNodeRange = function (t, n) {
					var r = dy(this.root, t[0]),
						i = dy(this.root, n[0])
					return i && i.next && n[0] + 1 === i.next.sourcepos[0][0] && (i = i.next), [r, i]
				}),
				(e.prototype.trigger = function (t, n) {
					this.eventHandlerMap[t].forEach(function (r) {
						r(n)
					})
				}),
				(e.prototype.extendEndLine = function (t) {
					for (; this.lineTexts[t] === ""; ) t += 1
					return t
				}),
				(e.prototype.parseRange = function (t, n, r, i) {
					t &&
						t.prev &&
						((N4(t.prev) && Pnt(this.lineTexts[r - 1])) ||
							(Ret(t.prev) && jnt(this.lineTexts[r - 1]))) &&
						((t = t.prev), (r = t.sourcepos[0][0]))
					for (
						var a = this.lineTexts.slice(r - 1, i),
							o = this.parser.partialParseStart(r, a),
							s = n ? n.next : this.root.firstChild,
							l = o.lastChild,
							u = l && Rz(l) && l.open,
							d = l && Lz(l) && l.open,
							p = l && N4(l);
						((u || d) && s) || (p && s && (s.type === "list" || s.sourcepos[0][1] >= 2));

					) {
						var m = this.extendEndLine(s.sourcepos[1][0])
						this.parser.partialParseExtends(this.lineTexts.slice(i, m)),
							t || (t = n),
							(n = s),
							(i = m),
							(s = s.next)
					}
					this.parser.partialParseFinish()
					var v = _nt(o)
					return { newNodes: v, extStartNode: t, extEndNode: n }
				}),
				(e.prototype.getRemovedNodeRange = function (t, n) {
					return !t || (t && xf(t)) || (n && xf(n))
						? null
						: { id: [t.id, n.id], line: [t.sourcepos[0][0] - 1, n.sourcepos[1][0] - 1] }
				}),
				(e.prototype.markDeletedRefMap = function (t, n) {
					var r = this
					if (!wf(this.refMap)) {
						var i = function (a) {
							if (xf(a)) {
								var o = r.refMap[a.label]
								o && a.id === o.id && (o.unlinked = !0)
							}
						}
						t && _k(i, t.parent, n), n && _k(i, n)
					}
				}),
				(e.prototype.replaceWithNewRefDefState = function (t) {
					var n = this
					if (!wf(this.refMap)) {
						var r = function (i) {
							if (xf(i)) {
								var a = i.label,
									o = n.refMap[a]
								;(!o || o.unlinked) && (n.refMap[a] = K2(i))
							}
						}
						t.forEach(function (i) {
							_k(r, i)
						})
					}
				}),
				(e.prototype.replaceWithRefDefCandidate = function () {
					var t = this
					wf(this.refDefCandidateMap) ||
						ly(this.refDefCandidateMap, function (n, r) {
							var i = r.label,
								a = r.sourcepos,
								o = t.refMap[i]
							;(!o || o.unlinked || o.sourcepos[0][0] > a[0][0]) && (t.refMap[i] = K2(r))
						})
				}),
				(e.prototype.getRangeWithRefDef = function (t, n, r, i, a) {
					if (this.referenceDefinition && !wf(this.refMap)) {
						var o = dy(this.root, t - 1),
							s = dy(this.root, n + 1)
						o && xf(o) && o !== r && o !== i && ((r = o), (t = r.sourcepos[0][0])),
							s &&
								xf(s) &&
								s !== r &&
								s !== i &&
								((i = s), (n = this.extendEndLine(i.sourcepos[1][0] + a)))
					}
					return [r, i, t, n]
				}),
				(e.prototype.parse = function (t, n, r) {
					r === void 0 && (r = 0)
					var i = this.getNodeRange(t, n),
						a = i[0],
						o = i[1],
						s = a ? Math.min(a.sourcepos[0][0], t[0]) : t[0],
						l = this.extendEndLine((o ? Math.max(o.sourcepos[1][0], n[0]) : n[0]) + r),
						u = this.parseRange.apply(this, this.getRangeWithRefDef(s, l, a, o, r)),
						d = u.newNodes,
						p = u.extStartNode,
						m = u.extEndNode,
						v = this.getRemovedNodeRange(p, m),
						y = m ? m.next : this.root.firstChild
					return (
						this.referenceDefinition
							? (this.markDeletedRefMap(p, m),
							  this.replaceRangeNodes(p, m, d),
							  this.replaceWithNewRefDefState(d))
							: this.replaceRangeNodes(p, m, d),
						{ nodes: d, removedNodeRange: v, nextNode: y }
					)
				}),
				(e.prototype.parseRefLink = function () {
					var t = this,
						n = []
					return (
						wf(this.refMap) ||
							ly(this.refMap, function (r, i) {
								i.unlinked && delete t.refMap[r],
									ly(t.refLinkCandidateMap, function (a, o) {
										var s = o.node,
											l = o.refLabel
										l === r && n.push(t.parse(s.sourcepos[0], s.sourcepos[1]))
									})
							}),
						n
					)
				}),
				(e.prototype.removeUnlinkedCandidate = function () {
					wf(this.refDefCandidateMap) ||
						[this.refLinkCandidateMap, this.refDefCandidateMap].forEach(function (t) {
							ly(t, function (n) {
								Lnt(n) && delete t[n]
							})
						})
				}),
				(e.prototype.editMarkdown = function (t, n, r) {
					var i = this.updateLineTexts(t, n, r),
						a = this.parse(t, n, i),
						o = ott(a, "nextNode")
					Ant(a.nextNode, i), this.updateRootNodeState()
					var s = [o]
					return (
						this.referenceDefinition &&
							(this.removeUnlinkedCandidate(),
							this.replaceWithRefDefCandidate(),
							(s = s.concat(this.parseRefLink()))),
						this.trigger("change", s),
						s
					)
				}),
				(e.prototype.getLineTexts = function () {
					return this.lineTexts
				}),
				(e.prototype.getRootNode = function () {
					return this.root
				}),
				(e.prototype.findNodeAtPosition = function (t) {
					var n = Rnt(this.root, t)
					return !n || n === this.root ? null : n
				}),
				(e.prototype.findFirstNodeAtLine = function (t) {
					return Int(this.root, t)
				}),
				(e.prototype.on = function (t, n) {
					this.eventHandlerMap[t].push(n)
				}),
				(e.prototype.off = function (t, n) {
					var r = this.eventHandlerMap[t],
						i = r.indexOf(n)
					r.splice(i, 1)
				}),
				(e.prototype.findNodeById = function (t) {
					return Xz(t)
				}),
				(e.prototype.removeAllNode = function () {
					bet()
				}),
				e
			)
		})(),
		Fnt = [
			"title",
			"textarea",
			"style",
			"xmp",
			"iframe",
			"noembed",
			"noframes",
			"script",
			"plaintext",
		],
		V4 = new RegExp("<(/?(?:" + Fnt.join("|") + ")[^>]*>)", "ig")
	function W4(e) {
		return V4.test(e)
			? e.replace(V4, function (t, n) {
					return "&lt;" + n
			  })
			: e
	}
	var Y4 = {
			heading: function (e, t) {
				var n = t.entering
				return { type: n ? "openTag" : "closeTag", tagName: "h" + e.level, outerNewLine: !0 }
			},
			text: function (e) {
				return { type: "text", content: e.literal }
			},
			softbreak: function (e, t) {
				var n = t.options
				return { type: "html", content: n.softbreak }
			},
			linebreak: function () {
				return {
					type: "html",
					content: `<br />
`,
				}
			},
			emph: function (e, t) {
				var n = t.entering
				return { type: n ? "openTag" : "closeTag", tagName: "em" }
			},
			strong: function (e, t) {
				var n = t.entering
				return { type: n ? "openTag" : "closeTag", tagName: "strong" }
			},
			paragraph: function (e, t) {
				var n,
					r = t.entering,
					i = (n = e.parent) === null || n === void 0 ? void 0 : n.parent
				return i && i.type === "list" && i.listData.tight
					? null
					: { type: r ? "openTag" : "closeTag", tagName: "p", outerNewLine: !0 }
			},
			thematicBreak: function () {
				return { type: "openTag", tagName: "hr", outerNewLine: !0, selfClose: !0 }
			},
			blockQuote: function (e, t) {
				var n = t.entering
				return {
					type: n ? "openTag" : "closeTag",
					tagName: "blockquote",
					outerNewLine: !0,
					innerNewLine: !0,
				}
			},
			list: function (e, t) {
				var n = t.entering,
					r = e.listData,
					i = r.type,
					a = r.start,
					o = i === "bullet" ? "ul" : "ol",
					s = {}
				return (
					o === "ol" && a !== null && a !== 1 && (s.start = a.toString()),
					{ type: n ? "openTag" : "closeTag", tagName: o, attributes: s, outerNewLine: !0 }
				)
			},
			item: function (e, t) {
				var n = t.entering
				return { type: n ? "openTag" : "closeTag", tagName: "li", outerNewLine: !0 }
			},
			htmlInline: function (e, t) {
				var n = t.options,
					r = n.tagFilter ? W4(e.literal) : e.literal
				return { type: "html", content: r }
			},
			htmlBlock: function (e, t) {
				var n = t.options,
					r = n.tagFilter ? W4(e.literal) : e.literal
				return n.nodeId
					? [
							{ type: "openTag", tagName: "div", outerNewLine: !0 },
							{ type: "html", content: r },
							{ type: "closeTag", tagName: "div", outerNewLine: !0 },
					  ]
					: { type: "html", content: r, outerNewLine: !0 }
			},
			code: function (e) {
				return [
					{ type: "openTag", tagName: "code" },
					{ type: "text", content: e.literal },
					{ type: "closeTag", tagName: "code" },
				]
			},
			codeBlock: function (e) {
				var t = e.info,
					n = t ? t.split(/\s+/) : [],
					r = []
				return (
					n.length > 0 && n[0].length > 0 && r.push("language-" + Af(n[0])),
					[
						{ type: "openTag", tagName: "pre", outerNewLine: !0 },
						{ type: "openTag", tagName: "code", classNames: r },
						{ type: "text", content: e.literal },
						{ type: "closeTag", tagName: "code" },
						{ type: "closeTag", tagName: "pre", outerNewLine: !0 },
					]
				)
			},
			link: function (e, t) {
				var n = t.entering
				if (n) {
					var r = e,
						i = r.title,
						a = r.destination
					return {
						type: "openTag",
						tagName: "a",
						attributes: Br({ href: Af(a) }, i && { title: Af(i) }),
					}
				}
				return { type: "closeTag", tagName: "a" }
			},
			image: function (e, t) {
				var n = t.getChildrenText,
					r = t.skipChildren,
					i = e,
					a = i.title,
					o = i.destination
				return (
					r(),
					{
						type: "openTag",
						tagName: "img",
						selfClose: !0,
						attributes: Br({ src: Af(o), alt: n(e) }, a && { title: Af(a) }),
					}
				)
			},
			customBlock: function (e, t, n) {
				var r = e.info.trim().toLowerCase(),
					i = n[r]
				if (i)
					try {
						return i(e, t)
					} catch (a) {
						console.warn(
							"[@toast-ui/editor] - The error occurred when " +
								r +
								" block node was parsed in markdown renderer: " +
								a,
						)
					}
				return [
					{ type: "openTag", tagName: "div", outerNewLine: !0 },
					{ type: "text", content: e.literal },
					{ type: "closeTag", tagName: "div", outerNewLine: !0 },
				]
			},
			frontMatter: function (e) {
				return [
					{
						type: "openTag",
						tagName: "div",
						outerNewLine: !0,
						attributes: { style: "white-space: pre; display: none;" },
					},
					{ type: "text", content: e.literal },
					{ type: "closeTag", tagName: "div", outerNewLine: !0 },
				]
			},
			customInline: function (e, t, n) {
				var r = e,
					i = r.info,
					a = r.firstChild,
					o = i.trim().toLowerCase(),
					s = n[o],
					l = t.entering
				if (s)
					try {
						return s(e, t)
					} catch (u) {
						console.warn(
							"[@toast-ui/editor] - The error occurred when " +
								o +
								" inline node was parsed in markdown renderer: " +
								u,
						)
					}
				return l
					? [
							{ type: "openTag", tagName: "span" },
							{ type: "text", content: "$$" + i + (a ? " " : "") },
					  ]
					: [
							{ type: "text", content: "$$" },
							{ type: "closeTag", tagName: "span" },
					  ]
			},
		},
		G4 = {
			strike: function (e, t) {
				var n = t.entering
				return { type: n ? "openTag" : "closeTag", tagName: "del" }
			},
			item: function (e, t) {
				var n = t.entering,
					r = e.listData,
					i = r.checked,
					a = r.task
				if (n) {
					var o = { type: "openTag", tagName: "li", outerNewLine: !0 }
					return a
						? [
								o,
								{
									type: "openTag",
									tagName: "input",
									selfClose: !0,
									attributes: Br(Br({}, i && { checked: "" }), { disabled: "", type: "checkbox" }),
								},
								{ type: "text", content: " " },
						  ]
						: o
				}
				return { type: "closeTag", tagName: "li", outerNewLine: !0 }
			},
			table: function (e, t) {
				var n = t.entering
				return { type: n ? "openTag" : "closeTag", tagName: "table", outerNewLine: !0 }
			},
			tableHead: function (e, t) {
				var n = t.entering
				return { type: n ? "openTag" : "closeTag", tagName: "thead", outerNewLine: !0 }
			},
			tableBody: function (e, t) {
				var n = t.entering
				return { type: n ? "openTag" : "closeTag", tagName: "tbody", outerNewLine: !0 }
			},
			tableRow: function (e, t) {
				var n = t.entering
				if (n) return { type: "openTag", tagName: "tr", outerNewLine: !0 }
				var r = []
				if (e.lastChild)
					for (
						var i = e.parent.parent.columns.length, a = e.lastChild.endIdx, o = a + 1;
						o < i;
						o += 1
					)
						r.push(
							{ type: "openTag", tagName: "td", outerNewLine: !0 },
							{ type: "closeTag", tagName: "td", outerNewLine: !0 },
						)
				return r.push({ type: "closeTag", tagName: "tr", outerNewLine: !0 }), r
			},
			tableCell: function (e, t) {
				var n = t.entering
				if (e.ignored) return { type: "text", content: "" }
				var r = e.parent.parent,
					i = r.type === "tableHead" ? "th" : "td",
					a = r.parent,
					o = a.columns[e.startIdx],
					s = o != null && o.align ? { align: o.align } : null
				return n
					? Br({ type: "openTag", tagName: i, outerNewLine: !0 }, s && { attributes: s })
					: { type: "closeTag", tagName: i, outerNewLine: !0 }
			},
		},
		Bnt = {
			softbreak: `
`,
			gfm: !1,
			tagFilter: !1,
			nodeId: !1,
		}
	function Hnt(e) {
		for (var t = [], n = e.walker(), r = null; (r = n.next()); ) {
			var i = r.node
			i.type === "text" && t.push(i.literal)
		}
		return t.join("")
	}
	var sA = (function () {
		function e(t) {
			;(this.buffer = []),
				(this.options = Br(Br({}, Bnt), t)),
				(this.convertors = this.createConvertors()),
				delete this.options.convertors
		}
		return (
			(e.prototype.createConvertors = function () {
				var t = Br({}, Y4)
				if ((this.options.gfm && (t = Br(Br({}, t), G4)), this.options.convertors)) {
					var n = this.options.convertors,
						r = Object.keys(n),
						i = Br(Br({}, Y4), G4)
					r.forEach(function (a) {
						var o = t[a],
							s = n[a],
							l = Object.keys(i).indexOf(a) === -1 ? a.toLowerCase() : a
						o
							? (t[l] = function (u, d, p) {
									return (
										(d.origin = function () {
											return o(u, d, p)
										}),
										s(u, d)
									)
							  })
							: (t[l] = s)
					})
				}
				return t
			}),
			(e.prototype.getConvertors = function () {
				return this.convertors
			}),
			(e.prototype.getOptions = function () {
				return this.options
			}),
			(e.prototype.render = function (t) {
				var n = this
				this.buffer = []
				for (
					var r = t.walker(),
						i = null,
						a = function () {
							var s = i.node,
								l = i.entering,
								u = o.convertors[s.type]
							if (!u) return "continue"
							var d = !1,
								p = {
									entering: l,
									leaf: !oA(s),
									options: o.options,
									getChildrenText: Hnt,
									skipChildren: function () {
										d = !0
									},
								},
								m = Lz(s) || Let(s) ? u(s, p, o.convertors) : u(s, p)
							if (m) {
								var v = Array.isArray(m) ? m : [m]
								v.forEach(function (y, b) {
									y.type === "openTag" &&
										n.options.nodeId &&
										b === 0 &&
										(y.attributes || (y.attributes = {}),
										(y.attributes["data-nodeid"] = String(s.id))),
										n.renderHTMLNode(y)
								}),
									d && (r.resumeAt(s, !1), r.next())
							}
						},
						o = this;
					(i = r.next());

				)
					a()
				return this.addNewLine(), this.buffer.join("")
			}),
			(e.prototype.renderHTMLNode = function (t) {
				switch (t.type) {
					case "openTag":
					case "closeTag":
						this.renderElementNode(t)
						break
					case "text":
						this.renderTextNode(t)
						break
					case "html":
						this.renderRawHtmlNode(t)
						break
				}
			}),
			(e.prototype.generateOpenTagString = function (t) {
				var n = this,
					r = t.tagName,
					i = t.classNames,
					a = t.attributes
				this.buffer.push("<" + r),
					i && i.length > 0 && this.buffer.push(' class="' + i.join(" ") + '"'),
					a &&
						Object.keys(a).forEach(function (o) {
							var s = a[o]
							n.buffer.push(" " + o + '="' + s + '"')
						}),
					t.selfClose && this.buffer.push(" /"),
					this.buffer.push(">")
			}),
			(e.prototype.generateCloseTagString = function (t) {
				var n = t.tagName
				this.buffer.push("</" + n + ">")
			}),
			(e.prototype.addNewLine = function () {
				this.buffer.length &&
					Tb(Tb(this.buffer)) !==
						`
` &&
					this.buffer.push(`
`)
			}),
			(e.prototype.addOuterNewLine = function (t) {
				t.outerNewLine && this.addNewLine()
			}),
			(e.prototype.addInnerNewLine = function (t) {
				t.innerNewLine && this.addNewLine()
			}),
			(e.prototype.renderTextNode = function (t) {
				this.buffer.push(Af(t.content))
			}),
			(e.prototype.renderRawHtmlNode = function (t) {
				this.addOuterNewLine(t), this.buffer.push(t.content), this.addOuterNewLine(t)
			}),
			(e.prototype.renderElementNode = function (t) {
				t.type === "openTag"
					? (this.addOuterNewLine(t),
					  this.generateOpenTagString(t),
					  t.selfClose ? this.addOuterNewLine(t) : this.addInnerNewLine(t))
					: (this.addInnerNewLine(t), this.generateCloseTagString(t), this.addOuterNewLine(t))
			}),
			e
		)
	})()
	/*! @license DOMPurify 2.3.3 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/2.3.3/LICENSE */ function $nt(
		e,
	) {
		if (Array.isArray(e)) {
			for (var t = 0, n = Array(e.length); t < e.length; t++) n[t] = e[t]
			return n
		} else return Array.from(e)
	}
	var Unt = Object.hasOwnProperty,
		K4 = Object.setPrototypeOf,
		znt = Object.isFrozen,
		qnt = Object.getPrototypeOf,
		Vnt = Object.getOwnPropertyDescriptor,
		Ci = Object.freeze,
		Cl = Object.seal,
		Wnt = Object.create,
		Zz = typeof Reflect < "u" && Reflect,
		Sb = Zz.apply,
		Q2 = Zz.construct
	Sb ||
		(Sb = function (t, n, r) {
			return t.apply(n, r)
		})
	Ci ||
		(Ci = function (t) {
			return t
		})
	Cl ||
		(Cl = function (t) {
			return t
		})
	Q2 ||
		(Q2 = function (t, n) {
			return new (Function.prototype.bind.apply(t, [null].concat($nt(n))))()
		})
	var Ynt = Ao(Array.prototype.forEach),
		Q4 = Ao(Array.prototype.pop),
		im = Ao(Array.prototype.push),
		p1 = Ao(String.prototype.toLowerCase),
		X4 = Ao(String.prototype.match),
		iu = Ao(String.prototype.replace),
		Gnt = Ao(String.prototype.indexOf),
		Knt = Ao(String.prototype.trim),
		Vs = Ao(RegExp.prototype.test),
		J4 = Qnt(TypeError)
	function Ao(e) {
		return function (t) {
			for (var n = arguments.length, r = Array(n > 1 ? n - 1 : 0), i = 1; i < n; i++)
				r[i - 1] = arguments[i]
			return Sb(e, t, r)
		}
	}
	function Qnt(e) {
		return function () {
			for (var t = arguments.length, n = Array(t), r = 0; r < t; r++) n[r] = arguments[r]
			return Q2(e, n)
		}
	}
	function Et(e, t) {
		K4 && K4(e, null)
		for (var n = t.length; n--; ) {
			var r = t[n]
			if (typeof r == "string") {
				var i = p1(r)
				i !== r && (znt(t) || (t[n] = i), (r = i))
			}
			e[r] = !0
		}
		return e
	}
	function kc(e) {
		var t = Wnt(null),
			n = void 0
		for (n in e) Sb(Unt, e, [n]) && (t[n] = e[n])
		return t
	}
	function fy(e, t) {
		for (; e !== null; ) {
			var n = Vnt(e, t)
			if (n) {
				if (n.get) return Ao(n.get)
				if (typeof n.value == "function") return Ao(n.value)
			}
			e = qnt(e)
		}
		function r(i) {
			return console.warn("fallback value for", i), null
		}
		return r
	}
	var Z4 = Ci([
			"a",
			"abbr",
			"acronym",
			"address",
			"area",
			"article",
			"aside",
			"audio",
			"b",
			"bdi",
			"bdo",
			"big",
			"blink",
			"blockquote",
			"body",
			"br",
			"button",
			"canvas",
			"caption",
			"center",
			"cite",
			"code",
			"col",
			"colgroup",
			"content",
			"data",
			"datalist",
			"dd",
			"decorator",
			"del",
			"details",
			"dfn",
			"dialog",
			"dir",
			"div",
			"dl",
			"dt",
			"element",
			"em",
			"fieldset",
			"figcaption",
			"figure",
			"font",
			"footer",
			"form",
			"h1",
			"h2",
			"h3",
			"h4",
			"h5",
			"h6",
			"head",
			"header",
			"hgroup",
			"hr",
			"html",
			"i",
			"img",
			"input",
			"ins",
			"kbd",
			"label",
			"legend",
			"li",
			"main",
			"map",
			"mark",
			"marquee",
			"menu",
			"menuitem",
			"meter",
			"nav",
			"nobr",
			"ol",
			"optgroup",
			"option",
			"output",
			"p",
			"picture",
			"pre",
			"progress",
			"q",
			"rp",
			"rt",
			"ruby",
			"s",
			"samp",
			"section",
			"select",
			"shadow",
			"small",
			"source",
			"spacer",
			"span",
			"strike",
			"strong",
			"style",
			"sub",
			"summary",
			"sup",
			"table",
			"tbody",
			"td",
			"template",
			"textarea",
			"tfoot",
			"th",
			"thead",
			"time",
			"tr",
			"track",
			"tt",
			"u",
			"ul",
			"var",
			"video",
			"wbr",
		]),
		Ok = Ci([
			"svg",
			"a",
			"altglyph",
			"altglyphdef",
			"altglyphitem",
			"animatecolor",
			"animatemotion",
			"animatetransform",
			"circle",
			"clippath",
			"defs",
			"desc",
			"ellipse",
			"filter",
			"font",
			"g",
			"glyph",
			"glyphref",
			"hkern",
			"image",
			"line",
			"lineargradient",
			"marker",
			"mask",
			"metadata",
			"mpath",
			"path",
			"pattern",
			"polygon",
			"polyline",
			"radialgradient",
			"rect",
			"stop",
			"style",
			"switch",
			"symbol",
			"text",
			"textpath",
			"title",
			"tref",
			"tspan",
			"view",
			"vkern",
		]),
		Ak = Ci([
			"feBlend",
			"feColorMatrix",
			"feComponentTransfer",
			"feComposite",
			"feConvolveMatrix",
			"feDiffuseLighting",
			"feDisplacementMap",
			"feDistantLight",
			"feFlood",
			"feFuncA",
			"feFuncB",
			"feFuncG",
			"feFuncR",
			"feGaussianBlur",
			"feMerge",
			"feMergeNode",
			"feMorphology",
			"feOffset",
			"fePointLight",
			"feSpecularLighting",
			"feSpotLight",
			"feTile",
			"feTurbulence",
		]),
		Xnt = Ci([
			"animate",
			"color-profile",
			"cursor",
			"discard",
			"fedropshadow",
			"feimage",
			"font-face",
			"font-face-format",
			"font-face-name",
			"font-face-src",
			"font-face-uri",
			"foreignobject",
			"hatch",
			"hatchpath",
			"mesh",
			"meshgradient",
			"meshpatch",
			"meshrow",
			"missing-glyph",
			"script",
			"set",
			"solidcolor",
			"unknown",
			"use",
		]),
		Nk = Ci([
			"math",
			"menclose",
			"merror",
			"mfenced",
			"mfrac",
			"mglyph",
			"mi",
			"mlabeledtr",
			"mmultiscripts",
			"mn",
			"mo",
			"mover",
			"mpadded",
			"mphantom",
			"mroot",
			"mrow",
			"ms",
			"mspace",
			"msqrt",
			"mstyle",
			"msub",
			"msup",
			"msubsup",
			"mtable",
			"mtd",
			"mtext",
			"mtr",
			"munder",
			"munderover",
		]),
		Jnt = Ci([
			"maction",
			"maligngroup",
			"malignmark",
			"mlongdiv",
			"mscarries",
			"mscarry",
			"msgroup",
			"mstack",
			"msline",
			"msrow",
			"semantics",
			"annotation",
			"annotation-xml",
			"mprescripts",
			"none",
		]),
		ej = Ci(["#text"]),
		tj = Ci([
			"accept",
			"action",
			"align",
			"alt",
			"autocapitalize",
			"autocomplete",
			"autopictureinpicture",
			"autoplay",
			"background",
			"bgcolor",
			"border",
			"capture",
			"cellpadding",
			"cellspacing",
			"checked",
			"cite",
			"class",
			"clear",
			"color",
			"cols",
			"colspan",
			"controls",
			"controlslist",
			"coords",
			"crossorigin",
			"datetime",
			"decoding",
			"default",
			"dir",
			"disabled",
			"disablepictureinpicture",
			"disableremoteplayback",
			"download",
			"draggable",
			"enctype",
			"enterkeyhint",
			"face",
			"for",
			"headers",
			"height",
			"hidden",
			"high",
			"href",
			"hreflang",
			"id",
			"inputmode",
			"integrity",
			"ismap",
			"kind",
			"label",
			"lang",
			"list",
			"loading",
			"loop",
			"low",
			"max",
			"maxlength",
			"media",
			"method",
			"min",
			"minlength",
			"multiple",
			"muted",
			"name",
			"noshade",
			"novalidate",
			"nowrap",
			"open",
			"optimum",
			"pattern",
			"placeholder",
			"playsinline",
			"poster",
			"preload",
			"pubdate",
			"radiogroup",
			"readonly",
			"rel",
			"required",
			"rev",
			"reversed",
			"role",
			"rows",
			"rowspan",
			"spellcheck",
			"scope",
			"selected",
			"shape",
			"size",
			"sizes",
			"span",
			"srclang",
			"start",
			"src",
			"srcset",
			"step",
			"style",
			"summary",
			"tabindex",
			"title",
			"translate",
			"type",
			"usemap",
			"valign",
			"value",
			"width",
			"xmlns",
			"slot",
		]),
		Mk = Ci([
			"accent-height",
			"accumulate",
			"additive",
			"alignment-baseline",
			"ascent",
			"attributename",
			"attributetype",
			"azimuth",
			"basefrequency",
			"baseline-shift",
			"begin",
			"bias",
			"by",
			"class",
			"clip",
			"clippathunits",
			"clip-path",
			"clip-rule",
			"color",
			"color-interpolation",
			"color-interpolation-filters",
			"color-profile",
			"color-rendering",
			"cx",
			"cy",
			"d",
			"dx",
			"dy",
			"diffuseconstant",
			"direction",
			"display",
			"divisor",
			"dur",
			"edgemode",
			"elevation",
			"end",
			"fill",
			"fill-opacity",
			"fill-rule",
			"filter",
			"filterunits",
			"flood-color",
			"flood-opacity",
			"font-family",
			"font-size",
			"font-size-adjust",
			"font-stretch",
			"font-style",
			"font-variant",
			"font-weight",
			"fx",
			"fy",
			"g1",
			"g2",
			"glyph-name",
			"glyphref",
			"gradientunits",
			"gradienttransform",
			"height",
			"href",
			"id",
			"image-rendering",
			"in",
			"in2",
			"k",
			"k1",
			"k2",
			"k3",
			"k4",
			"kerning",
			"keypoints",
			"keysplines",
			"keytimes",
			"lang",
			"lengthadjust",
			"letter-spacing",
			"kernelmatrix",
			"kernelunitlength",
			"lighting-color",
			"local",
			"marker-end",
			"marker-mid",
			"marker-start",
			"markerheight",
			"markerunits",
			"markerwidth",
			"maskcontentunits",
			"maskunits",
			"max",
			"mask",
			"media",
			"method",
			"mode",
			"min",
			"name",
			"numoctaves",
			"offset",
			"operator",
			"opacity",
			"order",
			"orient",
			"orientation",
			"origin",
			"overflow",
			"paint-order",
			"path",
			"pathlength",
			"patterncontentunits",
			"patterntransform",
			"patternunits",
			"points",
			"preservealpha",
			"preserveaspectratio",
			"primitiveunits",
			"r",
			"rx",
			"ry",
			"radius",
			"refx",
			"refy",
			"repeatcount",
			"repeatdur",
			"restart",
			"result",
			"rotate",
			"scale",
			"seed",
			"shape-rendering",
			"specularconstant",
			"specularexponent",
			"spreadmethod",
			"startoffset",
			"stddeviation",
			"stitchtiles",
			"stop-color",
			"stop-opacity",
			"stroke-dasharray",
			"stroke-dashoffset",
			"stroke-linecap",
			"stroke-linejoin",
			"stroke-miterlimit",
			"stroke-opacity",
			"stroke",
			"stroke-width",
			"style",
			"surfacescale",
			"systemlanguage",
			"tabindex",
			"targetx",
			"targety",
			"transform",
			"text-anchor",
			"text-decoration",
			"text-rendering",
			"textlength",
			"type",
			"u1",
			"u2",
			"unicode",
			"values",
			"viewbox",
			"visibility",
			"version",
			"vert-adv-y",
			"vert-origin-x",
			"vert-origin-y",
			"width",
			"word-spacing",
			"wrap",
			"writing-mode",
			"xchannelselector",
			"ychannelselector",
			"x",
			"x1",
			"x2",
			"xmlns",
			"y",
			"y1",
			"y2",
			"z",
			"zoomandpan",
		]),
		nj = Ci([
			"accent",
			"accentunder",
			"align",
			"bevelled",
			"close",
			"columnsalign",
			"columnlines",
			"columnspan",
			"denomalign",
			"depth",
			"dir",
			"display",
			"displaystyle",
			"encoding",
			"fence",
			"frame",
			"height",
			"href",
			"id",
			"largeop",
			"length",
			"linethickness",
			"lspace",
			"lquote",
			"mathbackground",
			"mathcolor",
			"mathsize",
			"mathvariant",
			"maxsize",
			"minsize",
			"movablelimits",
			"notation",
			"numalign",
			"open",
			"rowalign",
			"rowlines",
			"rowspacing",
			"rowspan",
			"rspace",
			"rquote",
			"scriptlevel",
			"scriptminsize",
			"scriptsizemultiplier",
			"selection",
			"separator",
			"separators",
			"stretchy",
			"subscriptshift",
			"supscriptshift",
			"symmetric",
			"voffset",
			"width",
			"xmlns",
		]),
		py = Ci(["xlink:href", "xml:id", "xlink:title", "xml:space", "xmlns:xlink"]),
		Znt = Cl(/\{\{[\s\S]*|[\s\S]*\}\}/gm),
		ert = Cl(/<%[\s\S]*|[\s\S]*%>/gm),
		trt = Cl(/^data-[\-\w.\u00B7-\uFFFF]/),
		nrt = Cl(/^aria-[\-\w]+$/),
		rrt = Cl(
			/^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i,
		),
		irt = Cl(/^(?:\w+script|data):/i),
		art = Cl(/[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g),
		Tm =
			typeof Symbol == "function" && typeof Symbol.iterator == "symbol"
				? function (e) {
						return typeof e
				  }
				: function (e) {
						return e &&
							typeof Symbol == "function" &&
							e.constructor === Symbol &&
							e !== Symbol.prototype
							? "symbol"
							: typeof e
				  }
	function Ho(e) {
		if (Array.isArray(e)) {
			for (var t = 0, n = Array(e.length); t < e.length; t++) n[t] = e[t]
			return n
		} else return Array.from(e)
	}
	var ort = function () {
			return typeof window > "u" ? null : window
		},
		srt = function (t, n) {
			if (
				(typeof t > "u" ? "undefined" : Tm(t)) !== "object" ||
				typeof t.createPolicy != "function"
			)
				return null
			var r = null,
				i = "data-tt-policy-suffix"
			n.currentScript && n.currentScript.hasAttribute(i) && (r = n.currentScript.getAttribute(i))
			var a = "dompurify" + (r ? "#" + r : "")
			try {
				return t.createPolicy(a, {
					createHTML: function (s) {
						return s
					},
				})
			} catch {
				return console.warn("TrustedTypes policy " + a + " could not be created."), null
			}
		}
	function eq() {
		var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : ort(),
			t = function (oe) {
				return eq(oe)
			}
		if (((t.version = "2.3.3"), (t.removed = []), !e || !e.document || e.document.nodeType !== 9))
			return (t.isSupported = !1), t
		var n = e.document,
			r = e.document,
			i = e.DocumentFragment,
			a = e.HTMLTemplateElement,
			o = e.Node,
			s = e.Element,
			l = e.NodeFilter,
			u = e.NamedNodeMap,
			d = u === void 0 ? e.NamedNodeMap || e.MozNamedAttrMap : u,
			p = e.Text,
			m = e.Comment,
			v = e.DOMParser,
			y = e.trustedTypes,
			b = s.prototype,
			x = fy(b, "cloneNode"),
			E = fy(b, "nextSibling"),
			T = fy(b, "childNodes"),
			C = fy(b, "parentNode")
		if (typeof a == "function") {
			var D = r.createElement("template")
			D.content && D.content.ownerDocument && (r = D.content.ownerDocument)
		}
		var O = srt(y, n),
			A = O && ur ? O.createHTML("") : "",
			N = r,
			I = N.implementation,
			P = N.createNodeIterator,
			L = N.createDocumentFragment,
			B = N.getElementsByTagName,
			z = n.importNode,
			V = {}
		try {
			V = kc(r).documentMode ? r.documentMode : {}
		} catch {}
		var K = {}
		t.isSupported = typeof C == "function" && I && typeof I.createHTMLDocument < "u" && V !== 9
		var ne = Znt,
			re = ert,
			ie = trt,
			J = nrt,
			le = irt,
			F = art,
			Y = rrt,
			ee = null,
			$ = Et({}, [].concat(Ho(Z4), Ho(Ok), Ho(Ak), Ho(Nk), Ho(ej))),
			ge = null,
			Se = Et({}, [].concat(Ho(tj), Ho(Mk), Ho(nj), Ho(py))),
			Ee = null,
			be = null,
			Le = !0,
			Be = !0,
			et = !1,
			pt = !1,
			mt = !1,
			Xt = !1,
			on = !1,
			dt = !1,
			cn = !1,
			sn = !0,
			ur = !1,
			Hn = !0,
			Jt = !0,
			mn = !1,
			ue = {},
			Re = null,
			pe = Et({}, [
				"annotation-xml",
				"audio",
				"colgroup",
				"desc",
				"foreignobject",
				"head",
				"iframe",
				"math",
				"mi",
				"mn",
				"mo",
				"ms",
				"mtext",
				"noembed",
				"noframes",
				"noscript",
				"plaintext",
				"script",
				"style",
				"svg",
				"template",
				"thead",
				"title",
				"video",
				"xmp",
			]),
			ye = null,
			X = Et({}, ["audio", "video", "img", "source", "image", "track"]),
			de = null,
			Me = Et({}, [
				"alt",
				"class",
				"for",
				"id",
				"label",
				"name",
				"pattern",
				"placeholder",
				"role",
				"summary",
				"title",
				"value",
				"style",
				"xmlns",
			]),
			Ze = "http://www.w3.org/1998/Math/MathML",
			ct = "http://www.w3.org/2000/svg",
			Ot = "http://www.w3.org/1999/xhtml",
			tr = Ot,
			Wn = !1,
			An = void 0,
			li = ["application/xhtml+xml", "text/html"],
			Nn = "text/html",
			Yn = void 0,
			Tn = null,
			rc = r.createElement("form"),
			ic = function (oe) {
				;(Tn && Tn === oe) ||
					((!oe || (typeof oe > "u" ? "undefined" : Tm(oe)) !== "object") && (oe = {}),
					(oe = kc(oe)),
					(ee = "ALLOWED_TAGS" in oe ? Et({}, oe.ALLOWED_TAGS) : $),
					(ge = "ALLOWED_ATTR" in oe ? Et({}, oe.ALLOWED_ATTR) : Se),
					(de = "ADD_URI_SAFE_ATTR" in oe ? Et(kc(Me), oe.ADD_URI_SAFE_ATTR) : Me),
					(ye = "ADD_DATA_URI_TAGS" in oe ? Et(kc(X), oe.ADD_DATA_URI_TAGS) : X),
					(Re = "FORBID_CONTENTS" in oe ? Et({}, oe.FORBID_CONTENTS) : pe),
					(Ee = "FORBID_TAGS" in oe ? Et({}, oe.FORBID_TAGS) : {}),
					(be = "FORBID_ATTR" in oe ? Et({}, oe.FORBID_ATTR) : {}),
					(ue = "USE_PROFILES" in oe ? oe.USE_PROFILES : !1),
					(Le = oe.ALLOW_ARIA_ATTR !== !1),
					(Be = oe.ALLOW_DATA_ATTR !== !1),
					(et = oe.ALLOW_UNKNOWN_PROTOCOLS || !1),
					(pt = oe.SAFE_FOR_TEMPLATES || !1),
					(mt = oe.WHOLE_DOCUMENT || !1),
					(dt = oe.RETURN_DOM || !1),
					(cn = oe.RETURN_DOM_FRAGMENT || !1),
					(sn = oe.RETURN_DOM_IMPORT !== !1),
					(ur = oe.RETURN_TRUSTED_TYPE || !1),
					(on = oe.FORCE_BODY || !1),
					(Hn = oe.SANITIZE_DOM !== !1),
					(Jt = oe.KEEP_CONTENT !== !1),
					(mn = oe.IN_PLACE || !1),
					(Y = oe.ALLOWED_URI_REGEXP || Y),
					(tr = oe.NAMESPACE || Ot),
					(An = li.indexOf(oe.PARSER_MEDIA_TYPE) === -1 ? (An = Nn) : (An = oe.PARSER_MEDIA_TYPE)),
					(Yn =
						An === "application/xhtml+xml"
							? function (Pe) {
									return Pe
							  }
							: p1),
					pt && (Be = !1),
					cn && (dt = !0),
					ue &&
						((ee = Et({}, [].concat(Ho(ej)))),
						(ge = []),
						ue.html === !0 && (Et(ee, Z4), Et(ge, tj)),
						ue.svg === !0 && (Et(ee, Ok), Et(ge, Mk), Et(ge, py)),
						ue.svgFilters === !0 && (Et(ee, Ak), Et(ge, Mk), Et(ge, py)),
						ue.mathMl === !0 && (Et(ee, Nk), Et(ge, nj), Et(ge, py))),
					oe.ADD_TAGS && (ee === $ && (ee = kc(ee)), Et(ee, oe.ADD_TAGS)),
					oe.ADD_ATTR && (ge === Se && (ge = kc(ge)), Et(ge, oe.ADD_ATTR)),
					oe.ADD_URI_SAFE_ATTR && Et(de, oe.ADD_URI_SAFE_ATTR),
					oe.FORBID_CONTENTS && (Re === pe && (Re = kc(Re)), Et(Re, oe.FORBID_CONTENTS)),
					Jt && (ee["#text"] = !0),
					mt && Et(ee, ["html", "head", "body"]),
					ee.table && (Et(ee, ["tbody"]), delete Ee.tbody),
					Ci && Ci(oe),
					(Tn = oe))
			},
			Ms = Et({}, ["mi", "mo", "mn", "ms", "mtext"]),
			Is = Et({}, ["foreignobject", "desc", "title", "annotation-xml"]),
			ac = Et({}, Ok)
		Et(ac, Ak), Et(ac, Xnt)
		var Hd = Et({}, Nk)
		Et(Hd, Jnt)
		var Dg = function (oe) {
				var Pe = C(oe)
				;(!Pe || !Pe.tagName) && (Pe = { namespaceURI: Ot, tagName: "template" })
				var Xe = p1(oe.tagName),
					St = p1(Pe.tagName)
				if (oe.namespaceURI === ct)
					return Pe.namespaceURI === Ot
						? Xe === "svg"
						: Pe.namespaceURI === Ze
						? Xe === "svg" && (St === "annotation-xml" || Ms[St])
						: !!ac[Xe]
				if (oe.namespaceURI === Ze)
					return Pe.namespaceURI === Ot
						? Xe === "math"
						: Pe.namespaceURI === ct
						? Xe === "math" && Is[St]
						: !!Hd[Xe]
				if (oe.namespaceURI === Ot) {
					if ((Pe.namespaceURI === ct && !Is[St]) || (Pe.namespaceURI === Ze && !Ms[St])) return !1
					var cr = Et({}, ["title", "style", "font", "a", "script"])
					return !Hd[Xe] && (cr[Xe] || !ac[Xe])
				}
				return !1
			},
			ka = function (oe) {
				im(t.removed, { element: oe })
				try {
					oe.parentNode.removeChild(oe)
				} catch {
					try {
						oe.outerHTML = A
					} catch {
						oe.remove()
					}
				}
			},
			uh = function (oe, Pe) {
				try {
					im(t.removed, { attribute: Pe.getAttributeNode(oe), from: Pe })
				} catch {
					im(t.removed, { attribute: null, from: Pe })
				}
				if ((Pe.removeAttribute(oe), oe === "is" && !ge[oe]))
					if (dt || cn)
						try {
							ka(Pe)
						} catch {}
					else
						try {
							Pe.setAttribute(oe, "")
						} catch {}
			},
			$d = function (oe) {
				var Pe = void 0,
					Xe = void 0
				if (on) oe = "<remove></remove>" + oe
				else {
					var St = X4(oe, /^[\r\n\t ]+/)
					Xe = St && St[0]
				}
				An === "application/xhtml+xml" &&
					(oe =
						'<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' +
						oe +
						"</body></html>")
				var cr = O ? O.createHTML(oe) : oe
				if (tr === Ot)
					try {
						Pe = new v().parseFromString(cr, An)
					} catch {}
				if (!Pe || !Pe.documentElement) {
					Pe = I.createDocument(tr, "template", null)
					try {
						Pe.documentElement.innerHTML = Wn ? "" : cr
					} catch {}
				}
				var dr = Pe.body || Pe.documentElement
				return (
					oe && Xe && dr.insertBefore(r.createTextNode(Xe), dr.childNodes[0] || null),
					tr === Ot ? B.call(Pe, mt ? "html" : "body")[0] : mt ? Pe.documentElement : dr
				)
			},
			ch = function (oe) {
				return P.call(
					oe.ownerDocument || oe,
					oe,
					l.SHOW_ELEMENT | l.SHOW_COMMENT | l.SHOW_TEXT,
					null,
					!1,
				)
			},
			oc = function (oe) {
				return oe instanceof p || oe instanceof m
					? !1
					: typeof oe.nodeName != "string" ||
							typeof oe.textContent != "string" ||
							typeof oe.removeChild != "function" ||
							!(oe.attributes instanceof d) ||
							typeof oe.removeAttribute != "function" ||
							typeof oe.setAttribute != "function" ||
							typeof oe.namespaceURI != "string" ||
							typeof oe.insertBefore != "function"
			},
			Rs = function (oe) {
				return (typeof o > "u" ? "undefined" : Tm(o)) === "object"
					? oe instanceof o
					: oe &&
							(typeof oe > "u" ? "undefined" : Tm(oe)) === "object" &&
							typeof oe.nodeType == "number" &&
							typeof oe.nodeName == "string"
			},
			ui = function (oe, Pe, Xe) {
				K[oe] &&
					Ynt(K[oe], function (St) {
						St.call(t, Pe, Xe, Tn)
					})
			},
			_g = function (oe) {
				var Pe = void 0
				if ((ui("beforeSanitizeElements", oe, null), oc(oe) || X4(oe.nodeName, /[\u0080-\uFFFF]/)))
					return ka(oe), !0
				var Xe = Yn(oe.nodeName)
				if (
					(ui("uponSanitizeElement", oe, { tagName: Xe, allowedTags: ee }),
					(!Rs(oe.firstElementChild) &&
						(!Rs(oe.content) || !Rs(oe.content.firstElementChild)) &&
						Vs(/<[/\w]/g, oe.innerHTML) &&
						Vs(/<[/\w]/g, oe.textContent)) ||
						(Xe === "select" && Vs(/<template/i, oe.innerHTML)))
				)
					return ka(oe), !0
				if (!ee[Xe] || Ee[Xe]) {
					if (Jt && !Re[Xe]) {
						var St = C(oe) || oe.parentNode,
							cr = T(oe) || oe.childNodes
						if (cr && St)
							for (var dr = cr.length, xr = dr - 1; xr >= 0; --xr)
								St.insertBefore(x(cr[xr], !0), E(oe))
					}
					return ka(oe), !0
				}
				return (oe instanceof s && !Dg(oe)) ||
					((Xe === "noscript" || Xe === "noembed") && Vs(/<\/no(script|embed)/i, oe.innerHTML))
					? (ka(oe), !0)
					: (pt &&
							oe.nodeType === 3 &&
							((Pe = oe.textContent),
							(Pe = iu(Pe, ne, " ")),
							(Pe = iu(Pe, re, " ")),
							oe.textContent !== Pe &&
								(im(t.removed, { element: oe.cloneNode() }), (oe.textContent = Pe))),
					  ui("afterSanitizeElements", oe, null),
					  !1)
			},
			Ll = function (oe, Pe, Xe) {
				if (Hn && (Pe === "id" || Pe === "name") && (Xe in r || Xe in rc)) return !1
				if (!(Be && !be[Pe] && Vs(ie, Pe))) {
					if (!(Le && Vs(J, Pe))) {
						if (!ge[Pe] || be[Pe]) return !1
						if (!de[Pe]) {
							if (!Vs(Y, iu(Xe, F, ""))) {
								if (
									!(
										(Pe === "src" || Pe === "xlink:href" || Pe === "href") &&
										oe !== "script" &&
										Gnt(Xe, "data:") === 0 &&
										ye[oe]
									)
								) {
									if (!(et && !Vs(le, iu(Xe, F, "")))) {
										if (Xe) return !1
									}
								}
							}
						}
					}
				}
				return !0
			},
			sc = function (oe) {
				var Pe = void 0,
					Xe = void 0,
					St = void 0,
					cr = void 0
				ui("beforeSanitizeAttributes", oe, null)
				var dr = oe.attributes
				if (dr) {
					var xr = { attrName: "", attrValue: "", keepAttr: !0, allowedAttributes: ge }
					for (cr = dr.length; cr--; ) {
						Pe = dr[cr]
						var Sa = Pe,
							Pl = Sa.name,
							dh = Sa.namespaceURI
						if (
							((Xe = Knt(Pe.value)),
							(St = Yn(Pl)),
							(xr.attrName = St),
							(xr.attrValue = Xe),
							(xr.keepAttr = !0),
							(xr.forceKeepAttr = void 0),
							ui("uponSanitizeAttribute", oe, xr),
							(Xe = xr.attrValue),
							!xr.forceKeepAttr && (uh(Pl, oe), !!xr.keepAttr))
						) {
							if (Vs(/\/>/i, Xe)) {
								uh(Pl, oe)
								continue
							}
							pt && ((Xe = iu(Xe, ne, " ")), (Xe = iu(Xe, re, " ")))
							var Og = Yn(oe.nodeName)
							if (Ll(Og, St, Xe))
								try {
									dh ? oe.setAttributeNS(dh, Pl, Xe) : oe.setAttribute(Pl, Xe), Q4(t.removed)
								} catch {}
						}
					}
					ui("afterSanitizeAttributes", oe, null)
				}
			},
			Ud = function tt(oe) {
				var Pe = void 0,
					Xe = ch(oe)
				for (ui("beforeSanitizeShadowDOM", oe, null); (Pe = Xe.nextNode()); )
					ui("uponSanitizeShadowNode", Pe, null),
						!_g(Pe) && (Pe.content instanceof i && tt(Pe.content), sc(Pe))
				ui("afterSanitizeShadowDOM", oe, null)
			}
		return (
			(t.sanitize = function (tt, oe) {
				var Pe = void 0,
					Xe = void 0,
					St = void 0,
					cr = void 0,
					dr = void 0
				if (((Wn = !tt), Wn && (tt = "<!-->"), typeof tt != "string" && !Rs(tt))) {
					if (typeof tt.toString != "function") throw J4("toString is not a function")
					if (((tt = tt.toString()), typeof tt != "string"))
						throw J4("dirty is not a string, aborting")
				}
				if (!t.isSupported) {
					if (Tm(e.toStaticHTML) === "object" || typeof e.toStaticHTML == "function") {
						if (typeof tt == "string") return e.toStaticHTML(tt)
						if (Rs(tt)) return e.toStaticHTML(tt.outerHTML)
					}
					return tt
				}
				if ((Xt || ic(oe), (t.removed = []), typeof tt == "string" && (mn = !1), !mn))
					if (tt instanceof o)
						(Pe = $d("<!---->")),
							(Xe = Pe.ownerDocument.importNode(tt, !0)),
							(Xe.nodeType === 1 && Xe.nodeName === "BODY") || Xe.nodeName === "HTML"
								? (Pe = Xe)
								: Pe.appendChild(Xe)
					else {
						if (!dt && !pt && !mt && tt.indexOf("<") === -1) return O && ur ? O.createHTML(tt) : tt
						if (((Pe = $d(tt)), !Pe)) return dt ? null : A
					}
				Pe && on && ka(Pe.firstChild)
				for (var xr = ch(mn ? tt : Pe); (St = xr.nextNode()); )
					(St.nodeType === 3 && St === cr) ||
						_g(St) ||
						(St.content instanceof i && Ud(St.content), sc(St), (cr = St))
				if (((cr = null), mn)) return tt
				if (dt) {
					if (cn) for (dr = L.call(Pe.ownerDocument); Pe.firstChild; ) dr.appendChild(Pe.firstChild)
					else dr = Pe
					return sn && (dr = z.call(n, dr, !0)), dr
				}
				var Sa = mt ? Pe.outerHTML : Pe.innerHTML
				return (
					pt && ((Sa = iu(Sa, ne, " ")), (Sa = iu(Sa, re, " "))), O && ur ? O.createHTML(Sa) : Sa
				)
			}),
			(t.setConfig = function (tt) {
				ic(tt), (Xt = !0)
			}),
			(t.clearConfig = function () {
				;(Tn = null), (Xt = !1)
			}),
			(t.isValidAttribute = function (tt, oe, Pe) {
				Tn || ic({})
				var Xe = Yn(tt),
					St = Yn(oe)
				return Ll(Xe, St, Pe)
			}),
			(t.addHook = function (tt, oe) {
				typeof oe == "function" && ((K[tt] = K[tt] || []), im(K[tt], oe))
			}),
			(t.removeHook = function (tt) {
				K[tt] && Q4(K[tt])
			}),
			(t.removeHooks = function (tt) {
				K[tt] && (K[tt] = [])
			}),
			(t.removeAllHooks = function () {
				K = {}
			}),
			t
		)
	}
	var lrt = eq(),
		urt = ["iframe", "embed"],
		tq = []
	function nq(e) {
		Vr(urt, e) && tq.push(e.toLowerCase())
	}
	function Cd(e, t) {
		return lrt.sanitize(
			e,
			me(
				{
					ADD_TAGS: tq,
					ADD_ATTR: ["rel", "target", "hreflang", "type"],
					FORBID_TAGS: [
						"input",
						"script",
						"textarea",
						"form",
						"button",
						"select",
						"meta",
						"style",
						"link",
						"title",
						"object",
						"base",
					],
				},
				t,
			),
		)
	}
	function rq(e, t) {
		return e.literal
			.replace(new RegExp("(<\\s*" + t + "[^>]*>)|(</" + t + "\\s*[>])", "ig"), "")
			.trim()
	}
	function X2(e) {
		e = e.match(yp)[0]
		var t = e.match(new RegExp(JU, "g"))
		return t
			? t.reduce(function (n, r) {
					var i = r.trim().split("="),
						a = i[0],
						o = i.slice(1)
					return o.length && (n[a] = o.join("=").replace(/'|"/g, "").trim()), n
			  }, {})
			: {}
	}
	function J2(e) {
		return Ds(e.attributes).reduce(function (t, n) {
			return (t[n.nodeName] = n.nodeValue), t
		}, {})
	}
	function rj(e, t, n, r) {
		var i = r.getToDOMNode(t)(e),
			a = n(i.outerHTML),
			o = document.createElement("div")
		;(o.innerHTML = a), (i = o.firstChild)
		var s = J2(i)
		return { dom: i, htmlAttrs: s }
	}
	var crt = {
		htmlBlock: function (e, t, n) {
			return {
				atom: !0,
				content: "block+",
				group: "block",
				attrs: {
					htmlAttrs: { default: {} },
					childrenHTML: { default: "" },
					htmlBlock: { default: !0 },
				},
				parseDOM: [
					{
						tag: e,
						getAttrs: function (r) {
							return { htmlAttrs: J2(r), childrenHTML: r.innerHTML }
						},
					},
				],
				toDOM: function (r) {
					var i = rj(r, e, t, n),
						a = i.dom,
						o = i.htmlAttrs
					return (
						(o.class = o.class ? o.class + " html-block" : "html-block"),
						Gi([e, o], Ds(a.childNodes))
					)
				},
			}
		},
		htmlInline: function (e, t, n) {
			return {
				attrs: { htmlAttrs: { default: {} }, htmlInline: { default: !0 } },
				parseDOM: [
					{
						tag: e,
						getAttrs: function (r) {
							return { htmlAttrs: J2(r) }
						},
					},
				],
				toDOM: function (r) {
					var i = rj(r, e, t, n).htmlAttrs
					return [e, i, 0]
				},
			}
		},
	}
	function drt(e, t, n) {
		var r = { nodes: {}, marks: {} }
		return (
			["htmlBlock", "htmlInline"].forEach(function (i) {
				e[i] &&
					Object.keys(e[i]).forEach(function (a) {
						var o = i === "htmlBlock" ? "nodes" : "marks"
						nq(a), (r[o][a] = crt[i](a, t, n))
					})
			}),
			r
		)
	}
	var frt = /^\s*<\s*\//,
		prt = {
			paragraph: function (e, t) {
				var n = t.entering,
					r = t.origin,
					i = t.options
				return i.nodeId ? { type: n ? "openTag" : "closeTag", outerNewLine: !0, tagName: "p" } : r()
			},
			softbreak: function (e) {
				var t = e.prev && e.prev.type === "htmlInline",
					n = t && /<br ?\/?>/.test(e.prev.literal),
					r = n
						? `
`
						: `<br>
`
				return { type: "html", content: r }
			},
			item: function (e, t) {
				var n = t.entering
				if (n) {
					var r = {},
						i = []
					return (
						e.listData.task &&
							((r["data-task"] = ""),
							i.push("task-list-item"),
							e.listData.checked && (i.push("checked"), (r["data-task-checked"] = ""))),
						{ type: "openTag", tagName: "li", classNames: i, attributes: r, outerNewLine: !0 }
					)
				}
				return { type: "closeTag", tagName: "li", outerNewLine: !0 }
			},
			code: function (e) {
				var t = { "data-backticks": String(e.tickCount) }
				return [
					{ type: "openTag", tagName: "code", attributes: t },
					{ type: "text", content: e.literal },
					{ type: "closeTag", tagName: "code" },
				]
			},
			codeBlock: function (e) {
				var t = e,
					n = t.fenceLength,
					r = t.info,
					i = r ? r.split(/\s+/) : [],
					a = [],
					o = {}
				if ((n > 3 && (o["data-backticks"] = n), i.length > 0 && i[0].length > 0)) {
					var s = i[0]
					a.push("lang-" + s), (o["data-language"] = s)
				}
				return [
					{ type: "openTag", tagName: "pre", classNames: a },
					{ type: "openTag", tagName: "code", attributes: o },
					{ type: "text", content: e.literal },
					{ type: "closeTag", tagName: "code" },
					{ type: "closeTag", tagName: "pre" },
				]
			},
			customInline: function (e, t) {
				var n = t.origin,
					r = t.entering,
					i = t.skipChildren,
					a = e.info
				if (a.indexOf("widget") !== -1 && r) {
					i()
					var o = GU(e),
						s = YU(a, o).outerHTML
					return [
						{ type: "openTag", tagName: "span", classNames: ["tui-widget"] },
						{ type: "html", content: s },
						{ type: "closeTag", tagName: "span" },
					]
				}
				return n()
			},
		}
	function lA(e, t) {
		var n = me({}, prt)
		return (
			e &&
				(n.link = function (r, i) {
					var a = i.entering,
						o = i.origin,
						s = o()
					return a && (s.attributes = me(me({}, s.attributes), e)), s
				}),
			t &&
				Object.keys(t).forEach(function (r) {
					var i = n[r],
						a = t[r]
					i && Ka(a)
						? (n[r] = function (o, s) {
								var l = me({}, s)
								return (
									(l.origin = function () {
										return i(o, s)
									}),
									a(o, l)
								)
						  })
						: Vr(["htmlBlock", "htmlInline"], r) && !Ka(a)
						? (n[r] = function (o, s) {
								var l = o.literal.match(yp)
								if (l) {
									var u = l[0],
										d = l[1],
										p = l[3],
										m = (d || p).toLowerCase(),
										v = a[m],
										y = rq(o, m)
									if (v) {
										var b = me({}, o)
										return (
											(b.attrs = X2(u)),
											(b.childrenHTML = y),
											(b.type = m),
											(s.entering = !frt.test(o.literal)),
											v(b, s)
										)
									}
								}
								return s.origin()
						  })
						: (n[r] = a)
				}),
			n
		)
	}
	var hrt = ["list", "item", "blockQuote"],
		mrt = ["UL", "OL", "BLOCKQUOTE"]
	function vrt(e, t) {
		var n,
			r = e.child(t)
		return (
			!r.childCount ||
			(r.childCount === 1 && !(!((n = r.firstChild.text) === null || n === void 0) && n.trim()))
		)
	}
	function ij(e, t, n) {
		var r = hg(t) - 1,
			i = sw(t) - 1,
			a = n[r].getBoundingClientRect(),
			o = n[i].offsetTop - n[r].offsetTop + n[i].clientHeight
		return {
			height: o <= 0 ? n[r].clientHeight : o + grt(e, n, Math.min(i + 1, e.childCount - 1)),
			rect: a,
		}
	}
	function grt(e, t, n) {
		for (var r = e.childCount - 1, i = 0; n <= r && vrt(e, n); ) (i += t[n].clientHeight), (n += 1)
		return i
	}
	function yrt(e, t) {
		for (; !e.getAttribute("data-nodeid") && e.parentElement !== t; ) e = e.parentElement
		return e
	}
	function Db(e, t) {
		for (
			var n = 0;
			e && e !== t && (Vr(mrt, e.tagName) || (n += e.offsetTop), e.offsetParent !== t.offsetParent);

		)
			e = e.parentElement
		return n
	}
	function brt(e, t) {
		for (var n = t, r = null; n; ) {
			var i = n.firstElementChild
			if (!i) break
			var a = iq(i, e, Db(n, t))
			;(r = n), (n = a)
		}
		var o = n || r
		return o === t ? null : o
	}
	function iq(e, t, n) {
		return e && t > n + e.offsetTop ? iq(e.nextElementSibling, t, n) || e : null
	}
	function xrt(e, t, n, r) {
		var i = Math.min((e - t) / n, 1)
		return i * r
	}
	function Ik(e, t) {
		for (var n = e.querySelector('[data-nodeid="' + t.id + '"]'); !n || o1e(t); )
			(t = t.parent), (n = e.querySelector('[data-nodeid="' + t.id + '"]'))
		return wrt({ mdNode: t, el: n })
	}
	function wrt(e) {
		for (var t = e.mdNode, n = e.el; (Vr(hrt, t.type) || t.type === "table") && t.firstChild; )
			(t = t.firstChild), (n = n.firstElementChild)
		return { mdNode: t, el: n }
	}
	var Eo = {}
	function Ert(e, t) {
		;(Eo[e] = Eo[e] || {}), (Eo[e].height = t)
	}
	function Crt(e, t) {
		;(Eo[e] = Eo[e] || {}), (Eo[e].offsetTop = t)
	}
	function Trt(e) {
		return Eo[e] && Eo[e].height
	}
	function krt(e) {
		return Eo[e] && Eo[e].offsetTop
	}
	function Z2(e) {
		e &&
			(delete Eo[Number(e.getAttribute("data-nodeid"))],
			Ds(e.children).forEach(function (t) {
				Z2(t)
			}))
	}
	function Srt(e, t, n) {
		var r = Trt(n),
			i = krt(n),
			a = r || e.clientHeight,
			o = i || Db(e, t) || e.offsetTop
		return r || Ert(n, a), i || Crt(n, o), { nodeHeight: a, offsetTop: o }
	}
	var Rk = Qe("md-preview-highlight")
	function Drt(e, t) {
		for (var n = e.firstChild; n && n.next && !(lw(n.next) > t + 1); ) n = n.next
		return n
	}
	var aq = (function () {
		function e(t, n) {
			var r = document.createElement("div")
			;(this.el = r),
				(this.eventEmitter = t),
				(this.isViewer = !!n.isViewer),
				(this.el.className = Qe("md-preview"))
			var i = n.linkAttributes,
				a = n.customHTMLRenderer,
				o = n.sanitizer,
				s = n.highlight,
				l = s === void 0 ? !1 : s
			;(this.renderer = new sA({ gfm: !0, nodeId: !0, convertors: lA(i, a) })),
				(this.cursorNodeId = null),
				(this.sanitizer = o),
				this.initEvent(l),
				this.initContentSection(),
				this.isViewer && (this.previewContent.style.overflowWrap = "break-word")
		}
		return (
			(e.prototype.initContentSection = function () {
				;(this.previewContent = rz('<div class="' + Qe("contents") + '"></div>')),
					this.isViewer || this.el.appendChild(this.previewContent)
			}),
			(e.prototype.toggleActive = function (t) {
				YO(this.el, "active", t)
			}),
			(e.prototype.initEvent = function (t) {
				var n = this
				this.eventEmitter.listen("updatePreview", this.update.bind(this)),
					!this.isViewer &&
						(t &&
							(this.eventEmitter.listen("changeToolbarState", function (r) {
								var i = r.mdNode,
									a = r.cursorPos
								n.updateCursorNode(i, a)
							}),
							this.eventEmitter.listen("blur", function () {
								n.removeHighlight()
							})),
						xz(this.el, "scroll", function (r) {
							n.eventEmitter.emit("scroll", "preview", brt(r.target.scrollTop, n.previewContent))
						}),
						this.eventEmitter.listen("changePreviewTabPreview", function () {
							return n.toggleActive(!0)
						}),
						this.eventEmitter.listen("changePreviewTabWrite", function () {
							return n.toggleActive(!1)
						}))
			}),
			(e.prototype.removeHighlight = function () {
				if (this.cursorNodeId) {
					var t = this.getElementByNodeId(this.cursorNodeId)
					t && go(t, Rk)
				}
			}),
			(e.prototype.updateCursorNode = function (t, n) {
				t &&
					((t = gp(t, function (o) {
						return !u1e(o)
					})),
					t.type === "tableRow" ? (t = Drt(t, n[1])) : t.type === "tableBody" && (t = null))
				var r = t ? t.id : null
				if (this.cursorNodeId !== r) {
					var i = this.getElementByNodeId(this.cursorNodeId),
						a = this.getElementByNodeId(r)
					i && go(i, Rk), a && ss(a, Rk), (this.cursorNodeId = r)
				}
			}),
			(e.prototype.getElementByNodeId = function (t) {
				return t ? this.previewContent.querySelector('[data-nodeid="' + t + '"]') : null
			}),
			(e.prototype.update = function (t) {
				var n = this
				t.forEach(function (r) {
					return n.replaceRangeNodes(r)
				}),
					this.eventEmitter.emit("afterPreviewRender", this)
			}),
			(e.prototype.replaceRangeNodes = function (t) {
				var n = this,
					r = t.nodes,
					i = t.removedNodeRange,
					a = this.previewContent,
					o = this.eventEmitter.emitReduce(
						"beforePreviewRender",
						this.sanitizer(
							r
								.map(function (y) {
									return n.renderer.render(y)
								})
								.join(""),
						),
					)
				if (!i) a.insertAdjacentHTML("afterbegin", o)
				else {
					var s = i.id,
						l = s[0],
						u = s[1],
						d = this.getElementByNodeId(l),
						p = this.getElementByNodeId(u)
					if (d) {
						d.insertAdjacentHTML("beforebegin", o)
						for (var m = d; m && m !== p; ) {
							var v = m.nextElementSibling
							xd(m), Z2(m), (m = v)
						}
						m != null && m.parentNode && (xd(m), Z2(m))
					}
				}
			}),
			(e.prototype.getRenderer = function () {
				return this.renderer
			}),
			(e.prototype.destroy = function () {
				bz(this.el, "scroll"), (this.el = null)
			}),
			(e.prototype.getElement = function () {
				return this.el
			}),
			(e.prototype.getHTML = function () {
				return QO(this.previewContent.innerHTML)
			}),
			(e.prototype.setHTML = function (t) {
				this.previewContent.innerHTML = t
			}),
			(e.prototype.setHeight = function (t) {
				gs(this.el, { height: t + "px" })
			}),
			(e.prototype.setMinHeight = function (t) {
				gs(this.el, { minHeight: t + "px" })
			}),
			e
		)
	})()
	function ol(e, t) {
		for (var n = e.depth; n; ) {
			var r = e.node(n)
			if (t(r, n)) return { node: r, depth: n, offset: n > 0 ? e.before(n) : 0 }
			n -= 1
		}
		return null
	}
	function Ep(e) {
		return !!ol(e, function (t) {
			var n = t.type
			return n.name === "listItem" || n.name === "bulletList" || n.name === "orderedList"
		})
	}
	function _b(e) {
		return !!ol(e, function (t) {
			var n = t.type
			return n.name === "tableHeadCell" || n.name === "tableBodyCell"
		})
	}
	function Cp(e) {
		return ol(e, function (t) {
			var n = t.type
			return n.name === "listItem"
		})
	}
	function gw(e) {
		return {
			tag: e,
			getAttrs: function (t) {
				var n = t.getAttribute("data-raw-html")
				return me({}, n && { rawHTML: n })
			},
		}
	}
	function oq(e) {
		return Object.keys(e).reduce(function (t, n) {
			return n !== "rawHTML" && e[n] && ((n = n === "className" ? "class" : n), (t[n] = e[n])), t
		}, {})
	}
	function sq(e) {
		return {
			tag: e,
			getAttrs: function (t) {
				return ["rawHTML", "colspan", "rowspan", "extended"].reduce(function (n, r) {
					var i = r === "rawHTML" ? "data-raw-html" : r,
						a = t.getAttribute(i)
					return a && (n[r] = Vr(["rawHTML", "extended"], r) ? a : Number(a)), n
				}, {})
			},
		}
	}
	function Mr() {
		return { htmlAttrs: { default: null }, classNames: { default: null } }
	}
	function sr(e) {
		var t = e.htmlAttrs,
			n = e.classNames
		return me(me({}, t), { class: n ? n.join(" ") : null })
	}
	function _rt(e, t) {
		var n = e.parent,
			r = e.startIndex,
			i = e.endIndex,
			a = n.contentMatchAt(r).findWrapping(t)
		if (a) {
			var o = a.length ? a[0] : t
			return n.canReplaceWith(r, i, o) ? a : null
		}
		return null
	}
	function Ort(e, t) {
		var n = e.parent,
			r = e.startIndex,
			i = e.endIndex,
			a = n.child(r),
			o = t.contentMatch.findWrapping(a.type)
		if (o) {
			for (var s = o.length ? o[o.length - 1] : t, l = s.contentMatch, u = r; l && u < i; u += 1)
				l = l.matchType(n.child(u).type)
			if (l && l.validEnd) return o
		}
		return null
	}
	function Art(e, t, n, r) {
		var i = _rt(e, n),
			a = Ort(t, n)
		if (i && a) {
			var o = i.map(function (l) {
					return { type: l }
				}),
				s = a.map(function (l) {
					return { type: l, attrs: r }
				})
			return o.concat({ type: n }).concat(s)
		}
		return null
	}
	function Nrt(e, t, n, r, i) {
		for (
			var a = t.start,
				o = t.end,
				s = t.startIndex,
				l = t.endIndex,
				u = t.parent,
				d = ke.empty,
				p = n.length - 1;
			p >= 0;
			p -= 1
		)
			d = ke.from(n[p].type.create(n[p].attrs, d))
		e.step(new Ar(a - (r ? 2 : 0), o, a, o, new Ue(d, 0, 0), n.length, !0))
		for (var m = 0, p = 0; p < n.length; p += 1)
			if (n[p].type === i) {
				m = p + 1
				break
			}
		for (var v = n.length - m, y = a + n.length - (r ? 2 : 0), p = s, b = l; p < b; p += 1) {
			var x = p === s
			!x && Yf(e.doc, y, v) && (e.split(y, v), (y += v * 2)), (y += u.child(p).nodeSize)
		}
		return e
	}
	function lq(e, t, n, r) {
		var i = t.$from,
			a = t.$to,
			o = t.depth,
			s = t,
			l = !1
		if (o >= 2 && i.node(o - 1).type.compatibleContent(n) && t.startIndex === 0 && i.index(o - 1)) {
			var u = e.doc.resolve(t.start - 2)
			;(s = new ab(u, u, o)),
				t.endIndex < t.parent.childCount && (t = new ab(i, e.doc.resolve(a.end(o)), o)),
				(l = !0)
		}
		var d = Art(s, t, n, r)
		return d ? Nrt(e, t, d, l, n) : e
	}
	function uq(e, t) {
		for (var n = e.resolve(t); n.node().type.name !== "paragraph"; ) (t -= 2), (n = e.resolve(t))
		return Cp(n)
	}
	function Mrt(e, t) {
		var n = t.$from,
			r = t.$to,
			i = Cp(n),
			a = Cp(r)
		if (i && a)
			for (; a; ) {
				var o = a.offset,
					s = a.node,
					l = { task: !s.attrs.task, checked: !1 }
				if ((e.setNodeMarkup(o, null, l), o === i.offset)) break
				a = uq(e.doc, o)
			}
		return e
	}
	function Irt(e, t, n) {
		var r = t.$from,
			i = t.$to,
			a = Cp(r),
			o = Cp(i)
		if (a && o)
			for (; o; ) {
				var s = o.offset,
					l = o.node,
					u = o.depth
				l.attrs.task && e.setNodeMarkup(s, null, { task: !1, checked: !1 })
				var d = e.doc.resolve(s)
				if (d.parent.type !== n) {
					var p = d.before(u - 1)
					e.setNodeMarkup(p, n)
				}
				if (s === a.offset) break
				o = uq(e.doc, s)
			}
		return e
	}
	function cq(e) {
		return function (t, n) {
			var r = t.selection,
				i = t.tr,
				a = r.$from,
				o = r.$to,
				s = a.blockRange(o)
			if (s) {
				var l = Ep(a) ? Irt(i, s, e) : lq(i, s, e)
				return n(l), !0
			}
			return !1
		}
	}
	function Rrt() {
		return function (e, t) {
			var n = e.selection,
				r = e.tr,
				i = e.schema,
				a = n.$from,
				o = n.$to,
				s = a.blockRange(o)
			if (s) {
				var l = Ep(a) ? Mrt(r, s) : lq(r, s, i.nodes.bulletList, { task: !0 })
				return t(l), !0
			}
			return !1
		}
	}
	function Lrt(e) {
		return function (t, n) {
			var r = t.tr,
				i = t.selection,
				a = i.$from,
				o = i.$to,
				s = a.blockRange(o, function (b) {
					var x = b.childCount,
						E = b.firstChild
					return !!x && E.type === e
				})
			if (s && s.startIndex > 0) {
				var l = s.parent,
					u = l.child(s.startIndex - 1)
				if (u.type !== e) return !1
				var d = u.lastChild && u.lastChild.type === l.type,
					p = d ? ke.from(e.create()) : null,
					m = new Ue(ke.from(e.create(null, ke.from(l.type.create(null, p)))), d ? 3 : 1, 0),
					v = s.start,
					y = s.end
				return r.step(new Ar(v - (d ? 3 : 1), y, v, y, m, 1, !0)), n(r), !0
			}
			return !1
		}
	}
	function Prt(e, t, n) {
		var r = t.$from,
			i = t.$to,
			a = t.end,
			o = t.depth,
			s = t.parent,
			l = i.end(o)
		return (
			a < l &&
				(e.step(new Ar(a - 1, l, a, l, new Ue(ke.from(n.create(null, s.copy())), 1, 0), 1, !0)),
				(t = new ab(e.doc.resolve(r.pos), e.doc.resolve(l), o))),
			e.lift(t, ew(t)),
			e
		)
	}
	function jrt(e, t) {
		for (var n = t.parent, r = t.end, i = t.endIndex - 1, a = t.startIndex; i > a; i -= 1)
			(r -= n.child(i).nodeSize), e.delete(r - 1, r + 1)
		var o = e.doc.resolve(t.start),
			s = o.nodeAfter,
			l = t.startIndex === 0,
			u = t.endIndex === n.childCount,
			d = o.node(-1),
			p = o.index(-1),
			m = d.canReplace(
				p + (l ? 0 : 1),
				p + 1,
				s == null ? void 0 : s.content.append(u ? ke.empty : ke.from(n)),
			)
		if (s && m) {
			var v = o.pos,
				y = v + s.nodeSize
			e.step(
				new Ar(
					v - (l ? 1 : 0),
					y + (u ? 1 : 0),
					v + 1,
					y - 1,
					new Ue(
						(l ? ke.empty : ke.from(n.copy(ke.empty))).append(
							u ? ke.empty : ke.from(n.copy(ke.empty)),
						),
						l ? 0 : 1,
						u ? 0 : 1,
					),
					l ? 0 : 1,
				),
			)
		}
		return e
	}
	function Frt(e) {
		return function (t, n) {
			var r = t.tr,
				i = t.selection,
				a = i.$from,
				o = i.$to,
				s = a.blockRange(o, function (d) {
					var p = d.childCount,
						m = d.firstChild
					return !!p && m.type === e
				})
			if (s) {
				var l = a.node(s.depth - 1).type === e,
					u = l ? Prt(r, s, e) : jrt(r, s)
				return n(u), !0
			}
			return !1
		}
	}
	function Brt(e) {
		return function (t, n) {
			var r = t.tr,
				i = t.selection,
				a = i.$from,
				o = i.$to
			if (a.depth < 2 || !a.sameParent(o)) return !1
			var s = a.node(-1)
			if (s.type !== e) return !1
			if (a.parent.content.size === 0 && a.node(-1).childCount === a.indexAfter(-1)) {
				if (a.depth === 2 || a.node(-3).type !== e || a.index(-2) !== a.node(-2).childCount - 1)
					return !1
				for (
					var l = a.index(-1) > 0, u = ke.empty, d = a.depth - (l ? 1 : 2);
					d >= a.depth - 3;
					d -= 1
				)
					u = ke.from(a.node(d).copy(u))
				return (
					(u = u.append(ke.from(e.createAndFill()))),
					r.replace(l ? a.before() : a.before(-1), a.after(-3), new Ue(u, l ? 3 : 2, 2)),
					r.setSelection(_t.near(r.doc.resolve(a.pos + (l ? 3 : 2)))),
					n(r),
					!0
				)
			}
			var p = o.pos === a.end() ? s.contentMatchAt(0).defaultType : null,
				m = p && [null, { type: p }]
			return r.delete(a.pos, o.pos), Yf(r.doc, a.pos, 2, m) ? (r.split(a.pos, 2, m), n(r), !0) : !1
		}
	}
	function Hrt() {
		return function () {
			return function (e, t) {
				var n = e.selection,
					r = e.schema,
					i = n.$from,
					a = n.$to,
					o = i.blockRange(a)
				return o && Ep(i) ? Lrt(r.nodes.listItem)(e, t) : !1
			}
		}
	}
	function $rt() {
		return function () {
			return function (e, t) {
				var n = e.selection,
					r = e.schema,
					i = n.$from,
					a = n.$to,
					o = i.blockRange(a)
				return o && Ep(i) ? Frt(r.nodes.listItem)(e, t) : !1
			}
		}
	}
	function uA() {
		return { indent: Hrt(), outdent: $rt() }
	}
	var aj = new Map(),
		Fr = (function () {
			function e(t, n, r, i) {
				;(this.table = t), (this.tableRows = n), (this.tableStartPos = r), (this.rowInfo = i)
			}
			return (
				(e.create = function (t) {
					var n = ol(t, function (y) {
						var b = y.type
						return b.name === "table"
					})
					if (n) {
						var r = n.node,
							i = n.depth,
							a = n.offset,
							o = aj.get(r)
						if ((o == null ? void 0 : o.tableStartPos) === a + 1) return o
						var s = [],
							l = t.start(i),
							u = r.child(0),
							d = r.child(1),
							p = eD(u, l),
							m = eD(d, l + u.nodeSize)
						u.forEach(function (y) {
							return s.push(y)
						}),
							d.forEach(function (y) {
								return s.push(y)
							})
						var v = new e(r, s, l, p.concat(m))
						return aj.set(r, v), v
					}
					return null
				}),
				Object.defineProperty(e.prototype, "totalRowCount", {
					get: function () {
						return this.rowInfo.length
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(e.prototype, "totalColumnCount", {
					get: function () {
						return this.rowInfo[0].length
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(e.prototype, "tableStartOffset", {
					get: function () {
						return this.tableStartPos
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(e.prototype, "tableEndOffset", {
					get: function () {
						return this.tableStartPos + this.table.nodeSize - 1
					},
					enumerable: !1,
					configurable: !0,
				}),
				(e.prototype.getCellInfo = function (t, n) {
					return this.rowInfo[t][n]
				}),
				(e.prototype.posAt = function (t, n) {
					for (var r = 0, i = this.tableStartPos; ; r += 1) {
						var a = i + this.tableRows[r].nodeSize
						if (r === t) {
							for (var o = n; o < this.totalColumnCount && this.rowInfo[r][o].offset < i; ) o += 1
							return o === this.totalColumnCount ? a : this.rowInfo[r][o].offset
						}
						i = a
					}
				}),
				(e.prototype.getNodeAndPos = function (t, n) {
					var r = this.rowInfo[t][n]
					return { node: this.table.nodeAt(r.offset - this.tableStartOffset), pos: r.offset }
				}),
				(e.prototype.extendedRowspan = function (t, n) {
					return !1
				}),
				(e.prototype.extendedColspan = function (t, n) {
					return !1
				}),
				(e.prototype.getRowspanCount = function (t, n) {
					return 0
				}),
				(e.prototype.getColspanCount = function (t, n) {
					return 0
				}),
				(e.prototype.decreaseColspanCount = function (t, n) {
					return 0
				}),
				(e.prototype.decreaseRowspanCount = function (t, n) {
					return 0
				}),
				(e.prototype.getColspanStartInfo = function (t, n) {
					return null
				}),
				(e.prototype.getRowspanStartInfo = function (t, n) {
					return null
				}),
				(e.prototype.getCellStartOffset = function (t, n) {
					var r = this.rowInfo[t][n].offset
					return this.extendedRowspan(t, n) ? this.posAt(t, n) : r
				}),
				(e.prototype.getCellEndOffset = function (t, n) {
					var r = this.rowInfo[t][n],
						i = r.offset,
						a = r.nodeSize
					return this.extendedRowspan(t, n) ? this.posAt(t, n) : i + a
				}),
				(e.prototype.getCellIndex = function (t) {
					for (var n = 0; n < this.totalRowCount; n += 1)
						for (var r = this.rowInfo[n], i = 0; i < this.totalColumnCount; i += 1)
							if (r[i].offset + 1 > t.pos) return [n, i]
					return [0, 0]
				}),
				(e.prototype.getRectOffsets = function (t, n) {
					var r, i, a
					n === void 0 && (n = t), t.pos > n.pos && ((r = [n, t]), (t = r[0]), (n = r[1]))
					var o = this.getCellIndex(t),
						s = o[0],
						l = o[1],
						u = this.getCellIndex(n),
						d = u[0],
						p = u[1]
					return (
						(i = o4(s, d)),
						(s = i[0]),
						(d = i[1]),
						(a = o4(l, p)),
						(l = a[0]),
						(p = a[1]),
						this.getSpannedOffsets({ startRowIdx: s, startColIdx: l, endRowIdx: d, endColIdx: p })
					)
				}),
				(e.prototype.getSpannedOffsets = function (t) {
					return t
				}),
				e
			)
		})(),
		eD = function (e, t) {
			var n = []
			return (
				e.forEach(function (r, i) {
					var a = { rowspanMap: {}, colspanMap: {}, length: 0 }
					r.forEach(function (o, s) {
						for (var l = o.nodeSize, u = 0; a[u]; ) u += 1
						;(a[u] = { offset: t + i + s + 2, nodeSize: l }), (a.length += 1)
					}),
						n.push(a)
				}),
				n
			)
		}
	function Urt(e, t) {
		return zO(Fr.prototype, e), (eD = t), Fr
	}
	function zrt(e, t, n) {
		for (
			var r = n.startRowIdx, i = n.startColIdx, a = n.endRowIdx, o = n.endColIdx, s = [], l = r;
			l <= a;
			l += 1
		)
			for (var u = i; u <= o; u += 1) {
				var d = t.getCellInfo(l, u),
					p = d.offset,
					m = d.nodeSize
				s.push(new Y7(e.resolve(p + 1), e.resolve(p + m - 1)))
			}
		return s
	}
	function qrt(e, t) {
		var n = []
		return e.childCount && n.push(e), t.childCount && n.push(t), ke.from(n)
	}
	var cA = (function (e) {
		Ve(t, e)
		function t(n, r) {
			r === void 0 && (r = n)
			var i = this,
				a = n.node(0),
				o = Fr.create(n),
				s = o.getRectOffsets(n, r),
				l = zrt(a, o, s)
			return (
				(i = e.call(this, l[0].$from, l[0].$to, l) || this),
				(i.startCell = n),
				(i.endCell = r),
				(i.offsetMap = o),
				(i.isCellSelection = !0),
				(i.visible = !1),
				i
			)
		}
		return (
			(t.prototype.map = function (n, r) {
				var i = this.startCell.pos,
					a = this.endCell.pos,
					o = n.resolve(r.map(i)),
					s = n.resolve(r.map(a)),
					l = Fr.create(o)
				if (
					this.offsetMap.totalColumnCount > l.totalColumnCount ||
					this.offsetMap.totalRowCount > l.totalRowCount
				) {
					var u = { tableBody: 1, tableRow: 2, tableCell: 3, paragraph: 4 },
						d = u[s.parent.type.name],
						p = s.end(s.depth - d),
						m = Math.min(p - 4, s.pos)
					return jt.create(n, m)
				}
				return new t(o, s)
			}),
			(t.prototype.eq = function (n) {
				return (
					n instanceof t &&
					n.startCell.pos === this.startCell.pos &&
					n.endCell.pos === this.endCell.pos
				)
			}),
			(t.prototype.content = function () {
				for (
					var n = this.startCell.node(-2),
						r = this.startCell.start(-2),
						i = n.child(1).firstChild,
						a = n.child(0).type.create(),
						o = n.child(1).type.create(),
						s = Fr.create(this.startCell),
						l = s.getRectOffsets(this.startCell, this.endCell),
						u = l.startRowIdx,
						d = l.startColIdx,
						p = l.endRowIdx,
						m = l.endColIdx,
						v = !1,
						y = u;
					y <= p;
					y += 1
				) {
					for (var b = [], x = d; x <= m; x += 1) {
						var E = s.getCellInfo(y, x).offset,
							T = n.nodeAt(E - r)
						T &&
							((v = T.type.name === "tableHeadCell"),
							s.extendedRowspan(y, x) || s.extendedColspan(y, x)
								? b.push(T.type.create({ extended: !0 }))
								: b.push(T.copy(T.content)))
					}
					var C = i.copy(ke.from(b)),
						D = v ? a : o
					D.content = D.content.append(ke.from(C))
				}
				return new Ue(qrt(a, o), 1, 1)
			}),
			(t.prototype.toJSON = function () {
				return JSON.stringify(this)
			}),
			t
		)
	})(_t)
	function Vrt(e, t, n) {
		for (
			var r = t.nodes, i = r.tableRow, a = r.tableHeadCell, o = r.paragraph, s = [], l = 0;
			l < e;
			l += 1
		) {
			var u = n && n[l],
				d = o.create(null, u ? t.text(u) : [])
			s.push(a.create(null, d))
		}
		return [i.create(null, s)]
	}
	function dq(e, t, n, r) {
		for (
			var i = n.nodes, a = i.tableRow, o = i.tableBodyCell, s = i.paragraph, l = [], u = 0;
			u < e;
			u += 1
		) {
			for (var d = [], p = 0; p < t; p += 1) {
				var m = r && r[u * t + p],
					v = s.create(null, m ? n.text(m) : [])
				d.push(o.create(null, v))
			}
			l.push(a.create(null, d))
		}
		return l
	}
	function h1(e, t, n, r) {
		r === void 0 && (r = null)
		for (
			var i = n.nodes,
				a = i.tableHeadCell,
				o = i.tableBodyCell,
				s = i.paragraph,
				l = t === 0 ? a : o,
				u = [],
				d = 0;
			d < e;
			d += 1
		)
			u.push(l.create(r, s.create()))
		return u
	}
	function fq(e, t) {
		for (; e && e !== t; ) {
			if (e.nodeName === "TD" || e.nodeName === "TH") return e
			e = e.parentNode
		}
		return null
	}
	function pq(e) {
		return ol(e, function (t) {
			var n = t.type
			return n.name === "tableHeadCell" || n.name === "tableBodyCell"
		})
	}
	function zo(e) {
		if (e instanceof jt) {
			var t = e.$anchor,
				n = pq(t)
			if (n) {
				var r = t.node(0).resolve(t.before(n.depth))
				return { anchor: r, head: r }
			}
		}
		var i = e,
			a = i.startCell,
			o = i.endCell
		return { anchor: a, head: o }
	}
	function hq(e) {
		var t
		if (e.size) {
			var n = e.content,
				r = e.openStart,
				i = e.openEnd
			if (n.childCount !== 1) return null
			for (
				;
				n.childCount === 1 &&
				((r > 0 && i > 0) ||
					((t = n.firstChild) === null || t === void 0 ? void 0 : t.type.name) === "table");

			)
				(r -= 1), (i -= 1), (n = n.firstChild.content)
			if (n.firstChild.type.name === "tableHead" || n.firstChild.type.name === "tableBody") return n
		}
		return null
	}
	function Hf(e) {
		var t = e.startRowIdx,
			n = e.startColIdx,
			r = e.endRowIdx,
			i = e.endColIdx,
			a = r - t + 1,
			o = i - n + 1
		return { rowCount: a, columnCount: o }
	}
	function Wrt(e, t) {
		return me(me({}, e.attrs), t)
	}
	var vu = new dg("cellSelection"),
		Yrt = 2,
		Grt = (function () {
			function e(t) {
				;(this.view = t),
					(this.handlers = {
						mousedown: this.handleMousedown.bind(this),
						mousemove: this.handleMousemove.bind(this),
						mouseup: this.handleMouseup.bind(this),
					}),
					(this.startCellPos = null),
					this.init()
			}
			return (
				(e.prototype.init = function () {
					this.view.dom.addEventListener("mousedown", this.handlers.mousedown)
				}),
				(e.prototype.handleMousedown = function (t) {
					var n = fq(t.target, this.view.dom)
					if (t.button === Yrt) {
						t.preventDefault()
						return
					}
					if (n) {
						var r = this.getCellPos(t)
						r && (this.startCellPos = r), this.bindEvent()
					}
				}),
				(e.prototype.handleMousemove = function (t) {
					var n = vu.getState(this.view.state),
						r = this.getCellPos(t),
						i = this.startCellPos,
						a
					n ? (a = this.view.state.doc.resolve(n)) : i !== r && (a = i),
						a && i && r && this.setCellSelection(i, r)
				}),
				(e.prototype.handleMouseup = function () {
					;(this.startCellPos = null),
						this.unbindEvent(),
						vu.getState(this.view.state) !== null &&
							this.view.dispatch(this.view.state.tr.setMeta(vu, -1))
				}),
				(e.prototype.bindEvent = function () {
					var t = this.view.dom
					t.addEventListener("mousemove", this.handlers.mousemove),
						t.addEventListener("mouseup", this.handlers.mouseup)
				}),
				(e.prototype.unbindEvent = function () {
					var t = this.view.dom
					t.removeEventListener("mousemove", this.handlers.mousemove),
						t.removeEventListener("mouseup", this.handlers.mouseup)
				}),
				(e.prototype.getCellPos = function (t) {
					var n = t.clientX,
						r = t.clientY,
						i = this.view.posAtCoords({ left: n, top: r })
					if (i) {
						var a = this.view.state.doc,
							o = a.resolve(i.pos),
							s = pq(o)
						if (s) {
							var l = o.before(s.depth)
							return a.resolve(l)
						}
					}
					return null
				}),
				(e.prototype.setCellSelection = function (t, n) {
					var r = this.view.state,
						i = r.selection,
						a = r.tr,
						o = vu.getState(this.view.state) === null,
						s = new cA(t, n)
					if (o || !i.eq(s)) {
						var l = a.setSelection(s)
						o && l.setMeta(vu, n.pos), this.view.dispatch(l)
					}
				}),
				(e.prototype.destroy = function () {
					this.view.dom.removeEventListener("mousedown", this.handlers.mousedown)
				}),
				e
			)
		})(),
		Krt = Qe("cell-selected")
	function Qrt(e) {
		var t = e.selection,
			n = e.doc
		if (t instanceof cA) {
			var r = [],
				i = t.ranges
			return (
				i.forEach(function (a) {
					var o = a.$from,
						s = a.$to
					r.push($i.node(o.pos - 1, s.pos + 1, { class: Krt }))
				}),
				mr.create(n, r)
			)
		}
		return null
	}
	function Xrt() {
		return new Ki({
			key: vu,
			state: {
				init: function () {
					return null
				},
				apply: function (e, t) {
					var n = e.getMeta(vu)
					if (n) return n === -1 ? null : n
					if (hb(t) || !e.docChanged) return t
					var r = e.mapping.mapResult(t),
						i = r.deleted,
						a = r.pos
					return i ? null : a
				},
			},
			props: {
				decorations: Qrt,
				createSelectionBetween: function (e) {
					var t = e.state
					return hb(vu.getState(t)) ? null : t.selection
				},
			},
			view: function (e) {
				return new Grt(e)
			},
		})
	}
	var mq = (function () {
			function e() {
				;(this.keys = []), (this.values = [])
			}
			return (
				(e.prototype.getKeyIndex = function (t) {
					return yd(t, this.keys)
				}),
				(e.prototype.get = function (t) {
					return this.values[this.getKeyIndex(t)]
				}),
				(e.prototype.set = function (t, n) {
					var r = this.getKeyIndex(t)
					return r > -1 ? (this.values[r] = n) : (this.keys.push(t), this.values.push(n)), this
				}),
				(e.prototype.has = function (t) {
					return this.getKeyIndex(t) > -1
				}),
				(e.prototype.delete = function (t) {
					var n = this.getKeyIndex(t)
					return n > -1 ? (this.keys.splice(n, 1), this.values.splice(n, 1), !0) : !1
				}),
				(e.prototype.forEach = function (t, n) {
					var r = this
					n === void 0 && (n = this),
						this.values.forEach(function (i, a) {
							i && r.keys[a] && t.call(n, i, r.keys[a], r)
						})
				}),
				(e.prototype.clear = function () {
					;(this.keys = []), (this.values = [])
				}),
				e
			)
		})(),
		Lk = "en-US",
		Jrt = (function () {
			function e() {
				;(this.code = Lk), (this.langs = new mq())
			}
			return (
				(e.prototype.setCode = function (t) {
					this.code = t || Lk
				}),
				(e.prototype.setLanguage = function (t, n) {
					var r = this
					;(t = [].concat(t)),
						t.forEach(function (i) {
							if (!r.langs.has(i)) r.langs.set(i, n)
							else {
								var a = r.langs.get(i)
								r.langs.set(i, jO(a, n))
							}
						})
				}),
				(e.prototype.get = function (t, n) {
					n || (n = this.code)
					var r = this.langs.get(n)
					r || (r = this.langs.get(Lk))
					var i = r[t]
					if (!i) throw new Error('There is no text key "' + t + '" in ' + n)
					return i
				}),
				e
			)
		})(),
		yt = new Jrt(),
		Zrt = [
			[
				{
					action: "Add row to up",
					command: "addRowToUp",
					disableInThead: !0,
					className: "add-row-up",
				},
				{
					action: "Add row to down",
					command: "addRowToDown",
					disableInThead: !0,
					className: "add-row-down",
				},
				{ action: "Remove row", command: "removeRow", disableInThead: !0, className: "remove-row" },
			],
			[
				{ action: "Add column to left", command: "addColumnToLeft", className: "add-column-left" },
				{
					action: "Add column to right",
					command: "addColumnToRight",
					className: "add-column-right",
				},
				{ action: "Remove column", command: "removeColumn", className: "remove-column" },
			],
			[
				{
					action: "Align column to left",
					command: "alignColumn",
					payload: { align: "left" },
					className: "align-column-left",
				},
				{
					action: "Align column to center",
					command: "alignColumn",
					payload: { align: "center" },
					className: "align-column-center",
				},
				{
					action: "Align column to right",
					command: "alignColumn",
					payload: { align: "right" },
					className: "align-column-right",
				},
			],
			[{ action: "Remove table", command: "removeTable", className: "remove-table" }],
		]
	function eit(e, t) {
		return Zrt.map(function (n) {
			return n.map(function (r) {
				var i = r.action,
					a = r.command,
					o = r.payload,
					s = r.disableInThead,
					l = r.className
				return {
					label: yt.get(i),
					onClick: function () {
						e.emit("command", a, o)
					},
					disabled: t && !!s,
					className: l,
				}
			})
		}).concat()
	}
	function tit(e) {
		return new Ki({
			props: {
				handleDOMEvents: {
					contextmenu: function (t, n) {
						var r = fq(n.target, t.dom)
						if (r) {
							n.preventDefault()
							var i = n,
								a = i.clientX,
								o = i.clientY,
								s = t.dom.parentNode.getBoundingClientRect(),
								l = s.left,
								u = s.top,
								d = r.nodeName === "TH"
							return (
								e.emit("contextmenu", {
									pos: { left: a - l + 10 + "px", top: o - u + 30 + "px" },
									menuGroups: eit(e, d),
									tableCell: r,
								}),
								!0
							)
						}
						return !1
					},
				},
			},
		})
	}
	function nit() {
		return new Ki({
			props: {
				handleDOMEvents: {
					mousedown: function (e, t) {
						var n = t,
							r = n.clientX,
							i = n.clientY,
							a = e.posAtCoords({ left: r, top: i })
						if (a) {
							var o = e.state,
								s = o.doc,
								l = o.tr,
								u = s.resolve(a.pos),
								d = Cp(u),
								p = t.target,
								m = getComputedStyle(p, ":before"),
								v = t,
								y = v.offsetX,
								b = v.offsetY
							if (!d || !WO(m, y, b)) return !1
							t.preventDefault()
							var x = u.before(d.depth),
								E = d.node.attrs
							return (
								l.setNodeMarkup(x, null, me(me({}, E), { checked: !E.checked })), e.dispatch(l), !0
							)
						}
						return !1
					},
				},
			},
		})
	}
	var rit = ["image", "link", "customBlock", "frontMatter"],
		iit = ["strong", "strike", "emph", "code"],
		vq = ["bulletList", "orderedList", "taskList"]
	function ait(e, t) {
		var n = e.type.name
		return n === "listItem"
			? e.attrs.task
				? "taskList"
				: t.type.name
			: n.indexOf("table") !== -1
			? "table"
			: n
	}
	function oit(e, t) {
		;(t[e] = { active: !0 }),
			vq
				.filter(function (n) {
					return n !== e
				})
				.forEach(function (n) {
					t[n] && delete t[n]
				})
	}
	function sit(e, t, n, r) {
		iit.forEach(function (i) {
			var a = n.marks[i],
				o = e.marksAcross(t) || [],
				s = !!a.isInSet(o)
			s && (r[i] = { active: !0 })
		})
	}
	function lit(e, t, n) {
		var r = e.$from,
			i = e.$to,
			a = e.from,
			o = e.to,
			s = { indent: { active: !1, disabled: !0 }, outdent: { active: !1, disabled: !0 } }
		return (
			t.nodesBetween(a, o, function (l, u, d) {
				var p = ait(l, d)
				Vr(rit, p) ||
					(Vr(vq, p)
						? (oit(p, s), (s.indent.disabled = !1), (s.outdent.disabled = !1))
						: p === "paragraph" || p === "text"
						? sit(r, i, n, s)
						: (s[p] = { active: !0 }))
			}),
			s
		)
	}
	function uit(e) {
		return new Ki({
			view: function () {
				return {
					update: function (t) {
						var n = t.state,
							r = n.selection,
							i = n.doc,
							a = n.schema
						e.emit("changeToolbarState", { toolbarState: lit(r, i, a) })
					},
				}
			},
		})
	}
	var cit = (function () {
			function e(t, n, r, i) {
				var a = this
				;(this.openEditor = function () {
					if (a.innerEditorView) throw new Error("The editor is already opened.")
					;(a.dom.draggable = !1),
						(a.wrapper.style.display = "none"),
						(a.innerViewContainer.style.display = "block"),
						(a.innerEditorView = new NO(a.innerViewContainer, {
							state: Bc.create({
								doc: a.node,
								plugins: [
									_v({
										"Mod-z": function () {
											return qm(a.innerEditorView.state, a.innerEditorView.dispatch)
										},
										"Shift-Mod-z": function () {
											return PO(a.innerEditorView.state, a.innerEditorView.dispatch)
										},
										Tab: function (o, s) {
											return s(o.tr.insertText("	")), !0
										},
										Enter: NU,
										Escape: function () {
											return a.cancelEditing(), !0
										},
										"Ctrl-Enter": function () {
											return a.saveAndFinishEditing(), !0
										},
									}),
									$U(),
								],
							}),
							dispatchTransaction: function (o) {
								return a.dispatchInner(o)
							},
							handleDOMEvents: {
								mousedown: function () {
									return a.editorView.hasFocus() && a.innerEditorView.focus(), !0
								},
								blur: function () {
									return a.saveAndFinishEditing(), !0
								},
							},
						})),
						a.innerEditorView.focus()
				}),
					(this.node = t),
					(this.editorView = n),
					(this.getPos = r),
					(this.toDOMAdaptor = i),
					(this.innerEditorView = null),
					(this.canceled = !1),
					(this.dom = document.createElement("div")),
					(this.dom.className = Qe("custom-block")),
					(this.wrapper = document.createElement("div")),
					(this.wrapper.className = Qe("custom-block-view")),
					this.createInnerViewContainer(),
					this.renderCustomBlock(),
					this.dom.appendChild(this.innerViewContainer),
					this.dom.appendChild(this.wrapper)
			}
			return (
				(e.prototype.renderToolArea = function () {
					var t = this,
						n = document.createElement("div"),
						r = document.createElement("span"),
						i = document.createElement("button")
					;(n.className = "tool"),
						(r.textContent = this.node.attrs.info),
						(r.className = "info"),
						(i.type = "button"),
						i.addEventListener("click", function () {
							return t.openEditor()
						}),
						n.appendChild(r),
						n.appendChild(i),
						this.wrapper.appendChild(n)
				}),
				(e.prototype.renderCustomBlock = function () {
					var t = this.toDOMAdaptor.getToDOMNode(this.node.attrs.info)
					if (t) {
						for (var n = t(this.node); this.wrapper.hasChildNodes(); )
							this.wrapper.removeChild(this.wrapper.lastChild)
						n && this.wrapper.appendChild(n), this.renderToolArea()
					}
				}),
				(e.prototype.createInnerViewContainer = function () {
					;(this.innerViewContainer = document.createElement("div")),
						(this.innerViewContainer.className = Qe("custom-block-editor")),
						(this.innerViewContainer.style.display = "none")
				}),
				(e.prototype.closeEditor = function () {
					this.innerEditorView &&
						(this.innerEditorView.destroy(),
						(this.innerEditorView = null),
						(this.innerViewContainer.style.display = "none")),
						(this.wrapper.style.display = "block")
				}),
				(e.prototype.saveAndFinishEditing = function () {
					var t = this.editorView.state.selection.to,
						n = this.editorView.state
					this.editorView.dispatch(n.tr.setSelection(Fn(n.tr, t))),
						this.editorView.focus(),
						this.renderCustomBlock(),
						this.closeEditor()
				}),
				(e.prototype.cancelEditing = function () {
					var t = iye(this.innerEditorView.state)
					for (this.canceled = !0; t--; )
						qm(this.innerEditorView.state, this.innerEditorView.dispatch),
							qm(this.editorView.state, this.editorView.dispatch)
					this.canceled = !1
					var n = this.editorView.state.selection.to,
						r = this.editorView.state
					this.editorView.dispatch(r.tr.setSelection(jt.create(r.doc, n))),
						this.editorView.focus(),
						this.closeEditor()
				}),
				(e.prototype.dispatchInner = function (t) {
					var n = this.innerEditorView.state.applyTransaction(t),
						r = n.state,
						i = n.transactions
					if ((this.innerEditorView.updateState(r), !this.canceled && Ka(this.getPos))) {
						for (
							var a = this.editorView.state.tr, o = Ua.offset(this.getPos() + 1), s = 0;
							s < i.length;
							s += 1
						)
							for (var l = i[s].steps, u = 0; u < l.length; u += 1) a.step(l[u].map(o))
						a.docChanged && this.editorView.dispatch(a)
					}
				}),
				(e.prototype.update = function (t) {
					return t.sameMarkup(this.node)
						? ((this.node = t), this.innerEditorView || this.renderCustomBlock(), !0)
						: !1
				}),
				(e.prototype.stopEvent = function (t) {
					return !!this.innerEditorView && !!t.target && this.innerEditorView.dom.contains(t.target)
				}),
				(e.prototype.ignoreMutation = function () {
					return !0
				}),
				(e.prototype.destroy = function () {
					this.dom.removeEventListener("dblclick", this.openEditor), this.closeEditor()
				}),
				e
			)
		})(),
		oj = "image-link",
		dit = (function () {
			function e(t, n, r, i) {
				var a = this,
					o
				;(this.handleMousedown = function (s) {
					s.preventDefault()
					var l = s.target,
						u = s.offsetX,
						d = s.offsetY
					if (a.imageLink && Ka(a.getPos) && QU(l, oj)) {
						var p = getComputedStyle(l, ":before")
						if ((s.stopPropagation(), WO(p, u, d))) {
							var m = a.view.state.tr,
								v = a.getPos()
							m.setSelection(Fn(m, v, v + 1)),
								a.view.dispatch(m),
								a.eventEmitter.emit("openPopup", "link", a.imageLink.attrs)
						}
					}
				}),
					(this.node = t),
					(this.view = n),
					(this.getPos = r),
					(this.eventEmitter = i),
					(this.imageLink =
						(o = t.marks.filter(function (s) {
							var l = s.type
							return l.name === "link"
						})[0]) !== null && o !== void 0
							? o
							: null),
					(this.dom = this.createElement()),
					this.bindEvent()
			}
			return (
				(e.prototype.createElement = function () {
					var t = this.createImageElement(this.node)
					if (this.imageLink) {
						var n = document.createElement("span")
						return (n.className = oj), n.appendChild(t), n
					}
					return t
				}),
				(e.prototype.createImageElement = function (t) {
					var n = document.createElement("img"),
						r = t.attrs,
						i = r.imageUrl,
						a = r.altText,
						o = sr(t.attrs)
					return (n.src = i), a && (n.alt = a), KO(o, n), n
				}),
				(e.prototype.bindEvent = function () {
					this.imageLink && this.dom.addEventListener("mousedown", this.handleMousedown)
				}),
				(e.prototype.stopEvent = function () {
					return !0
				}),
				(e.prototype.destroy = function () {
					this.imageLink && this.dom.removeEventListener("mousedown", this.handleMousedown)
				}),
				e
			)
		})(),
		fit = "toastui-editor-ww-code-block",
		pit = "toastui-editor-ww-code-block-language",
		hit = (function () {
			function e(t, n, r, i) {
				var a = this
				;(this.contentDOM = null),
					(this.input = null),
					(this.timer = null),
					(this.handleMousedown = function (o) {
						var s = o.target,
							l = getComputedStyle(s, ":after")
						if (l.backgroundImage !== "none" && Ka(a.getPos)) {
							var u = a.view.coordsAtPos(a.getPos()),
								d = u.top,
								p = u.right
							a.createLanguageEditor({ top: d, right: p })
						}
					}),
					(this.handleKeydown = function (o) {
						o.key === "Enter" && a.input && (o.preventDefault(), a.changeLanguage())
					}),
					(this.node = t),
					(this.view = n),
					(this.getPos = r),
					(this.eventEmitter = i),
					this.createElement(),
					this.bindDOMEvent(),
					this.bindEvent()
			}
			return (
				(e.prototype.createElement = function () {
					var t = this.node.attrs.language,
						n = document.createElement("div")
					n.setAttribute("data-language", t || "text"), (n.className = fit)
					var r = this.createCodeBlockElement(),
						i = r.firstChild
					n.appendChild(r), (this.dom = n), (this.contentDOM = i)
				}),
				(e.prototype.createCodeBlockElement = function () {
					var t = document.createElement("pre"),
						n = document.createElement("code"),
						r = this.node.attrs.language,
						i = sr(this.node.attrs)
					return r && n.setAttribute("data-language", r), KO(i, t), t.appendChild(n), t
				}),
				(e.prototype.createLanguageEditor = function (t) {
					var n = this,
						r = t.top,
						i = t.right,
						a = document.createElement("span")
					a.className = pit
					var o = document.createElement("input")
					;(o.type = "text"),
						(o.value = this.node.attrs.language),
						a.appendChild(o),
						this.view.dom.parentElement.appendChild(a)
					var s = a.clientWidth
					gs(a, { top: r + 10 + "px", left: i - s - 10 + "px", width: s + "px" }),
						(this.input = o),
						this.input.addEventListener("blur", function () {
							return n.changeLanguage()
						}),
						this.input.addEventListener("keydown", this.handleKeydown),
						this.clearTimer(),
						(this.timer = setTimeout(function () {
							n.input.focus()
						}))
				}),
				(e.prototype.bindDOMEvent = function () {
					this.dom && this.dom.addEventListener("click", this.handleMousedown)
				}),
				(e.prototype.bindEvent = function () {
					var t = this
					this.eventEmitter.listen("scroll", function () {
						t.input && t.reset()
					})
				}),
				(e.prototype.changeLanguage = function () {
					if (this.input && Ka(this.getPos)) {
						var t = this.input.value
						this.reset()
						var n = this.getPos(),
							r = this.view.state.tr
						r.setNodeMarkup(n, null, { language: t }), this.view.dispatch(r)
					}
				}),
				(e.prototype.reset = function () {
					var t
					if (!((t = this.input) === null || t === void 0) && t.parentElement) {
						var n = this.input.parentElement
						;(this.input = null), xd(n)
					}
				}),
				(e.prototype.clearTimer = function () {
					this.timer && (clearTimeout(this.timer), (this.timer = null))
				}),
				(e.prototype.stopEvent = function () {
					return !0
				}),
				(e.prototype.update = function (t) {
					return t.sameMarkup(this.node) ? ((this.node = t), !0) : !1
				}),
				(e.prototype.destroy = function () {
					this.reset(),
						this.clearTimer(),
						this.dom && this.dom.removeEventListener("click", this.handleMousedown)
				}),
				e
			)
		})(),
		mit = /MsoListParagraph/,
		gq = /style=(.|\n)*mso-/,
		yq = /mso-list:(.*)/,
		vit = /O:P/,
		git = /^(n|u|l)/,
		yit = "p.MsoListParagraph"
	function bit(e) {
		return gq.test(e)
	}
	function xit(e) {
		for (var t = [], n = document.createTreeWalker(e, 1, null, !1); n.nextNode(); ) {
			var r = n.currentNode
			if (cw(r)) {
				var i = r,
					a = i.outerHTML,
					o = i.textContent,
					s = gq.test(a),
					l = yq.test(a)
				s && !l && o ? t.push([r, !0]) : (vit.test(r.nodeName) || (s && !o) || l) && t.push([r, !1])
			}
		}
		return (
			t.forEach(function (u) {
				var d = u[0],
					p = u[1]
				p ? j1e(d) : xd(d)
			}),
			e.innerHTML.trim()
		)
	}
	function wit(e, t) {
		var n = e.getAttribute("style")
		if (n) {
			var r = n.match(yq),
				i = r[1],
				a = i.trim().split(" "),
				o = a[1],
				s = parseInt(o.replace("level", ""), 10),
				l = git.test(e.textContent || "")
			return {
				id: t,
				level: s,
				prev: null,
				parent: null,
				children: [],
				unordered: l,
				contents: xit(e),
			}
		}
		return null
	}
	function Eit(e, t) {
		if (t.level < e.level) t.children.push(e), (e.parent = t)
		else {
			for (; t && t.level !== e.level; ) t = t.parent
			t && ((e.prev = t), (e.parent = t.parent), e.parent && e.parent.children.push(e))
		}
	}
	function Cit(e) {
		var t = []
		return (
			e.forEach(function (n, r) {
				var i = t[r - 1],
					a = wit(n, r)
				a && (i && Eit(a, i), t.push(a))
			}),
			t
		)
	}
	function bq(e) {
		var t = e[0].unordered ? "ul" : "ol",
			n = document.createElement(t)
		return (
			e.forEach(function (r) {
				var i = r.children,
					a = r.contents,
					o = document.createElement("li")
				;(o.innerHTML = a), n.appendChild(o), i.length && n.appendChild(bq(i))
			}),
			n
		)
	}
	function Tit(e) {
		var t = Cit(e),
			n = t.filter(function (r) {
				var i = r.parent
				return !i
			})
		return bq(n)
	}
	function kit(e) {
		for (; e && !cw(e); ) e = e.nextSibling
		return e ? !mit.test(e.className) : !0
	}
	function Sit(e) {
		var t = document.createElement("div")
		t.innerHTML = e
		var n = [],
			r = R1e(t, yit)
		r.forEach(function (a) {
			var o = kit(a.nextSibling)
			if ((n.push(a), o)) {
				var s = Tit(n),
					l = a.nextSibling
				l ? P1e(s, l) : L1e(t, s), (n = [])
			}
			xd(a)
		})
		var i = r.length ? "<p></p>" : ""
		return "" + i + t.innerHTML
	}
	var sj = "<!--StartFragment-->",
		Dit = "<!--EndFragment-->"
	function _it(e) {
		var t = e.indexOf(sj),
			n = e.lastIndexOf(Dit)
		return t > -1 && n > -1 && (e = e.slice(t + sj.length, n)), e.replace(/<br[^>]*>/g, tz)
	}
	function Oit(e) {
		return (
			/<\/td>((?!<\/tr>)[\s\S])*$/i.test(e) && (e = "<tr>" + e + "</tr>"),
			/<\/tr>((?!<\/table>)[\s\S])*$/i.test(e) && (e = "<table>" + e + "</table>"),
			e
		)
	}
	function Ait(e) {
		return (e = _it(e)), (e = Oit(e)), bit(e) && (e = Sit(e)), e
	}
	function Nit(e) {
		var t = e.reduce(function (n, r) {
			return n.childCount > r.childCount ? n : r
		})
		return t.childCount
	}
	function xq(e, t, n) {
		for (var r = [], i = e.childCount, a = 0; a < i; a += 1)
			if (!e.child(a).attrs.extended) {
				var o = a < i ? n.create(e.child(a).attrs, e.child(a).content) : n.createAndFill()
				r.push(o)
			}
		return r
	}
	function wq(e, t, n) {
		var r = n.nodes,
			i = r.tableRow,
			a = r.tableHeadCell,
			o = xq(e, t, a)
		return i.create(null, o)
	}
	function Eq(e, t, n) {
		var r = n.nodes,
			i = r.tableRow,
			a = r.tableBodyCell,
			o = xq(e, t, a)
		return i.create(null, o)
	}
	function Mit(e, t) {
		for (var n = t.nodes, r = n.tableRow, i = n.tableBodyCell, a = [], o = 0; o < e; o += 1) {
			var s = i.createAndFill()
			a.push(s)
		}
		return r.create({ dummyRowForPasting: !0 }, a)
	}
	function Cq(e) {
		var t = [],
			n = []
		if (e.firstChild.type.name === "tableHead") {
			var r = e.firstChild
			r.forEach(function (a) {
				return t.push(a)
			})
		}
		if (e.lastChild.type.name === "tableBody") {
			var i = e.lastChild
			i.forEach(function (a) {
				return n.push(a)
			})
		}
		return Gi(Gi([], t), n)
	}
	function Iit(e, t, n) {
		var r = wq(e, t, n)
		return n.nodes.tableHead.create(null, r)
	}
	function lj(e, t, n) {
		var r = e.map(function (a) {
			return Eq(a, t, n)
		})
		if (!e.length) {
			var i = Mit(t, n)
			r.push(i)
		}
		return n.nodes.tableBody.create(null, r)
	}
	function Rit(e, t, n, r) {
		var i = Nit(e)
		if (n && r) return t.nodes.table.create(null, [lj(e, i, t)])
		var a = e[0],
			o = e.slice(1),
			s = [Iit(a, i, t)]
		return o.length && s.push(lj(o, i, t)), t.nodes.table.create(null, s)
	}
	function Lit(e, t, n) {
		var r = [],
			i = e.content,
			a = e.openStart,
			o = e.openEnd
		return (
			i.forEach(function (s) {
				if (s.type.name === "table") {
					var l = hq(new Ue(ke.from(s), 0, 0))
					if (l) {
						var u = Cq(l),
							d = l.firstChild.type.name === "tableBody",
							p = Rit(u, t, d, n)
						r.push(p)
					}
				} else r.push(s)
			}),
			new Ue(ke.from(r), a, o)
		)
	}
	var Pit = 4,
		jit = 2
	function m1(e) {
		return e * Pit
	}
	function Fit(e, t, n) {
		var r = [],
			i = Cq(e),
			a = i[0].childCount,
			o = i.length,
			s = t.startRowIdx === 0,
			l = i.slice(0, o)
		if (s) {
			var u = l.shift()
			if (u) {
				var d = wq(u, a, n).content
				r.push(d)
			}
		}
		return (
			l.forEach(function (p) {
				if (!p.attrs.dummyRowForPasting) {
					var m = Eq(p, a, n).content
					r.push(m)
				}
			}),
			r
		)
	}
	function Bit(e, t, n) {
		for (
			var r = t.startRowIdx,
				i = t.startColIdx,
				a = n.length,
				o = 0,
				s = function (v) {
					var y = n[v].childCount
					n[v].forEach(function (b) {
						var x = b.attrs,
							E = x.colspan
						E > 1 && (y += E - 1)
					}),
						(o = Math.max(o, y))
				},
				l = 0;
			l < a;
			l += 1
		)
			s(l)
		var u = r + a - 1,
			d = i + o - 1,
			p = Math.max(u + 1 - e.totalRowCount, 0),
			m = Math.max(d + 1 - e.totalColumnCount, 0)
		return {
			startRowIdx: r,
			startColIdx: i,
			endRowIdx: u,
			endColIdx: d,
			addedRowCount: p,
			addedColumnCount: m,
		}
	}
	function Hit(e, t) {
		for (
			var n = e.startRowIdx,
				r = e.startColIdx,
				i = e.endRowIdx,
				a = e.endColIdx,
				o = e.addedRowCount,
				s = e.addedColumnCount,
				l = n;
			l <= i - o;
			l += 1
		)
			t.push({ rowIdx: l, startColIdx: r, endColIdx: a - s })
	}
	function $it(e, t, n, r, i) {
		for (
			var a = r.startRowIdx,
				o = r.startColIdx,
				s = r.endRowIdx,
				l = r.endColIdx,
				u = r.addedRowCount,
				d = r.addedColumnCount,
				p = n.totalRowCount,
				m = 0,
				v = 0;
			v < p;
			v += 1
		) {
			var y = n.getCellInfo(v, l - d),
				b = y.offset,
				x = y.nodeSize,
				E = e.mapping.map(b + x),
				T = h1(d, v, t)
			if ((e.insert(E, T), v >= a && v <= s - u)) {
				var C = n.getCellInfo(v, l - d),
					D = e.mapping.map(C.offset),
					O = E + m1(d)
				;(i[m] = { rowIdx: v, startColIdx: o, endColIdx: l, dummyOffsets: [D, O] }), (m += 1)
			}
		}
	}
	function Uit(e, t, n, r, i) {
		var a = r.addedRowCount,
			o = r.addedColumnCount,
			s = r.startColIdx,
			l = r.endColIdx,
			u = e.mapping.maps.length,
			d = n.tableEndOffset - 2,
			p = dq(a, n.totalColumnCount + o, t),
			m = d
		e.insert(e.mapping.slice(u).map(m), p)
		for (var v = 0; v < a; v += 1) {
			var y = m + m1(s) + 1,
				b = m + m1(l + 1) + 1,
				x = m + m1(n.totalColumnCount + o) + jit
			i.push({ rowIdx: v + n.totalRowCount, startColIdx: s, endColIdx: l, dummyOffsets: [y, b] }),
				(m = x)
		}
	}
	function zit(e, t, n, r) {
		var i = e.mapping.maps.length
		n.forEach(function (a, o) {
			var s = a.rowIdx,
				l = a.startColIdx,
				u = a.endColIdx,
				d = a.dummyOffsets,
				p = e.mapping.slice(i),
				m = new Ue(t[o], 0, 0),
				v = d ? d[0] : r.getCellStartOffset(s, l),
				y = d ? d[1] : r.getCellEndOffset(s, u)
			e.replace(p.map(v), p.map(y), m)
		})
	}
	function qit(e, t) {
		var n = e.state,
			r = n.selection,
			i = n.schema,
			a = n.tr,
			o = zo(r),
			s = o.anchor,
			l = o.head
		if (s && l) {
			var u = hq(t)
			if (!u) return !1
			var d = Fr.create(s),
				p = d.getRectOffsets(s, l),
				m = Fit(u, p, i),
				v = Bit(d, p, m),
				y = []
			return (
				Wit(d, v) &&
					(Hit(v, y),
					v.addedColumnCount && $it(a, i, d, v, y),
					v.addedRowCount && Uit(a, i, d, v, y),
					zit(a, m, y, d),
					e.dispatch(a),
					Vit(e, y, d.getCellInfo(0, 0).offset)),
				!0
			)
		}
		return !1
	}
	function Vit(e, t, n) {
		var r = e.state,
			i = r.tr,
			a = r.doc,
			o = Fr.create(a.resolve(n)),
			s = t[0],
			l = s.rowIdx,
			u = s.startColIdx,
			d = ni(t),
			p = d.rowIdx,
			m = d.endColIdx,
			v = o.getCellInfo(l, u).offset,
			y = o.getCellInfo(p, m).offset
		e.dispatch(i.setSelection(new cA(a.resolve(v), a.resolve(y))))
	}
	function Wit(e, t) {
		var n = e.getSpannedOffsets(t),
			r = Hf(n),
			i = r.rowCount,
			a = r.columnCount,
			o = Hf(t),
			s = o.rowCount,
			l = o.columnCount
		return i === s && a === l
	}
	var Yit = (function (e) {
			Ve(t, e)
			function t() {
				return (e !== null && e.apply(this, arguments)) || this
			}
			return (
				Object.defineProperty(t.prototype, "name", {
					get: function () {
						return "doc"
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(t.prototype, "schema", {
					get: function () {
						return { content: "block+" }
					},
					enumerable: !1,
					configurable: !0,
				}),
				t
			)
		})(On),
		Git = (function (e) {
			Ve(t, e)
			function t() {
				return (e !== null && e.apply(this, arguments)) || this
			}
			return (
				Object.defineProperty(t.prototype, "name", {
					get: function () {
						return "paragraph"
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(t.prototype, "schema", {
					get: function () {
						return {
							content: "inline*",
							group: "block",
							attrs: me({}, Mr()),
							parseDOM: [{ tag: "p" }],
							toDOM: function (n) {
								var r = n.attrs
								return ["p", sr(r), 0]
							},
						}
					},
					enumerable: !1,
					configurable: !0,
				}),
				t
			)
		})(On),
		Kit = /\s{1,4}$/,
		Qit = (function (e) {
			Ve(t, e)
			function t() {
				return (e !== null && e.apply(this, arguments)) || this
			}
			return (
				Object.defineProperty(t.prototype, "name", {
					get: function () {
						return "text"
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(t.prototype, "schema", {
					get: function () {
						return { group: "inline" }
					},
					enumerable: !1,
					configurable: !0,
				}),
				(t.prototype.addSpaces = function () {
					return function (n, r) {
						var i = n.selection,
							a = n.tr,
							o = i.$from,
							s = i.$to,
							l = o.blockRange(s)
						return l && !Ep(o) && !_b(o) ? (r(a.insertText("    ", o.pos, s.pos)), !0) : !1
					}
				}),
				(t.prototype.removeSpaces = function () {
					return function (n, r) {
						var i = n.selection,
							a = n.tr,
							o = i.$from,
							s = i.$to,
							l = i.from,
							u = o.blockRange(s)
						if (u && !Ep(o) && !_b(o)) {
							var d = o.nodeBefore
							if (d && d.isText) {
								var p = d.text,
									m = p.replace(Kit, ""),
									v = p.length - m.length
								return r(a.delete(l - v, l)), !0
							}
						}
						return !1
					}
				}),
				(t.prototype.keymaps = function () {
					return { Tab: this.addSpaces(), "Shift-Tab": this.removeSpaces() }
				}),
				t
			)
		})(On),
		Xit = (function (e) {
			Ve(t, e)
			function t() {
				return (e !== null && e.apply(this, arguments)) || this
			}
			return (
				Object.defineProperty(t.prototype, "name", {
					get: function () {
						return "heading"
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(t.prototype, "levels", {
					get: function () {
						return [1, 2, 3, 4, 5, 6]
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(t.prototype, "schema", {
					get: function () {
						var n = this.levels.map(function (r) {
							return {
								tag: "h" + r,
								getAttrs: function (i) {
									var a = i.getAttribute("data-raw-html")
									return me({ level: r }, a && { rawHTML: a })
								},
							}
						})
						return {
							attrs: me(
								{
									level: { default: 1 },
									headingType: { default: "atx" },
									rawHTML: { default: null },
								},
								Mr(),
							),
							content: "inline*",
							group: "block",
							defining: !0,
							parseDOM: n,
							toDOM: function (r) {
								var i = r.attrs
								return ["h" + i.level, sr(i), 0]
							},
						}
					},
					enumerable: !1,
					configurable: !0,
				}),
				(t.prototype.commands = function () {
					return function (n) {
						return function (r, i) {
							var a = r.schema.nodes[n.level ? "heading" : "paragraph"]
							return LO(a, n)(r, i)
						}
					}
				}),
				t
			)
		})(On),
		Jit = (function (e) {
			Ve(t, e)
			function t() {
				return (e !== null && e.apply(this, arguments)) || this
			}
			return (
				Object.defineProperty(t.prototype, "name", {
					get: function () {
						return "codeBlock"
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(t.prototype, "schema", {
					get: function () {
						return {
							content: "text*",
							group: "block",
							attrs: me({ language: { default: null }, rawHTML: { default: null } }, Mr()),
							code: !0,
							defining: !0,
							marks: "",
							parseDOM: [
								{
									tag: "pre",
									preserveWhitespace: "full",
									getAttrs: function (n) {
										var r = n.getAttribute("data-raw-html"),
											i = n.firstElementChild
										return me(
											{ language: (i == null ? void 0 : i.getAttribute("data-language")) || null },
											r && { rawHTML: r },
										)
									},
								},
							],
							toDOM: function (n) {
								var r = n.attrs
								return [r.rawHTML || "pre", ["code", me({ "data-language": r.language }, sr(r)), 0]]
							},
						}
					},
					enumerable: !1,
					configurable: !0,
				}),
				(t.prototype.commands = function () {
					return function () {
						return function (n, r) {
							return LO(n.schema.nodes.codeBlock)(n, r)
						}
					}
				}),
				(t.prototype.moveCursor = function (n) {
					var r = this
					return function (i, a) {
						var o = i.tr,
							s = i.doc,
							l = i.schema,
							u = i.selection.$from,
							d = r.context.view
						if (d.endOfTextblock(n) && u.node().type.name === "codeBlock") {
							var p = u.parent.textContent.split(`
`),
								m = n === "up" ? u.start() : u.end(),
								v = n === "up" ? [m, p[0].length + m] : [m - ni(p).length, m],
								y = s.resolve(n === "up" ? u.before() : u.after()),
								b = n === "up" ? y.nodeBefore : y.nodeAfter
							if (n1e(u.pos, v[0], v[1]) && !b) {
								var x = qO(o, y, l)
								if (x) return a(x), !0
							}
						}
						return !1
					}
				}),
				(t.prototype.keymaps = function () {
					var n = this.commands()()
					return {
						"Shift-Mod-p": n,
						"Shift-Mod-P": n,
						ArrowUp: this.moveCursor("up"),
						ArrowDown: this.moveCursor("down"),
					}
				}),
				t
			)
		})(On),
		Zit = (function (e) {
			Ve(t, e)
			function t() {
				return (e !== null && e.apply(this, arguments)) || this
			}
			return (
				Object.defineProperty(t.prototype, "name", {
					get: function () {
						return "bulletList"
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(t.prototype, "schema", {
					get: function () {
						return {
							content: "listItem+",
							group: "block",
							attrs: me({ rawHTML: { default: null } }, Mr()),
							parseDOM: [gw("ul")],
							toDOM: function (n) {
								var r = n.attrs
								return ["ul", sr(r), 0]
							},
						}
					},
					enumerable: !1,
					configurable: !0,
				}),
				(t.prototype.changeList = function () {
					return function (n, r) {
						return cq(n.schema.nodes.bulletList)(n, r)
					}
				}),
				(t.prototype.commands = function () {
					return { bulletList: this.changeList, taskList: Rrt }
				}),
				(t.prototype.keymaps = function () {
					var n = this.changeList(),
						r = uA(),
						i = r.indent,
						a = r.outdent
					return { "Mod-u": n, "Mod-U": n, Tab: i(), "Shift-Tab": a() }
				}),
				t
			)
		})(On),
		eat = (function (e) {
			Ve(t, e)
			function t() {
				return (e !== null && e.apply(this, arguments)) || this
			}
			return (
				Object.defineProperty(t.prototype, "name", {
					get: function () {
						return "orderedList"
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(t.prototype, "schema", {
					get: function () {
						return {
							content: "listItem+",
							group: "block",
							attrs: me({ order: { default: 1 }, rawHTML: { default: null } }, Mr()),
							parseDOM: [
								{
									tag: "ol",
									getAttrs: function (n) {
										var r = n.getAttribute("start"),
											i = n.getAttribute("data-raw-html")
										return me(
											{ order: n.hasAttribute("start") ? Number(r) : 1 },
											i && { rawHTML: i },
										)
									},
								},
							],
							toDOM: function (n) {
								var r = n.attrs
								return [r.rawHTML || "ol", me({ start: r.order === 1 ? null : r.order }, sr(r)), 0]
							},
						}
					},
					enumerable: !1,
					configurable: !0,
				}),
				(t.prototype.commands = function () {
					return function () {
						return function (n, r) {
							return cq(n.schema.nodes.orderedList)(n, r)
						}
					}
				}),
				(t.prototype.keymaps = function () {
					var n = this.commands()(),
						r = uA(),
						i = r.indent,
						a = r.outdent
					return { "Mod-o": n, "Mod-O": n, Tab: i(), "Shift-Tab": a() }
				}),
				t
			)
		})(On),
		tat = (function (e) {
			Ve(t, e)
			function t() {
				return (e !== null && e.apply(this, arguments)) || this
			}
			return (
				Object.defineProperty(t.prototype, "name", {
					get: function () {
						return "listItem"
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(t.prototype, "schema", {
					get: function () {
						return {
							content: "paragraph block*",
							selectable: !1,
							attrs: {
								task: { default: !1 },
								checked: { default: !1 },
								rawHTML: { default: null },
							},
							defining: !0,
							parseDOM: [
								{
									tag: "li",
									getAttrs: function (n) {
										var r = n.getAttribute("data-raw-html")
										return me(
											{
												task: n.hasAttribute("data-task"),
												checked: n.hasAttribute("data-task-checked"),
											},
											r && { rawHTML: r },
										)
									},
								},
							],
							toDOM: function (n) {
								var r = n.attrs,
									i = r.task,
									a = r.checked
								if (!i) return [r.rawHTML || "li", 0]
								var o = ["task-list-item"]
								return (
									a && o.push("checked"),
									[
										r.rawHTML || "li",
										me({ class: o.join(" "), "data-task": i }, a && { "data-task-checked": a }),
										0,
									]
								)
							},
						}
					},
					enumerable: !1,
					configurable: !0,
				}),
				(t.prototype.liftToPrevListItem = function () {
					return function (n, r) {
						var i = n.selection,
							a = n.tr,
							o = n.schema,
							s = i.$from,
							l = i.empty,
							u = o.nodes.listItem,
							d = s.parent,
							p = s.node(-1)
						if (l && !d.childCount && p.type === u) {
							if (s.index(-2) >= 1) return a.delete(s.start(-1) - 1, s.end(-1)), r(a), !0
							var m = s.node(-3)
							if (m.type === u) return a.delete(s.start(-2) - 1, s.end(-1)), r(a), !0
						}
						return !1
					}
				}),
				(t.prototype.keymaps = function () {
					var n = function (r, i) {
						return Brt(r.schema.nodes.listItem)(r, i)
					}
					return { Backspace: this.liftToPrevListItem(), Enter: n }
				}),
				t
			)
		})(On),
		nat = (function (e) {
			Ve(t, e)
			function t() {
				return (e !== null && e.apply(this, arguments)) || this
			}
			return (
				Object.defineProperty(t.prototype, "name", {
					get: function () {
						return "blockQuote"
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(t.prototype, "schema", {
					get: function () {
						return {
							attrs: me({ rawHTML: { default: null } }, Mr()),
							content: "block+",
							group: "block",
							parseDOM: [gw("blockquote")],
							toDOM: function (n) {
								var r = n.attrs
								return ["blockquote", sr(r), 0]
							},
						}
					},
					enumerable: !1,
					configurable: !0,
				}),
				(t.prototype.commands = function () {
					return function () {
						return function (n, r) {
							return V0e(n.schema.nodes.blockQuote)(n, r)
						}
					}
				}),
				(t.prototype.keymaps = function () {
					var n = this.commands()()
					return { "Alt-q": n, "Alt-Q": n }
				}),
				t
			)
		})(On),
		rat = { left: dat, right: cat, up: fat, down: pat }
	function iat(e, t, n) {
		var r = n[0],
			i = n[1],
			a = t.resolve(e.before(r - 1))
		return i === r && !a.nodeBefore
	}
	function aat(e) {
		for (var t, n = e.depth, r; n && ((r = e.node(n)), r.type.name !== "tableBodyCell"); ) {
			if (r.type.name === "listItem") {
				var i = e.node(n - 1),
					a = i.lastChild === r,
					o = ((t = r.lastChild) === null || t === void 0 ? void 0 : t.type.name) !== "paragraph"
				return a ? !o : !1
			}
			n -= 1
		}
		return !1
	}
	function oat(e, t, n, r, i) {
		var a = t[0],
			o = t[1],
			s = t[2]
		if (e === "left" || e === "up") {
			if (i && !iat(n, r, [a, o])) return !1
			var l = n.before(s),
				u = r.resolve(l).nodeBefore
			if (u) return !1
		}
		return !0
	}
	function sat(e, t, n, r, i) {
		if (e === "right" || e === "down") {
			if (i && !aat(n)) return !1
			var a = n.after(t),
				o = r.resolve(a).nodeAfter
			if (o) return !1
		}
		return !0
	}
	function lat(e, t, n, r) {
		var i = t[0],
			a = t[1],
			o = i + 3,
			s = a >= o,
			l = s ? i + 1 : a,
			u = oat(e, [a, o, l], n, r, s),
			d = sat(e, l, n, r, s)
		return u && d
	}
	function uj(e, t, n) {
		var r = n[0],
			i = n[1],
			a = t.getRowspanStartInfo(r, i),
			o = e === "up" && r === 0,
			s =
				e === "down" &&
				((a == null ? void 0 : a.count) > 1 ? r + a.count - 1 : r) === t.totalRowCount - 1
		return o || s
	}
	function uat(e, t, n) {
		var r = e.doc.resolve(t.tableStartOffset - 1)
		return r.nodeBefore ? e.setSelection(_t.near(r, -1)) : qO(e, r, n)
	}
	function Pk(e, t, n, r) {
		r === void 0 && (r = !1)
		var i = e.doc.resolve(t.tableEndOffset)
		return r || !i.nodeAfter ? qO(e, i, n) : e.setSelection(_t.near(i, 1))
	}
	function cat(e, t) {
		var n = e[0],
			r = e[1],
			i = t.totalRowCount,
			a = t.totalColumnCount,
			o = r === a - 1,
			s = n === i - 1 && o
		if (!s) {
			var l = r + 1,
				u = t.getColspanStartInfo(n, r)
			;(u == null ? void 0 : u.count) > 1 && (l += u.count - 1),
				(o || l === a) && ((n += 1), (l = 0))
			var d = t.getCellInfo(n, l).offset
			return d + 2
		}
		return null
	}
	function dat(e, t) {
		var n = e[0],
			r = e[1],
			i = t.totalColumnCount,
			a = r === 0,
			o = n === 0 && a
		if (!o) {
			;(r -= 1), a && ((n -= 1), (r = i - 1))
			var s = t.getCellInfo(n, r),
				l = s.offset,
				u = s.nodeSize
			return l + u - 2
		}
		return null
	}
	function fat(e, t) {
		var n = e[0],
			r = e[1]
		if (n > 0) {
			var i = t.getCellInfo(n - 1, r),
				a = i.offset,
				o = i.nodeSize
			return a + o - 2
		}
		return null
	}
	function pat(e, t) {
		var n = e[0],
			r = e[1],
			i = t.totalRowCount
		if (n < i - 1) {
			var a = n + 1,
				o = t.getRowspanStartInfo(n, r)
			;(o == null ? void 0 : o.count) > 1 && (a += o.count - 1)
			var s = t.getCellInfo(a, r).offset
			return s + 2
		}
		return null
	}
	function cj(e, t, n, r) {
		var i = rat[e],
			a = i(n, r)
		if (a) {
			var o = e === "right" || e === "down" ? 1 : -1
			return t.setSelection(_t.near(t.doc.resolve(a), o))
		}
		return null
	}
	function hat(e, t, n) {
		var r = n[0],
			i = n[1]
		if (e === "up" || e === "down") return !1
		var a = t.tableStartOffset,
			o = t.tableEndOffset,
			s = t.getCellInfo(r, i),
			l = s.offset,
			u = s.nodeSize,
			d = e === "left" ? a : o,
			p = e === "left" ? l - 2 : l + u + 3
		return d === p
	}
	function mat(e, t, n) {
		var r = e.doc.resolve(t.before(n - 3))
		return e.setSelection(new vt(r))
	}
	function vat(e, t, n) {
		var r, i, a
		return (
			e === "up"
				? ((r = n.startRowIdx), (i = 0), (a = -1))
				: ((r = n.endRowIdx), (i = t.totalColumnCount - 1), (a = t.getCellInfo(r, i).nodeSize + 1)),
			{ targetRowIdx: r, insertColIdx: i, nodeSize: a }
		)
	}
	function gat(e, t, n) {
		var r = e.getCellInfo(t, 0).offset,
			i = e.getCellInfo(t, n - 1),
			a = i.offset,
			o = i.nodeSize
		return { from: r, to: a + o }
	}
	var yat = (function (e) {
			Ve(t, e)
			function t() {
				return (e !== null && e.apply(this, arguments)) || this
			}
			return (
				Object.defineProperty(t.prototype, "name", {
					get: function () {
						return "table"
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(t.prototype, "schema", {
					get: function () {
						return {
							content: "tableHead{1} tableBody{1}",
							group: "block",
							attrs: me({ rawHTML: { default: null } }, Mr()),
							parseDOM: [gw("table")],
							toDOM: function (n) {
								var r = n.attrs
								return ["table", sr(r), 0]
							},
						}
					},
					enumerable: !1,
					configurable: !0,
				}),
				(t.prototype.addTable = function () {
					return function (n) {
						return (
							n === void 0 && (n = { rowCount: 2, columnCount: 1, data: [] }),
							function (r, i) {
								var a = n.rowCount,
									o = n.columnCount,
									s = n.data,
									l = r.schema,
									u = r.selection,
									d = r.tr,
									p = u.from,
									m = u.to,
									v = u.$from,
									y = p === m
								if (y && !_b(v)) {
									var b = l.nodes,
										x = b.tableHead,
										E = b.tableBody,
										T = s == null ? void 0 : s.slice(0, o),
										C = s == null ? void 0 : s.slice(o, s.length),
										D = Vrt(o, l, T),
										O = dq(a - 1, o, l, C),
										A = l.nodes.table.create(null, [x.create(null, D), E.create(null, O)])
									return i(d.replaceSelectionWith(A)), !0
								}
								return !1
							}
						)
					}
				}),
				(t.prototype.removeTable = function () {
					return function () {
						return function (n, r) {
							var i = n.selection,
								a = n.tr,
								o = Fr.create(i.$anchor)
							if (o) {
								var s = o.tableStartOffset,
									l = o.tableEndOffset,
									u = s - 1,
									d = Fn(a.delete(u, l), u)
								return r(a.setSelection(d)), !0
							}
							return !1
						}
					}
				}),
				(t.prototype.addColumn = function (n) {
					return function () {
						return function (r, i) {
							var a = r.selection,
								o = r.tr,
								s = r.schema,
								l = zo(a),
								u = l.anchor,
								d = l.head
							if (u && d) {
								for (
									var p = Fr.create(u),
										m = p.getRectOffsets(u, d),
										v = n === "left" ? m.startColIdx : m.endColIdx + 1,
										y = Hf(m).columnCount,
										b = p.totalRowCount,
										x = 0;
									x < b;
									x += 1
								) {
									var E = h1(y, x, s)
									o.insert(o.mapping.map(p.posAt(x, v)), E)
								}
								return i(o), !0
							}
							return !1
						}
					}
				}),
				(t.prototype.removeColumn = function () {
					return function () {
						return function (n, r) {
							var i = n.selection,
								a = n.tr,
								o = zo(i),
								s = o.anchor,
								l = o.head
							if (s && l) {
								var u = Fr.create(s),
									d = u.getRectOffsets(s, l),
									p = u.totalColumnCount,
									m = u.totalRowCount,
									v = Hf(d).columnCount,
									y = v === p
								if (y) return !1
								for (
									var b = d.startColIdx, x = d.endColIdx, E = a.mapping.maps.length, T = 0;
									T < m;
									T += 1
								)
									for (var C = x; C >= b; C -= 1) {
										var D = u.getCellInfo(T, C),
											O = D.offset,
											A = D.nodeSize,
											N = a.mapping.slice(E).map(O),
											I = N + A
										a.delete(N, I)
									}
								return r(a), !0
							}
							return !1
						}
					}
				}),
				(t.prototype.addRow = function (n) {
					return function () {
						return function (r, i) {
							var a = r.selection,
								o = r.schema,
								s = r.tr,
								l = zo(a),
								u = l.anchor,
								d = l.head
							if (u && d) {
								var p = Fr.create(u),
									m = p.totalColumnCount,
									v = p.getRectOffsets(u, d),
									y = Hf(v).rowCount,
									b = vat(n, p, v),
									x = b.targetRowIdx,
									E = b.insertColIdx,
									T = b.nodeSize,
									C = x === 0
								if (!C) {
									for (
										var D = [], O = s.mapping.map(p.posAt(x, E)) + T, A = [], N = 0;
										N < m;
										N += 1
									)
										A = A.concat(h1(1, x, o))
									for (var I = 0; I < y; I += 1) D.push(o.nodes.tableRow.create(null, A))
									return i(s.insert(O, D)), !0
								}
							}
							return !1
						}
					}
				}),
				(t.prototype.removeRow = function () {
					return function () {
						return function (n, r) {
							var i = n.selection,
								a = n.tr,
								o = zo(i),
								s = o.anchor,
								l = o.head
							if (s && l) {
								var u = Fr.create(s),
									d = u.totalRowCount,
									p = u.totalColumnCount,
									m = u.getRectOffsets(s, l),
									v = Hf(m).rowCount,
									y = m.startRowIdx,
									b = m.endRowIdx,
									x = y === 0,
									E = v === d - 1
								if (E || x) return !1
								for (var T = b; T >= y; T -= 1) {
									var C = gat(u, T, p),
										D = C.from,
										O = C.to
									a.delete(D - 1, O + 1)
								}
								return r(a), !0
							}
							return !1
						}
					}
				}),
				(t.prototype.alignColumn = function () {
					return function (n) {
						return (
							n === void 0 && (n = { align: "center" }),
							function (r, i) {
								var a = n.align,
									o = r.selection,
									s = r.tr,
									l = zo(o),
									u = l.anchor,
									d = l.head
								if (u && d) {
									for (
										var p = Fr.create(u),
											m = p.totalRowCount,
											v = p.getRectOffsets(u, d),
											y = v.startColIdx,
											b = v.endColIdx,
											x = 0;
										x < m;
										x += 1
									)
										for (var E = y; E <= b; E += 1)
											if (!p.extendedRowspan(x, E) && !p.extendedColspan(x, E)) {
												var T = p.getNodeAndPos(x, E),
													C = T.node,
													D = T.pos,
													O = Wrt(C, { align: a })
												s.setNodeMarkup(D, null, O)
											}
									return i(s), !0
								}
								return !1
							}
						)
					}
				}),
				(t.prototype.moveToCell = function (n) {
					return function (r, i) {
						var a = r.selection,
							o = r.tr,
							s = r.schema,
							l = zo(a),
							u = l.anchor,
							d = l.head
						if (u && d) {
							var p = Fr.create(u),
								m = p.getCellIndex(u),
								v = void 0
							if ((uj(n, p, m) ? (v = Pk(o, p, s)) : (v = cj(n, o, m, p)), v)) return i(v), !0
						}
						return !1
					}
				}),
				(t.prototype.moveInCell = function (n) {
					var r = this
					return function (i, a) {
						var o = i.selection,
							s = i.tr,
							l = i.doc,
							u = i.schema,
							d = o.$from,
							p = r.context.view
						if (!p.endOfTextblock(n)) return !1
						var m = ol(d, function (C) {
							var D = C.type
							return D.name === "tableHeadCell" || D.name === "tableBodyCell"
						})
						if (m) {
							var v = ol(d, function (C) {
									var D = C.type
									return D.name === "paragraph"
								}),
								y = m.depth
							if (v && lat(n, [y, v.depth], d, l)) {
								var b = zo(o).anchor,
									x = Fr.create(b),
									E = x.getCellIndex(b),
									T = void 0
								if (
									(hat(n, x, E)
										? (T = mat(s, d, y))
										: uj(n, x, E)
										? n === "up"
											? (T = uat(s, x, u))
											: n === "down" && (T = Pk(s, x, u))
										: (T = cj(n, s, E, x)),
									T)
								)
									return a(T), !0
							}
						}
						return !1
					}
				}),
				(t.prototype.deleteCells = function () {
					return function (n, r) {
						var i = n.schema,
							a = n.selection,
							o = n.tr,
							s = zo(a),
							l = s.anchor,
							u = s.head,
							d = a instanceof jt
						if (l && u && !d) {
							for (
								var p = Fr.create(l),
									m = p.getRectOffsets(l, u),
									v = m.startRowIdx,
									y = m.startColIdx,
									b = m.endRowIdx,
									x = m.endColIdx,
									E = v;
								E <= b;
								E += 1
							)
								for (var T = y; T <= x; T += 1)
									if (!p.extendedRowspan(E, T) && !p.extendedColspan(E, T)) {
										var C = p.getNodeAndPos(E, T),
											D = C.node,
											O = C.pos,
											A = h1(1, E, i, D.attrs)
										o.replaceWith(o.mapping.map(O), o.mapping.map(O + D.nodeSize), A)
									}
							return r(o), !0
						}
						return !1
					}
				}),
				(t.prototype.exitTable = function () {
					return function (n, r) {
						var i = n.selection,
							a = n.tr,
							o = n.schema,
							s = i.$from,
							l = ol(s, function (m) {
								var v = m.type
								return v.name === "tableHeadCell" || v.name === "tableBodyCell"
							})
						if (l) {
							var u = ol(s, function (m) {
								var v = m.type
								return v.name === "paragraph"
							})
							if (u) {
								var d = zo(i).anchor,
									p = Fr.create(d)
								return r(Pk(a, p, o, !0)), !0
							}
						}
						return !1
					}
				}),
				(t.prototype.commands = function () {
					return {
						addTable: this.addTable(),
						removeTable: this.removeTable(),
						addColumnToLeft: this.addColumn("left"),
						addColumnToRight: this.addColumn("right"),
						removeColumn: this.removeColumn(),
						addRowToUp: this.addRow("up"),
						addRowToDown: this.addRow("down"),
						removeRow: this.removeRow(),
						alignColumn: this.alignColumn(),
					}
				}),
				(t.prototype.keymaps = function () {
					var n = this.deleteCells()
					return {
						Tab: this.moveToCell("right"),
						"Shift-Tab": this.moveToCell("left"),
						ArrowUp: this.moveInCell("up"),
						ArrowDown: this.moveInCell("down"),
						ArrowLeft: this.moveInCell("left"),
						ArrowRight: this.moveInCell("right"),
						Backspace: n,
						"Mod-Backspace": n,
						Delete: n,
						"Mod-Delete": n,
						"Mod-Enter": this.exitTable(),
					}
				}),
				t
			)
		})(On),
		bat = (function (e) {
			Ve(t, e)
			function t() {
				return (e !== null && e.apply(this, arguments)) || this
			}
			return (
				Object.defineProperty(t.prototype, "name", {
					get: function () {
						return "tableHead"
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(t.prototype, "schema", {
					get: function () {
						return {
							content: "tableRow{1}",
							attrs: me({ rawHTML: { default: null } }, Mr()),
							parseDOM: [gw("thead")],
							toDOM: function (n) {
								var r = n.attrs
								return ["thead", sr(r), 0]
							},
						}
					},
					enumerable: !1,
					configurable: !0,
				}),
				t
			)
		})(On),
		xat = (function (e) {
			Ve(t, e)
			function t() {
				return (e !== null && e.apply(this, arguments)) || this
			}
			return (
				Object.defineProperty(t.prototype, "name", {
					get: function () {
						return "tableBody"
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(t.prototype, "schema", {
					get: function () {
						return {
							content: "tableRow+",
							attrs: me({ rawHTML: { default: null } }, Mr()),
							parseDOM: [
								{
									tag: "tbody",
									getAttrs: function (n) {
										var r = n.querySelectorAll("tr"),
											i = r[0].children.length,
											a = n.getAttribute("data-raw-html")
										return i ? me({}, a && { rawHTML: a }) : !1
									},
								},
							],
							toDOM: function (n) {
								var r = n.attrs
								return ["tbody", sr(r), 0]
							},
						}
					},
					enumerable: !1,
					configurable: !0,
				}),
				t
			)
		})(On),
		wat = (function (e) {
			Ve(t, e)
			function t() {
				return (e !== null && e.apply(this, arguments)) || this
			}
			return (
				Object.defineProperty(t.prototype, "name", {
					get: function () {
						return "tableRow"
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(t.prototype, "schema", {
					get: function () {
						return {
							content: "(tableHeadCell | tableBodyCell)*",
							attrs: me({ rawHTML: { default: null } }, Mr()),
							parseDOM: [
								{
									tag: "tr",
									getAttrs: function (n) {
										var r = n.children.length,
											i = n.getAttribute("data-raw-html")
										return r ? me({}, i && { rawHTML: i }) : !1
									},
								},
							],
							toDOM: function (n) {
								var r = n.attrs
								return ["tr", sr(r), 0]
							},
						}
					},
					enumerable: !1,
					configurable: !0,
				}),
				t
			)
		})(On),
		Eat = (function (e) {
			Ve(t, e)
			function t() {
				return (e !== null && e.apply(this, arguments)) || this
			}
			return (
				Object.defineProperty(t.prototype, "name", {
					get: function () {
						return "tableHeadCell"
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(t.prototype, "schema", {
					get: function () {
						return {
							content: "paragraph+",
							attrs: me(
								{
									align: { default: null },
									className: { default: null },
									rawHTML: { default: null },
									colspan: { default: null },
									extended: { default: null },
								},
								Mr(),
							),
							isolating: !0,
							parseDOM: [sq("th")],
							toDOM: function (n) {
								var r = n.attrs,
									i = oq(r)
								return ["th", me(me({}, i), sr(r)), 0]
							},
						}
					},
					enumerable: !1,
					configurable: !0,
				}),
				t
			)
		})(On),
		Cat = (function (e) {
			Ve(t, e)
			function t() {
				return (e !== null && e.apply(this, arguments)) || this
			}
			return (
				Object.defineProperty(t.prototype, "name", {
					get: function () {
						return "tableBodyCell"
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(t.prototype, "schema", {
					get: function () {
						return {
							content: "(paragraph | bulletList | orderedList)+",
							attrs: {
								align: { default: null },
								className: { default: null },
								rawHTML: { default: null },
								colspan: { default: null },
								rowspan: { default: null },
								extended: { default: null },
							},
							isolating: !0,
							parseDOM: [sq("td")],
							toDOM: function (n) {
								var r = n.attrs,
									i = oq(r)
								return ["td", i, 0]
							},
						}
					},
					enumerable: !1,
					configurable: !0,
				}),
				t
			)
		})(On),
		Tat = (function (e) {
			Ve(t, e)
			function t() {
				return (e !== null && e.apply(this, arguments)) || this
			}
			return (
				Object.defineProperty(t.prototype, "name", {
					get: function () {
						return "image"
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(t.prototype, "schema", {
					get: function () {
						return {
							inline: !0,
							attrs: me(
								{
									imageUrl: { default: "" },
									altText: { default: null },
									rawHTML: { default: null },
								},
								Mr(),
							),
							group: "inline",
							selectable: !1,
							parseDOM: [
								{
									tag: "img[src]",
									getAttrs: function (n) {
										var r = Cd(n, { RETURN_DOM_FRAGMENT: !0 }).firstChild,
											i = r.getAttribute("src") || "",
											a = r.getAttribute("data-raw-html"),
											o = r.getAttribute("alt")
										return me({ imageUrl: i, altText: o }, a && { rawHTML: a })
									},
								},
							],
							toDOM: function (n) {
								var r = n.attrs
								return [
									r.rawHTML || "img",
									me(me({ src: Bf(r.imageUrl) }, r.altText && { alt: r.altText }), sr(r)),
								]
							},
						}
					},
					enumerable: !1,
					configurable: !0,
				}),
				(t.prototype.addImage = function () {
					return function (n) {
						return function (r, i) {
							var a = r.schema,
								o = r.tr,
								s = n,
								l = s.imageUrl,
								u = s.altText
							if (!l) return !1
							var d = a.nodes.image.createAndFill(me({ imageUrl: l }, u && { altText: u }))
							return i(o.replaceSelectionWith(d).scrollIntoView()), !0
						}
					}
				}),
				(t.prototype.commands = function () {
					return { addImage: this.addImage() }
				}),
				t
			)
		})(On),
		dj = 1,
		kat = (function (e) {
			Ve(t, e)
			function t() {
				return (e !== null && e.apply(this, arguments)) || this
			}
			return (
				Object.defineProperty(t.prototype, "name", {
					get: function () {
						return "thematicBreak"
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(t.prototype, "schema", {
					get: function () {
						return {
							attrs: me({ rawHTML: { default: null } }, Mr()),
							group: "block",
							parseDOM: [{ tag: "hr" }],
							selectable: !1,
							toDOM: function (n) {
								var r = n.attrs
								return ["div", sr(r), [r.rawHTML || "hr"]]
							},
						}
					},
					enumerable: !1,
					configurable: !0,
				}),
				(t.prototype.hr = function () {
					var n = this
					return function () {
						return function (r, i) {
							var a,
								o = r.selection,
								s = o.$from,
								l = o.$to
							if (s === l) {
								var u = r.doc,
									d = r.schema.nodes,
									p = d.thematicBreak,
									m = d.paragraph,
									v = [p.create()],
									y = s.node(dj),
									b = u.child(u.childCount - 1) === y,
									x = u.resolve(s.after(dj)),
									E = ((a = s.nodeAfter) === null || a === void 0 ? void 0 : a.type.name) === n.name
								return (b || E) && v.push(m.create()), i(r.tr.insert(x.pos, v).scrollIntoView()), !0
							}
							return !1
						}
					}
				}),
				(t.prototype.commands = function () {
					return { hr: this.hr() }
				}),
				(t.prototype.keymaps = function () {
					var n = this.hr()()
					return { "Mod-l": n, "Mod-L": n }
				}),
				t
			)
		})(On),
		Sat = (function (e) {
			Ve(t, e)
			function t() {
				return (e !== null && e.apply(this, arguments)) || this
			}
			return (
				Object.defineProperty(t.prototype, "name", {
					get: function () {
						return "strong"
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(t.prototype, "schema", {
					get: function () {
						var n = ["b", "strong"].map(function (r) {
							return {
								tag: r,
								getAttrs: function (i) {
									var a = i.getAttribute("data-raw-html")
									return me({}, a && { rawHTML: a })
								},
							}
						})
						return {
							attrs: me({ rawHTML: { default: null } }, Mr()),
							parseDOM: n,
							toDOM: function (r) {
								var i = r.attrs
								return [i.rawHTML || "strong", sr(i)]
							},
						}
					},
					enumerable: !1,
					configurable: !0,
				}),
				(t.prototype.bold = function () {
					return function () {
						return function (n, r) {
							return pg(n.schema.marks.strong)(n, r)
						}
					}
				}),
				(t.prototype.commands = function () {
					return { bold: this.bold() }
				}),
				(t.prototype.keymaps = function () {
					var n = this.bold()()
					return { "Mod-b": n, "Mod-B": n }
				}),
				t
			)
		})(Bn),
		Dat = (function (e) {
			Ve(t, e)
			function t() {
				return (e !== null && e.apply(this, arguments)) || this
			}
			return (
				Object.defineProperty(t.prototype, "name", {
					get: function () {
						return "emph"
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(t.prototype, "schema", {
					get: function () {
						var n = ["i", "em"].map(function (r) {
							return {
								tag: r,
								getAttrs: function (i) {
									var a = i.getAttribute("data-raw-html")
									return me({}, a && { rawHTML: a })
								},
							}
						})
						return {
							attrs: me({ rawHTML: { default: null } }, Mr()),
							parseDOM: n,
							toDOM: function (r) {
								var i = r.attrs
								return [i.rawHTML || "em", sr(i)]
							},
						}
					},
					enumerable: !1,
					configurable: !0,
				}),
				(t.prototype.italic = function () {
					return function () {
						return function (n, r) {
							return pg(n.schema.marks.emph)(n, r)
						}
					}
				}),
				(t.prototype.commands = function () {
					return { italic: this.italic() }
				}),
				(t.prototype.keymaps = function () {
					var n = this.italic()()
					return { "Mod-i": n, "Mod-I": n }
				}),
				t
			)
		})(Bn),
		_at = (function (e) {
			Ve(t, e)
			function t() {
				return (e !== null && e.apply(this, arguments)) || this
			}
			return (
				Object.defineProperty(t.prototype, "name", {
					get: function () {
						return "strike"
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(t.prototype, "schema", {
					get: function () {
						var n = ["s", "del"].map(function (r) {
							return {
								tag: r,
								getAttrs: function (i) {
									var a = i.getAttribute("data-raw-html")
									return me({}, a && { rawHTML: a })
								},
							}
						})
						return {
							attrs: me({ rawHTML: { default: null } }, Mr()),
							parseDOM: n,
							toDOM: function (r) {
								var i = r.attrs
								return [i.rawHTML || "del", sr(i)]
							},
						}
					},
					enumerable: !1,
					configurable: !0,
				}),
				(t.prototype.commands = function () {
					return function () {
						return function (n, r) {
							return pg(n.schema.marks.strike)(n, r)
						}
					}
				}),
				(t.prototype.keymaps = function () {
					var n = this.commands()()
					return { "Mod-s": n, "Mod-S": n }
				}),
				t
			)
		})(Bn),
		Oat = (function (e) {
			Ve(t, e)
			function t(n) {
				var r = e.call(this) || this
				return (r.linkAttributes = n), r
			}
			return (
				Object.defineProperty(t.prototype, "name", {
					get: function () {
						return "link"
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(t.prototype, "schema", {
					get: function () {
						var n = this
						return {
							attrs: me(
								{ linkUrl: { default: "" }, title: { default: null }, rawHTML: { default: null } },
								Mr(),
							),
							inclusive: !1,
							parseDOM: [
								{
									tag: "a[href]",
									getAttrs: function (r) {
										var i = Cd(r, { RETURN_DOM_FRAGMENT: !0 }).firstChild,
											a = i.getAttribute("href") || "",
											o = i.getAttribute("title") || "",
											s = i.getAttribute("data-raw-html")
										return me({ linkUrl: a, title: o }, s && { rawHTML: s })
									},
								},
							],
							toDOM: function (r) {
								var i = r.attrs
								return [i.rawHTML || "a", me(me({ href: Bf(i.linkUrl) }, n.linkAttributes), sr(i))]
							},
						}
					},
					enumerable: !1,
					configurable: !0,
				}),
				(t.prototype.addLink = function () {
					return function (n) {
						return function (r, i) {
							var a = n,
								o = a.linkUrl,
								s = a.linkText,
								l = s === void 0 ? "" : s,
								u = r.schema,
								d = r.tr,
								p = r.selection,
								m = p.empty,
								v = p.from,
								y = p.to
							if (v && y && o) {
								var b = { linkUrl: o },
									x = u.mark("link", b)
								if (m && l) {
									var E = zr(u, l, x)
									d.replaceRangeWith(v, y, E)
								} else d.addMark(v, y, x)
								return i(d.scrollIntoView()), !0
							}
							return !1
						}
					}
				}),
				(t.prototype.toggleLink = function () {
					return function (n) {
						return function (r, i) {
							return pg(r.schema.marks.link, n)(r, i)
						}
					}
				}),
				(t.prototype.commands = function () {
					return { addLink: this.addLink(), toggleLink: this.toggleLink() }
				}),
				t
			)
		})(Bn),
		Aat = (function (e) {
			Ve(t, e)
			function t() {
				return (e !== null && e.apply(this, arguments)) || this
			}
			return (
				Object.defineProperty(t.prototype, "name", {
					get: function () {
						return "code"
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(t.prototype, "schema", {
					get: function () {
						return {
							attrs: me({ rawHTML: { default: null } }, Mr()),
							parseDOM: [
								{
									tag: "code",
									getAttrs: function (n) {
										var r = n.getAttribute("data-raw-html")
										return me({}, r && { rawHTML: r })
									},
								},
							],
							toDOM: function (n) {
								var r = n.attrs
								return [r.rawHTML || "code", sr(r)]
							},
						}
					},
					enumerable: !1,
					configurable: !0,
				}),
				(t.prototype.commands = function () {
					return function () {
						return function (n, r) {
							return pg(n.schema.marks.code)(n, r)
						}
					}
				}),
				(t.prototype.keymaps = function () {
					var n = this.commands()()
					return { "Shift-Mod-c": n, "Shift-Mod-C": n }
				}),
				t
			)
		})(Bn),
		Nat = (function (e) {
			Ve(t, e)
			function t() {
				return (e !== null && e.apply(this, arguments)) || this
			}
			return (
				Object.defineProperty(t.prototype, "name", {
					get: function () {
						return "customBlock"
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(t.prototype, "schema", {
					get: function () {
						return {
							content: "text*",
							group: "block",
							attrs: { info: { default: null } },
							atom: !0,
							code: !0,
							defining: !0,
							parseDOM: [
								{
									tag: "div[data-custom-info]",
									getAttrs: function (n) {
										var r = n.getAttribute("data-custom-info")
										return { info: r }
									},
								},
							],
							toDOM: function (n) {
								var r = n.attrs
								return ["div", { "data-custom-info": r.info || null }, 0]
							},
						}
					},
					enumerable: !1,
					configurable: !0,
				}),
				(t.prototype.commands = function () {
					return function (n) {
						return function (r, i) {
							return n != null && n.info ? LO(r.schema.nodes.customBlock, n)(r, i) : !1
						}
					}
				}),
				t
			)
		})(On),
		Mat = (function (e) {
			Ve(t, e)
			function t() {
				return (e !== null && e.apply(this, arguments)) || this
			}
			return (
				Object.defineProperty(t.prototype, "name", {
					get: function () {
						return "frontMatter"
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(t.prototype, "schema", {
					get: function () {
						return {
							content: "text*",
							group: "block",
							code: !0,
							defining: !0,
							parseDOM: [{ preserveWhitespace: "full", tag: "div[data-front-matter]" }],
							toDOM: function () {
								return ["div", { "data-front-matter": "true" }, 0]
							},
						}
					},
					enumerable: !1,
					configurable: !0,
				}),
				(t.prototype.commands = function () {
					return function () {
						return function (n, r, i) {
							var a = n.selection.$from
							return i.endOfTextblock("down") && a.node().type.name === "frontMatter"
								? RO(n, r)
								: !1
						}
					}
				}),
				(t.prototype.keymaps = function () {
					return { Enter: this.commands()() }
				}),
				t
			)
		})(On),
		Iat = (function (e) {
			Ve(t, e)
			function t() {
				return (e !== null && e.apply(this, arguments)) || this
			}
			return (
				Object.defineProperty(t.prototype, "name", {
					get: function () {
						return "htmlComment"
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(t.prototype, "schema", {
					get: function () {
						return {
							content: "text*",
							group: "block",
							code: !0,
							defining: !0,
							parseDOM: [{ preserveWhitespace: "full", tag: "div[data-html-comment]" }],
							toDOM: function () {
								return ["div", { "data-html-comment": "true" }, 0]
							},
						}
					},
					enumerable: !1,
					configurable: !0,
				}),
				(t.prototype.commands = function () {
					return function () {
						return function (n, r, i) {
							var a = n.selection.$from
							return i.endOfTextblock("down") && a.node().type.name === "htmlComment"
								? RO(n, r)
								: !1
						}
					}
				}),
				(t.prototype.keymaps = function () {
					return { Enter: this.commands()() }
				}),
				t
			)
		})(On)
	function Rat(e) {
		return new cz([
			new Yit(),
			new Git(),
			new Qit(),
			new Xit(),
			new Jit(),
			new Zit(),
			new eat(),
			new tat(),
			new nat(),
			new yat(),
			new bat(),
			new xat(),
			new wat(),
			new Eat(),
			new Cat(),
			new Tat(),
			new kat(),
			new Sat(),
			new Dat(),
			new _at(),
			new Oat(e),
			new Aat(),
			new Nat(),
			new Mat(),
			new lz(),
			new Iat(),
		])
	}
	var Lat = Qe("contents"),
		Pat = (function (e) {
			Ve(t, e)
			function t(n, r) {
				var i = e.call(this, n) || this,
					a = r.toDOMAdaptor,
					o = r.htmlSchemaMap,
					s = o === void 0 ? {} : o,
					l = r.linkAttributes,
					u = l === void 0 ? {} : l,
					d = r.useCommandShortcut,
					p = d === void 0 ? !0 : d,
					m = r.wwPlugins,
					v = m === void 0 ? [] : m,
					y = r.wwNodeViews,
					b = y === void 0 ? {} : y
				return (
					(i.editorType = "wysiwyg"),
					i.el.classList.add("ww-mode"),
					(i.toDOMAdaptor = a),
					(i.linkAttributes = u),
					(i.extraPlugins = v),
					(i.pluginNodeViews = b),
					(i.specs = i.createSpecs()),
					(i.schema = i.createSchema(s)),
					(i.context = i.createContext()),
					(i.keymaps = i.createKeymaps(p)),
					(i.view = i.createView()),
					(i.commands = i.createCommands()),
					i.specs.setContext(me(me({}, i.context), { view: i.view })),
					i.initEvent(),
					i
				)
			}
			return (
				(t.prototype.createSpecs = function () {
					return Rat(this.linkAttributes)
				}),
				(t.prototype.createContext = function () {
					return { schema: this.schema, eventEmitter: this.eventEmitter }
				}),
				(t.prototype.createSchema = function (n) {
					return new R7({
						nodes: me(me({}, this.specs.nodes), n.nodes),
						marks: me(me({}, this.specs.marks), n.marks),
					})
				}),
				(t.prototype.createPlugins = function () {
					return Gi(
						[Xrt(), tit(this.eventEmitter), nit(), uit(this.eventEmitter)],
						this.createPluginProps(),
					).concat(this.defaultPlugins)
				}),
				(t.prototype.createPluginNodeViews = function () {
					var n = this,
						r = n.eventEmitter,
						i = n.pluginNodeViews,
						a = {}
					return (
						i &&
							Object.keys(i).forEach(function (o) {
								a[o] = function (s, l, u) {
									return i[o](s, l, u, r)
								}
							}),
						a
					)
				}),
				(t.prototype.createView = function () {
					var n = this,
						r = this,
						i = r.toDOMAdaptor,
						a = r.eventEmitter
					return new NO(this.el, {
						state: this.createState(),
						attributes: { class: Lat },
						nodeViews: me(
							{
								customBlock: function (o, s, l) {
									return new cit(o, s, l, i)
								},
								image: function (o, s, l) {
									return new dit(o, s, l, a)
								},
								codeBlock: function (o, s, l) {
									return new hit(o, s, l, a)
								},
								widget: sz,
							},
							this.createPluginNodeViews(),
						),
						dispatchTransaction: function (o) {
							var s = n.view.state.applyTransaction(o).state
							n.view.updateState(s),
								n.emitChangeEvent(o.scrollIntoView()),
								n.eventEmitter.emit("setFocusedNode", s.selection.$from.node(1))
						},
						transformPastedHTML: Ait,
						transformPasted: function (o) {
							return Lit(o, n.schema, _b(n.view.state.selection.$from))
						},
						handlePaste: function (o, s, l) {
							return qit(o, l)
						},
						handleKeyDown: function (o, s) {
							return n.eventEmitter.emit("keydown", n.editorType, s), !1
						},
						handleDOMEvents: {
							paste: function (o, s) {
								var l = s.clipboardData || window.clipboardData,
									u = l == null ? void 0 : l.items
								if (u) {
									var d = Ds(u).some(function (m) {
										return m.kind === "string" && m.type === "text/rtf"
									})
									if (!d) {
										var p = oz(u)
										p && (s.preventDefault(), XO(n.eventEmitter, p, s.type))
									}
								}
								return !1
							},
							keyup: function (o, s) {
								return n.eventEmitter.emit("keyup", n.editorType, s), !1
							},
							scroll: function () {
								return n.eventEmitter.emit("scroll", "editor"), !0
							},
						},
					})
				}),
				(t.prototype.createCommands = function () {
					return this.specs.commands(this.view, uA())
				}),
				(t.prototype.getHTML = function () {
					return QO(this.view.dom.innerHTML)
				}),
				(t.prototype.getModel = function () {
					return this.view.state.doc
				}),
				(t.prototype.getSelection = function () {
					var n = this.view.state.selection,
						r = n.from,
						i = n.to
					return [r, i]
				}),
				(t.prototype.getSchema = function () {
					return this.view.state.schema
				}),
				(t.prototype.replaceSelection = function (n, r, i) {
					var a = this.view.state,
						o = a.schema,
						s = a.tr,
						l = n.split(`
`),
						u = l.map(function (m) {
							return yb(o, td(m, o))
						}),
						d = new Ue(ke.from(u), 1, 1),
						p = Js(r) && Js(i) ? s.replaceRange(r, i, d) : s.replaceSelection(d)
					this.view.dispatch(p), this.focus()
				}),
				(t.prototype.deleteSelection = function (n, r) {
					var i = this.view.state.tr,
						a = Js(n) && Js(r) ? i.deleteRange(n, r) : i.deleteSelection()
					this.view.dispatch(a.scrollIntoView())
				}),
				(t.prototype.getSelectedText = function (n, r) {
					var i = this.view.state,
						a = i.doc,
						o = i.selection,
						s = o.from,
						l = o.to
					return (
						Js(n) && Js(r) && ((s = n), (l = r)),
						a.textBetween(
							s,
							l,
							`
`,
						)
					)
				}),
				(t.prototype.setModel = function (n, r) {
					r === void 0 && (r = !1)
					var i = this.view.state,
						a = i.tr,
						o = i.doc
					this.view.dispatch(a.replaceWith(0, o.content.size, n)), r && this.moveCursorToEnd(!0)
				}),
				(t.prototype.setSelection = function (n, r) {
					r === void 0 && (r = n)
					var i = this.view.state.tr,
						a = Fn(i, n, r)
					this.view.dispatch(i.setSelection(a).scrollIntoView())
				}),
				(t.prototype.addWidget = function (n, r, i) {
					var a = this.view,
						o = a.dispatch,
						s = a.state
					o(s.tr.setMeta("widget", { pos: i ?? s.selection.to, node: n, style: r }))
				}),
				(t.prototype.replaceWithWidget = function (n, r, i) {
					var a = this.view.state,
						o = a.tr,
						s = a.schema,
						l = td(i, s)
					this.view.dispatch(o.replaceWith(n, r, l))
				}),
				(t.prototype.getRangeInfoOfNode = function (n) {
					var r = this.view.state,
						i = r.doc,
						a = r.selection,
						o = n ? i.resolve(n) : a.$from,
						s = o.marks(),
						l = o.node(),
						u = o.start(),
						d = o.end(),
						p = l.type.name
					if (s.length || p === "paragraph") {
						var m = s[s.length - 1],
							v = function (y) {
								return y.length ? Vr(y, m) : !0
							}
						;(p = m ? m.type.name : "text"),
							l.forEach(function (y, b) {
								var x = y.isText,
									E = y.nodeSize,
									T = y.marks,
									C = o.pos - u
								x && b <= C && b + E >= C && v(T) && ((u = u + b), (d = u + E))
							})
					}
					return { range: [u, d], type: p }
				}),
				t
			)
		})(uz),
		jat = Oo,
		Fat = hb
	function Bat(e) {
		return !jat(e) && !Fat(e)
	}
	var Hat = Bat,
		$at = Hat
	function Uat(e) {
		return $at(e) && e !== !1
	}
	var zat = Uat,
		qat = zat
	function Vat(e) {
		return !qat(e)
	}
	var Wat = Vat,
		fj = [
			"afterPreviewRender",
			"updatePreview",
			"changeMode",
			"needChangeMode",
			"command",
			"changePreviewStyle",
			"changePreviewTabPreview",
			"changePreviewTabWrite",
			"scroll",
			"contextmenu",
			"show",
			"hide",
			"changeLanguage",
			"changeToolbarState",
			"toggleScrollSync",
			"mixinTableOffsetMapPrototype",
			"setFocusedNode",
			"removePopupWidget",
			"query",
			"openPopup",
			"closePopup",
			"addImageBlobHook",
			"beforePreviewRender",
			"beforeConvertWysiwygToMarkdown",
			"load",
			"loadUI",
			"change",
			"caretChange",
			"destroy",
			"focus",
			"blur",
			"keydown",
			"keyup",
		],
		Tq = (function () {
			function e() {
				var t = this
				;(this.events = new mq()),
					(this.eventTypes = fj.reduce(function (n, r) {
						return me(me({}, n), { type: r })
					}, {})),
					(this.hold = !1),
					fj.forEach(function (n) {
						t.addEventType(n)
					})
			}
			return (
				(e.prototype.listen = function (t, n) {
					var r = this.getTypeInfo(t),
						i = this.events.get(r.type) || []
					if (!this.hasEventType(r.type)) throw new Error("There is no event type " + r.type)
					r.namespace && (n.namespace = r.namespace), i.push(n), this.events.set(r.type, i)
				}),
				(e.prototype.emit = function (t) {
					for (var n = [], r = 1; r < arguments.length; r++) n[r - 1] = arguments[r]
					var i = this.getTypeInfo(t),
						a = this.events.get(i.type),
						o = []
					return (
						!this.hold &&
							a &&
							a.forEach(function (s) {
								var l = s.apply(void 0, n)
								Oo(l) || o.push(l)
							}),
						o
					)
				}),
				(e.prototype.emitReduce = function (t, n) {
					for (var r = [], i = 2; i < arguments.length; i++) r[i - 2] = arguments[i]
					var a = this.events.get(t)
					return (
						!this.hold &&
							a &&
							a.forEach(function (o) {
								var s = o.apply(void 0, Gi([n], r))
								Wat(s) || (n = s)
							}),
						n
					)
				}),
				(e.prototype.getTypeInfo = function (t) {
					var n = t.split(".")
					return { type: n[0], namespace: n[1] }
				}),
				(e.prototype.hasEventType = function (t) {
					return !Oo(this.eventTypes[this.getTypeInfo(t).type])
				}),
				(e.prototype.addEventType = function (t) {
					if (this.hasEventType(t)) throw new Error("There is already have event type " + t)
					this.eventTypes[t] = t
				}),
				(e.prototype.removeEventHandler = function (t, n) {
					var r = this,
						i = this.getTypeInfo(t),
						a = i.type,
						o = i.namespace
					a && n
						? this.removeEventHandlerWithHandler(a, n)
						: a && !o
						? this.events.delete(a)
						: !a && o
						? this.events.forEach(function (s, l) {
								r.removeEventHandlerWithTypeInfo(l, o)
						  })
						: a && o && this.removeEventHandlerWithTypeInfo(a, o)
				}),
				(e.prototype.removeEventHandlerWithHandler = function (t, n) {
					var r = this.events.get(t)
					if (r) {
						var i = r.indexOf(n)
						r.indexOf(n) >= 0 && r.splice(i, 1)
					}
				}),
				(e.prototype.removeEventHandlerWithTypeInfo = function (t, n) {
					var r = [],
						i = this.events.get(t)
					i &&
						(i.map(function (a) {
							return a.namespace !== n && r.push(a), null
						}),
						this.events.set(t, r))
				}),
				(e.prototype.getEvents = function () {
					return this.events
				}),
				(e.prototype.holdEventInvoke = function (t) {
					;(this.hold = !0), t(), (this.hold = !1)
				}),
				e
			)
		})(),
		Yat = (function () {
			function e(t, n, r, i) {
				;(this.eventEmitter = t),
					(this.mdCommands = n),
					(this.wwCommands = r),
					(this.getEditorType = i),
					this.initEvent()
			}
			return (
				(e.prototype.initEvent = function () {
					var t = this
					this.eventEmitter.listen("command", function (n, r) {
						t.exec(n, r)
					})
				}),
				(e.prototype.addCommand = function (t, n, r) {
					t === "markdown" ? (this.mdCommands[n] = r) : (this.wwCommands[n] = r)
				}),
				(e.prototype.deleteCommand = function (t, n) {
					t === "markdown" ? delete this.mdCommands[n] : delete this.wwCommands[n]
				}),
				(e.prototype.exec = function (t, n) {
					var r = this.getEditorType()
					r === "markdown" ? this.mdCommands[t](n) : this.wwCommands[t](n)
				}),
				e
			)
		})()
	function v1(e) {
		return e[e.length - 1] ===
			`
`
			? e.slice(0, e.length - 1)
			: e
	}
	function tD(e, t) {
		var n = e.schema,
			r = t.literal,
			i = r.match(yp)
		if (i) {
			var a = i[1],
				o = i[3],
				s = (a || o).toLowerCase()
			return t.type === "htmlInline" && !!(n.marks[s] || n.nodes[s])
		}
		return !1
	}
	function nD(e) {
		var t = e.type
		return Vr(["text", "strong", "emph", "strike", "image", "link", "code"], t)
	}
	function pj(e) {
		return (e == null ? void 0 : e.type) === "softbreak"
	}
	function am(e) {
		var t = e.type,
			n = e.literal,
			r = t === "htmlInline" && n.match(yp)
		if (r) {
			var i = r[1],
				a = r[3],
				o = i || a
			if (o) return Vr(["ul", "ol", "li"], o.toLowerCase())
		}
		return !1
	}
	function Gat(e) {
		var t = e.literal,
			n = /data-task/.test(t),
			r = /data-task-checked/.test(t)
		return { task: n, checked: r }
	}
	function hj(e) {
		for (var t = [], n = 1; n < arguments.length; n++) t[n - 1] = arguments[n]
		var r = document.createElement("div")
		r.innerHTML = Cd(e)
		var i = r.firstChild
		return t.map(function (a) {
			return i.getAttribute(a) || ""
		})
	}
	function Kat(e) {
		var t = {}
		return (
			Object.keys(e).forEach(function (n) {
				var r = n.split(", ")
				r.forEach(function (i) {
					var a = i.toLowerCase()
					t[a] = e[n]
				})
			}),
			t
		)
	}
	var Qat = {
			"b, strong": function (e, t, n) {
				var r = e.schema.marks.strong
				n ? e.openMark(r.create({ rawHTML: n })) : e.closeMark(r)
			},
			"i, em": function (e, t, n) {
				var r = e.schema.marks.emph
				n ? e.openMark(r.create({ rawHTML: n })) : e.closeMark(r)
			},
			"s, del": function (e, t, n) {
				var r = e.schema.marks.strike
				n ? e.openMark(r.create({ rawHTML: n })) : e.closeMark(r)
			},
			code: function (e, t, n) {
				var r = e.schema.marks.code
				n ? e.openMark(r.create({ rawHTML: n })) : e.closeMark(r)
			},
			a: function (e, t, n) {
				var r = t.literal,
					i = e.schema.marks.link
				if (n) {
					var a = hj(r, "href")[0]
					e.openMark(i.create({ linkUrl: a, rawHTML: n }))
				} else e.closeMark(i)
			},
			img: function (e, t, n) {
				var r = t.literal
				if (n) {
					var i = hj(r, "src", "alt"),
						a = i[0],
						o = i[1],
						s = e.schema.nodes.image
					e.addNode(s, me({ rawHTML: n, imageUrl: a }, o && { altText: o }))
				}
			},
			hr: function (e, t, n) {
				e.addNode(e.schema.nodes.thematicBreak, { rawHTML: n })
			},
			br: function (e, t) {
				var n = e.schema.nodes.paragraph,
					r = t.parent,
					i = t.prev,
					a = t.next
				;(r == null ? void 0 : r.type) === "paragraph"
					? (pj(i) && e.openNode(n), pj(a) ? e.closeNode() : a && (e.closeNode(), e.openNode(n)))
					: (r == null ? void 0 : r.type) === "tableCell" &&
					  (i && (nD(i) || tD(e, i)) && e.closeNode(), a && (nD(a) || tD(e, a)) && e.openNode(n))
			},
			pre: function (e, t, n) {
				var r,
					i,
					a = document.createElement("div")
				a.innerHTML = t.literal
				var o =
					(i = (r = a.firstChild) === null || r === void 0 ? void 0 : r.firstChild) === null ||
					i === void 0
						? void 0
						: i.textContent
				e.openNode(e.schema.nodes.codeBlock, { rawHTML: n }), e.addText(v1(o)), e.closeNode()
			},
			"ul, ol": function (e, t, n) {
				if (t.parent.type === "tableCell") {
					var r = e.schema.nodes,
						i = r.bulletList,
						a = r.orderedList,
						o = r.paragraph,
						s = n === "ul" ? i : a
					n
						? (t.prev && !am(t.prev) && e.closeNode(), e.openNode(s, { rawHTML: n }))
						: (e.closeNode(), t.next && !am(t.next) && e.openNode(o))
				}
			},
			li: function (e, t, n) {
				var r
				if (((r = t.parent) === null || r === void 0 ? void 0 : r.type) === "tableCell") {
					var i = e.schema.nodes,
						a = i.listItem,
						o = i.paragraph
					if (n) {
						var s = Gat(t)
						t.prev && !am(t.prev) && e.closeNode(),
							e.openNode(a, me({ rawHTML: n }, s)),
							t.next && !am(t.next) && e.openNode(o)
					} else t.prev && !am(t.prev) && e.closeNode(), e.closeNode()
				}
			},
		},
		Xat = Kat(Qat)
	function mj(e) {
		return e.type === "htmlInline" && P2.test(e.literal)
	}
	function kq(e) {
		Ds(e.childNodes).forEach(function (t) {
			if (cw(t)) {
				var n = t.nodeName.toLowerCase()
				t.setAttribute("data-raw-html", n), t.childNodes && kq(t)
			}
		})
	}
	var vj = {
		text: function (e, t) {
			e.addText(t.literal || "")
		},
		paragraph: function (e, t, n, r) {
			var i,
				a = n.entering
			if (a) {
				var o = e.schema.nodes.paragraph
				;((i = t.prev) === null || i === void 0 ? void 0 : i.type) === "paragraph" &&
					(e.openNode(o, r), e.closeNode()),
					e.openNode(o, r)
			} else e.closeNode()
		},
		heading: function (e, t, n, r) {
			var i = n.entering
			if (i) {
				var a = t,
					o = a.level,
					s = a.headingType
				e.openNode(e.schema.nodes.heading, me({ level: o, headingType: s }, r))
			} else e.closeNode()
		},
		codeBlock: function (e, t, n) {
			var r = e.schema.nodes.codeBlock,
				i = t,
				a = i.info,
				o = i.literal
			e.openNode(r, me({ language: a }, n)), e.addText(v1(o || "")), e.closeNode()
		},
		list: function (e, t, n, r) {
			var i = n.entering
			if (i) {
				var a = e.schema.nodes,
					o = a.bulletList,
					s = a.orderedList,
					l = t.listData,
					u = l.type,
					d = l.start
				u === "bullet" ? e.openNode(o, r) : e.openNode(s, me({ order: d }, r))
			} else e.closeNode()
		},
		item: function (e, t, n, r) {
			var i = n.entering,
				a = e.schema.nodes.listItem,
				o = t.listData,
				s = o.task,
				l = o.checked
			if (i) {
				var u = me(me(me({}, s && { task: s }), l && { checked: l }), r)
				e.openNode(a, u)
			} else e.closeNode()
		},
		blockQuote: function (e, t, n, r) {
			var i = n.entering
			i ? e.openNode(e.schema.nodes.blockQuote, r) : e.closeNode()
		},
		image: function (e, t, n, r) {
			var i = n.entering,
				a = n.skipChildren,
				o = e.schema.nodes.image,
				s = t,
				l = s.destination,
				u = s.firstChild
			i && a && a(), e.addNode(o, me(me({ imageUrl: l }, u && { altText: u.literal }), r))
		},
		thematicBreak: function (e, t, n, r) {
			e.addNode(e.schema.nodes.thematicBreak, r)
		},
		strong: function (e, t, n, r) {
			var i = n.entering,
				a = e.schema.marks.strong
			i ? e.openMark(a.create(r)) : e.closeMark(a)
		},
		emph: function (e, t, n, r) {
			var i = n.entering,
				a = e.schema.marks.emph
			i ? e.openMark(a.create(r)) : e.closeMark(a)
		},
		link: function (e, t, n, r) {
			var i = n.entering,
				a = e.schema.marks.link,
				o = t,
				s = o.destination,
				l = o.title
			if (i) {
				var u = me({ linkUrl: s, title: l }, r)
				e.openMark(a.create(u))
			} else e.closeMark(a)
		},
		softbreak: function (e, t) {
			if (t.parent.type === "paragraph") {
				var n = t.prev,
					r = t.next
				n && !mj(n) && e.closeNode(), r && !mj(r) && e.openNode(e.schema.nodes.paragraph)
			}
		},
		table: function (e, t, n, r) {
			var i = n.entering
			i ? e.openNode(e.schema.nodes.table, r) : e.closeNode()
		},
		tableHead: function (e, t, n, r) {
			var i = n.entering
			i ? e.openNode(e.schema.nodes.tableHead, r) : e.closeNode()
		},
		tableBody: function (e, t, n, r) {
			var i = n.entering
			i ? e.openNode(e.schema.nodes.tableBody, r) : e.closeNode()
		},
		tableRow: function (e, t, n, r) {
			var i = n.entering
			i ? e.openNode(e.schema.nodes.tableRow, r) : e.closeNode()
		},
		tableCell: function (e, t, n) {
			var r = n.entering
			if (!t.ignored) {
				var i = function (y) {
					return y && (nD(y) || tD(e, y))
				}
				if (r) {
					var a = e.schema.nodes,
						o = a.tableHeadCell,
						s = a.tableBodyCell,
						l = a.paragraph,
						u = t.parent.parent,
						d = u.type === "tableHead" ? o : s,
						p = u.parent,
						m = (p.columns[t.startIdx] || {}).align,
						v = me({}, t.attrs)
					m && (v.align = m), e.openNode(d, v), i(t.firstChild) && e.openNode(l)
				} else i(t.lastChild) && e.closeNode(), e.closeNode()
			}
		},
		strike: function (e, t, n, r) {
			var i = n.entering,
				a = e.schema.marks.strike
			i ? e.openMark(a.create(r)) : e.closeMark(a)
		},
		code: function (e, t, n, r) {
			var i = e.schema.marks.code
			e.openMark(i.create(r)), e.addText(v1(t.literal || "")), e.closeMark(i)
		},
		customBlock: function (e, t) {
			var n = e.schema.nodes,
				r = n.customBlock,
				i = n.paragraph,
				a = t,
				o = a.info,
				s = a.literal
			e.openNode(r, { info: o }),
				e.addText(v1(s || "")),
				e.closeNode(),
				t.next || (e.openNode(i), e.closeNode())
		},
		frontMatter: function (e, t) {
			e.openNode(e.schema.nodes.frontMatter), e.addText(t.literal), e.closeNode()
		},
		htmlInline: function (e, t) {
			var n = t.literal,
				r = n.match(yp),
				i = r[1],
				a = r[3],
				o = (i || a).toLowerCase(),
				s = e.schema.marks[o],
				l = Cd(n)
			if (s != null && s.spec.attrs.htmlInline)
				if (i) {
					var u = X2(l)
					e.openMark(s.create({ htmlAttrs: u }))
				} else e.closeMark(s)
			else {
				var d = Xat[o]
				d && d(e, t, i)
			}
		},
		htmlBlock: function (e, t) {
			var n = t.literal,
				r = document.createElement("div"),
				i = M1e.test(n)
			if (i) e.openNode(e.schema.nodes.htmlComment), e.addText(t.literal), e.closeNode()
			else {
				var a = n.match(yp),
					o = a[1],
					s = a[3],
					l = (o || s).toLowerCase(),
					u = e.schema.nodes[l],
					d = Cd(n)
				if (u != null && u.spec.attrs.htmlBlock) {
					var p = X2(d),
						m = rq(t, l)
					e.addNode(u, { htmlAttrs: p, childrenHTML: m })
				} else (r.innerHTML = d), kq(r), e.convertByDOMParser(r)
			}
		},
		customInline: function (e, t, n) {
			var r = n.entering,
				i = n.skipChildren,
				a = t,
				o = a.info,
				s = a.firstChild,
				l = e.schema
			if (o.indexOf("widget") !== -1 && r) {
				var u = GU(t)
				i(), e.addNode(l.nodes.widget, { info: o }, [l.text(WU(o, u))])
			} else {
				var d = "$$"
				r && (d += s ? o + " " : o), e.addText(d)
			}
		},
	}
	function Jat(e) {
		var t = Object.keys(e),
			n = me({}, vj),
			r = new sA({ gfm: !0, nodeId: !0, convertors: e }),
			i = r.getConvertors()
		return (
			t.forEach(function (a) {
				var o = vj[a]
				o &&
					!Vr(["htmlBlock", "htmlInline"], a) &&
					(n[a] = function (s, l, u) {
						u.origin = function () {
							return i[a](l, u, i)
						}
						var d = e[a](l, u),
							p
						if (d) {
							var m = Array.isArray(d) ? d[0] : d,
								v = m.attributes,
								y = m.classNames
							p = { htmlAttrs: v, classNames: y }
						}
						o(s, l, u, p)
					})
			}),
			n
		)
	}
	function Zat(e, t) {
		return e.isText && t.isText && tn.sameSet(e.marks, t.marks) ? e.withText(e.text + t.text) : !1
	}
	var eot = (function () {
		function e(t, n) {
			;(this.schema = t),
				(this.convertors = n),
				(this.stack = [{ type: this.schema.topNodeType, attrs: null, content: [] }]),
				(this.marks = tn.none)
		}
		return (
			(e.prototype.top = function () {
				return ni(this.stack)
			}),
			(e.prototype.push = function (t) {
				this.stack.length && this.top().content.push(t)
			}),
			(e.prototype.addText = function (t) {
				if (t) {
					var n = this.top().content,
						r = ni(n),
						i = this.schema.text(t, this.marks),
						a = r && Zat(r, i)
					a ? (n[n.length - 1] = a) : n.push(i)
				}
			}),
			(e.prototype.openMark = function (t) {
				this.marks = t.addToSet(this.marks)
			}),
			(e.prototype.closeMark = function (t) {
				this.marks = t.removeFromSet(this.marks)
			}),
			(e.prototype.addNode = function (t, n, r) {
				var i = t.createAndFill(n, r, this.marks)
				return i ? (this.push(i), i) : null
			}),
			(e.prototype.openNode = function (t, n) {
				this.stack.push({ type: t, attrs: n, content: [] })
			}),
			(e.prototype.closeNode = function () {
				this.marks.length && (this.marks = tn.none)
				var t = this.stack.pop(),
					n = t.type,
					r = t.attrs,
					i = t.content
				return this.addNode(n, r, i)
			}),
			(e.prototype.convertByDOMParser = function (t) {
				var n = this,
					r = md.fromSchema(this.schema).parse(t)
				r.content.forEach(function (i) {
					return n.push(i)
				})
			}),
			(e.prototype.closeUnmatchedHTMLInline = function (t, n) {
				var r
				if (!n && t.type !== "htmlInline")
					for (var i = this.stack.length - 1, a = i; a >= 0; a -= 1) {
						var o = this.stack[a]
						if (!((r = o.attrs) === null || r === void 0) && r.rawHTML)
							o.content.length ? this.closeNode() : this.stack.pop()
						else break
					}
			}),
			(e.prototype.convert = function (t, n) {
				for (
					var r = t.walker(),
						i = r.next(),
						a = function () {
							var s = i.node,
								l = i.entering,
								u = o.convertors[s.type],
								d = !1
							if (u) {
								var p = {
									entering: l,
									leaf: !f1e(s),
									getChildrenText: p1e,
									options: {
										gfm: !0,
										nodeId: !1,
										tagFilter: !1,
										softbreak: `
`,
									},
									skipChildren: function () {
										d = !0
									},
								}
								if (
									(o.closeUnmatchedHTMLInline(s, l),
									u(o, s, p),
									(n == null ? void 0 : n.node) === s)
								) {
									var m =
										o.stack.reduce(function (v, y) {
											return (
												v +
												y.content.reduce(function (b, x) {
													return b + x.nodeSize
												}, 0)
											)
										}, 0) + 1
									n.setMappedPos(m)
								}
							}
							d && (r.resumeAt(s, !1), r.next()), (i = r.next())
						},
						o = this;
					i;

				)
					a()
			}),
			(e.prototype.convertNode = function (t, n) {
				return this.convert(t, n), this.stack.length ? this.closeNode() : null
			}),
			e
		)
	})()
	function tot(e, t, n) {
		var r = n[0],
			i = n[1]
		e.write(r), e.convertInline(t), e.write(i)
	}
	function not(e, t, n) {
		var r = t.node,
			i = t.parent,
			a = n[0],
			o = n[1]
		;(e.stopNewline = !0),
			e.write(a),
			e.convertNode(r),
			e.write(o),
			(i == null ? void 0 : i.type.name) === "doc" && (e.closeBlock(r), (e.stopNewline = !1))
	}
	function rot(e, t) {
		var n = e.length,
			r = "",
			i = ""
		return (
			t === "left"
				? ((r = ":"), (n -= 1))
				: t === "right"
				? ((i = ":"), (n -= 1))
				: t === "center" && ((r = ":"), (i = ":"), (n -= 2)),
			"" + r + mb("-", Math.max(n, 3)) + i
		)
	}
	var rD = {
		text: function (e, t) {
			var n,
				r = t.node,
				i = (n = r.text) !== null && n !== void 0 ? n : ""
			;(r.marks || []).some(function (a) {
				return a.type.name === "link"
			})
				? e.text(vb(i), !1)
				: e.text(i)
		},
		paragraph: function (e, t) {
			var n = t.node,
				r = t.parent,
				i = t.index,
				a = i === void 0 ? 0 : i
			if (e.stopNewline) e.convertInline(n)
			else {
				var o = a === 0,
					s = !o && r.child(a - 1),
					l = s && s.childCount === 0,
					u = a < r.childCount - 1 && r.child(a + 1),
					d = u && u.type.name === "paragraph",
					p = n.childCount === 0
				if (p && l)
					e.write(`<br>
`)
				else if (p && !l && !o) {
					if ((r == null ? void 0 : r.type.name) === "listItem") {
						var m = e.getDelim()
						e.setDelim(""), e.write("<br>"), e.setDelim(m)
					}
					e.write(`
`)
				} else
					e.convertInline(n),
						d
							? e.write(`
`)
							: e.closeBlock(n)
			}
		},
		heading: function (e, t, n) {
			var r = t.node,
				i = n.delim,
				a = r.attrs.headingType
			a === "atx"
				? (e.write(i + " "), e.convertInline(r), e.closeBlock(r))
				: (e.convertInline(r), e.ensureNewLine(), e.write(i), e.closeBlock(r))
		},
		codeBlock: function (e, t, n) {
			var r = t.node,
				i = n.delim,
				a = n.text,
				o = i,
				s = o[0],
				l = o[1]
			e.write(s), e.ensureNewLine(), e.text(a, !1), e.ensureNewLine(), e.write(l), e.closeBlock(r)
		},
		blockQuote: function (e, t, n) {
			var r = t.node,
				i = t.parent,
				a = n.delim
			;(i == null ? void 0 : i.type.name) === r.type.name && e.flushClose(1),
				e.wrapBlock(a, null, r, function () {
					return e.convertNode(r)
				})
		},
		bulletList: function (e, t, n) {
			var r = t.node,
				i = n.delim
			e.convertList(r, mb(" ", 4), function () {
				return i + " "
			})
		},
		orderedList: function (e, t) {
			var n = t.node,
				r = n.attrs.order || 1
			e.convertList(n, mb(" ", 4), function (i) {
				var a = String(r + i)
				return a + ". "
			})
		},
		listItem: function (e, t) {
			var n = t.node,
				r = n.attrs,
				i = r.task,
				a = r.checked
			i && e.write("[" + (a ? "x" : " ") + "] "), e.convertNode(n)
		},
		image: function (e, t, n) {
			var r = n.attrs
			e.write(
				"![" + (r == null ? void 0 : r.altText) + "](" + (r == null ? void 0 : r.imageUrl) + ")",
			)
		},
		thematicBreak: function (e, t, n) {
			var r = t.node,
				i = n.delim
			e.write(i), e.closeBlock(r)
		},
		table: function (e, t) {
			var n = t.node
			e.convertNode(n), e.closeBlock(n)
		},
		tableHead: function (e, t, n) {
			var r = t.node,
				i = n.delim,
				a = r.firstChild
			e.convertNode(r)
			var o = i ?? ""
			!i &&
				a &&
				a.forEach(function (s) {
					var l = s.textContent,
						u = s.attrs,
						d = rot(l, u.align)
					o += "| " + d + " "
				}),
				e.write(o + "|"),
				e.ensureNewLine()
		},
		tableBody: function (e, t) {
			var n = t.node
			e.convertNode(n)
		},
		tableRow: function (e, t) {
			var n = t.node
			e.convertNode(n), e.write("|"), e.ensureNewLine()
		},
		tableHeadCell: function (e, t, n) {
			var r = t.node,
				i = n.delim,
				a = i === void 0 ? "| " : i
			e.write(a), e.convertTableCell(r), e.write(" ")
		},
		tableBodyCell: function (e, t, n) {
			var r = t.node,
				i = n.delim,
				a = i === void 0 ? "| " : i
			e.write(a), e.convertTableCell(r), e.write(" ")
		},
		customBlock: function (e, t, n) {
			var r = t.node,
				i = n.delim,
				a = n.text,
				o = i,
				s = o[0],
				l = o[1]
			e.write(s), e.ensureNewLine(), e.text(a, !1), e.ensureNewLine(), e.write(l), e.closeBlock(r)
		},
		frontMatter: function (e, t, n) {
			var r = t.node,
				i = n.text
			e.text(i, !1), e.closeBlock(r)
		},
		widget: function (e, t, n) {
			var r = n.text
			e.write(r)
		},
		html: function (e, t, n) {
			var r = t.node,
				i = n.text
			e.write(i), r.attrs.htmlBlock && e.closeBlock(r)
		},
		htmlComment: function (e, t, n) {
			var r = t.node,
				i = n.text
			e.write(i), e.closeBlock(r)
		},
	}
	function iot(e, t) {
		var n = t.state,
			r = t.nodeInfo,
			i = t.params,
			a = i.rawHTML
		a
			? yd(e, ["heading", "codeBlock"]) > -1
				? tot(n, r.node, a)
				: yd(e, ["image", "thematicBreak"]) > -1
				? n.write(a)
				: not(n, r, a)
			: rD[e](n, r, i)
	}
	function gj(e, t) {
		var n = e.text,
			r = /`+/g,
			i = 0
		if (e.isText && n) for (var a = r.exec(n); a; ) (i = Math.max(i, a[0].length)), (a = r.exec(n))
		for (var o = i > 0 && t > 0 ? " `" : "`", s = 0; s < i; s += 1) o += "`"
		return i > 0 && t < 0 && (o += " "), o
	}
	function uo(e) {
		return e ? ["<" + e + ">", "</" + e + ">"] : null
	}
	function om(e) {
		return e ? "<" + e + ">" : null
	}
	function sm(e) {
		return e ? "</" + e + ">" : null
	}
	var lm = {
			heading: function (e) {
				var t = e.node,
					n = t.attrs,
					r = n.level,
					i = mb("#", r)
				return (
					n.headingType === "setext" && (i = r === 1 ? "===" : "---"),
					{ delim: i, rawHTML: uo(n.rawHTML) }
				)
			},
			codeBlock: function (e) {
				var t = e.node,
					n = t,
					r = n.attrs,
					i = n.textContent
				return { delim: ["```" + (r.language || ""), "```"], rawHTML: uo(r.rawHTML), text: i }
			},
			blockQuote: function (e) {
				var t = e.node
				return { delim: "> ", rawHTML: uo(t.attrs.rawHTML) }
			},
			bulletList: function (e, t) {
				var n = e.node,
					r = t.inTable,
					i = n.attrs.rawHTML
				return r && (i = i || "ul"), { delim: "*", rawHTML: uo(i) }
			},
			orderedList: function (e, t) {
				var n = e.node,
					r = t.inTable,
					i = n.attrs.rawHTML
				return r && (i = i || "ol"), { rawHTML: uo(i) }
			},
			listItem: function (e, t) {
				var n = e.node,
					r = t.inTable,
					i = n.attrs,
					a = i.task,
					o = i.checked,
					s = n.attrs.rawHTML
				r && (s = s || "li")
				var l = a ? ' class="task-list-item' + (o ? " checked" : "") + '"' : "",
					u = a ? " data-task" + (o ? " data-task-checked" : "") : ""
				return { rawHTML: s ? ["<" + s + l + u + ">", "</" + s + ">"] : null }
			},
			table: function (e) {
				var t = e.node
				return { rawHTML: uo(t.attrs.rawHTML) }
			},
			tableHead: function (e) {
				var t = e.node
				return { rawHTML: uo(t.attrs.rawHTML) }
			},
			tableBody: function (e) {
				var t = e.node
				return { rawHTML: uo(t.attrs.rawHTML) }
			},
			tableRow: function (e) {
				var t = e.node
				return { rawHTML: uo(t.attrs.rawHTML) }
			},
			tableHeadCell: function (e) {
				var t = e.node
				return { rawHTML: uo(t.attrs.rawHTML) }
			},
			tableBodyCell: function (e) {
				var t = e.node
				return { rawHTML: uo(t.attrs.rawHTML) }
			},
			image: function (e) {
				var t = e.node,
					n = t.attrs,
					r = n.rawHTML,
					i = n.altText,
					a = n.imageUrl.replace(/&amp;/g, "&"),
					o = i ? ' alt="' + Bf(i) + '"' : ""
				return {
					rawHTML: r ? "<" + r + ' src="' + Bf(a) + '"' + o + ">" : null,
					attrs: { altText: vb(i || ""), imageUrl: a },
				}
			},
			thematicBreak: function (e) {
				var t = e.node
				return { delim: "***", rawHTML: om(t.attrs.rawHTML) }
			},
			customBlock: function (e) {
				var t = e.node,
					n = t,
					r = n.attrs,
					i = n.textContent
				return { delim: ["$$" + r.info, "$$"], text: i }
			},
			frontMatter: function (e) {
				var t = e.node
				return { text: t.textContent }
			},
			widget: function (e) {
				var t = e.node
				return { text: t.textContent }
			},
			strong: function (e, t) {
				var n = e.node,
					r = t.entering,
					i = n.attrs.rawHTML
				return { delim: "**", rawHTML: r ? om(i) : sm(i) }
			},
			emph: function (e, t) {
				var n = e.node,
					r = t.entering,
					i = n.attrs.rawHTML
				return { delim: "*", rawHTML: r ? om(i) : sm(i) }
			},
			strike: function (e, t) {
				var n = e.node,
					r = t.entering,
					i = n.attrs.rawHTML
				return { delim: "~~", rawHTML: r ? om(i) : sm(i) }
			},
			link: function (e, t) {
				var n = e.node,
					r = t.entering,
					i = n.attrs,
					a = i.title,
					o = i.rawHTML,
					s = i.linkUrl.replace(/&amp;/g, "&"),
					l = a ? ' title="' + Bf(a) + '"' : ""
				return r
					? { delim: "[", rawHTML: o ? "<" + o + ' href="' + Bf(s) + '"' + l + ">" : null }
					: { delim: "](" + s + (a ? " " + t1e(vb(a)) : "") + ")", rawHTML: sm(o) }
			},
			code: function (e, t) {
				var n = e.node,
					r = e.parent,
					i = e.index,
					a = i === void 0 ? 0 : i,
					o = t.entering,
					s = o ? gj(r.child(a), -1) : gj(r.child(a - 1), 1),
					l = o ? om(n.attrs.rawHTML) : sm(n.attrs.rawHTML)
				return { delim: s, rawHTML: l }
			},
			htmlComment: function (e) {
				var t = e.node
				return { text: t.textContent }
			},
			html: function (e, t) {
				var n = e.node,
					r = t.entering,
					i = n.type.name,
					a = n.attrs.htmlAttrs,
					o = "<" + i,
					s = "</" + i + ">"
				return (
					Object.keys(a).forEach(function (l) {
						o += " " + l + '="' + a[l].replace(/"/g, "'") + '"'
					}),
					(o += ">"),
					n.attrs.htmlInline ? { rawHTML: r ? o : s } : { text: "" + o + n.attrs.childrenHTML + s }
				)
			},
		},
		yj = {
			strong: { mixable: !0, removedEnclosingWhitespace: !0 },
			emph: { mixable: !0, removedEnclosingWhitespace: !0 },
			strike: { mixable: !0, removedEnclosingWhitespace: !0 },
			code: { escape: !1 },
			link: null,
			html: null,
		}
	function aot(e) {
		var t = {},
			n = Object.keys(rD)
		return (
			n.forEach(function (r) {
				t[r] = function (i, a) {
					var o = rD[r]
					if (o) {
						var s = e[r],
							l = s ? s(a, { inTable: i.inTable }) : {}
						iot(r, { state: i, nodeInfo: a, params: l })
					}
				}
			}),
			t
		)
	}
	function oot(e) {
		var t = {},
			n = Object.keys(yj)
		return (
			n.forEach(function (r) {
				t[r] = function (i, a) {
					var o = yj[r],
						s = e[r],
						l = s && i && !Oo(a),
						u = l ? s(i, { entering: a }) : {}
					return me(me({}, u), o)
				}
			}),
			t
		)
	}
	function sot(e) {
		var t = Object.keys(e)
		t.forEach(function (i) {
			var a = lm[i],
				o = e[i]
			a
				? (lm[i] = function (s, l) {
						return (
							(l.origin = function () {
								return a(s, l)
							}),
							o(s, l)
						)
				  })
				: (lm[i] = o),
				delete e[i]
		})
		var n = aot(lm),
			r = oot(lm)
		return { nodeTypeConvertors: n, markTypeConvertors: r }
	}
	var lot = (function () {
			function e(t) {
				var n = t.nodeTypeConvertors,
					r = t.markTypeConvertors
				;(this.nodeTypeConvertors = n),
					(this.markTypeConvertors = r),
					(this.delim = ""),
					(this.result = ""),
					(this.closed = !1),
					(this.tightList = !1),
					(this.stopNewline = !1),
					(this.inTable = !1)
			}
			return (
				(e.prototype.getMarkConvertor = function (t) {
					var n = t.attrs.htmlInline ? "html" : t.type.name
					return this.markTypeConvertors[n]
				}),
				(e.prototype.isInBlank = function () {
					return /(^|\n)$/.test(this.result)
				}),
				(e.prototype.markText = function (t, n, r, i) {
					var a = this.getMarkConvertor(t)
					if (a) {
						var o = a({ node: t, parent: r, index: i }, n),
							s = o.delim,
							l = o.rawHTML
						return l || s
					}
					return ""
				}),
				(e.prototype.setDelim = function (t) {
					this.delim = t
				}),
				(e.prototype.getDelim = function () {
					return this.delim
				}),
				(e.prototype.flushClose = function (t) {
					if (!this.stopNewline && this.closed) {
						if (
							(this.isInBlank() ||
								(this.result += `
`),
							t || (t = 2),
							t > 1)
						) {
							var n = this.delim,
								r = /\s+$/.exec(n)
							r && (n = n.slice(0, n.length - r[0].length))
							for (var i = 1; i < t; i += 1)
								this.result +=
									n +
									`
`
						}
						this.closed = !1
					}
				}),
				(e.prototype.wrapBlock = function (t, n, r, i) {
					var a = this.getDelim()
					this.write(n || t),
						this.setDelim(this.getDelim() + t),
						i(),
						this.setDelim(a),
						this.closeBlock(r)
				}),
				(e.prototype.ensureNewLine = function () {
					this.isInBlank() ||
						(this.result += `
`)
				}),
				(e.prototype.write = function (t) {
					t === void 0 && (t = ""),
						this.flushClose(),
						this.delim && this.isInBlank() && (this.result += this.delim),
						t && (this.result += t)
				}),
				(e.prototype.closeBlock = function (t) {
					this.closed = t
				}),
				(e.prototype.text = function (t, n) {
					n === void 0 && (n = !0)
					for (
						var r = t.split(`
`),
							i = 0;
						i < r.length;
						i += 1
					)
						this.write(),
							(this.result += n ? e1e(r[i]) : r[i]),
							i !== r.length - 1 &&
								(this.result += `
`)
				}),
				(e.prototype.convertBlock = function (t, n, r) {
					var i = t.type.name,
						a = this.nodeTypeConvertors[i],
						o = { node: t, parent: n, index: r }
					t.attrs.htmlBlock ? this.nodeTypeConvertors.html(this, o) : a && a(this, o)
				}),
				(e.prototype.convertInline = function (t) {
					var n = this,
						r = [],
						i = "",
						a = function (o, s, l) {
							var u = o ? o.marks : [],
								d = i
							i = ""
							var p =
								o &&
								o.isText &&
								u.some(function (L) {
									var B = n.getMarkConvertor(L),
										z = B && B()
									return z && z.removedEnclosingWhitespace
								})
							if (p && o && o.text) {
								var m = /^(\s*)(.*?)(\s*)$/m.exec(o.text),
									v = m[1],
									y = m[2],
									b = m[3]
								;(d += v), (i = b), (v || b) && ((o = y ? o.withText(y) : null), o || (u = r))
							}
							for (
								var x = u.length && ni(u),
									E = x && n.getMarkConvertor(x),
									T = E && E(),
									C = T && T.escape === !1,
									D = u.length - (C ? 1 : 0),
									O = 0;
								O < D;
								O += 1
							) {
								var y = u[O]
								if (T && !T.mixable) break
								for (var A = 0; A < r.length; A += 1) {
									var N = r[A]
									if (T && !T.mixable) break
									if (y.eq(N)) {
										O > A
											? (u = u
													.slice(0, A)
													.concat(y)
													.concat(u.slice(A, O))
													.concat(u.slice(O + 1, D)))
											: A > O &&
											  (u = u
													.slice(0, O)
													.concat(u.slice(O + 1, A))
													.concat(y)
													.concat(u.slice(A, D)))
										break
									}
								}
							}
							for (var I = 0; I < Math.min(r.length, D) && u[I].eq(r[I]); ) I += 1
							for (; I < r.length; ) {
								var P = r.pop()
								P && n.text(n.markText(P, !1, t, l), !1)
							}
							if ((d && n.text(d), o)) {
								for (; r.length < D; ) {
									var y = u[r.length]
									r.push(y), n.text(n.markText(y, !0, t, l), !1)
								}
								C && o.isText
									? n.text(n.markText(x, !0, t, l) + o.text + n.markText(x, !1, t, l + 1), !1)
									: n.convertBlock(o, t, l)
							}
						}
					t.forEach(a), a(null, null, t.childCount)
				}),
				(e.prototype.convertList = function (t, n, r) {
					var i = this,
						a
					this.closed && this.closed.type === t.type
						? this.flushClose(3)
						: this.tightList && this.flushClose(1)
					var o = (a = t.attrs.tight) !== null && a !== void 0 ? a : !0,
						s = this.tightList
					;(this.tightList = o),
						t.forEach(function (l, u, d) {
							d && o && i.flushClose(1),
								i.wrapBlock(n, r(d), t, function () {
									return i.convertBlock(l, t, d)
								})
						}),
						(this.tightList = s)
				}),
				(e.prototype.convertTableCell = function (t) {
					var n = this
					;(this.stopNewline = !0),
						(this.inTable = !0),
						t.forEach(function (r, i, a) {
							if (Vr(["bulletList", "orderedList"], r.type.name))
								n.convertBlock(r, t, a), (n.closed = !1)
							else if ((n.convertInline(r), a < t.childCount - 1)) {
								var o = t.child(a + 1)
								o.type.name === "paragraph" && n.write("<br>")
							}
						}),
						(this.stopNewline = !1),
						(this.inTable = !1)
				}),
				(e.prototype.convertNode = function (t, n) {
					var r = this
					return (
						t.forEach(function (i, a, o) {
							if ((r.convertBlock(i, t, o), (n == null ? void 0 : n.node) === i)) {
								var s = r.result.split(`
`)
								n.setMappedPos([s.length, ni(s).length + 1])
							}
						}),
						this.result
					)
				}),
				e
			)
		})(),
		uot = (function () {
			function e(t, n, r, i) {
				var a = this
				;(this.setMappedPos = function (o) {
					a.mappedPosWhenConverting = o
				}),
					(this.schema = t),
					(this.eventEmitter = i),
					(this.focusedNode = null),
					(this.mappedPosWhenConverting = null),
					(this.toWwConvertors = Jat(r)),
					(this.toMdConvertors = sot(n || {})),
					this.eventEmitter.listen("setFocusedNode", function (o) {
						return (a.focusedNode = o)
					})
			}
			return (
				(e.prototype.getMappedPos = function () {
					return this.mappedPosWhenConverting
				}),
				(e.prototype.getInfoForPosSync = function () {
					return { node: this.focusedNode, setMappedPos: this.setMappedPos }
				}),
				(e.prototype.toWysiwygModel = function (t) {
					var n = new eot(this.schema, this.toWwConvertors)
					return n.convertNode(t, this.getInfoForPosSync())
				}),
				(e.prototype.toMarkdownText = function (t) {
					var n = new lot(this.toMdConvertors),
						r = n.convertNode(t, this.getInfoForPosSync())
					return (r = this.eventEmitter.emitReduce("beforeConvertWysiwygToMarkdown", r)), r
				}),
				e
			)
		})()
	function cot(e) {
		var t = e.plugin,
			n = e.eventEmitter,
			r = e.usageStatistics,
			i = e.instance,
			a = { Plugin: Ki, PluginKey: dg, Selection: _t, TextSelection: jt },
			o = { Decoration: $i, DecorationSet: mr },
			s = { Fragment: ke },
			l = { InputRule: PU, inputRules: jU, undoInputRule: Q0e },
			u = { keymap: _v },
			d = {
				eventEmitter: n,
				usageStatistics: r,
				instance: i,
				pmState: a,
				pmView: o,
				pmModel: s,
				pmRules: l,
				pmKeymap: u,
				i18n: yt,
			}
		if (th(t)) {
			var p = t[0],
				m = t[1],
				v = m === void 0 ? {} : m
			return p(d, v)
		}
		return t(d)
	}
	function Sq(e) {
		var t = e.plugins,
			n = e.eventEmitter,
			r = e.usageStatistics,
			i = e.instance
		return (
			n.listen("mixinTableOffsetMapPrototype", Urt),
			(t ?? []).reduce(
				function (a, o) {
					var s = cot({ plugin: o, eventEmitter: n, usageStatistics: r, instance: i })
					if (!s) throw new Error("The return value of the executed plugin is empty.")
					var l = s.markdownParsers,
						u = s.toHTMLRenderers,
						d = s.toMarkdownRenderers,
						p = s.markdownPlugins,
						m = s.wysiwygPlugins,
						v = s.wysiwygNodeViews,
						y = s.markdownCommands,
						b = s.wysiwygCommands,
						x = s.toolbarItems
					return (
						u && (a.toHTMLRenderers = gb(a.toHTMLRenderers, u)),
						d && (a.toMarkdownRenderers = gb(a.toMarkdownRenderers, d)),
						p && (a.mdPlugins = a.mdPlugins.concat(p)),
						m && (a.wwPlugins = a.wwPlugins.concat(m)),
						v && (a.wwNodeViews = me(me({}, a.wwNodeViews), v)),
						y && (a.mdCommands = me(me({}, a.mdCommands), y)),
						b && (a.wwCommands = me(me({}, a.wwCommands), b)),
						x && (a.toolbarItems = a.toolbarItems.concat(x)),
						l && (a.markdownParsers = me(me({}, a.markdownParsers), l)),
						a
					)
				},
				{
					toHTMLRenderers: {},
					toMarkdownRenderers: {},
					mdPlugins: [],
					wwPlugins: [],
					wwNodeViews: {},
					mdCommands: {},
					wwCommands: {},
					toolbarItems: [],
					markdownParsers: {},
				},
			)
		)
	}
	var dot = "data-task",
		fot = "data-task-disabled",
		pot = "checked"
	function hot(e) {
		;["htmlBlock", "htmlInline"].forEach(function (t) {
			e[t] &&
				Object.keys(e[t]).forEach(function (n) {
					return nq(n)
				})
		})
	}
	var Dq = (function () {
		function e(t) {
			var n = this
			;(this.options = jO(
				{
					linkAttributes: null,
					extendedAutolinks: !1,
					customHTMLRenderer: null,
					referenceDefinition: !1,
					customHTMLSanitizer: null,
					frontMatter: !1,
					usageStatistics: !0,
					theme: "light",
				},
				t,
			)),
				(this.eventEmitter = new Tq())
			var r = zU(this.options.linkAttributes),
				i =
					Sq({
						plugins: this.options.plugins,
						eventEmitter: this.eventEmitter,
						usageStatistics: this.options.usageStatistics,
						instance: this,
					}) || {},
				a = i.toHTMLRenderers,
				o = i.markdownParsers,
				s = this.options,
				l = s.customHTMLRenderer,
				u = s.extendedAutolinks,
				d = s.referenceDefinition,
				p = s.frontMatter,
				m = s.customHTMLSanitizer,
				v = {
					linkAttributes: r,
					customHTMLRenderer: me(me({}, a), l),
					extendedAutolinks: u,
					referenceDefinition: d,
					frontMatter: p,
					sanitizer: m || Cd,
				}
			hot(v.customHTMLRenderer),
				this.options.events &&
					mp(this.options.events, function (C, D) {
						n.on(D, C)
					})
			var y = this.options,
				b = y.el,
				x = y.initialValue,
				E = y.theme,
				T = b.innerHTML
			E !== "light" && b.classList.add(Qe(E)),
				(b.innerHTML = ""),
				(this.toastMark = new Jz("", {
					disallowedHtmlBlockTags: ["br", "img"],
					extendedAutolinks: u,
					referenceDefinition: d,
					disallowDeepHeading: !0,
					frontMatter: p,
					customParser: o,
				})),
				(this.preview = new aq(this.eventEmitter, me(me({}, v), { isViewer: !0 }))),
				xz(this.preview.previewContent, "mousedown", this.toggleTask.bind(this)),
				x ? this.setMarkdown(x) : T && this.preview.setHTML(T),
				b.appendChild(this.preview.previewContent),
				this.eventEmitter.emit("load", this)
		}
		return (
			(e.prototype.toggleTask = function (t) {
				var n = t.target,
					r = getComputedStyle(n, ":before")
				!n.hasAttribute(fot) &&
					n.hasAttribute(dot) &&
					WO(r, t.offsetX, t.offsetY) &&
					(YO(n, pot), this.eventEmitter.emit("change", { source: "viewer", date: t }))
			}),
			(e.prototype.setMarkdown = function (t) {
				var n = this.toastMark.getLineTexts(),
					r = n.length,
					i = ni(n),
					a = [r, i.length + 1],
					o = this.toastMark.editMarkdown([1, 1], a, t || "")
				this.eventEmitter.emit("updatePreview", o)
			}),
			(e.prototype.on = function (t, n) {
				this.eventEmitter.listen(t, n)
			}),
			(e.prototype.off = function (t) {
				this.eventEmitter.removeEventHandler(t)
			}),
			(e.prototype.addHook = function (t, n) {
				this.eventEmitter.removeEventHandler(t), this.eventEmitter.listen(t, n)
			}),
			(e.prototype.destroy = function () {
				bz(this.preview.el, "mousedown", this.toggleTask.bind(this)),
					this.preview.destroy(),
					this.eventEmitter.emit("destroy")
			}),
			(e.prototype.isViewer = function () {
				return !0
			}),
			(e.prototype.isMarkdownMode = function () {
				return !1
			}),
			(e.prototype.isWysiwygMode = function () {
				return !1
			}),
			e
		)
	})()
	function g1(e) {
		return e instanceof Tu
	}
	function _q(e) {
		var t = [
			"document",
			"blockQuote",
			"bulletList",
			"orderedList",
			"listItem",
			"paragraph",
			"heading",
			"emph",
			"strong",
			"strike",
			"link",
			"image",
			"table",
			"tableHead",
			"tableBody",
			"tableRow",
			"tableHeadCell",
			"tableBodyCell",
		]
		return Vr(t, e)
	}
	function mot(e) {
		var t = e.attrs,
			n = e.type,
			r = n.name,
			i = { type: r, wysiwygNode: !0, literal: !_q(r) && g1(e) ? e.textContent : null },
			a = {
				heading: { level: t.level },
				link: { destination: t.linkUrl, title: t.title },
				image: { destination: t.imageUrl },
				codeBlock: { info: t.language },
				bulletList: { type: "list", listData: { type: "bullet" } },
				orderedList: { type: "list", listData: { type: "ordered", start: t.order } },
				listItem: { type: "item", listData: { task: t.task, checked: t.checked } },
				tableHeadCell: { type: "tableCell", cellType: "head", align: t.align },
				tableBodyCell: { type: "tableCell", cellType: "body", align: t.align },
				customBlock: { info: t.info },
			},
			o = a[r],
			s = me(me({}, i), o),
			l = e.attrs,
			u = l.htmlAttrs,
			d = l.childrenHTML
		return u ? me(me({}, s), { attrs: u, childrenHTML: d }) : s
	}
	var vot = {
			openTag: function (e, t) {
				var n = e,
					r = n.tagName,
					i = n.classNames,
					a = n.attributes,
					o = document.createElement(r),
					s = {}
				i && (o.className = i.join(" ")), a && (s = me(me({}, s), a)), KO(s, o), t.push(o)
			},
			closeTag: function (e, t) {
				if (t.length > 1) {
					var n = t.pop()
					ni(t).appendChild(n)
				}
			},
			html: function (e, t) {
				ni(t).insertAdjacentHTML("beforeend", e.content)
			},
			text: function (e, t) {
				var n = document.createTextNode(e.content)
				ni(t).appendChild(n)
			},
		},
		got = (function () {
			function e(t, n) {
				var r = lA(t, n),
					i = me(me({}, n.htmlBlock), n.htmlInline)
				;(this.customConvertorKeys = Object.keys(n).concat(Object.keys(i))),
					(this.renderer = new sA({ gfm: !0, convertors: me(me({}, r), i) })),
					(this.convertors = this.renderer.getConvertors())
			}
			return (
				(e.prototype.generateTokens = function (t) {
					var n = mot(t),
						r = {
							entering: !0,
							leaf: g1(t) ? t.isLeaf : !1,
							options: this.renderer.getOptions(),
							getChildrenText: function () {
								return g1(t) ? t.textContent : ""
							},
							skipChildren: function () {
								return !1
							},
						},
						i = this.convertors[t.type.name],
						a = i(n, r, this.convertors),
						o = th(a) ? a : [a]
					return (
						(_q(t.type.name) || t.attrs.htmlInline) &&
							((r.entering = !1),
							o.push({ type: "text", content: g1(t) ? t.textContent : "" }),
							(o = o.concat(i(n, r, this.convertors)))),
						o
					)
				}),
				(e.prototype.toDOMNode = function (t) {
					var n = this.generateTokens(t),
						r = []
					return (
						n.forEach(function (i) {
							return vot[i.type](i, r)
						}),
						r[0]
					)
				}),
				(e.prototype.getToDOMNode = function (t) {
					return Vr(this.customConvertorKeys, t) ? this.toDOMNode.bind(this) : null
				}),
				e
			)
		})(),
		yot = 100,
		bot = 15,
		hy = null,
		jk = null
	function bj(e, t) {
		var n = t.syncScrollTop,
			r = t.releaseEventBlock
		jk && clearTimeout(jk),
			n(e),
			(jk = setTimeout(function () {
				r()
			}, bot))
	}
	function xot(e, t, n) {
		var r = t - e,
			i = Date.now(),
			a = function () {
				var o = Date.now(),
					s = (o - i) / yot,
					l
				hy && clearTimeout(hy),
					s < 1
						? ((l = e + r * Math.cos(((1 - s) * Math.PI) / 2)),
						  bj(Math.ceil(l), n),
						  (hy = setTimeout(a, 1)))
						: (bj(t, n), (hy = null))
			}
		a()
	}
	var wot = 18,
		Eot = (function () {
			function e(t, n, r) {
				;(this.latestEditorScrollTop = null),
					(this.latestPreviewScrollTop = null),
					(this.blockedScroll = null),
					(this.active = !0),
					(this.timer = null)
				var i = n.previewContent,
					a = n.el
				;(this.previewRoot = i),
					(this.previewEl = a),
					(this.mdEditor = t),
					(this.editorView = t.view),
					(this.toastMark = t.getToastMark()),
					(this.eventEmitter = r),
					this.addScrollSyncEvent()
			}
			return (
				(e.prototype.addScrollSyncEvent = function () {
					var t = this
					this.eventEmitter.listen("afterPreviewRender", function () {
						t.clearTimer(),
							(t.timer = setTimeout(function () {
								t.syncPreviewScrollTop(!0)
							}, 200))
					}),
						this.eventEmitter.listen("scroll", function (n, r) {
							t.active &&
								(n === "editor" && t.blockedScroll !== "editor"
									? t.syncPreviewScrollTop()
									: n === "preview" && t.blockedScroll !== "preview" && t.syncEditorScrollTop(r))
						}),
						this.eventEmitter.listen("toggleScrollSync", function (n) {
							t.active = n
						})
				}),
				(e.prototype.getMdNodeAtPos = function (t, n) {
					var r = t.content.findIndex(n.pos),
						i = r.index
					return this.toastMark.findFirstNodeAtLine(i + 1)
				}),
				(e.prototype.getScrollTopByCaretPos = function () {
					var t = this.mdEditor.getSelection(),
						n = this.toastMark.findFirstNodeAtLine(t[0][0]),
						r = this.previewEl.clientHeight,
						i = Ik(this.previewRoot, n).el,
						a = Db(i, this.previewRoot) || i.offsetTop,
						o = i.clientHeight,
						s = a + o - r * 0.5
					this.latestEditorScrollTop = null
					var l = i.getBoundingClientRect().top - this.previewEl.getBoundingClientRect().top
					return l < r ? null : s
				}),
				(e.prototype.syncPreviewScrollTop = function (t) {
					t === void 0 && (t = !1)
					var n = this,
						r = n.editorView,
						i = n.previewEl,
						a = n.previewRoot,
						o = r.dom.getBoundingClientRect(),
						s = o.left,
						l = o.top,
						u = r.posAtCoords({ left: s, top: l }),
						d = r.state.doc,
						p = this.getMdNodeAtPos(d, u)
					if (!(!p || a1e(p))) {
						var m = i.scrollTop,
							v = r.dom,
							y = v.scrollTop,
							b = v.scrollHeight,
							x = v.clientHeight,
							E = v.children,
							T = b - y <= x + wot,
							C = T ? i.scrollHeight : 0
						if (y && !T) {
							if (t) {
								var D = this.getScrollTopByCaretPos()
								if (!D) return
								C = D
							} else {
								var O = Ik(this.previewRoot, p),
									A = O.el,
									N = O.mdNode,
									I = ij(d, N, E),
									P = I.height,
									L = I.rect,
									B = Db(A, a) || A.offsetTop,
									z = A.clientHeight,
									V = l > L.top ? Math.min((l - L.top) / P, 1) : 0
								C = B + z * V
							}
							;(C = this.getResolvedScrollTop("editor", y, C, m)), (this.latestEditorScrollTop = y)
						}
						C !== m && this.run("editor", C, m)
					}
				}),
				(e.prototype.syncEditorScrollTop = function (t) {
					var n = this,
						r = n.toastMark,
						i = n.editorView,
						a = n.previewRoot,
						o = n.previewEl,
						s = i.dom,
						l = i.state,
						u = o.scrollTop,
						d = o.clientHeight,
						p = o.scrollHeight,
						m = p - u <= d,
						v = s.scrollTop,
						y = m ? s.scrollHeight : 0
					if (u && t && !m) {
						if (((t = yrt(t, a)), !t.getAttribute("data-nodeid"))) return
						var b = s.children,
							x = Number(t.getAttribute("data-nodeid")),
							E = Ik(this.previewRoot, r.findNodeById(x)),
							T = E.mdNode,
							C = E.el,
							D = hg(T)
						y = b[D - 1].offsetTop
						var O = ij(l.doc, T, b).height,
							A = Srt(C, a, x),
							N = A.nodeHeight,
							I = A.offsetTop
						;(y += xrt(u, I, N, O)),
							(y = this.getResolvedScrollTop("preview", u, y, v)),
							(this.latestPreviewScrollTop = u)
					}
					y !== v && this.run("preview", y, v)
				}),
				(e.prototype.getResolvedScrollTop = function (t, n, r, i) {
					var a = t === "editor" ? this.latestEditorScrollTop : this.latestPreviewScrollTop
					return a === null ? r : a < n ? Math.max(r, i) : Math.min(r, i)
				}),
				(e.prototype.run = function (t, n, r) {
					var i = this,
						a
					t === "editor"
						? ((a = this.previewEl), (this.blockedScroll = "preview"))
						: ((a = this.editorView.dom), (this.blockedScroll = "editor"))
					var o = {
						syncScrollTop: function (s) {
							return (a.scrollTop = s)
						},
						releaseEventBlock: function () {
							return (i.blockedScroll = null)
						},
					}
					xot(r, n, o)
				}),
				(e.prototype.clearTimer = function () {
					this.timer && (clearTimeout(this.timer), (this.timer = null))
				}),
				(e.prototype.destroy = function () {
					this.clearTimer(),
						this.eventEmitter.removeEventHandler("scroll"),
						this.eventEmitter.removeEventHandler("afterPreviewRender")
				}),
				e
			)
		})(),
		Cot = {
			getPopupInitialValues: function (e, t) {
				var n = t.popupName
				return n === "link" ? { linkText: e.getSelectedText() } : {}
			},
		}
	function Tot(e) {
		e.eventEmitter.listen("query", function (t, n) {
			return Cot[t](e, n)
		})
	}
	var Oq = (function () {
		function e(t) {
			var n = this
			;(this.initialHTML = t.el.innerHTML),
				(t.el.innerHTML = ""),
				(this.options = jO(
					{
						previewStyle: "tab",
						previewHighlight: !0,
						initialEditType: "markdown",
						height: "300px",
						minHeight: "200px",
						language: "en-US",
						useCommandShortcut: !0,
						usageStatistics: !0,
						toolbarItems: [
							["heading", "bold", "italic", "strike"],
							["hr", "quote"],
							["ul", "ol", "task", "indent", "outdent"],
							["table", "image", "link"],
							["code", "codeblock"],
							["scrollSync"],
						],
						hideModeSwitch: !1,
						linkAttributes: null,
						extendedAutolinks: !1,
						customHTMLRenderer: null,
						customMarkdownRenderer: null,
						referenceDefinition: !1,
						customHTMLSanitizer: null,
						frontMatter: !1,
						widgetRules: [],
						theme: "light",
						autofocus: !0,
					},
					t,
				))
			var r = this.options,
				i = r.customHTMLRenderer,
				a = r.extendedAutolinks,
				o = r.referenceDefinition,
				s = r.frontMatter,
				l = r.customMarkdownRenderer,
				u = r.useCommandShortcut,
				d = r.initialEditType,
				p = r.widgetRules,
				m = r.customHTMLSanitizer
			;(this.mode = d || "markdown"),
				(this.mdPreviewStyle = this.options.previewStyle),
				(this.i18n = yt),
				this.i18n.setCode(this.options.language),
				(this.eventEmitter = new Tq()),
				m1e(p)
			var v = zU(this.options.linkAttributes)
			this.pluginInfo = Sq({
				plugins: this.options.plugins,
				eventEmitter: this.eventEmitter,
				usageStatistics: this.options.usageStatistics,
				instance: this,
			})
			var y = this.pluginInfo,
				b = y.toHTMLRenderers,
				x = y.toMarkdownRenderers,
				E = y.mdPlugins,
				T = y.wwPlugins,
				C = y.wwNodeViews,
				D = y.mdCommands,
				O = y.wwCommands,
				A = y.markdownParsers,
				N = {
					linkAttributes: v,
					customHTMLRenderer: gb(b, i),
					extendedAutolinks: a,
					referenceDefinition: o,
					frontMatter: s,
					sanitizer: m || Cd,
				},
				I = new got(v, N.customHTMLRenderer),
				P = drt(N.customHTMLRenderer, N.sanitizer, I)
			;(this.toastMark = new Jz("", {
				disallowedHtmlBlockTags: ["br", "img"],
				extendedAutolinks: a,
				referenceDefinition: o,
				disallowDeepHeading: !0,
				frontMatter: s,
				customParser: A,
			})),
				(this.mdEditor = new gxe(this.eventEmitter, {
					toastMark: this.toastMark,
					useCommandShortcut: u,
					mdPlugins: E,
				})),
				(this.preview = new aq(
					this.eventEmitter,
					me(me({}, N), { isViewer: !1, highlight: this.options.previewHighlight }),
				)),
				(this.wwEditor = new Pat(this.eventEmitter, {
					toDOMAdaptor: I,
					useCommandShortcut: u,
					htmlSchemaMap: P,
					linkAttributes: v,
					wwPlugins: T,
					wwNodeViews: C,
				})),
				(this.convertor = new uot(
					this.wwEditor.getSchema(),
					me(me({}, x), l),
					lA(v, N.customHTMLRenderer),
					this.eventEmitter,
				)),
				this.setMinHeight(this.options.minHeight),
				this.setHeight(this.options.height),
				this.setMarkdown(this.options.initialValue, !1),
				this.options.placeholder && this.setPlaceholder(this.options.placeholder),
				this.options.initialValue || this.setHTML(this.initialHTML, !1),
				(this.commandManager = new Yat(
					this.eventEmitter,
					this.mdEditor.commands,
					this.wwEditor.commands,
					function () {
						return n.mode
					},
				)),
				this.options.usageStatistics && Qye(),
				(this.scrollSync = new Eot(this.mdEditor, this.preview, this.eventEmitter)),
				this.addInitEvent(),
				this.addInitCommand(D, O),
				Tot(this),
				this.options.hooks &&
					mp(this.options.hooks, function (L, B) {
						return n.addHook(B, L)
					}),
				this.options.events &&
					mp(this.options.events, function (L, B) {
						return n.on(B, L)
					}),
				this.eventEmitter.emit("load", this),
				this.moveCursorToStart(this.options.autofocus)
		}
		return (
			(e.prototype.addInitEvent = function () {
				var t = this
				this.on("needChangeMode", this.changeMode.bind(this)),
					this.on("loadUI", function () {
						if (t.height !== "auto") {
							var n = Math.min(parseInt(t.minHeight, 10), parseInt(t.height, 10) - 75) + "px"
							t.setMinHeight(n)
						}
					}),
					$1e(this.eventEmitter)
			}),
			(e.prototype.addInitCommand = function (t, n) {
				var r = this,
					i = function (a, o) {
						Object.keys(o).forEach(function (s) {
							r.addCommand(a, s, o[s])
						})
					}
				this.addCommand("markdown", "toggleScrollSync", function (a) {
					return r.eventEmitter.emit("toggleScrollSync", a.active), !0
				}),
					i("markdown", t),
					i("wysiwyg", n)
			}),
			(e.prototype.getCurrentModeEditor = function () {
				return this.isMarkdownMode() ? this.mdEditor : this.wwEditor
			}),
			(e.factory = function (t) {
				return t.viewer ? new Dq(t) : new e(t)
			}),
			(e.setLanguage = function (t, n) {
				yt.setLanguage(t, n)
			}),
			(e.prototype.changePreviewStyle = function (t) {
				this.mdPreviewStyle !== t &&
					((this.mdPreviewStyle = t), this.eventEmitter.emit("changePreviewStyle", t))
			}),
			(e.prototype.exec = function (t, n) {
				this.commandManager.exec(t, n)
			}),
			(e.prototype.addCommand = function (t, n, r) {
				var i = this,
					a = function (o) {
						o === void 0 && (o = {})
						var s = (t === "markdown" ? i.mdEditor : i.wwEditor).view
						r(o, s.state, s.dispatch, s)
					}
				this.commandManager.addCommand(t, n, a)
			}),
			(e.prototype.on = function (t, n) {
				this.eventEmitter.listen(t, n)
			}),
			(e.prototype.off = function (t) {
				this.eventEmitter.removeEventHandler(t)
			}),
			(e.prototype.addHook = function (t, n) {
				this.eventEmitter.removeEventHandler(t), this.eventEmitter.listen(t, n)
			}),
			(e.prototype.removeHook = function (t) {
				this.eventEmitter.removeEventHandler(t)
			}),
			(e.prototype.focus = function () {
				this.getCurrentModeEditor().focus()
			}),
			(e.prototype.blur = function () {
				this.getCurrentModeEditor().blur()
			}),
			(e.prototype.moveCursorToEnd = function (t) {
				t === void 0 && (t = !0), this.getCurrentModeEditor().moveCursorToEnd(t)
			}),
			(e.prototype.moveCursorToStart = function (t) {
				t === void 0 && (t = !0), this.getCurrentModeEditor().moveCursorToStart(t)
			}),
			(e.prototype.setMarkdown = function (t, n) {
				if (
					(t === void 0 && (t = ""),
					n === void 0 && (n = !0),
					this.mdEditor.setMarkdown(t, n),
					this.isWysiwygMode())
				) {
					var r = this.toastMark.getRootNode(),
						i = this.convertor.toWysiwygModel(r)
					this.wwEditor.setModel(i, n)
				}
			}),
			(e.prototype.setHTML = function (t, n) {
				t === void 0 && (t = ""), n === void 0 && (n = !0)
				var r = document.createElement("div")
				r.innerHTML = F1e(t)
				var i = md.fromSchema(this.wwEditor.schema).parse(r)
				this.isMarkdownMode()
					? this.mdEditor.setMarkdown(this.convertor.toMarkdownText(i), n)
					: this.wwEditor.setModel(i, n)
			}),
			(e.prototype.getMarkdown = function () {
				return this.isMarkdownMode()
					? this.mdEditor.getMarkdown()
					: this.convertor.toMarkdownText(this.wwEditor.getModel())
			}),
			(e.prototype.getHTML = function () {
				var t = this
				this.eventEmitter.holdEventInvoke(function () {
					if (t.isMarkdownMode()) {
						var i = t.toastMark.getRootNode(),
							a = t.convertor.toWysiwygModel(i)
						t.wwEditor.setModel(a)
					}
				})
				var n = QO(this.wwEditor.view.dom.innerHTML)
				if (this.placeholder) {
					var r = new RegExp('<span class="placeholder[^>]+>' + this.placeholder + "</span>", "i")
					return n.replace(r, "")
				}
				return n
			}),
			(e.prototype.insertText = function (t) {
				this.getCurrentModeEditor().replaceSelection(t)
			}),
			(e.prototype.setSelection = function (t, n) {
				this.getCurrentModeEditor().setSelection(t, n)
			}),
			(e.prototype.replaceSelection = function (t, n, r) {
				this.getCurrentModeEditor().replaceSelection(t, n, r)
			}),
			(e.prototype.deleteSelection = function (t, n) {
				this.getCurrentModeEditor().deleteSelection(t, n)
			}),
			(e.prototype.getSelectedText = function (t, n) {
				return this.getCurrentModeEditor().getSelectedText(t, n)
			}),
			(e.prototype.getRangeInfoOfNode = function (t) {
				return this.getCurrentModeEditor().getRangeInfoOfNode(t)
			}),
			(e.prototype.addWidget = function (t, n, r) {
				this.getCurrentModeEditor().addWidget(t, n, r)
			}),
			(e.prototype.replaceWithWidget = function (t, n, r) {
				this.getCurrentModeEditor().replaceWithWidget(t, n, r)
			}),
			(e.prototype.setHeight = function (t) {
				var n = this.options.el
				Nl(t) &&
					(t === "auto" ? ss(n, "auto-height") : go(n, "auto-height"),
					this.setMinHeight(this.getMinHeight())),
					gs(n, { height: t }),
					(this.height = t)
			}),
			(e.prototype.getHeight = function () {
				return this.height
			}),
			(e.prototype.setMinHeight = function (t) {
				if (t !== this.minHeight) {
					var n = this.height || this.options.height
					n !== "auto" &&
						this.options.el.querySelector("." + Qe("main")) &&
						(t = Math.min(parseInt(t, 10), parseInt(n, 10) - 75) + "px")
					var r = parseInt(t, 10)
					;(this.minHeight = t),
						this.wwEditor.setMinHeight(r),
						this.mdEditor.setMinHeight(r),
						this.preview.setMinHeight(r)
				}
			}),
			(e.prototype.getMinHeight = function () {
				return this.minHeight
			}),
			(e.prototype.isMarkdownMode = function () {
				return this.mode === "markdown"
			}),
			(e.prototype.isWysiwygMode = function () {
				return this.mode === "wysiwyg"
			}),
			(e.prototype.isViewer = function () {
				return !1
			}),
			(e.prototype.getCurrentPreviewStyle = function () {
				return this.mdPreviewStyle
			}),
			(e.prototype.changeMode = function (t, n) {
				if (this.mode !== t) {
					if (((this.mode = t), this.isWysiwygMode())) {
						var r = this.toastMark.getRootNode(),
							i = this.convertor.toWysiwygModel(r)
						this.wwEditor.setModel(i)
					} else {
						var i = this.wwEditor.getModel()
						this.mdEditor.setMarkdown(this.convertor.toMarkdownText(i), !n)
					}
					if (
						(this.eventEmitter.emit("removePopupWidget"),
						this.eventEmitter.emit("changeMode", t),
						!n)
					) {
						var a = this.convertor.getMappedPos()
						this.focus(),
							this.isWysiwygMode() && Js(a)
								? this.wwEditor.setSelection(a)
								: Array.isArray(a) && this.mdEditor.setSelection(a)
					}
				}
			}),
			(e.prototype.destroy = function () {
				var t = this
				this.wwEditor.destroy(),
					this.mdEditor.destroy(),
					this.preview.destroy(),
					this.scrollSync.destroy(),
					this.eventEmitter.emit("destroy"),
					this.eventEmitter.getEvents().forEach(function (n, r) {
						return t.off(r)
					})
			}),
			(e.prototype.hide = function () {
				this.eventEmitter.emit("hide")
			}),
			(e.prototype.show = function () {
				this.eventEmitter.emit("show")
			}),
			(e.prototype.setScrollTop = function (t) {
				this.getCurrentModeEditor().setScrollTop(t)
			}),
			(e.prototype.getScrollTop = function () {
				return this.getCurrentModeEditor().getScrollTop()
			}),
			(e.prototype.reset = function () {
				this.wwEditor.setModel([]), this.mdEditor.setMarkdown("")
			}),
			(e.prototype.getSelection = function () {
				return this.getCurrentModeEditor().getSelection()
			}),
			(e.prototype.setPlaceholder = function (t) {
				;(this.placeholder = t), this.mdEditor.setPlaceholder(t), this.wwEditor.setPlaceholder(t)
			}),
			(e.prototype.getEditorElements = function () {
				return {
					mdEditor: this.mdEditor.getElement(),
					mdPreview: this.preview.getElement(),
					wwEditor: this.wwEditor.getElement(),
				}
			}),
			(e.prototype.convertPosToMatchEditorMode = function (t, n, r) {
				var i, a
				n === void 0 && (n = t), r === void 0 && (r = this.mode)
				var o = this.mdEditor.view.state.doc,
					s = Array.isArray(t),
					l = Array.isArray(n),
					u = t,
					d = n
				if (s !== l) throw new Error("Types of arguments must be same")
				return (
					r === "markdown" && !s && !l
						? ((i = d1(o, t, n)), (u = i[0]), (d = i[1]))
						: r === "wysiwyg" && s && l && ((a = Ac(o, t, n)), (u = a[0]), (d = a[1])),
					[u, d]
				)
			}),
			e
		)
	})()
	function kot(e) {
		for (
			var t,
				n,
				r = arguments,
				i = 1,
				a = "",
				o = "",
				s = [0],
				l = function (d) {
					i === 1 && (d || (a = a.replace(/^\s*\n\s*|\s*\n\s*$/g, "")))
						? s.push(d ? r[d] : a)
						: i === 3 && (d || a)
						? ((s[1] = d ? r[d] : a), (i = 2))
						: i === 2 && a === "..." && d
						? (s[2] = zO(s[2] || {}, r[d]))
						: i === 2 && a && !d
						? ((s[2] = s[2] || {})[a] = !0)
						: i >= 5 &&
						  (i === 5
								? (((s[2] = s[2] || {})[n] = d ? (a ? a + r[d] : r[d]) : a), (i = 6))
								: (d || a) && (s[2][n] += d ? a + r[d] : a)),
						(a = "")
				},
				u = 0;
			u < e.length;
			u++
		) {
			u && (i === 1 && l(), l(u))
			for (let d = 0; d < e[u].length; d++)
				(t = e[u][d]),
					i === 1
						? t === "<"
							? (l(), (s = [s, "", null]), (i = 3))
							: (a += t)
						: i === 4
						? a === "--" && t === ">"
							? ((i = 1), (a = ""))
							: (a = t + a[0])
						: o
						? t === o
							? (o = "")
							: (a += t)
						: t === '"' || t === "'"
						? (o = t)
						: t === ">"
						? (l(), (i = 1))
						: i &&
						  (t === "="
								? ((i = 5), (n = a), (a = ""))
								: t === "/" && (i < 5 || e[u][d + 1] === ">")
								? (l(),
								  i === 3 && (s = s[0]),
								  (i = s),
								  (s = s[0]).push(this.apply(null, i.slice(1))),
								  (i = 0))
								: t === " " ||
								  t === "	" ||
								  t ===
										`
` ||
								  t === "\r"
								? (l(), (i = 2))
								: (a += t)),
					i === 3 && a === "!--" && ((i = 4), (s = s[0]))
		}
		return l(), s.length > 2 ? s.slice(1) : s[1]
	}
	function Sot(e) {
		return typeof e == "boolean" || e instanceof Boolean
	}
	var Dot = Sot,
		_ot = (function () {
			function e(t) {
				;(this.current = t), (this.root = t), (this.entering = !0)
			}
			return (
				(e.prototype.walk = function () {
					var t = this,
						n = t.entering,
						r = t.current
					return r
						? (n
								? r.firstChild
									? ((this.current = r.firstChild), (this.entering = !0))
									: (this.entering = !1)
								: r === this.root
								? (this.current = null)
								: r.next
								? ((this.current = r.next), (this.entering = !0))
								: ((this.current = r.parent), (this.entering = !1)),
						  { vnode: r, entering: n })
						: null
				}),
				e
			)
		})(),
		Co = (function () {
			function e(t, n, r) {
				;(this.parent = null),
					(this.old = null),
					(this.firstChild = null),
					(this.next = null),
					(this.skip = !1),
					(this.type = t),
					(this.props = n),
					(this.children = r),
					(this.props.children = r),
					n.ref && ((this.ref = n.ref), delete n.ref),
					n.key && ((this.key = n.key), delete n.key)
			}
			return (
				(e.prototype.walker = function () {
					return new _ot(this)
				}),
				(e.removalNodes = []),
				e
			)
		})()
	function Oot(e) {
		return new Co("TEXT_NODE", { nodeValue: e }, [])
	}
	function xj(e, t) {
		var n = e
		Dot(e) || e == null ? (n = null) : (Nl(e) || Js(e)) && (n = Oot(String(e))), n && t.push(n)
	}
	function Aot(e, t) {
		for (var n = [], r = 2; r < arguments.length; r++) n[r - 2] = arguments[r]
		var i = []
		return (
			n.forEach(function (a) {
				Array.isArray(a)
					? a.forEach(function (o) {
							xj(o, i)
					  })
					: xj(a, i)
			}),
			new Co(e, t || {}, i)
		)
	}
	var Pt = kot.bind(Aot)
	function Not(e) {
		return e === Object(e)
	}
	var Mot = Not
	function Iot(e) {
		var t
		return (
			e.type === "TEXT_NODE"
				? (t = document.createTextNode(e.props.nodeValue))
				: ((t = document.createElement(e.type)), Nq(t, {}, e.props)),
			t
		)
	}
	function Aq(e, t) {
		e.node ? t.removeChild(e.node) : Aq(e.firstChild, t)
	}
	function Rot(e, t, n) {
		Object.keys(t).forEach(function (r) {
			if (/^on/.test(r)) {
				if (!n[r] || t[r] !== n[r]) {
					var i = r.slice(2).toLowerCase()
					e.removeEventListener(i, t[r])
				}
			} else r !== "children" && !n[r] && !I1e(e) && e.removeAttribute(r)
		}),
			Nq(e, t, n, function (r) {
				return !BO(t[r], n[r])
			})
	}
	var Lot = /acit|ex(?:s|g|n|p|$)|rph|ows|mnc|ntw|ine[ch]|zoo|^ord/i
	function Nq(e, t, n, r) {
		Object.keys(n).forEach(function (i) {
			if (!r || r(i))
				if (/^on/.test(i)) {
					var a = i.slice(2).toLowerCase()
					e.addEventListener(a, n[i])
				} else
					i === "nodeValue"
						? (e[i] = n[i])
						: i === "style" && Mot(n[i])
						? Pot(e, t[i], n[i])
						: i !== "children" && (n[i] === !1 ? e.removeAttribute(i) : e.setAttribute(i, n[i]))
		})
	}
	function Pot(e, t, n) {
		t &&
			Object.keys(t).forEach(function (r) {
				e.style[r] = ""
			}),
			Object.keys(n).forEach(function (r) {
				var i = n[r]
				e.style[r] = Js(i) && !Lot.test(r) ? i + "px" : i
			})
	}
	function dA(e) {
		if (
			(Co.removalNodes.forEach(function (a) {
				return Ej(a)
			}),
			e)
		) {
			for (var t = void 0, n = e.walker(); (t = n.walk()); )
				if (((e = t.vnode), t.entering)) Ej(e)
				else if (Ka(e.type)) {
					var r = e.component
					if ((!e.old && r.mounted && r.mounted(), e.old && r.updated)) {
						var i = r.prevProps || {}
						r.updated(i)
					}
				}
		}
	}
	function wj(e) {
		for (var t = e.parent; !t.node; ) t = t.parent
		return t.node
	}
	function Ej(e) {
		if (!(!e || !e.parent)) {
			if (e.node) {
				var t = wj(e)
				e.effect === "A"
					? t.appendChild(e.node)
					: e.effect === "U" && Rot(e.node, e.old.props, e.props)
			}
			if (e.effect === "D") {
				for (var n = void 0, r = e.walker(); (n = r.walk()); )
					if (((e = n.vnode), !n.entering))
						if (Ka(e.type)) {
							var i = e.component
							i.beforeDestroy && i.beforeDestroy()
						} else {
							var t = wj(e)
							Aq(e, t)
						}
			}
			e.ref && (e.component ? e.ref(e.component) : e.node && e.ref(e.node))
		}
	}
	function jot(e, t) {
		var n = t.props,
			r = t.component
		return r ? ((r.prevProps = r.props), (r.props = t.props), r) : new e(n)
	}
	function Mq(e) {
		for (var t = e; e && !e.skip; ) {
			if (Ka(e.type)) {
				var n = jot(e.type, e)
				;(n.vnode = e), (e.component = n), (e.props.children = e.children = [n.render()]), Cj(e)
			} else e.node || (e.node = Iot(e)), Cj(e)
			if (e.firstChild) e = e.firstChild
			else {
				for (; e && e.parent && !e.next && ((e = e.parent), e !== t); );
				e = e.next
			}
		}
	}
	function Fot(e, t) {
		return e && t && t.type === e.type && (!t.key || t.key === e.key)
	}
	function Cj(e) {
		var t = e.children,
			n = e.old ? e.old.firstChild : null,
			r = null
		t.forEach(function (a, o) {
			var s = Fot(n, a)
			s &&
				((a.old = n),
				(a.parent = e),
				(a.node = n.node),
				(a.component = n.component),
				(a.effect = "U")),
				a && !s && ((a.old = null), (a.parent = e), (a.node = null), (a.effect = "A")),
				n && !s && (Co.removalNodes.push(n), (n.effect = "D")),
				n && (n = n.next),
				o === 0 ? (e.firstChild = a) : a && (r.next = a),
				(r = a)
		})
		var i = ni(t)
		if (!t.length) for (; n; ) Co.removalNodes.push(n), (n.effect = "D"), (n = n.next)
		for (; n && i; ) n && i.old !== n && (Co.removalNodes.push(n), (n.effect = "D"), (n = n.next))
	}
	function Bot(e) {
		;(e.effect = "D"), (Co.removalNodes = [e]), dA(), (Co.removalNodes = [])
	}
	function Hot(e) {
		var t = e.vnode
		;(t.effect = "U"),
			(t.old = t),
			t.next && (t.next.skip = !0),
			(Co.removalNodes = []),
			Mq(t),
			dA(t),
			t.next && (t.next.skip = !1)
	}
	function $ot(e, t) {
		var n = new Co(e.tagName.toLowerCase(), {}, [t])
		return (
			(n.node = e),
			(Co.removalNodes = []),
			Mq(n),
			dA(n),
			function () {
				return Bot(n.firstChild)
			}
		)
	}
	var ai = (function () {
			function e(t) {
				;(this.props = t), (this.state = {}), (this.refs = {})
			}
			return (
				(e.prototype.setState = function (t) {
					var n = me(me({}, this.state), t)
					BO(this.state, n) || ((this.state = n), Hot(this))
				}),
				e
			)
		})(),
		Uot = (function (e) {
			Ve(t, e)
			function t(n) {
				var r = e.call(this, n) || this
				return (r.state = { hide: !1 }), r
			}
			return (
				(t.prototype.show = function () {
					this.setState({ hide: !1 })
				}),
				(t.prototype.hide = function () {
					this.setState({ hide: !0 })
				}),
				(t.prototype.render = function () {
					var n = this.props,
						r = n.editorType,
						i = n.eventEmitter
					return Pt(
						Tj ||
							(Tj = Lt(
								[
									`
      <div class="`,
									'" style="display: ',
									`">
        <div
          class="tab-item`,
									`"
          onClick=`,
									`
        >
          `,
									`
        </div>
        <div
          class="tab-item`,
									`"
          onClick=`,
									`
        >
          `,
									`
        </div>
      </div>
    `,
								],
								[
									`
      <div class="`,
									'" style="display: ',
									`">
        <div
          class="tab-item`,
									`"
          onClick=`,
									`
        >
          `,
									`
        </div>
        <div
          class="tab-item`,
									`"
          onClick=`,
									`
        >
          `,
									`
        </div>
      </div>
    `,
								],
							)),
						Qe("mode-switch"),
						this.state.hide ? "none" : "block",
						r === "markdown" ? " active" : "",
						function () {
							i.emit("needChangeMode", "markdown")
						},
						yt.get("Markdown"),
						r === "wysiwyg" ? " active" : "",
						function () {
							i.emit("needChangeMode", "wysiwyg")
						},
						yt.get("WYSIWYG"),
					)
				}),
				t
			)
		})(ai),
		Tj
	function zot(e, t) {
		var n, r
		t = t || 0
		function i() {
			;(r = Array.prototype.slice.call(arguments)),
				window.clearTimeout(n),
				(n = window.setTimeout(function () {
					e.apply(null, r)
				}, t))
		}
		return i
	}
	var qot = zot,
		Vot = qot
	function Wot(e, t) {
		var n,
			r = !0,
			i = function (d) {
				e.apply(null, d), (n = null)
			},
			a,
			o,
			s
		;(t = t || 0), (a = Vot(i, t))
		function l() {
			if (((s = Array.prototype.slice.call(arguments)), r)) {
				i(s), (r = !1)
				return
			}
			;(o = Number(new Date())), (n = n || o), a(s), o - n >= t && i(s)
		}
		function u() {
			;(r = !0), (n = null)
		}
		return (l.reset = u), l
	}
	var Yot = Wot,
		Iq = (function () {
			if (typeof Map < "u") return Map
			function e(t, n) {
				var r = -1
				return (
					t.some(function (i, a) {
						return i[0] === n ? ((r = a), !0) : !1
					}),
					r
				)
			}
			return (function () {
				function t() {
					this.__entries__ = []
				}
				return (
					Object.defineProperty(t.prototype, "size", {
						get: function () {
							return this.__entries__.length
						},
						enumerable: !0,
						configurable: !0,
					}),
					(t.prototype.get = function (n) {
						var r = e(this.__entries__, n),
							i = this.__entries__[r]
						return i && i[1]
					}),
					(t.prototype.set = function (n, r) {
						var i = e(this.__entries__, n)
						~i ? (this.__entries__[i][1] = r) : this.__entries__.push([n, r])
					}),
					(t.prototype.delete = function (n) {
						var r = this.__entries__,
							i = e(r, n)
						~i && r.splice(i, 1)
					}),
					(t.prototype.has = function (n) {
						return !!~e(this.__entries__, n)
					}),
					(t.prototype.clear = function () {
						this.__entries__.splice(0)
					}),
					(t.prototype.forEach = function (n, r) {
						r === void 0 && (r = null)
						for (var i = 0, a = this.__entries__; i < a.length; i++) {
							var o = a[i]
							n.call(r, o[1], o[0])
						}
					}),
					t
				)
			})()
		})(),
		iD = typeof window < "u" && typeof document < "u" && window.document === document,
		Ob = (function () {
			return typeof global < "u" && global.Math === Math
				? global
				: typeof self < "u" && self.Math === Math
				? self
				: typeof window < "u" && window.Math === Math
				? window
				: Function("return this")()
		})(),
		Got = (function () {
			return typeof requestAnimationFrame == "function"
				? requestAnimationFrame.bind(Ob)
				: function (e) {
						return setTimeout(function () {
							return e(Date.now())
						}, 1e3 / 60)
				  }
		})(),
		Kot = 2
	function Qot(e, t) {
		var n = !1,
			r = !1,
			i = 0
		function a() {
			n && ((n = !1), e()), r && s()
		}
		function o() {
			Got(a)
		}
		function s() {
			var l = Date.now()
			if (n) {
				if (l - i < Kot) return
				r = !0
			} else (n = !0), (r = !1), setTimeout(o, t)
			i = l
		}
		return s
	}
	var Xot = 20,
		Jot = ["top", "right", "bottom", "left", "width", "height", "size", "weight"],
		Zot = typeof MutationObserver < "u",
		est = (function () {
			function e() {
				;(this.connected_ = !1),
					(this.mutationEventsAdded_ = !1),
					(this.mutationsObserver_ = null),
					(this.observers_ = []),
					(this.onTransitionEnd_ = this.onTransitionEnd_.bind(this)),
					(this.refresh = Qot(this.refresh.bind(this), Xot))
			}
			return (
				(e.prototype.addObserver = function (t) {
					~this.observers_.indexOf(t) || this.observers_.push(t), this.connected_ || this.connect_()
				}),
				(e.prototype.removeObserver = function (t) {
					var n = this.observers_,
						r = n.indexOf(t)
					~r && n.splice(r, 1), !n.length && this.connected_ && this.disconnect_()
				}),
				(e.prototype.refresh = function () {
					var t = this.updateObservers_()
					t && this.refresh()
				}),
				(e.prototype.updateObservers_ = function () {
					var t = this.observers_.filter(function (n) {
						return n.gatherActive(), n.hasActive()
					})
					return (
						t.forEach(function (n) {
							return n.broadcastActive()
						}),
						t.length > 0
					)
				}),
				(e.prototype.connect_ = function () {
					!iD ||
						this.connected_ ||
						(document.addEventListener("transitionend", this.onTransitionEnd_),
						window.addEventListener("resize", this.refresh),
						Zot
							? ((this.mutationsObserver_ = new MutationObserver(this.refresh)),
							  this.mutationsObserver_.observe(document, {
									attributes: !0,
									childList: !0,
									characterData: !0,
									subtree: !0,
							  }))
							: (document.addEventListener("DOMSubtreeModified", this.refresh),
							  (this.mutationEventsAdded_ = !0)),
						(this.connected_ = !0))
				}),
				(e.prototype.disconnect_ = function () {
					!iD ||
						!this.connected_ ||
						(document.removeEventListener("transitionend", this.onTransitionEnd_),
						window.removeEventListener("resize", this.refresh),
						this.mutationsObserver_ && this.mutationsObserver_.disconnect(),
						this.mutationEventsAdded_ &&
							document.removeEventListener("DOMSubtreeModified", this.refresh),
						(this.mutationsObserver_ = null),
						(this.mutationEventsAdded_ = !1),
						(this.connected_ = !1))
				}),
				(e.prototype.onTransitionEnd_ = function (t) {
					var n = t.propertyName,
						r = n === void 0 ? "" : n,
						i = Jot.some(function (a) {
							return !!~r.indexOf(a)
						})
					i && this.refresh()
				}),
				(e.getInstance = function () {
					return this.instance_ || (this.instance_ = new e()), this.instance_
				}),
				(e.instance_ = null),
				e
			)
		})(),
		Rq = function (e, t) {
			for (var n = 0, r = Object.keys(t); n < r.length; n++) {
				var i = r[n]
				Object.defineProperty(e, i, { value: t[i], enumerable: !1, writable: !1, configurable: !0 })
			}
			return e
		},
		Tp = function (e) {
			var t = e && e.ownerDocument && e.ownerDocument.defaultView
			return t || Ob
		},
		Lq = yw(0, 0, 0, 0)
	function Ab(e) {
		return parseFloat(e) || 0
	}
	function kj(e) {
		for (var t = [], n = 1; n < arguments.length; n++) t[n - 1] = arguments[n]
		return t.reduce(function (r, i) {
			var a = e["border-" + i + "-width"]
			return r + Ab(a)
		}, 0)
	}
	function tst(e) {
		for (var t = ["top", "right", "bottom", "left"], n = {}, r = 0, i = t; r < i.length; r++) {
			var a = i[r],
				o = e["padding-" + a]
			n[a] = Ab(o)
		}
		return n
	}
	function nst(e) {
		var t = e.getBBox()
		return yw(0, 0, t.width, t.height)
	}
	function rst(e) {
		var t = e.clientWidth,
			n = e.clientHeight
		if (!t && !n) return Lq
		var r = Tp(e).getComputedStyle(e),
			i = tst(r),
			a = i.left + i.right,
			o = i.top + i.bottom,
			s = Ab(r.width),
			l = Ab(r.height)
		if (
			(r.boxSizing === "border-box" &&
				(Math.round(s + a) !== t && (s -= kj(r, "left", "right") + a),
				Math.round(l + o) !== n && (l -= kj(r, "top", "bottom") + o)),
			!ast(e))
		) {
			var u = Math.round(s + a) - t,
				d = Math.round(l + o) - n
			Math.abs(u) !== 1 && (s -= u), Math.abs(d) !== 1 && (l -= d)
		}
		return yw(i.left, i.top, s, l)
	}
	var ist = (function () {
		return typeof SVGGraphicsElement < "u"
			? function (e) {
					return e instanceof Tp(e).SVGGraphicsElement
			  }
			: function (e) {
					return e instanceof Tp(e).SVGElement && typeof e.getBBox == "function"
			  }
	})()
	function ast(e) {
		return e === Tp(e).document.documentElement
	}
	function ost(e) {
		return iD ? (ist(e) ? nst(e) : rst(e)) : Lq
	}
	function sst(e) {
		var t = e.x,
			n = e.y,
			r = e.width,
			i = e.height,
			a = typeof DOMRectReadOnly < "u" ? DOMRectReadOnly : Object,
			o = Object.create(a.prototype)
		return (
			Rq(o, { x: t, y: n, width: r, height: i, top: n, right: t + r, bottom: i + n, left: t }), o
		)
	}
	function yw(e, t, n, r) {
		return { x: e, y: t, width: n, height: r }
	}
	var lst = (function () {
			function e(t) {
				;(this.broadcastWidth = 0),
					(this.broadcastHeight = 0),
					(this.contentRect_ = yw(0, 0, 0, 0)),
					(this.target = t)
			}
			return (
				(e.prototype.isActive = function () {
					var t = ost(this.target)
					return (
						(this.contentRect_ = t),
						t.width !== this.broadcastWidth || t.height !== this.broadcastHeight
					)
				}),
				(e.prototype.broadcastRect = function () {
					var t = this.contentRect_
					return (this.broadcastWidth = t.width), (this.broadcastHeight = t.height), t
				}),
				e
			)
		})(),
		ust = (function () {
			function e(t, n) {
				var r = sst(n)
				Rq(this, { target: t, contentRect: r })
			}
			return e
		})(),
		cst = (function () {
			function e(t, n, r) {
				if (
					((this.activeObservations_ = []), (this.observations_ = new Iq()), typeof t != "function")
				)
					throw new TypeError("The callback provided as parameter 1 is not a function.")
				;(this.callback_ = t), (this.controller_ = n), (this.callbackCtx_ = r)
			}
			return (
				(e.prototype.observe = function (t) {
					if (!arguments.length) throw new TypeError("1 argument required, but only 0 present.")
					if (!(typeof Element > "u" || !(Element instanceof Object))) {
						if (!(t instanceof Tp(t).Element))
							throw new TypeError('parameter 1 is not of type "Element".')
						var n = this.observations_
						n.has(t) ||
							(n.set(t, new lst(t)), this.controller_.addObserver(this), this.controller_.refresh())
					}
				}),
				(e.prototype.unobserve = function (t) {
					if (!arguments.length) throw new TypeError("1 argument required, but only 0 present.")
					if (!(typeof Element > "u" || !(Element instanceof Object))) {
						if (!(t instanceof Tp(t).Element))
							throw new TypeError('parameter 1 is not of type "Element".')
						var n = this.observations_
						n.has(t) && (n.delete(t), n.size || this.controller_.removeObserver(this))
					}
				}),
				(e.prototype.disconnect = function () {
					this.clearActive(), this.observations_.clear(), this.controller_.removeObserver(this)
				}),
				(e.prototype.gatherActive = function () {
					var t = this
					this.clearActive(),
						this.observations_.forEach(function (n) {
							n.isActive() && t.activeObservations_.push(n)
						})
				}),
				(e.prototype.broadcastActive = function () {
					if (this.hasActive()) {
						var t = this.callbackCtx_,
							n = this.activeObservations_.map(function (r) {
								return new ust(r.target, r.broadcastRect())
							})
						this.callback_.call(t, n, t), this.clearActive()
					}
				}),
				(e.prototype.clearActive = function () {
					this.activeObservations_.splice(0)
				}),
				(e.prototype.hasActive = function () {
					return this.activeObservations_.length > 0
				}),
				e
			)
		})(),
		Pq = typeof WeakMap < "u" ? new WeakMap() : new Iq(),
		jq = (function () {
			function e(t) {
				if (!(this instanceof e)) throw new TypeError("Cannot call a class as a function.")
				if (!arguments.length) throw new TypeError("1 argument required, but only 0 present.")
				var n = est.getInstance(),
					r = new cst(t, n, this)
				Pq.set(this, r)
			}
			return e
		})()
	;["observe", "unobserve", "disconnect"].forEach(function (e) {
		jq.prototype[e] = function () {
			var t
			return (t = Pq.get(this))[e].apply(t, arguments)
		}
	})
	var dst = (function () {
			return typeof Ob.ResizeObserver < "u" ? Ob.ResizeObserver : jq
		})(),
		fst = (function (e) {
			Ve(t, e)
			function t() {
				return (e !== null && e.apply(this, arguments)) || this
			}
			return (
				(t.prototype.execCommand = function (n) {
					var r = ls(n.target, "li")
					this.props.execCommand("heading", { level: Number(r.getAttribute("data-level")) })
				}),
				(t.prototype.render = function () {
					var n = this
					return Pt(
						Dj ||
							(Dj = Lt(
								[
									`
      <ul
        onClick=`,
									`
        aria-role="menu"
        aria-label="`,
									`"
      >
        `,
									`
        <li data-type="Paragraph" aria-role="menuitem">
          <div>`,
									`</div>
        </li>
      </ul>
    `,
								],
								[
									`
      <ul
        onClick=`,
									`
        aria-role="menu"
        aria-label="`,
									`"
      >
        `,
									`
        <li data-type="Paragraph" aria-role="menuitem">
          <div>`,
									`</div>
        </li>
      </ul>
    `,
								],
							)),
						function (r) {
							return n.execCommand(r)
						},
						yt.get("Headings"),
						[1, 2, 3, 4, 5, 6].map(function (r) {
							return Pt(
								Sj ||
									(Sj = Lt(
										[
											`
              <li data-level="`,
											`" data-type="Heading" aria-role="menuitem">
                <`,
											">",
											" ",
											`</$>
              </li>
            `,
										],
										[
											`
              <li data-level="`,
											`" data-type="Heading" aria-role="menuitem">
                <`,
											">",
											" ",
											`</$>
              </li>
            `,
										],
									)),
								r,
								"h" + r,
								yt.get("Heading"),
								r,
							)
						}),
						yt.get("Paragraph"),
					)
				}),
				t
			)
		})(ai),
		Sj,
		Dj,
		Fq = (function (e) {
			Ve(t, e)
			function t() {
				return (e !== null && e.apply(this, arguments)) || this
			}
			return (
				(t.prototype.toggleTab = function (n, r) {
					this.props.onClick(n, r)
				}),
				(t.prototype.render = function () {
					var n = this
					return Pt(
						Oj ||
							(Oj = Lt(
								[
									`
      <div class="`,
									`" aria-role="tabpanel">
        `,
									`
      </div>
    `,
								],
								[
									`
      <div class="`,
									`" aria-role="tabpanel">
        `,
									`
      </div>
    `,
								],
							)),
						Qe("tabs"),
						this.props.tabs.map(function (r) {
							var i = r.name,
								a = r.text,
								o = n.props.activeTab === i
							return Pt(
								_j ||
									(_j = Lt(
										[
											`
            <div
              class="tab-item`,
											`"
              onClick=`,
											`
              aria-role="tab"
              aria-label="`,
											`"
              aria-selected="`,
											`"
              tabindex="`,
											`"
            >
              `,
											`
            </div>
          `,
										],
										[
											`
            <div
              class="tab-item`,
											`"
              onClick=`,
											`
              aria-role="tab"
              aria-label="`,
											`"
              aria-selected="`,
											`"
              tabindex="`,
											`"
            >
              `,
											`
            </div>
          `,
										],
									)),
								o ? " active" : "",
								function (s) {
									return n.toggleTab(s, i)
								},
								yt.get(a),
								o ? "true" : "false",
								o ? "0" : "-1",
								yt.get(a),
							)
						}),
					)
				}),
				t
			)
		})(ai),
		_j,
		Oj,
		pst = "ui",
		hst = (function (e) {
			Ve(t, e)
			function t(n) {
				var r = e.call(this, n) || this
				return (
					(r.initialize = function (i) {
						i === void 0 && (i = "file")
						var a = r.refs.url
						;(a.value = ""),
							(r.refs.altText.value = ""),
							(r.refs.file.value = ""),
							go(a, "wrong"),
							r.setState({ activeTab: i, file: null, fileNameElClassName: "" })
					}),
					(r.execCommand = function () {
						r.state.activeTab === "file" ? r.emitAddImageBlob() : r.emitAddImage()
					}),
					(r.toggleTab = function (i, a) {
						a !== r.state.activeTab && r.initialize(a)
					}),
					(r.showFileSelectBox = function () {
						r.refs.file.click()
					}),
					(r.changeFile = function (i) {
						var a = i.target.files
						a != null && a.length && r.setState({ file: a[0] })
					}),
					(r.state = { activeTab: "file", file: null, fileNameElClassName: "" }),
					(r.tabs = [
						{ name: "file", text: "File" },
						{ name: "url", text: "URL" },
					]),
					r
				)
			}
			return (
				(t.prototype.emitAddImageBlob = function () {
					var n = this,
						r = this.refs.file.files,
						i = this.refs.altText,
						a = " wrong"
					if (r != null && r.length) {
						a = ""
						var o = r.item(0),
							s = function (l, u) {
								return n.props.execCommand("addImage", { imageUrl: l, altText: u || i.value })
							}
						this.props.eventEmitter.emit("addImageBlobHook", o, s, pst)
					}
					this.setState({ fileNameElClassName: a })
				}),
				(t.prototype.emitAddImage = function () {
					var n = this.refs.url,
						r = this.refs.altText,
						i = n.value,
						a = r.value || "image"
					if ((go(n, "wrong"), !i.length)) {
						ss(n, "wrong")
						return
					}
					i && this.props.execCommand("addImage", { imageUrl: i, altText: a })
				}),
				(t.prototype.preventSelectStart = function (n) {
					n.preventDefault()
				}),
				(t.prototype.updated = function () {
					this.props.show || this.initialize()
				}),
				(t.prototype.render = function () {
					var n = this,
						r = this.state,
						i = r.activeTab,
						a = r.file,
						o = r.fileNameElClassName
					return Pt(
						Aj ||
							(Aj = Lt(
								[
									`
      <div aria-label="`,
									`">
        <`,
									" tabs=",
									" activeTab=",
									" onClick=",
									` />
        <div style="display:`,
									`">
          <label for="toastuiImageUrlInput">`,
									`</label>
          <input
            id="toastuiImageUrlInput"
            type="text"
            ref=`,
									`
          />
        </div>
        <div style="display:`,
									`;position: relative;">
          <label for="toastuiImageFileInput">`,
									`</label>
          <span
            class="`,
									"",
									`"
            onClick=`,
									`
            onSelectstart=`,
									`
          >
            `,
									`
          </span>
          <button
            type="button"
            class="`,
									`"
            onClick=`,
									`
          >
            `,
									`
          </button>
          <input
            id="toastuiImageFileInput"
            type="file"
            accept="image/*"
            onChange=`,
									`
            ref=`,
									`
          />
        </div>
        <label for="toastuiAltTextInput">`,
									`</label>
        <input
          id="toastuiAltTextInput"
          type="text"
          ref=`,
									`
        />
        <div class="`,
									`">
          <button type="button" class="`,
									'" onClick=',
									`>
            `,
									`
          </button>
          <button type="button" class="`,
									'" onClick=',
									`>
            `,
									`
          </button>
        </div>
      </div>
    `,
								],
								[
									`
      <div aria-label="`,
									`">
        <`,
									" tabs=",
									" activeTab=",
									" onClick=",
									` />
        <div style="display:`,
									`">
          <label for="toastuiImageUrlInput">`,
									`</label>
          <input
            id="toastuiImageUrlInput"
            type="text"
            ref=`,
									`
          />
        </div>
        <div style="display:`,
									`;position: relative;">
          <label for="toastuiImageFileInput">`,
									`</label>
          <span
            class="`,
									"",
									`"
            onClick=`,
									`
            onSelectstart=`,
									`
          >
            `,
									`
          </span>
          <button
            type="button"
            class="`,
									`"
            onClick=`,
									`
          >
            `,
									`
          </button>
          <input
            id="toastuiImageFileInput"
            type="file"
            accept="image/*"
            onChange=`,
									`
            ref=`,
									`
          />
        </div>
        <label for="toastuiAltTextInput">`,
									`</label>
        <input
          id="toastuiAltTextInput"
          type="text"
          ref=`,
									`
        />
        <div class="`,
									`">
          <button type="button" class="`,
									'" onClick=',
									`>
            `,
									`
          </button>
          <button type="button" class="`,
									'" onClick=',
									`>
            `,
									`
          </button>
        </div>
      </div>
    `,
								],
							)),
						yt.get("Insert image"),
						Fq,
						this.tabs,
						i,
						this.toggleTab,
						i === "url" ? "block" : "none",
						yt.get("Image URL"),
						function (s) {
							return (n.refs.url = s)
						},
						i === "file" ? "block" : "none",
						yt.get("Select image file"),
						Qe("file-name"),
						a ? " has-file" : o,
						this.showFileSelectBox,
						this.preventSelectStart,
						a ? a.name : yt.get("No file"),
						Qe("file-select-button"),
						this.showFileSelectBox,
						yt.get("Choose a file"),
						this.changeFile,
						function (s) {
							return (n.refs.file = s)
						},
						yt.get("Description"),
						function (s) {
							return (n.refs.altText = s)
						},
						Qe("button-container"),
						Qe("close-button"),
						this.props.hidePopup,
						yt.get("Cancel"),
						Qe("ok-button"),
						this.execCommand,
						yt.get("OK"),
					)
				}),
				t
			)
		})(ai),
		Aj,
		mst = (function (e) {
			Ve(t, e)
			function t() {
				var n = (e !== null && e.apply(this, arguments)) || this
				return (
					(n.execCommand = function () {
						var r = n.refs.url,
							i = n.refs.text
						if ((go(r, "wrong"), go(i, "wrong"), r.value.length < 1)) {
							ss(r, "wrong")
							return
						}
						var a = Oo(n.props.initialValues.linkUrl)
						if (a && i.value.length < 1) {
							ss(i, "wrong")
							return
						}
						n.props.execCommand("addLink", { linkUrl: r.value, linkText: i.value })
					}),
					n
				)
			}
			return (
				(t.prototype.initialize = function () {
					var n = this.props.initialValues,
						r = n.linkUrl,
						i = n.linkText,
						a = this.refs.url,
						o = this.refs.text
					go(a, "wrong"),
						go(o, "wrong", "disabled"),
						o.removeAttribute("disabled"),
						r && (ss(o, "disabled"), o.setAttribute("disabled", "disabled")),
						(a.value = r || ""),
						(o.value = i || "")
				}),
				(t.prototype.mounted = function () {
					this.initialize()
				}),
				(t.prototype.updated = function (n) {
					!n.show && this.props.show && this.initialize()
				}),
				(t.prototype.render = function () {
					var n = this
					return Pt(
						Nj ||
							(Nj = Lt(
								[
									`
      <div aria-label="`,
									`">
        <label for="toastuiLinkUrlInput">`,
									`</label>
        <input
          id="toastuiLinkUrlInput"
          type="text"
          ref=`,
									`
        />
        <label for="toastuiLinkTextInput">`,
									`</label>
        <input
          id="toastuiLinkTextInput"
          type="text"
          ref=`,
									`
        />
        <div class="`,
									`">
          <button type="button" class="`,
									'" onClick=',
									`>
            `,
									`
          </button>
          <button type="button" class="`,
									'" onClick=',
									`>
            `,
									`
          </button>
        </div>
      </div>
    `,
								],
								[
									`
      <div aria-label="`,
									`">
        <label for="toastuiLinkUrlInput">`,
									`</label>
        <input
          id="toastuiLinkUrlInput"
          type="text"
          ref=`,
									`
        />
        <label for="toastuiLinkTextInput">`,
									`</label>
        <input
          id="toastuiLinkTextInput"
          type="text"
          ref=`,
									`
        />
        <div class="`,
									`">
          <button type="button" class="`,
									'" onClick=',
									`>
            `,
									`
          </button>
          <button type="button" class="`,
									'" onClick=',
									`>
            `,
									`
          </button>
        </div>
      </div>
    `,
								],
							)),
						yt.get("Insert link"),
						yt.get("URL"),
						function (r) {
							return (n.refs.url = r)
						},
						yt.get("Link text"),
						function (r) {
							return (n.refs.text = r)
						},
						Qe("button-container"),
						Qe("close-button"),
						this.props.hidePopup,
						yt.get("Cancel"),
						Qe("ok-button"),
						this.execCommand,
						yt.get("OK"),
					)
				}),
				t
			)
		})(ai),
		Nj,
		Mj = 20,
		Ij = 20,
		Rj = 5,
		Lj = 14,
		Pj = 5,
		jj = 9,
		vst = 1,
		gst = 1,
		Fj = 1,
		yst = (function (e) {
			Ve(t, e)
			function t(n) {
				var r = e.call(this, n) || this
				return (
					(r.extendSelectionRange = function (i) {
						var a = i.pageX,
							o = i.pageY,
							s = a - r.offsetRect.left,
							l = o - r.offsetRect.top,
							u = r.getSelectionRangeByOffset(s, l)
						r.setState(me({}, u))
					}),
					(r.execCommand = function () {
						r.props.execCommand("addTable", {
							rowCount: r.state.rowIdx + 1,
							columnCount: r.state.colIdx + 1,
						})
					}),
					(r.state = { rowIdx: -1, colIdx: -1 }),
					r
				)
			}
			return (
				(t.prototype.getDescription = function () {
					return this.state.colIdx === -1
						? ""
						: this.state.colIdx + 1 + " x " + (this.state.rowIdx + 1)
				}),
				(t.prototype.getBoundByRange = function (n, r) {
					return { width: (n + 1) * Mj, height: (r + 1) * Ij }
				}),
				(t.prototype.getRangeByOffset = function (n, r) {
					return { colIdx: Math.floor(n / Mj), rowIdx: Math.floor(r / Ij) }
				}),
				(t.prototype.getTableRange = function () {
					var n = this.state,
						r = n.colIdx,
						i = n.rowIdx,
						a = Math.max(r, Pj),
						o = Math.max(i, Rj)
					return (
						r >= Pj && a < jj && (a += 1),
						i >= Rj && o < Lj && (o += 1),
						{ colIdx: a + 1, rowIdx: o + 1 }
					)
				}),
				(t.prototype.getSelectionAreaBound = function () {
					var n = this.getBoundByRange(this.state.colIdx, this.state.rowIdx),
						r = n.width,
						i = n.height
					return !r && !i
						? { display: "none" }
						: { width: r - Fj, height: i - Fj, display: "block" }
				}),
				(t.prototype.getSelectionRangeByOffset = function (n, r) {
					var i = this.getRangeByOffset(n, r)
					return (
						(i.rowIdx = Math.min(Math.max(i.rowIdx, vst), Lj)),
						(i.colIdx = Math.min(Math.max(i.colIdx, gst), jj)),
						i
					)
				}),
				(t.prototype.updated = function () {
					if (!this.props.show) this.setState({ colIdx: -1, rowIdx: -1 })
					else if (this.state.colIdx === -1 && this.state.rowIdx === -1) {
						var n = this.refs.tableEl.getBoundingClientRect(),
							r = n.left,
							i = n.top
						this.offsetRect = { left: window.pageXOffset + r, top: window.pageYOffset + i }
					}
				}),
				(t.prototype.createTableArea = function (n) {
					for (var r = n.colIdx, i = n.rowIdx, a = [], o = 0; o < i; o += 1) {
						for (var s = [], l = 0; l < r; l += 1) {
							var u = "" + Qe("table-cell") + (o > 0 ? "" : " header")
							s.push(
								Pt(Bj || (Bj = Lt(['<div class="', '"></div>'], ['<div class="', '"></div>'])), u),
							)
						}
						a.push(
							Pt(
								Hj || (Hj = Lt(['<div class="', '">', "</div>"], ['<div class="', '">', "</div>"])),
								Qe("table-row"),
								s,
							),
						)
					}
					return Pt(
						$j || ($j = Lt(['<div class="', '">', "</div>"], ['<div class="', '">', "</div>"])),
						Qe("table"),
						a,
					)
				}),
				(t.prototype.render = function () {
					var n = this,
						r = this.getTableRange(),
						i = this.getSelectionAreaBound()
					return Pt(
						Uj ||
							(Uj = Lt(
								[
									`
      <div aria-label="`,
									`">
        <div
          class="`,
									`"
          ref=`,
									`
          onMousemove=`,
									`
          onClick=`,
									`
        >
          `,
									`
          <div class="`,
									'" style=',
									`></div>
        </div>
        <p class="`,
									'">',
									`</p>
      </div>
    `,
								],
								[
									`
      <div aria-label="`,
									`">
        <div
          class="`,
									`"
          ref=`,
									`
          onMousemove=`,
									`
          onClick=`,
									`
        >
          `,
									`
          <div class="`,
									'" style=',
									`></div>
        </div>
        <p class="`,
									'">',
									`</p>
      </div>
    `,
								],
							)),
						yt.get("Insert table"),
						Qe("table-selection"),
						function (a) {
							return (n.refs.tableEl = a)
						},
						this.extendSelectionRange,
						this.execCommand,
						this.createTableArea(r),
						Qe("table-selection-layer"),
						i,
						Qe("table-description"),
						this.getDescription(),
					)
				}),
				t
			)
		})(ai),
		Bj,
		Hj,
		$j,
		Uj,
		bst = (function (e) {
			Ve(t, e)
			function t() {
				return (e !== null && e.apply(this, arguments)) || this
			}
			return (
				(t.prototype.mounted = function () {
					this.refs.el.appendChild(this.props.body)
				}),
				(t.prototype.updated = function (n) {
					this.refs.el.replaceChild(this.props.body, n.body)
				}),
				(t.prototype.render = function () {
					var n = this
					return Pt(
						zj || (zj = Lt(["<div ref=", "></div>"], ["<div ref=", "></div>"])),
						function (r) {
							return (n.refs.el = r)
						},
					)
				}),
				t
			)
		})(ai),
		zj
	function aD(e) {
		return Nl(e) ? wst(e) : e
	}
	function xst() {
		var e = document.createElement("label"),
			t = document.createElement("input"),
			n = document.createElement("span")
		;(e.className = "scroll-sync active"),
			(t.type = "checkbox"),
			(t.checked = !0),
			(n.className = "switch")
		var r = function (i) {
			return t.addEventListener("change", function (a) {
				var o = a.target.checked
				o ? ss(e, "active") : go(e, "active"), i("toggleScrollSync", { active: o })
			})
		}
		return e.appendChild(t), e.appendChild(n), { name: "scrollSync", el: e, onMounted: r }
	}
	function wst(e) {
		var t
		switch (e) {
			case "heading":
				t = { name: "heading", className: "heading", tooltip: yt.get("Headings"), state: "heading" }
				break
			case "bold":
				t = {
					name: "bold",
					className: "bold",
					command: "bold",
					tooltip: yt.get("Bold"),
					state: "strong",
				}
				break
			case "italic":
				t = {
					name: "italic",
					className: "italic",
					command: "italic",
					tooltip: yt.get("Italic"),
					state: "emph",
				}
				break
			case "strike":
				t = {
					name: "strike",
					className: "strike",
					command: "strike",
					tooltip: yt.get("Strike"),
					state: "strike",
				}
				break
			case "hr":
				t = {
					name: "hr",
					className: "hrline",
					command: "hr",
					tooltip: yt.get("Line"),
					state: "thematicBreak",
				}
				break
			case "quote":
				t = {
					name: "quote",
					className: "quote",
					command: "blockQuote",
					tooltip: yt.get("Blockquote"),
					state: "blockQuote",
				}
				break
			case "ul":
				t = {
					name: "ul",
					className: "bullet-list",
					command: "bulletList",
					tooltip: yt.get("Unordered list"),
					state: "bulletList",
				}
				break
			case "ol":
				t = {
					name: "ol",
					className: "ordered-list",
					command: "orderedList",
					tooltip: yt.get("Ordered list"),
					state: "orderedList",
				}
				break
			case "task":
				t = {
					name: "task",
					className: "task-list",
					command: "taskList",
					tooltip: yt.get("Task"),
					state: "taskList",
				}
				break
			case "table":
				t = { name: "table", className: "table", tooltip: yt.get("Insert table"), state: "table" }
				break
			case "image":
				t = { name: "image", className: "image", tooltip: yt.get("Insert image") }
				break
			case "link":
				t = { name: "link", className: "link", tooltip: yt.get("Insert link") }
				break
			case "code":
				t = {
					name: "code",
					className: "code",
					command: "code",
					tooltip: yt.get("Code"),
					state: "code",
				}
				break
			case "codeblock":
				t = {
					name: "codeblock",
					className: "codeblock",
					command: "codeBlock",
					tooltip: yt.get("Insert CodeBlock"),
					state: "codeBlock",
				}
				break
			case "indent":
				t = {
					name: "indent",
					className: "indent",
					command: "indent",
					tooltip: yt.get("Indent"),
					state: "indent",
				}
				break
			case "outdent":
				t = {
					name: "outdent",
					className: "outdent",
					command: "outdent",
					tooltip: yt.get("Outdent"),
					state: "outdent",
				}
				break
			case "scrollSync":
				t = xst()
				break
			case "more":
				t = { name: "more", className: "more", tooltip: yt.get("More") }
				break
		}
		return t.name !== "scrollSync" && (t.className += " " + Qe("toolbar-icons")), t
	}
	function fA(e, t) {
		var n = t.el,
			r = t.pos,
			i = t.popup,
			a = t.initialValues
		switch (e) {
			case "heading":
				return {
					render: function (o) {
						return Pt(qj || (qj = Lt(["<", " ...", " />"], ["<", " ...", " />"])), fst, o)
					},
					className: Qe("popup-add-heading"),
					fromEl: n,
					pos: r,
				}
			case "link":
				return {
					render: function (o) {
						return Pt(Vj || (Vj = Lt(["<", " ...", " />"], ["<", " ...", " />"])), mst, o)
					},
					className: Qe("popup-add-link"),
					fromEl: n,
					pos: r,
					initialValues: a,
				}
			case "image":
				return {
					render: function (o) {
						return Pt(Wj || (Wj = Lt(["<", " ...", " />"], ["<", " ...", " />"])), hst, o)
					},
					className: Qe("popup-add-image"),
					fromEl: n,
					pos: r,
				}
			case "table":
				return {
					render: function (o) {
						return Pt(Yj || (Yj = Lt(["<", " ...", " />"], ["<", " ...", " />"])), yst, o)
					},
					className: Qe("popup-add-table"),
					fromEl: n,
					pos: r,
				}
			case "customPopupBody":
				return i
					? me(
							{
								render: function (o) {
									return Pt(
										Gj || (Gj = Lt(["<", " ...", " body=", " />"], ["<", " ...", " body=", " />"])),
										bst,
										o,
										i.body,
									)
								},
								fromEl: n,
								pos: r,
							},
							i,
					  )
					: null
			default:
				return null
		}
	}
	function Nb(e) {
		e.hidden =
			e.length ===
			e.filter(function (t) {
				return t.hidden
			}).length
	}
	function Est(e, t) {
		var n = function (r) {
			return (r.hidden = r.name === "scrollSync" && t), r
		}
		return e.reduce(function (r, i) {
			r.push(
				i.map(function (o) {
					return n(aD(o))
				}),
			)
			var a = r[(r.length || 1) - 1]
			return a && Nb(a), r
		}, [])
	}
	function Cst(e, t) {
		e.forEach(function (n) {
			n.forEach(function (r) {
				return (r.hidden = r.name === "scrollSync" && t)
			}),
				Nb(n)
		})
	}
	var qj,
		Vj,
		Wj,
		Yj,
		Gj,
		Tst = 20,
		kst = (function (e) {
			Ve(t, e)
			function t() {
				var n = (e !== null && e.apply(this, arguments)) || this
				return (
					(n.handleMousedown = function (r) {
						!ls(r.target, "." + Qe("popup")) &&
							!ls(r.target, n.props.info.fromEl) &&
							n.props.hidePopup()
					}),
					n
				)
			}
			return (
				(t.prototype.mounted = function () {
					document.addEventListener("mousedown", this.handleMousedown),
						this.props.eventEmitter.listen("closePopup", this.props.hidePopup)
				}),
				(t.prototype.beforeDestroy = function () {
					document.removeEventListener("mousedown", this.handleMousedown)
				}),
				(t.prototype.updated = function (n) {
					var r = this.props,
						i = r.show,
						a = r.info
					if (i && a.pos && n.show !== i) {
						var o = me({}, a.pos),
							s = this.refs.el.offsetWidth,
							l = ls(this.refs.el, "." + Qe("toolbar")),
							u = l.offsetWidth
						o.left + s >= u && (o.left = u - s - Tst),
							BO(this.state.popupPos, o) || this.setState({ popupPos: o })
					}
				}),
				(t.prototype.render = function () {
					var n = this,
						r = this.props,
						i = r.info,
						a = r.show,
						o = r.hidePopup,
						s = r.eventEmitter,
						l = r.execCommand,
						u = i || {},
						d = u.className,
						p = d === void 0 ? "" : d,
						m = u.style,
						v = u.render,
						y = u.initialValues,
						b = y === void 0 ? {} : y,
						x = me(me({ display: a ? "block" : "none" }, m), this.state.popupPos)
					return Pt(
						Kj ||
							(Kj = Lt(
								[
									`
      <div
        class="`,
									" ",
									`"
        style=`,
									`
        ref=`,
									`
        aria-role="dialog"
      >
        <div class="`,
									`">
          `,
									`
        </div>
      </div>
    `,
								],
								[
									`
      <div
        class="`,
									" ",
									`"
        style=`,
									`
        ref=`,
									`
        aria-role="dialog"
      >
        <div class="`,
									`">
          `,
									`
        </div>
      </div>
    `,
								],
							)),
						Qe("popup"),
						p,
						x,
						function (E) {
							return (n.refs.el = E)
						},
						Qe("popup-body"),
						v && v({ eventEmitter: s, show: a, hidePopup: o, execCommand: l, initialValues: b }),
					)
				}),
				t
			)
		})(ai),
		Kj,
		Qj = 6
	function pA(e) {
		return (function (t) {
			Ve(n, t)
			function n(r) {
				var i = t.call(this, r) || this
				return (
					(i.showTooltip = function (a) {
						var o = i.props.item.tooltip
						if (!i.props.disabled && o) {
							var s = i.getBound(a),
								l = s.left + Qj + "px",
								u = s.top + Qj + "px"
							gs(i.props.tooltipRef.current, { display: "block", left: l, top: u }),
								(i.props.tooltipRef.current.querySelector(".text").textContent = o)
						}
					}),
					(i.hideTooltip = function () {
						gs(i.props.tooltipRef.current, "display", "none")
					}),
					(i.state = { active: !1, disabled: r.disabled }),
					i.addEvent(),
					i
				)
			}
			return (
				(n.prototype.addEvent = function () {
					var r = this,
						i = this.props,
						a = i.item,
						o = i.eventEmitter
					a.state &&
						o.listen("changeToolbarState", function (s) {
							var l,
								u = s.toolbarState,
								d = (l = u[a.state]) !== null && l !== void 0 ? l : {},
								p = d.active,
								m = d.disabled
							r.setState({ active: !!p, disabled: m ?? r.props.disabled })
						})
				}),
				(n.prototype.getBound = function (r) {
					var i = iz(r, ls(r, "." + Qe("toolbar"))),
						a = i.offsetLeft,
						o = i.offsetTop
					return { left: a, top: r.offsetHeight + o }
				}),
				(n.prototype.render = function () {
					return Pt(
						Xj ||
							(Xj = Lt(
								[
									`
        <`,
									`
          ...`,
									`
          active=`,
									`
          showTooltip=`,
									`
          hideTooltip=`,
									`
          getBound=`,
									`
          disabled=`,
									`
        />
      `,
								],
								[
									`
        <`,
									`
          ...`,
									`
          active=`,
									`
          showTooltip=`,
									`
          hideTooltip=`,
									`
          getBound=`,
									`
          disabled=`,
									`
        />
      `,
								],
							)),
						e,
						this.props,
						this.state.active,
						this.showTooltip,
						this.hideTooltip,
						this.getBound,
						this.state.disabled || this.props.disabled,
					)
				}),
				n
			)
		})(ai)
	}
	var Xj,
		Sst = 80,
		Dst = (function (e) {
			Ve(t, e)
			function t() {
				var n = (e !== null && e.apply(this, arguments)) || this
				return (
					(n.showTooltip = function () {
						n.props.showTooltip(n.refs.el)
					}),
					(n.execCommand = function () {
						var r = n.props,
							i = r.item,
							a = r.execCommand,
							o = r.setPopupInfo,
							s = r.getBound,
							l = r.eventEmitter,
							u = i.command,
							d = i.name,
							p = i.popup
						if (u) a(u)
						else {
							var m = p ? "customPopupBody" : d,
								v = l.emit("query", "getPopupInitialValues", { popupName: m })[0],
								y = fA(m, { el: n.refs.el, pos: s(n.refs.el), popup: p, initialValues: v })
							y && o(y)
						}
					}),
					n
				)
			}
			return (
				(t.prototype.mounted = function () {
					this.setItemWidth()
				}),
				(t.prototype.updated = function (n) {
					n.item.name !== this.props.item.name && this.setItemWidth()
				}),
				(t.prototype.setItemWidth = function () {
					var n = this.props,
						r = n.setItemWidth,
						i = n.item
					r && r(i.name, GO(this.refs.el) + (i.hidden ? Sst : 0))
				}),
				(t.prototype.render = function () {
					var n = this,
						r = this.props,
						i = r.hideTooltip,
						a = r.disabled,
						o = r.item,
						s = r.active,
						l = me({ display: o.hidden ? "none" : null }, o.style),
						u = "" + (o.className || "") + (s ? " active" : "")
					return Pt(
						Jj ||
							(Jj = Lt(
								[
									`
      <button
        ref=`,
									`
        type="button"
        style=`,
									`
        class=`,
									`
        onClick=`,
									`
        onMouseover=`,
									`
        onMouseout=`,
									`
        disabled=`,
									`
        aria-label=`,
									`
      >
        `,
									`
      </button>
    `,
								],
								[
									`
      <button
        ref=`,
									`
        type="button"
        style=`,
									`
        class=`,
									`
        onClick=`,
									`
        onMouseover=`,
									`
        onMouseout=`,
									`
        disabled=`,
									`
        aria-label=`,
									`
      >
        `,
									`
      </button>
    `,
								],
							)),
						function (d) {
							return (n.refs.el = d)
						},
						l,
						u,
						this.execCommand,
						this.showTooltip,
						i,
						!!a,
						o.text || o.tooltip || "",
						o.text || "",
					)
				}),
				t
			)
		})(ai),
		_st = pA(Dst),
		Jj,
		Ost = (function (e) {
			Ve(t, e)
			function t() {
				var n = (e !== null && e.apply(this, arguments)) || this
				return (
					(n.showTooltip = function () {
						n.props.showTooltip(n.refs.el)
					}),
					(n.showPopup = function () {
						var r = fA("customPopupBody", {
							el: n.refs.el,
							pos: n.props.getBound(n.refs.el),
							popup: n.props.item.popup,
						})
						r && n.props.setPopupInfo(r)
					}),
					n
				)
			}
			return (
				(t.prototype.mounted = function () {
					var n = this.props,
						r = n.setItemWidth,
						i = n.item
					this.refs.el.appendChild(i.el),
						r && r(i.name, GO(this.refs.el)),
						i.onMounted && i.onMounted(this.props.execCommand)
				}),
				(t.prototype.updated = function (n) {
					var r,
						i = this.props,
						a = i.item,
						o = i.active,
						s = i.disabled
					;(n.active !== o || n.disabled !== s) &&
						((r = a.onUpdated) === null || r === void 0 || r.call(a, { active: o, disabled: s }))
				}),
				(t.prototype.render = function () {
					var n = this,
						r = this.props,
						i = r.disabled,
						a = r.item,
						o = { display: a.hidden ? "none" : "inline-block" },
						s = function (l) {
							return i ? null : l
						}
					return Pt(
						Zj ||
							(Zj = Lt(
								[
									`
      <div
        ref=`,
									`
        style=`,
									`
        class=`,
									`
        onClick=`,
									`
        onMouseover=`,
									`
        onMouseout=`,
									`
      ></div>
    `,
								],
								[
									`
      <div
        ref=`,
									`
        style=`,
									`
        class=`,
									`
        onClick=`,
									`
        onMouseover=`,
									`
        onMouseout=`,
									`
      ></div>
    `,
								],
							)),
						function (l) {
							return (n.refs.el = l)
						},
						o,
						Qe("toolbar-item-wrapper"),
						s(this.showPopup),
						s(this.showTooltip),
						s(this.props.hideTooltip),
					)
				}),
				t
			)
		})(ai),
		Ast = pA(Ost),
		Zj,
		Bq = (function (e) {
			Ve(t, e)
			function t() {
				return (e !== null && e.apply(this, arguments)) || this
			}
			return (
				(t.prototype.render = function () {
					var n = this,
						r = this.props,
						i = r.group,
						a = r.hiddenDivider,
						o = i.hidden ? { display: "none" } : null,
						s = a ? { display: "none" } : null
					return Pt(
						t6 ||
							(t6 = Lt(
								[
									`
      <div class="`,
									'" style=',
									`>
        `,
									`
        <div class="`,
									'" style=',
									`></div>
      </div>
    `,
								],
								[
									`
      <div class="`,
									'" style=',
									`>
        `,
									`
        <div class="`,
									'" style=',
									`></div>
      </div>
    `,
								],
							)),
						Qe("toolbar-group"),
						o,
						i.map(function (l) {
							var u = l.el ? Ast : _st
							return Pt(
								e6 ||
									(e6 = Lt(
										["<", " key=", " ...", " item=", " />"],
										["<", " key=", " ...", " item=", " />"],
									)),
								u,
								l.name,
								n.props,
								l,
							)
						}),
						Qe("toolbar-divider"),
						s,
					)
				}),
				t
			)
		})(ai),
		e6,
		t6,
		Nst = 4,
		Mst = (function (e) {
			Ve(t, e)
			function t(n) {
				var r = e.call(this, n) || this
				return (
					(r.handleClickDocument = function (i) {
						var a = i.target
						!ls(a, "." + Qe("dropdown-toolbar")) &&
							!ls(a, ".more") &&
							r.setState({ showDropdown: !1, dropdownPos: null })
					}),
					(r.showTooltip = function () {
						r.props.showTooltip(r.refs.el)
					}),
					(r.state = { showDropdown: !1, dropdownPos: null }),
					r
				)
			}
			return (
				(t.prototype.getBound = function () {
					var n = this.props.getBound(this.refs.el)
					return (n.top += Nst), me(me({}, n), { left: null, right: 10 })
				}),
				(t.prototype.mounted = function () {
					document.addEventListener("click", this.handleClickDocument)
				}),
				(t.prototype.updated = function () {
					this.state.showDropdown &&
						!this.state.dropdownPos &&
						this.setState({ dropdownPos: this.getBound() })
				}),
				(t.prototype.beforeDestroy = function () {
					document.removeEventListener("click", this.handleClickDocument)
				}),
				(t.prototype.render = function () {
					var n = this,
						r = this.state,
						i = r.showDropdown,
						a = r.dropdownPos,
						o = this.props,
						s = o.disabled,
						l = o.item,
						u = o.items,
						d = o.hideTooltip,
						p = u.filter(function (y) {
							return !y.hidden
						}),
						m = p.length ? null : { display: "none" },
						v = i ? null : { display: "none" }
					return Pt(
						r6 ||
							(r6 = Lt(
								[
									`
      <div class="`,
									'" style=',
									`>
        <button
          ref=`,
									`
          type="button"
          class=`,
									`
          onClick=`,
									`
          onMouseover=`,
									`
          onMouseout=`,
									`
          disabled=`,
									`
        ></button>
        <div
          class="`,
									`"
          style=`,
									`
          ref=`,
									`
        >
          `,
									`
        </div>
      </div>
    `,
								],
								[
									`
      <div class="`,
									'" style=',
									`>
        <button
          ref=`,
									`
          type="button"
          class=`,
									`
          onClick=`,
									`
          onMouseover=`,
									`
          onMouseout=`,
									`
          disabled=`,
									`
        ></button>
        <div
          class="`,
									`"
          style=`,
									`
          ref=`,
									`
        >
          `,
									`
        </div>
      </div>
    `,
								],
							)),
						Qe("toolbar-group"),
						m,
						function (y) {
							return (n.refs.el = y)
						},
						l.className,
						function () {
							return n.setState({ showDropdown: !0 })
						},
						this.showTooltip,
						d,
						s,
						Qe("dropdown-toolbar"),
						me(me({}, v), a),
						function (y) {
							return (n.refs.dropdownEl = y)
						},
						p.length
							? p.map(function (y, b) {
									var x
									return Pt(
										n6 ||
											(n6 = Lt(
												[
													`
                  <`,
													`
                    group=`,
													`
                    hiddenDivider=`,
													`
                    ...`,
													`
                  />
                `,
												],
												[
													`
                  <`,
													`
                    group=`,
													`
                    hiddenDivider=`,
													`
                    ...`,
													`
                  />
                `,
												],
											)),
										Bq,
										y,
										b === p.length - 1 ||
											((x = p[b + 1]) === null || x === void 0 ? void 0 : x.hidden),
										n.props,
									)
							  })
							: null,
					)
				}),
				t
			)
		})(ai),
		Ist = pA(Mst),
		n6,
		r6,
		Rst = 50,
		Lst = (function (e) {
			Ve(t, e)
			function t(n) {
				var r = e.call(this, n) || this
				return (
					(r.toggleTab = function (i, a) {
						var o = r.props.eventEmitter
						if (r.state.activeTab !== a) {
							var s = a === "write" ? "changePreviewTabWrite" : "changePreviewTabPreview"
							o.emit(s), r.setState({ activeTab: a })
						}
					}),
					(r.setItemWidth = function (i, a) {
						r.itemWidthMap[i] = a
					}),
					(r.setPopupInfo = function (i) {
						r.setState({ showPopup: !0, popupInfo: i })
					}),
					(r.openPopup = function (i, a) {
						a === void 0 && (a = {})
						var o = r.refs.el.querySelector("." + Qe("toolbar-group") + " ." + i)
						if (o) {
							var s = iz(o, ls(o, "." + Qe("toolbar"))),
								l = s.offsetLeft,
								u = s.offsetTop,
								d = fA(i, { el: o, pos: { left: l, top: o.offsetHeight + u }, initialValues: a })
							d && r.setPopupInfo(d)
						}
					}),
					(r.hidePopup = function () {
						r.state.showPopup && r.setState({ showPopup: !1 })
					}),
					(r.execCommand = function (i, a) {
						var o = r.props.eventEmitter
						o.emit("command", i, a), r.hidePopup()
					}),
					(r.tabs = [
						{ name: "write", text: "Write" },
						{ name: "preview", text: "Preview" },
					]),
					(r.itemWidthMap = {}),
					(r.initialItems = Est(n.toolbarItems || [], r.hiddenScrollSync())),
					(r.state = {
						items: r.initialItems,
						dropdownItems: [],
						showPopup: !1,
						popupInfo: {},
						activeTab: "write",
					}),
					(r.tooltipRef = { current: null }),
					(r.resizeObserver = new dst(function () {
						return r.handleResize()
					})),
					r.addEvent(),
					r
				)
			}
			return (
				(t.prototype.insertToolbarItem = function (n, r) {
					var i = n.groupIndex,
						a = n.itemIndex,
						o = this.initialItems[i]
					;(r = aD(r)),
						o ? o.splice(a, 0, r) : this.initialItems.push([r]),
						this.setState(this.classifyToolbarItems())
				}),
				(t.prototype.removeToolbarItem = function (n) {
					var r = this
					vp(this.initialItems, function (i) {
						var a = !1
						return (
							vp(i, function (o, s) {
								return o.name === n
									? ((a = !0), i.splice(s, 1), r.setState(r.classifyToolbarItems()), !1)
									: !0
							}),
							!a
						)
					})
				}),
				(t.prototype.addEvent = function () {
					var n = this,
						r = this.props.eventEmitter
					;(this.handleResize = Yot(function () {
						n.setState({ items: n.initialItems, dropdownItems: [] }),
							n.setState(n.classifyToolbarItems())
					}, 200)),
						r.listen("openPopup", this.openPopup)
				}),
				(t.prototype.appendTooltipToRoot = function () {
					var n =
						'<div class="' +
						Qe("tooltip") +
						`" style="display:none">
        <div class="arrow"></div>
        <span class="text"></span>
      </div>`
					this.tooltipRef.current = rz(n, this.refs.el)
				}),
				(t.prototype.hiddenScrollSync = function () {
					return this.props.editorType === "wysiwyg" || this.props.previewStyle === "tab"
				}),
				(t.prototype.movePrevItemToDropdownToolbar = function (n, r, i, a) {
					var o = function (l) {
						var u = l.pop()
						u && a.push(u)
					}
					if (n > 1) o(i)
					else {
						var s = ni(r)
						s && o(s)
					}
				}),
				(t.prototype.classifyToolbarItems = function () {
					var n = this,
						r = 0,
						i = this.refs.el.clientWidth,
						a = this.refs.el.querySelector("." + Qe("toolbar-divider")),
						o = a ? GO(a) : 0,
						s = [],
						l = [],
						u = !1
					return (
						this.initialItems.forEach(function (d, p) {
							var m = [],
								v = []
							d.forEach(function (y, b) {
								y.hidden ||
									((r += n.itemWidthMap[y.name]),
									r > i - Rst
										? (u || (n.movePrevItemToDropdownToolbar(b, s, m, v), (u = !0)), v.push(y))
										: m.push(y))
							}),
								m.length && (Nb(m), s.push(m)),
								v.length && (Nb(v), l.push(v)),
								p < n.state.items.length - 1 && (r += o)
						}),
						{ items: s, dropdownItems: l }
					)
				}),
				(t.prototype.mounted = function () {
					this.props.previewStyle === "tab" &&
						this.props.eventEmitter.emit("changePreviewTabWrite", !0),
						this.setState(this.classifyToolbarItems()),
						this.appendTooltipToRoot(),
						this.resizeObserver.observe(this.refs.el)
				}),
				(t.prototype.updated = function (n) {
					var r = this.props,
						i = r.editorType,
						a = r.previewStyle,
						o = r.eventEmitter,
						s = a !== n.previewStyle,
						l = i !== n.editorType
					if (s || l) {
						Cst(this.initialItems, this.hiddenScrollSync())
						var u = this.classifyToolbarItems()
						;(s || (a === "tab" && i === "markdown")) &&
							(o.emit("changePreviewTabWrite"), (u.activeTab = "write")),
							this.setState(u)
					}
				}),
				(t.prototype.beforeDestroy = function () {
					window.removeEventListener("resize", this.handleResize),
						this.resizeObserver.disconnect(),
						xd(this.tooltipRef.current)
				}),
				(t.prototype.render = function () {
					var n = this,
						r = this.props,
						i = r.previewStyle,
						a = r.eventEmitter,
						o = r.editorType,
						s = this.state,
						l = s.popupInfo,
						u = s.showPopup,
						d = s.activeTab,
						p = s.items,
						m = s.dropdownItems,
						v = {
							eventEmitter: a,
							tooltipRef: this.tooltipRef,
							disabled: o === "markdown" && i === "tab" && d === "preview",
							execCommand: this.execCommand,
							setPopupInfo: this.setPopupInfo,
						},
						y = i === "tab" ? { borderTopLeftRadius: 0 } : null
					return Pt(
						a6 ||
							(a6 = Lt(
								[
									`
      <div class="`,
									`">
        <div
          class="`,
									`"
          style="display: `,
									`"
        >
          <`,
									" tabs=",
									" activeTab=",
									" onClick=",
									` />
        </div>
        <div
          class="`,
									`"
          ref=`,
									`
          style=`,
									`
        >
          `,
									`
          <`,
									`
            item=`,
									`
            items=`,
									`
            ...`,
									`
          />
        </div>
        <`,
									`
          info=`,
									`
          show=`,
									`
          eventEmitter=`,
									`
          hidePopup=`,
									`
          execCommand=`,
									`
        />
      </div>
    `,
								],
								[
									`
      <div class="`,
									`">
        <div
          class="`,
									`"
          style="display: `,
									`"
        >
          <`,
									" tabs=",
									" activeTab=",
									" onClick=",
									` />
        </div>
        <div
          class="`,
									`"
          ref=`,
									`
          style=`,
									`
        >
          `,
									`
          <`,
									`
            item=`,
									`
            items=`,
									`
            ...`,
									`
          />
        </div>
        <`,
									`
          info=`,
									`
          show=`,
									`
          eventEmitter=`,
									`
          hidePopup=`,
									`
          execCommand=`,
									`
        />
      </div>
    `,
								],
							)),
						Qe("toolbar"),
						Qe("md-tab-container"),
						o === "wysiwyg" || i === "vertical" ? "none" : "block",
						Fq,
						this.tabs,
						d,
						this.toggleTab,
						Qe("defaultUI-toolbar"),
						function (b) {
							return (n.refs.el = b)
						},
						y,
						p.map(function (b, x) {
							var E
							return Pt(
								i6 ||
									(i6 = Lt(
										[
											`
              <`,
											`
                group=`,
											`
                hiddenDivider=`,
											`
                setItemWidth=`,
											`
                ...`,
											`
              />
            `,
										],
										[
											`
              <`,
											`
                group=`,
											`
                hiddenDivider=`,
											`
                setItemWidth=`,
											`
                ...`,
											`
              />
            `,
										],
									)),
								Bq,
								b,
								x === p.length - 1 || ((E = p[x + 1]) === null || E === void 0 ? void 0 : E.hidden),
								n.setItemWidth,
								v,
							)
						}),
						Ist,
						aD("more"),
						m,
						v,
						kst,
						l,
						u,
						a,
						this.hidePopup,
						this.execCommand,
					)
				}),
				t
			)
		})(ai),
		i6,
		a6,
		Pst = (function (e) {
			Ve(t, e)
			function t(n) {
				var r = e.call(this, n) || this
				return (
					(r.handleClickDocument = function (i) {
						ls(i.target, "." + Qe("context-menu")) || r.setState({ pos: null })
					}),
					(r.state = { pos: null, menuGroups: [] }),
					r.addEvent(),
					r
				)
			}
			return (
				(t.prototype.addEvent = function () {
					var n = this
					this.props.eventEmitter.listen("contextmenu", function (r) {
						var i = r.pos,
							a = r.menuGroups
						n.setState({ pos: i, menuGroups: a })
					})
				}),
				(t.prototype.mounted = function () {
					document.addEventListener("click", this.handleClickDocument)
				}),
				(t.prototype.beforeDestroy = function () {
					document.removeEventListener("click", this.handleClickDocument)
				}),
				(t.prototype.getMenuGroupElements = function () {
					var n = this,
						r = this.state,
						i = r.pos,
						a = r.menuGroups
					return i
						? a.reduce(function (o, s) {
								var l = []
								return (
									s.forEach(function (u) {
										var d = u.label,
											p = u.className,
											m = p === void 0 ? !1 : p,
											v = u.disabled,
											y = u.onClick,
											b = function () {
												v || (y(), n.setState({ pos: null }))
											}
										l.push(
											Pt(
												o6 ||
													(o6 = Lt(
														[
															`
                <li
                  onClick=`,
															`
                  class="menu-item`,
															`"
                  aria-role="menuitem"
                >
                  <span class="`,
															'">',
															`</span>
                </li>
              `,
														],
														[
															`
                <li
                  onClick=`,
															`
                  class="menu-item`,
															`"
                  aria-role="menuitem"
                >
                  <span class="`,
															'">',
															`</span>
                </li>
              `,
														],
													)),
												b,
												v ? " disabled" : "",
												m,
												d,
											),
										)
									}),
									o.push(
										Pt(
											s6 ||
												(s6 = Lt(
													[
														`<ul class="menu-group">
              `,
														`
            </ul>`,
													],
													[
														`<ul class="menu-group">
              `,
														`
            </ul>`,
													],
												)),
											l,
										),
									),
									o
								)
						  }, [])
						: []
				}),
				(t.prototype.render = function () {
					var n = me({ display: this.state.pos ? "block" : "none" }, this.state.pos)
					return Pt(
						l6 ||
							(l6 = Lt(
								[
									'<div class="',
									'" style=',
									` aria-role="menu">
      `,
									`
    </div>`,
								],
								[
									'<div class="',
									'" style=',
									` aria-role="menu">
      `,
									`
    </div>`,
								],
							)),
						Qe("context-menu"),
						n,
						this.getMenuGroupElements(),
					)
				}),
				t
			)
		})(ai),
		o6,
		s6,
		l6,
		jst = (function (e) {
			Ve(t, e)
			function t(n) {
				var r = e.call(this, n) || this
				;(r.changeMode = function (o) {
					o !== r.state.editorType && r.setState({ editorType: o })
				}),
					(r.changePreviewStyle = function (o) {
						o !== r.state.previewStyle && r.setState({ previewStyle: o })
					}),
					(r.hide = function () {
						r.setState({ hide: !0 })
					}),
					(r.show = function () {
						r.setState({ hide: !1 })
					})
				var i = n.editorType,
					a = n.previewStyle
				return (r.state = { editorType: i, previewStyle: a, hide: !1 }), r.addEvent(), r
			}
			return (
				(t.prototype.mounted = function () {
					var n = this.props.slots,
						r = n.wwEditor,
						i = n.mdEditor,
						a = n.mdPreview
					this.refs.wwContainer.appendChild(r),
						this.refs.mdContainer.insertAdjacentElement("afterbegin", i),
						this.refs.mdContainer.appendChild(a)
				}),
				(t.prototype.insertToolbarItem = function (n, r) {
					this.toolbar.insertToolbarItem(n, r)
				}),
				(t.prototype.removeToolbarItem = function (n) {
					this.toolbar.removeToolbarItem(n)
				}),
				(t.prototype.render = function () {
					var n = this,
						r = this.props,
						i = r.eventEmitter,
						a = r.hideModeSwitch,
						o = r.toolbarItems,
						s = r.theme,
						l = this.state,
						u = l.hide,
						d = l.previewStyle,
						p = l.editorType,
						m = u ? " hidden" : "",
						v = Qe(p === "markdown" ? "md-mode" : "ww-mode"),
						y = Qe("md") + "-" + d + "-style",
						b = Qe([s !== "light", s + " "])
					return Pt(
						c6 ||
							(c6 = Lt(
								[
									`
      <div
        class="`,
									"",
									"",
									`"
        ref=`,
									`
      >
        <`,
									`
          ref=`,
									`
          eventEmitter=`,
									`
          previewStyle=`,
									`
          toolbarItems=`,
									`
          editorType=`,
									`
        />
        <div
          class="`,
									" ",
									`"
          ref=`,
									`
        >
          <div class="`,
									`">
            <div
              class="`,
									" ",
									`"
              ref=`,
									`
            >
              <div class="`,
									`"></div>
            </div>
            <div
              class="`,
									`"
              ref=`,
									`
            />
          </div>
        </div>
        `,
									`
        <`,
									" eventEmitter=",
									` />
      </div>
    `,
								],
								[
									`
      <div
        class="`,
									"",
									"",
									`"
        ref=`,
									`
      >
        <`,
									`
          ref=`,
									`
          eventEmitter=`,
									`
          previewStyle=`,
									`
          toolbarItems=`,
									`
          editorType=`,
									`
        />
        <div
          class="`,
									" ",
									`"
          ref=`,
									`
        >
          <div class="`,
									`">
            <div
              class="`,
									" ",
									`"
              ref=`,
									`
            >
              <div class="`,
									`"></div>
            </div>
            <div
              class="`,
									`"
              ref=`,
									`
            />
          </div>
        </div>
        `,
									`
        <`,
									" eventEmitter=",
									` />
      </div>
    `,
								],
							)),
						b,
						Qe("defaultUI"),
						m,
						function (x) {
							return (n.refs.el = x)
						},
						Lst,
						function (x) {
							return (n.toolbar = x)
						},
						i,
						d,
						o,
						p,
						Qe("main"),
						v,
						function (x) {
							return (n.refs.editorSection = x)
						},
						Qe("main-container"),
						Qe("md-container"),
						y,
						function (x) {
							return (n.refs.mdContainer = x)
						},
						Qe("md-splitter"),
						Qe("ww-container"),
						function (x) {
							return (n.refs.wwContainer = x)
						},
						!a &&
							Pt(
								u6 ||
									(u6 = Lt(
										["<", " eventEmitter=", " editorType=", " />"],
										["<", " eventEmitter=", " editorType=", " />"],
									)),
								Uot,
								i,
								p,
							),
						Pst,
						i,
					)
				}),
				(t.prototype.addEvent = function () {
					var n = this.props.eventEmitter
					n.listen("hide", this.hide),
						n.listen("show", this.show),
						n.listen("changeMode", this.changeMode),
						n.listen("changePreviewStyle", this.changePreviewStyle)
				}),
				t
			)
		})(ai),
		u6,
		c6,
		Hq = (function (e) {
			Ve(t, e)
			function t(n) {
				var r,
					i = e.call(this, n) || this,
					a,
					o = $ot(
						i.options.el,
						Pt(
							d6 ||
								(d6 = Lt(
									[
										`
        <`,
										`
          ref=`,
										`
          eventEmitter=`,
										`
          slots=`,
										`
          hideModeSwitch=`,
										`
          toolbarItems=`,
										`
          previewStyle=`,
										`
          editorType=`,
										`
          theme=`,
										`
        />
      `,
									],
									[
										`
        <`,
										`
          ref=`,
										`
          eventEmitter=`,
										`
          slots=`,
										`
          hideModeSwitch=`,
										`
          toolbarItems=`,
										`
          previewStyle=`,
										`
          editorType=`,
										`
          theme=`,
										`
        />
      `,
									],
								)),
							jst,
							function (s) {
								return (a = s)
							},
							i.eventEmitter,
							i.getEditorElements(),
							i.options.hideModeSwitch,
							i.options.toolbarItems,
							i.options.previewStyle,
							i.options.initialEditType,
							i.options.theme,
						),
					)
				return (
					i.setMinHeight(i.options.minHeight),
					i.setHeight(i.options.height),
					(i.defaultUI = {
						insertToolbarItem: a.insertToolbarItem.bind(a),
						removeToolbarItem: a.removeToolbarItem.bind(a),
						destroy: o,
					}),
					(r = i.pluginInfo.toolbarItems) === null ||
						r === void 0 ||
						r.forEach(function (s) {
							var l = s.groupIndex,
								u = s.itemIndex,
								d = s.item
							i.defaultUI.insertToolbarItem({ groupIndex: l, itemIndex: u }, d)
						}),
					i.eventEmitter.emit("loadUI", i),
					i
				)
			}
			return (
				(t.factory = function (n) {
					return n.viewer ? new Dq(n) : new t(n)
				}),
				(t.prototype.insertToolbarItem = function (n, r) {
					this.defaultUI.insertToolbarItem(n, r)
				}),
				(t.prototype.removeToolbarItem = function (n) {
					this.defaultUI.removeToolbarItem(n)
				}),
				(t.prototype.destroy = function () {
					e.prototype.destroy.call(this), this.defaultUI.destroy()
				}),
				t
			)
		})(Oq),
		d6
	Oq.setLanguage(["en", "en-US"], {
		Markdown: "Markdown",
		WYSIWYG: "WYSIWYG",
		Write: "Write",
		Preview: "Preview",
		Headings: "Headings",
		Paragraph: "Paragraph",
		Bold: "Bold",
		Italic: "Italic",
		Strike: "Strike",
		Code: "Inline code",
		Line: "Line",
		Blockquote: "Blockquote",
		"Unordered list": "Unordered list",
		"Ordered list": "Ordered list",
		Task: "Task",
		Indent: "Indent",
		Outdent: "Outdent",
		"Insert link": "Insert link",
		"Insert CodeBlock": "Insert codeBlock",
		"Insert table": "Insert table",
		"Insert image": "Insert image",
		Heading: "Heading",
		"Image URL": "Image URL",
		"Select image file": "Select image file",
		"Choose a file": "Choose a file",
		"No file": "No file",
		Description: "Description",
		OK: "OK",
		More: "More",
		Cancel: "Cancel",
		File: "File",
		URL: "URL",
		"Link text": "Link text",
		"Add row to up": "Add row to up",
		"Add row to down": "Add row to down",
		"Add column to left": "Add column to left",
		"Add column to right": "Add column to right",
		"Remove row": "Remove row",
		"Remove column": "Remove column",
		"Align column to left": "Align column to left",
		"Align column to center": "Align column to center",
		"Align column to right": "Align column to right",
		"Remove table": "Remove table",
		"Would you like to paste as table?": "Would you like to paste as table?",
		"Text color": "Text color",
		"Auto scroll enabled": "Auto scroll enabled",
		"Auto scroll disabled": "Auto scroll disabled",
		"Choose language": "Choose language",
	})
	/**
	 * TOAST UI Editor : React Wrapper
	 * @version 3.2.3 | Mon Dec 02 2024
	 * @author NHN Cloud FE Development Lab <dl_javascript@nhn.com>
	 * @license MIT
	 */ var oD = function (e, t) {
		return (
			(oD =
				Object.setPrototypeOf ||
				({ __proto__: [] } instanceof Array &&
					function (n, r) {
						n.__proto__ = r
					}) ||
				function (n, r) {
					for (var i in r) Object.prototype.hasOwnProperty.call(r, i) && (n[i] = r[i])
				}),
			oD(e, t)
		)
	}
	function Fst(e, t) {
		if (typeof t != "function" && t !== null)
			throw new TypeError("Class extends value " + String(t) + " is not a constructor or null")
		oD(e, t)
		function n() {
			this.constructor = e
		}
		e.prototype = t === null ? Object.create(t) : ((n.prototype = t.prototype), new n())
	}
	var kp = function () {
		return (
			(kp =
				Object.assign ||
				function (t) {
					for (var n, r = 1, i = arguments.length; r < i; r++) {
						n = arguments[r]
						for (var a in n) Object.prototype.hasOwnProperty.call(n, a) && (t[a] = n[a])
					}
					return t
				}),
			kp.apply(this, arguments)
		)
	}
	function Bst(e) {
		var t = _.useRef(null),
			n = _.useRef(null)
		return (
			_.useEffect(function () {
				t.current &&
					(n.current = new Hq(
						kp(kp({}, e), { el: t.current, usageStatistics: !1, events: $st(e) }),
					))
			}, []),
			_.useEffect(
				function () {
					var r, i
					e.height && ((r = n.current) === null || r === void 0 || r.setHeight(e.height)),
						e.previewStyle &&
							((i = n.current) === null || i === void 0 || i.changePreviewStyle(e.previewStyle)),
						n.current && Hst(n.current, e)
				},
				[e],
			),
			H.createElement("div", { ref: t })
		)
	}
	function $q(e) {
		return Object.keys(e)
			.filter(function (t) {
				return /^on[A-Z][a-zA-Z]+/.test(t)
			})
			.filter(function (t) {
				return e[t]
			})
	}
	function Hst(e, t) {
		$q(t).forEach(function (n) {
			var r = n[2].toLowerCase() + n.slice(3)
			e.off(r), e.on(r, t[n])
		})
	}
	function $st(e) {
		return $q(e).reduce(function (t, n) {
			var r = n[2].toLowerCase() + n.slice(3)
			return (t[r] = e[n]), t
		}, {})
	}
	;(function (e) {
		Fst(t, e)
		function t() {
			var n = (e !== null && e.apply(this, arguments)) || this
			return (n.rootEl = H.createRef()), n
		}
		return (
			(t.prototype.getRootElement = function () {
				return this.rootEl.current
			}),
			(t.prototype.getInstance = function () {
				return this.viewerInst
			}),
			(t.prototype.getBindingEventNames = function () {
				var n = this
				return Object.keys(this.props)
					.filter(function (r) {
						return /^on[A-Z][a-zA-Z]+/.test(r)
					})
					.filter(function (r) {
						return n.props[r]
					})
			}),
			(t.prototype.bindEventHandlers = function (n) {
				var r = this
				this.getBindingEventNames().forEach(function (i) {
					var a = i[2].toLowerCase() + i.slice(3)
					r.viewerInst.off(a), r.viewerInst.on(a, n[i])
				})
			}),
			(t.prototype.getInitEvents = function () {
				var n = this
				return this.getBindingEventNames().reduce(function (r, i) {
					var a = i[2].toLowerCase() + i.slice(3)
					return (r[a] = n.props[i]), r
				}, {})
			}),
			(t.prototype.componentDidMount = function () {
				this.viewerInst = new Hq(
					kp(kp({ el: this.rootEl.current }, this.props), { events: this.getInitEvents() }),
				)
			}),
			(t.prototype.shouldComponentUpdate = function (n) {
				return this.bindEventHandlers(n), !1
			}),
			(t.prototype.render = function () {
				return H.createElement("div", { ref: this.rootEl })
			}),
			t
		)
	})(H.Component)
	function Ust(e) {
		const { text: t, onSubmit: n, ...r } = e,
			i = H.useRef(),
			a = () => {
				var s
				const o = ((s = i.current) == null ? void 0 : s.getInstance().getMarkdown()) || t
				n(o)
			}
		return h.jsx(Bst, {
			initialValue: t,
			previewStyle: "tab",
			initialEditType: "wysiwyg",
			onChange: a,
			toolbarItems: [
				["heading", "bold", "italic", "strike"],
				["hr", "quote"],
				["ul", "ol", "task", "indent", "outdent"],
				["table", "image", "link"],
			],
			ref: i,
			...r,
		})
	}
	function _s(e) {
		const { setFieldValue: t } = Bx(),
			[n] = bH(e),
			r = (i) => {
				t(n.name, i)
			}
		return h.jsx(Ust, { text: n.value, onSubmit: r, height: e.height || "300px" })
	}
	function lr(e) {
		const t = Nr((r) => r.app),
			n = e.busy !== void 0 ? e.busy : t.isBusy
		return h.jsxs(Ge, {
			variant: "secondary",
			type: "submit",
			size: "sm",
			disabled: n,
			children: [
				n
					? h.jsx(Qv, { animation: "border", variant: "light", size: "sm" })
					: h.jsx(Rme, { color: "whitesmoke" }),
				" ",
				"Save",
			],
		})
	}
	const zst = Bt({ title: Oe().max(120).required() }),
		qst = (e) => {
			const { pageContent: t, onClose: n } = e,
				[r, { isLoading: i }] = uve(),
				a = async (o) => {
					const s = o.prepJson()
					await r(s)
						.unwrap()
						.then(() => {
							je.success(`${t.title} has been saved.`), n()
						})
						.catch((l) => {
							je.error(" " + l)
						})
				}
			return h.jsxs("div", {
				children: [
					h.jsx(cg, { loading: i }),
					h.jsx(Vt, {
						validationSchema: zst,
						onSubmit: a,
						initialValues: t,
						children: ({
							handleSubmit: o,
							handleChange: s,
							handleBlur: l,
							values: u,
							touched: d,
							errors: p,
						}) =>
							h.jsxs(R, {
								noValidate: !0,
								onSubmit: o,
								children: [
									h.jsxs(R.Group, {
										controlId: "title",
										children: [
											h.jsx(R.Label, { children: "Title" }),
											h.jsx(R.Control, {
												name: "title",
												placeholder: "Title",
												value: u.title,
												isValid: d.title && !p.title,
												isInvalid: !!p.title,
												onChange: s,
												onBlur: l,
											}),
											h.jsx(R.Control.Feedback, { type: "invalid", children: p.title }),
										],
									}),
									h.jsxs(R.Group, {
										controlId: "description",
										children: [
											h.jsx(R.Label, { children: "Text" }),
											h.jsx(_s, { name: "content", value: u.content, height: "300px" }),
										],
									}),
									h.jsx(lr, {}),
								],
							}),
					}),
				],
			})
		}
	function f6(e) {
		const t = [],
			n = String(e || "")
		let r = n.indexOf(","),
			i = 0,
			a = !1
		for (; !a; ) {
			r === -1 && ((r = n.length), (a = !0))
			const o = n.slice(i, r).trim()
			;(o || !a) && t.push(o), (i = r + 1), (r = n.indexOf(",", i))
		}
		return t
	}
	function Uq(e, t) {
		const n = {}
		return (e[e.length - 1] === "" ? [...e, ""] : e)
			.join((n.padRight ? " " : "") + "," + (n.padLeft === !1 ? "" : " "))
			.trim()
	}
	const Vst = /^[$_\p{ID_Start}][$_\u{200C}\u{200D}\p{ID_Continue}]*$/u,
		Wst = /^[$_\p{ID_Start}][-$_\u{200C}\u{200D}\p{ID_Continue}]*$/u,
		Yst = {}
	function p6(e, t) {
		return (Yst.jsx ? Wst : Vst).test(e)
	}
	const Gst = /[ \t\n\f\r]/g
	function Kst(e) {
		return typeof e == "object" ? (e.type === "text" ? h6(e.value) : !1) : h6(e)
	}
	function h6(e) {
		return e.replace(Gst, "") === ""
	}
	class vg {
		constructor(t, n, r) {
			;(this.property = t), (this.normal = n), r && (this.space = r)
		}
	}
	vg.prototype.property = {}
	vg.prototype.normal = {}
	vg.prototype.space = null
	function zq(e, t) {
		const n = {},
			r = {}
		let i = -1
		for (; ++i < e.length; ) Object.assign(n, e[i].property), Object.assign(r, e[i].normal)
		return new vg(n, r, t)
	}
	function Nv(e) {
		return e.toLowerCase()
	}
	class to {
		constructor(t, n) {
			;(this.property = t), (this.attribute = n)
		}
	}
	to.prototype.space = null
	to.prototype.boolean = !1
	to.prototype.booleanish = !1
	to.prototype.overloadedBoolean = !1
	to.prototype.number = !1
	to.prototype.commaSeparated = !1
	to.prototype.spaceSeparated = !1
	to.prototype.commaOrSpaceSeparated = !1
	to.prototype.mustUseProperty = !1
	to.prototype.defined = !1
	let Qst = 0
	const gt = Rd(),
		rr = Rd(),
		qq = Rd(),
		Ne = Rd(),
		pn = Rd(),
		Kf = Rd(),
		ta = Rd()
	function Rd() {
		return 2 ** ++Qst
	}
	const sD = Object.freeze(
			Object.defineProperty(
				{
					__proto__: null,
					boolean: gt,
					booleanish: rr,
					commaOrSpaceSeparated: ta,
					commaSeparated: Kf,
					number: Ne,
					overloadedBoolean: qq,
					spaceSeparated: pn,
				},
				Symbol.toStringTag,
				{ value: "Module" },
			),
		),
		Fk = Object.keys(sD)
	class hA extends to {
		constructor(t, n, r, i) {
			let a = -1
			if ((super(t, n), m6(this, "space", i), typeof r == "number"))
				for (; ++a < Fk.length; ) {
					const o = Fk[a]
					m6(this, Fk[a], (r & sD[o]) === sD[o])
				}
		}
	}
	hA.prototype.defined = !0
	function m6(e, t, n) {
		n && (e[t] = n)
	}
	const Xst = {}.hasOwnProperty
	function nh(e) {
		const t = {},
			n = {}
		let r
		for (r in e.properties)
			if (Xst.call(e.properties, r)) {
				const i = e.properties[r],
					a = new hA(r, e.transform(e.attributes || {}, r), i, e.space)
				e.mustUseProperty && e.mustUseProperty.includes(r) && (a.mustUseProperty = !0),
					(t[r] = a),
					(n[Nv(r)] = r),
					(n[Nv(a.attribute)] = r)
			}
		return new vg(t, n, e.space)
	}
	const Vq = nh({
			space: "xlink",
			transform(e, t) {
				return "xlink:" + t.slice(5).toLowerCase()
			},
			properties: {
				xLinkActuate: null,
				xLinkArcRole: null,
				xLinkHref: null,
				xLinkRole: null,
				xLinkShow: null,
				xLinkTitle: null,
				xLinkType: null,
			},
		}),
		Wq = nh({
			space: "xml",
			transform(e, t) {
				return "xml:" + t.slice(3).toLowerCase()
			},
			properties: { xmlLang: null, xmlBase: null, xmlSpace: null },
		})
	function Yq(e, t) {
		return t in e ? e[t] : t
	}
	function Gq(e, t) {
		return Yq(e, t.toLowerCase())
	}
	const Kq = nh({
			space: "xmlns",
			attributes: { xmlnsxlink: "xmlns:xlink" },
			transform: Gq,
			properties: { xmlns: null, xmlnsXLink: null },
		}),
		Qq = nh({
			transform(e, t) {
				return t === "role" ? t : "aria-" + t.slice(4).toLowerCase()
			},
			properties: {
				ariaActiveDescendant: null,
				ariaAtomic: rr,
				ariaAutoComplete: null,
				ariaBusy: rr,
				ariaChecked: rr,
				ariaColCount: Ne,
				ariaColIndex: Ne,
				ariaColSpan: Ne,
				ariaControls: pn,
				ariaCurrent: null,
				ariaDescribedBy: pn,
				ariaDetails: null,
				ariaDisabled: rr,
				ariaDropEffect: pn,
				ariaErrorMessage: null,
				ariaExpanded: rr,
				ariaFlowTo: pn,
				ariaGrabbed: rr,
				ariaHasPopup: null,
				ariaHidden: rr,
				ariaInvalid: null,
				ariaKeyShortcuts: null,
				ariaLabel: null,
				ariaLabelledBy: pn,
				ariaLevel: Ne,
				ariaLive: null,
				ariaModal: rr,
				ariaMultiLine: rr,
				ariaMultiSelectable: rr,
				ariaOrientation: null,
				ariaOwns: pn,
				ariaPlaceholder: null,
				ariaPosInSet: Ne,
				ariaPressed: rr,
				ariaReadOnly: rr,
				ariaRelevant: null,
				ariaRequired: rr,
				ariaRoleDescription: pn,
				ariaRowCount: Ne,
				ariaRowIndex: Ne,
				ariaRowSpan: Ne,
				ariaSelected: rr,
				ariaSetSize: Ne,
				ariaSort: null,
				ariaValueMax: Ne,
				ariaValueMin: Ne,
				ariaValueNow: Ne,
				ariaValueText: null,
				role: null,
			},
		}),
		Jst = nh({
			space: "html",
			attributes: {
				acceptcharset: "accept-charset",
				classname: "class",
				htmlfor: "for",
				httpequiv: "http-equiv",
			},
			transform: Gq,
			mustUseProperty: ["checked", "multiple", "muted", "selected"],
			properties: {
				abbr: null,
				accept: Kf,
				acceptCharset: pn,
				accessKey: pn,
				action: null,
				allow: null,
				allowFullScreen: gt,
				allowPaymentRequest: gt,
				allowUserMedia: gt,
				alt: null,
				as: null,
				async: gt,
				autoCapitalize: null,
				autoComplete: pn,
				autoFocus: gt,
				autoPlay: gt,
				blocking: pn,
				capture: null,
				charSet: null,
				checked: gt,
				cite: null,
				className: pn,
				cols: Ne,
				colSpan: null,
				content: null,
				contentEditable: rr,
				controls: gt,
				controlsList: pn,
				coords: Ne | Kf,
				crossOrigin: null,
				data: null,
				dateTime: null,
				decoding: null,
				default: gt,
				defer: gt,
				dir: null,
				dirName: null,
				disabled: gt,
				download: qq,
				draggable: rr,
				encType: null,
				enterKeyHint: null,
				fetchPriority: null,
				form: null,
				formAction: null,
				formEncType: null,
				formMethod: null,
				formNoValidate: gt,
				formTarget: null,
				headers: pn,
				height: Ne,
				hidden: gt,
				high: Ne,
				href: null,
				hrefLang: null,
				htmlFor: pn,
				httpEquiv: pn,
				id: null,
				imageSizes: null,
				imageSrcSet: null,
				inert: gt,
				inputMode: null,
				integrity: null,
				is: null,
				isMap: gt,
				itemId: null,
				itemProp: pn,
				itemRef: pn,
				itemScope: gt,
				itemType: pn,
				kind: null,
				label: null,
				lang: null,
				language: null,
				list: null,
				loading: null,
				loop: gt,
				low: Ne,
				manifest: null,
				max: null,
				maxLength: Ne,
				media: null,
				method: null,
				min: null,
				minLength: Ne,
				multiple: gt,
				muted: gt,
				name: null,
				nonce: null,
				noModule: gt,
				noValidate: gt,
				onAbort: null,
				onAfterPrint: null,
				onAuxClick: null,
				onBeforeMatch: null,
				onBeforePrint: null,
				onBeforeToggle: null,
				onBeforeUnload: null,
				onBlur: null,
				onCancel: null,
				onCanPlay: null,
				onCanPlayThrough: null,
				onChange: null,
				onClick: null,
				onClose: null,
				onContextLost: null,
				onContextMenu: null,
				onContextRestored: null,
				onCopy: null,
				onCueChange: null,
				onCut: null,
				onDblClick: null,
				onDrag: null,
				onDragEnd: null,
				onDragEnter: null,
				onDragExit: null,
				onDragLeave: null,
				onDragOver: null,
				onDragStart: null,
				onDrop: null,
				onDurationChange: null,
				onEmptied: null,
				onEnded: null,
				onError: null,
				onFocus: null,
				onFormData: null,
				onHashChange: null,
				onInput: null,
				onInvalid: null,
				onKeyDown: null,
				onKeyPress: null,
				onKeyUp: null,
				onLanguageChange: null,
				onLoad: null,
				onLoadedData: null,
				onLoadedMetadata: null,
				onLoadEnd: null,
				onLoadStart: null,
				onMessage: null,
				onMessageError: null,
				onMouseDown: null,
				onMouseEnter: null,
				onMouseLeave: null,
				onMouseMove: null,
				onMouseOut: null,
				onMouseOver: null,
				onMouseUp: null,
				onOffline: null,
				onOnline: null,
				onPageHide: null,
				onPageShow: null,
				onPaste: null,
				onPause: null,
				onPlay: null,
				onPlaying: null,
				onPopState: null,
				onProgress: null,
				onRateChange: null,
				onRejectionHandled: null,
				onReset: null,
				onResize: null,
				onScroll: null,
				onScrollEnd: null,
				onSecurityPolicyViolation: null,
				onSeeked: null,
				onSeeking: null,
				onSelect: null,
				onSlotChange: null,
				onStalled: null,
				onStorage: null,
				onSubmit: null,
				onSuspend: null,
				onTimeUpdate: null,
				onToggle: null,
				onUnhandledRejection: null,
				onUnload: null,
				onVolumeChange: null,
				onWaiting: null,
				onWheel: null,
				open: gt,
				optimum: Ne,
				pattern: null,
				ping: pn,
				placeholder: null,
				playsInline: gt,
				popover: null,
				popoverTarget: null,
				popoverTargetAction: null,
				poster: null,
				preload: null,
				readOnly: gt,
				referrerPolicy: null,
				rel: pn,
				required: gt,
				reversed: gt,
				rows: Ne,
				rowSpan: Ne,
				sandbox: pn,
				scope: null,
				scoped: gt,
				seamless: gt,
				selected: gt,
				shadowRootClonable: gt,
				shadowRootDelegatesFocus: gt,
				shadowRootMode: null,
				shape: null,
				size: Ne,
				sizes: null,
				slot: null,
				span: Ne,
				spellCheck: rr,
				src: null,
				srcDoc: null,
				srcLang: null,
				srcSet: null,
				start: Ne,
				step: null,
				style: null,
				tabIndex: Ne,
				target: null,
				title: null,
				translate: null,
				type: null,
				typeMustMatch: gt,
				useMap: null,
				value: rr,
				width: Ne,
				wrap: null,
				writingSuggestions: null,
				align: null,
				aLink: null,
				archive: pn,
				axis: null,
				background: null,
				bgColor: null,
				border: Ne,
				borderColor: null,
				bottomMargin: Ne,
				cellPadding: null,
				cellSpacing: null,
				char: null,
				charOff: null,
				classId: null,
				clear: null,
				code: null,
				codeBase: null,
				codeType: null,
				color: null,
				compact: gt,
				declare: gt,
				event: null,
				face: null,
				frame: null,
				frameBorder: null,
				hSpace: Ne,
				leftMargin: Ne,
				link: null,
				longDesc: null,
				lowSrc: null,
				marginHeight: Ne,
				marginWidth: Ne,
				noResize: gt,
				noHref: gt,
				noShade: gt,
				noWrap: gt,
				object: null,
				profile: null,
				prompt: null,
				rev: null,
				rightMargin: Ne,
				rules: null,
				scheme: null,
				scrolling: rr,
				standby: null,
				summary: null,
				text: null,
				topMargin: Ne,
				valueType: null,
				version: null,
				vAlign: null,
				vLink: null,
				vSpace: Ne,
				allowTransparency: null,
				autoCorrect: null,
				autoSave: null,
				disablePictureInPicture: gt,
				disableRemotePlayback: gt,
				prefix: null,
				property: null,
				results: Ne,
				security: null,
				unselectable: null,
			},
		}),
		Zst = nh({
			space: "svg",
			attributes: {
				accentHeight: "accent-height",
				alignmentBaseline: "alignment-baseline",
				arabicForm: "arabic-form",
				baselineShift: "baseline-shift",
				capHeight: "cap-height",
				className: "class",
				clipPath: "clip-path",
				clipRule: "clip-rule",
				colorInterpolation: "color-interpolation",
				colorInterpolationFilters: "color-interpolation-filters",
				colorProfile: "color-profile",
				colorRendering: "color-rendering",
				crossOrigin: "crossorigin",
				dataType: "datatype",
				dominantBaseline: "dominant-baseline",
				enableBackground: "enable-background",
				fillOpacity: "fill-opacity",
				fillRule: "fill-rule",
				floodColor: "flood-color",
				floodOpacity: "flood-opacity",
				fontFamily: "font-family",
				fontSize: "font-size",
				fontSizeAdjust: "font-size-adjust",
				fontStretch: "font-stretch",
				fontStyle: "font-style",
				fontVariant: "font-variant",
				fontWeight: "font-weight",
				glyphName: "glyph-name",
				glyphOrientationHorizontal: "glyph-orientation-horizontal",
				glyphOrientationVertical: "glyph-orientation-vertical",
				hrefLang: "hreflang",
				horizAdvX: "horiz-adv-x",
				horizOriginX: "horiz-origin-x",
				horizOriginY: "horiz-origin-y",
				imageRendering: "image-rendering",
				letterSpacing: "letter-spacing",
				lightingColor: "lighting-color",
				markerEnd: "marker-end",
				markerMid: "marker-mid",
				markerStart: "marker-start",
				navDown: "nav-down",
				navDownLeft: "nav-down-left",
				navDownRight: "nav-down-right",
				navLeft: "nav-left",
				navNext: "nav-next",
				navPrev: "nav-prev",
				navRight: "nav-right",
				navUp: "nav-up",
				navUpLeft: "nav-up-left",
				navUpRight: "nav-up-right",
				onAbort: "onabort",
				onActivate: "onactivate",
				onAfterPrint: "onafterprint",
				onBeforePrint: "onbeforeprint",
				onBegin: "onbegin",
				onCancel: "oncancel",
				onCanPlay: "oncanplay",
				onCanPlayThrough: "oncanplaythrough",
				onChange: "onchange",
				onClick: "onclick",
				onClose: "onclose",
				onCopy: "oncopy",
				onCueChange: "oncuechange",
				onCut: "oncut",
				onDblClick: "ondblclick",
				onDrag: "ondrag",
				onDragEnd: "ondragend",
				onDragEnter: "ondragenter",
				onDragExit: "ondragexit",
				onDragLeave: "ondragleave",
				onDragOver: "ondragover",
				onDragStart: "ondragstart",
				onDrop: "ondrop",
				onDurationChange: "ondurationchange",
				onEmptied: "onemptied",
				onEnd: "onend",
				onEnded: "onended",
				onError: "onerror",
				onFocus: "onfocus",
				onFocusIn: "onfocusin",
				onFocusOut: "onfocusout",
				onHashChange: "onhashchange",
				onInput: "oninput",
				onInvalid: "oninvalid",
				onKeyDown: "onkeydown",
				onKeyPress: "onkeypress",
				onKeyUp: "onkeyup",
				onLoad: "onload",
				onLoadedData: "onloadeddata",
				onLoadedMetadata: "onloadedmetadata",
				onLoadStart: "onloadstart",
				onMessage: "onmessage",
				onMouseDown: "onmousedown",
				onMouseEnter: "onmouseenter",
				onMouseLeave: "onmouseleave",
				onMouseMove: "onmousemove",
				onMouseOut: "onmouseout",
				onMouseOver: "onmouseover",
				onMouseUp: "onmouseup",
				onMouseWheel: "onmousewheel",
				onOffline: "onoffline",
				onOnline: "ononline",
				onPageHide: "onpagehide",
				onPageShow: "onpageshow",
				onPaste: "onpaste",
				onPause: "onpause",
				onPlay: "onplay",
				onPlaying: "onplaying",
				onPopState: "onpopstate",
				onProgress: "onprogress",
				onRateChange: "onratechange",
				onRepeat: "onrepeat",
				onReset: "onreset",
				onResize: "onresize",
				onScroll: "onscroll",
				onSeeked: "onseeked",
				onSeeking: "onseeking",
				onSelect: "onselect",
				onShow: "onshow",
				onStalled: "onstalled",
				onStorage: "onstorage",
				onSubmit: "onsubmit",
				onSuspend: "onsuspend",
				onTimeUpdate: "ontimeupdate",
				onToggle: "ontoggle",
				onUnload: "onunload",
				onVolumeChange: "onvolumechange",
				onWaiting: "onwaiting",
				onZoom: "onzoom",
				overlinePosition: "overline-position",
				overlineThickness: "overline-thickness",
				paintOrder: "paint-order",
				panose1: "panose-1",
				pointerEvents: "pointer-events",
				referrerPolicy: "referrerpolicy",
				renderingIntent: "rendering-intent",
				shapeRendering: "shape-rendering",
				stopColor: "stop-color",
				stopOpacity: "stop-opacity",
				strikethroughPosition: "strikethrough-position",
				strikethroughThickness: "strikethrough-thickness",
				strokeDashArray: "stroke-dasharray",
				strokeDashOffset: "stroke-dashoffset",
				strokeLineCap: "stroke-linecap",
				strokeLineJoin: "stroke-linejoin",
				strokeMiterLimit: "stroke-miterlimit",
				strokeOpacity: "stroke-opacity",
				strokeWidth: "stroke-width",
				tabIndex: "tabindex",
				textAnchor: "text-anchor",
				textDecoration: "text-decoration",
				textRendering: "text-rendering",
				transformOrigin: "transform-origin",
				typeOf: "typeof",
				underlinePosition: "underline-position",
				underlineThickness: "underline-thickness",
				unicodeBidi: "unicode-bidi",
				unicodeRange: "unicode-range",
				unitsPerEm: "units-per-em",
				vAlphabetic: "v-alphabetic",
				vHanging: "v-hanging",
				vIdeographic: "v-ideographic",
				vMathematical: "v-mathematical",
				vectorEffect: "vector-effect",
				vertAdvY: "vert-adv-y",
				vertOriginX: "vert-origin-x",
				vertOriginY: "vert-origin-y",
				wordSpacing: "word-spacing",
				writingMode: "writing-mode",
				xHeight: "x-height",
				playbackOrder: "playbackorder",
				timelineBegin: "timelinebegin",
			},
			transform: Yq,
			properties: {
				about: ta,
				accentHeight: Ne,
				accumulate: null,
				additive: null,
				alignmentBaseline: null,
				alphabetic: Ne,
				amplitude: Ne,
				arabicForm: null,
				ascent: Ne,
				attributeName: null,
				attributeType: null,
				azimuth: Ne,
				bandwidth: null,
				baselineShift: null,
				baseFrequency: null,
				baseProfile: null,
				bbox: null,
				begin: null,
				bias: Ne,
				by: null,
				calcMode: null,
				capHeight: Ne,
				className: pn,
				clip: null,
				clipPath: null,
				clipPathUnits: null,
				clipRule: null,
				color: null,
				colorInterpolation: null,
				colorInterpolationFilters: null,
				colorProfile: null,
				colorRendering: null,
				content: null,
				contentScriptType: null,
				contentStyleType: null,
				crossOrigin: null,
				cursor: null,
				cx: null,
				cy: null,
				d: null,
				dataType: null,
				defaultAction: null,
				descent: Ne,
				diffuseConstant: Ne,
				direction: null,
				display: null,
				dur: null,
				divisor: Ne,
				dominantBaseline: null,
				download: gt,
				dx: null,
				dy: null,
				edgeMode: null,
				editable: null,
				elevation: Ne,
				enableBackground: null,
				end: null,
				event: null,
				exponent: Ne,
				externalResourcesRequired: null,
				fill: null,
				fillOpacity: Ne,
				fillRule: null,
				filter: null,
				filterRes: null,
				filterUnits: null,
				floodColor: null,
				floodOpacity: null,
				focusable: null,
				focusHighlight: null,
				fontFamily: null,
				fontSize: null,
				fontSizeAdjust: null,
				fontStretch: null,
				fontStyle: null,
				fontVariant: null,
				fontWeight: null,
				format: null,
				fr: null,
				from: null,
				fx: null,
				fy: null,
				g1: Kf,
				g2: Kf,
				glyphName: Kf,
				glyphOrientationHorizontal: null,
				glyphOrientationVertical: null,
				glyphRef: null,
				gradientTransform: null,
				gradientUnits: null,
				handler: null,
				hanging: Ne,
				hatchContentUnits: null,
				hatchUnits: null,
				height: null,
				href: null,
				hrefLang: null,
				horizAdvX: Ne,
				horizOriginX: Ne,
				horizOriginY: Ne,
				id: null,
				ideographic: Ne,
				imageRendering: null,
				initialVisibility: null,
				in: null,
				in2: null,
				intercept: Ne,
				k: Ne,
				k1: Ne,
				k2: Ne,
				k3: Ne,
				k4: Ne,
				kernelMatrix: ta,
				kernelUnitLength: null,
				keyPoints: null,
				keySplines: null,
				keyTimes: null,
				kerning: null,
				lang: null,
				lengthAdjust: null,
				letterSpacing: null,
				lightingColor: null,
				limitingConeAngle: Ne,
				local: null,
				markerEnd: null,
				markerMid: null,
				markerStart: null,
				markerHeight: null,
				markerUnits: null,
				markerWidth: null,
				mask: null,
				maskContentUnits: null,
				maskUnits: null,
				mathematical: null,
				max: null,
				media: null,
				mediaCharacterEncoding: null,
				mediaContentEncodings: null,
				mediaSize: Ne,
				mediaTime: null,
				method: null,
				min: null,
				mode: null,
				name: null,
				navDown: null,
				navDownLeft: null,
				navDownRight: null,
				navLeft: null,
				navNext: null,
				navPrev: null,
				navRight: null,
				navUp: null,
				navUpLeft: null,
				navUpRight: null,
				numOctaves: null,
				observer: null,
				offset: null,
				onAbort: null,
				onActivate: null,
				onAfterPrint: null,
				onBeforePrint: null,
				onBegin: null,
				onCancel: null,
				onCanPlay: null,
				onCanPlayThrough: null,
				onChange: null,
				onClick: null,
				onClose: null,
				onCopy: null,
				onCueChange: null,
				onCut: null,
				onDblClick: null,
				onDrag: null,
				onDragEnd: null,
				onDragEnter: null,
				onDragExit: null,
				onDragLeave: null,
				onDragOver: null,
				onDragStart: null,
				onDrop: null,
				onDurationChange: null,
				onEmptied: null,
				onEnd: null,
				onEnded: null,
				onError: null,
				onFocus: null,
				onFocusIn: null,
				onFocusOut: null,
				onHashChange: null,
				onInput: null,
				onInvalid: null,
				onKeyDown: null,
				onKeyPress: null,
				onKeyUp: null,
				onLoad: null,
				onLoadedData: null,
				onLoadedMetadata: null,
				onLoadStart: null,
				onMessage: null,
				onMouseDown: null,
				onMouseEnter: null,
				onMouseLeave: null,
				onMouseMove: null,
				onMouseOut: null,
				onMouseOver: null,
				onMouseUp: null,
				onMouseWheel: null,
				onOffline: null,
				onOnline: null,
				onPageHide: null,
				onPageShow: null,
				onPaste: null,
				onPause: null,
				onPlay: null,
				onPlaying: null,
				onPopState: null,
				onProgress: null,
				onRateChange: null,
				onRepeat: null,
				onReset: null,
				onResize: null,
				onScroll: null,
				onSeeked: null,
				onSeeking: null,
				onSelect: null,
				onShow: null,
				onStalled: null,
				onStorage: null,
				onSubmit: null,
				onSuspend: null,
				onTimeUpdate: null,
				onToggle: null,
				onUnload: null,
				onVolumeChange: null,
				onWaiting: null,
				onZoom: null,
				opacity: null,
				operator: null,
				order: null,
				orient: null,
				orientation: null,
				origin: null,
				overflow: null,
				overlay: null,
				overlinePosition: Ne,
				overlineThickness: Ne,
				paintOrder: null,
				panose1: null,
				path: null,
				pathLength: Ne,
				patternContentUnits: null,
				patternTransform: null,
				patternUnits: null,
				phase: null,
				ping: pn,
				pitch: null,
				playbackOrder: null,
				pointerEvents: null,
				points: null,
				pointsAtX: Ne,
				pointsAtY: Ne,
				pointsAtZ: Ne,
				preserveAlpha: null,
				preserveAspectRatio: null,
				primitiveUnits: null,
				propagate: null,
				property: ta,
				r: null,
				radius: null,
				referrerPolicy: null,
				refX: null,
				refY: null,
				rel: ta,
				rev: ta,
				renderingIntent: null,
				repeatCount: null,
				repeatDur: null,
				requiredExtensions: ta,
				requiredFeatures: ta,
				requiredFonts: ta,
				requiredFormats: ta,
				resource: null,
				restart: null,
				result: null,
				rotate: null,
				rx: null,
				ry: null,
				scale: null,
				seed: null,
				shapeRendering: null,
				side: null,
				slope: null,
				snapshotTime: null,
				specularConstant: Ne,
				specularExponent: Ne,
				spreadMethod: null,
				spacing: null,
				startOffset: null,
				stdDeviation: null,
				stemh: null,
				stemv: null,
				stitchTiles: null,
				stopColor: null,
				stopOpacity: null,
				strikethroughPosition: Ne,
				strikethroughThickness: Ne,
				string: null,
				stroke: null,
				strokeDashArray: ta,
				strokeDashOffset: null,
				strokeLineCap: null,
				strokeLineJoin: null,
				strokeMiterLimit: Ne,
				strokeOpacity: Ne,
				strokeWidth: null,
				style: null,
				surfaceScale: Ne,
				syncBehavior: null,
				syncBehaviorDefault: null,
				syncMaster: null,
				syncTolerance: null,
				syncToleranceDefault: null,
				systemLanguage: ta,
				tabIndex: Ne,
				tableValues: null,
				target: null,
				targetX: Ne,
				targetY: Ne,
				textAnchor: null,
				textDecoration: null,
				textRendering: null,
				textLength: null,
				timelineBegin: null,
				title: null,
				transformBehavior: null,
				type: null,
				typeOf: ta,
				to: null,
				transform: null,
				transformOrigin: null,
				u1: null,
				u2: null,
				underlinePosition: Ne,
				underlineThickness: Ne,
				unicode: null,
				unicodeBidi: null,
				unicodeRange: null,
				unitsPerEm: Ne,
				values: null,
				vAlphabetic: Ne,
				vMathematical: Ne,
				vectorEffect: null,
				vHanging: Ne,
				vIdeographic: Ne,
				version: null,
				vertAdvY: Ne,
				vertOriginX: Ne,
				vertOriginY: Ne,
				viewBox: null,
				viewTarget: null,
				visibility: null,
				width: null,
				widths: null,
				wordSpacing: null,
				writingMode: null,
				x: null,
				x1: null,
				x2: null,
				xChannelSelector: null,
				xHeight: Ne,
				y: null,
				y1: null,
				y2: null,
				yChannelSelector: null,
				z: null,
				zoomAndPan: null,
			},
		}),
		elt = /^data[-\w.:]+$/i,
		v6 = /-[a-z]/g,
		tlt = /[A-Z]/g
	function bw(e, t) {
		const n = Nv(t)
		let r = t,
			i = to
		if (n in e.normal) return e.property[e.normal[n]]
		if (n.length > 4 && n.slice(0, 4) === "data" && elt.test(t)) {
			if (t.charAt(4) === "-") {
				const a = t.slice(5).replace(v6, rlt)
				r = "data" + a.charAt(0).toUpperCase() + a.slice(1)
			} else {
				const a = t.slice(4)
				if (!v6.test(a)) {
					let o = a.replace(tlt, nlt)
					o.charAt(0) !== "-" && (o = "-" + o), (t = "data" + o)
				}
			}
			i = hA
		}
		return new i(r, t)
	}
	function nlt(e) {
		return "-" + e.toLowerCase()
	}
	function rlt(e) {
		return e.charAt(1).toUpperCase()
	}
	const ilt = {
			classId: "classID",
			dataType: "datatype",
			itemId: "itemID",
			strokeDashArray: "strokeDasharray",
			strokeDashOffset: "strokeDashoffset",
			strokeLineCap: "strokeLinecap",
			strokeLineJoin: "strokeLinejoin",
			strokeMiterLimit: "strokeMiterlimit",
			typeOf: "typeof",
			xLinkActuate: "xlinkActuate",
			xLinkArcRole: "xlinkArcrole",
			xLinkHref: "xlinkHref",
			xLinkRole: "xlinkRole",
			xLinkShow: "xlinkShow",
			xLinkTitle: "xlinkTitle",
			xLinkType: "xlinkType",
			xmlnsXLink: "xmlnsXlink",
		},
		gg = zq([Wq, Vq, Kq, Qq, Jst], "html"),
		Zu = zq([Wq, Vq, Kq, Qq, Zst], "svg")
	function g6(e) {
		const t = String(e || "").trim()
		return t ? t.split(/[ \t\n\r\f]+/g) : []
	}
	function Xq(e) {
		return e.join(" ").trim()
	}
	var Cf = {},
		Bk,
		y6
	function alt() {
		if (y6) return Bk
		y6 = 1
		var e = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g,
			t = /\n/g,
			n = /^\s*/,
			r = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/,
			i = /^:\s*/,
			a = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/,
			o = /^[;\s]*/,
			s = /^\s+|\s+$/g,
			l = `
`,
			u = "/",
			d = "*",
			p = "",
			m = "comment",
			v = "declaration"
		Bk = function (b, x) {
			if (typeof b != "string") throw new TypeError("First argument must be a string")
			if (!b) return []
			x = x || {}
			var E = 1,
				T = 1
			function C(V) {
				var K = V.match(t)
				K && (E += K.length)
				var ne = V.lastIndexOf(l)
				T = ~ne ? V.length - ne : T + V.length
			}
			function D() {
				var V = { line: E, column: T }
				return function (K) {
					return (K.position = new O(V)), I(), K
				}
			}
			function O(V) {
				;(this.start = V), (this.end = { line: E, column: T }), (this.source = x.source)
			}
			O.prototype.content = b
			function A(V) {
				var K = new Error(x.source + ":" + E + ":" + T + ": " + V)
				if (
					((K.reason = V),
					(K.filename = x.source),
					(K.line = E),
					(K.column = T),
					(K.source = b),
					!x.silent)
				)
					throw K
			}
			function N(V) {
				var K = V.exec(b)
				if (K) {
					var ne = K[0]
					return C(ne), (b = b.slice(ne.length)), K
				}
			}
			function I() {
				N(n)
			}
			function P(V) {
				var K
				for (V = V || []; (K = L()); ) K !== !1 && V.push(K)
				return V
			}
			function L() {
				var V = D()
				if (!(u != b.charAt(0) || d != b.charAt(1))) {
					for (var K = 2; p != b.charAt(K) && (d != b.charAt(K) || u != b.charAt(K + 1)); ) ++K
					if (((K += 2), p === b.charAt(K - 1))) return A("End of comment missing")
					var ne = b.slice(2, K - 2)
					return (T += 2), C(ne), (b = b.slice(K)), (T += 2), V({ type: m, comment: ne })
				}
			}
			function B() {
				var V = D(),
					K = N(r)
				if (K) {
					if ((L(), !N(i))) return A("property missing ':'")
					var ne = N(a),
						re = V({
							type: v,
							property: y(K[0].replace(e, p)),
							value: ne ? y(ne[0].replace(e, p)) : p,
						})
					return N(o), re
				}
			}
			function z() {
				var V = []
				P(V)
				for (var K; (K = B()); ) K !== !1 && (V.push(K), P(V))
				return V
			}
			return I(), z()
		}
		function y(b) {
			return b ? b.replace(s, p) : p
		}
		return Bk
	}
	var b6
	function olt() {
		if (b6) return Cf
		b6 = 1
		var e =
			(Cf && Cf.__importDefault) ||
			function (r) {
				return r && r.__esModule ? r : { default: r }
			}
		Object.defineProperty(Cf, "__esModule", { value: !0 }), (Cf.default = n)
		var t = e(alt())
		function n(r, i) {
			var a = null
			if (!r || typeof r != "string") return a
			var o = (0, t.default)(r),
				s = typeof i == "function"
			return (
				o.forEach(function (l) {
					if (l.type === "declaration") {
						var u = l.property,
							d = l.value
						s ? i(u, d, l) : d && ((a = a || {}), (a[u] = d))
					}
				}),
				a
			)
		}
		return Cf
	}
	var slt = olt()
	const x6 = Ti(slt),
		llt = x6.default || x6,
		xw = Jq("end"),
		Os = Jq("start")
	function Jq(e) {
		return t
		function t(n) {
			const r = (n && n.position && n.position[e]) || {}
			if (typeof r.line == "number" && r.line > 0 && typeof r.column == "number" && r.column > 0)
				return {
					line: r.line,
					column: r.column,
					offset: typeof r.offset == "number" && r.offset > -1 ? r.offset : void 0,
				}
		}
	}
	function ult(e) {
		const t = Os(e),
			n = xw(e)
		if (t && n) return { start: t, end: n }
	}
	function Wm(e) {
		return !e || typeof e != "object"
			? ""
			: "position" in e || "type" in e
			? w6(e.position)
			: "start" in e || "end" in e
			? w6(e)
			: "line" in e || "column" in e
			? lD(e)
			: ""
	}
	function lD(e) {
		return E6(e && e.line) + ":" + E6(e && e.column)
	}
	function w6(e) {
		return lD(e && e.start) + "-" + lD(e && e.end)
	}
	function E6(e) {
		return e && typeof e == "number" ? e : 1
	}
	class oi extends Error {
		constructor(t, n, r) {
			super(), typeof n == "string" && ((r = n), (n = void 0))
			let i = "",
				a = {},
				o = !1
			if (
				(n &&
					("line" in n && "column" in n
						? (a = { place: n })
						: "start" in n && "end" in n
						? (a = { place: n })
						: "type" in n
						? (a = { ancestors: [n], place: n.position })
						: (a = { ...n })),
				typeof t == "string"
					? (i = t)
					: !a.cause && t && ((o = !0), (i = t.message), (a.cause = t)),
				!a.ruleId && !a.source && typeof r == "string")
			) {
				const l = r.indexOf(":")
				l === -1 ? (a.ruleId = r) : ((a.source = r.slice(0, l)), (a.ruleId = r.slice(l + 1)))
			}
			if (!a.place && a.ancestors && a.ancestors) {
				const l = a.ancestors[a.ancestors.length - 1]
				l && (a.place = l.position)
			}
			const s = a.place && "start" in a.place ? a.place.start : a.place
			;(this.ancestors = a.ancestors || void 0),
				(this.cause = a.cause || void 0),
				(this.column = s ? s.column : void 0),
				(this.fatal = void 0),
				this.file,
				(this.message = i),
				(this.line = s ? s.line : void 0),
				(this.name = Wm(a.place) || "1:1"),
				(this.place = a.place || void 0),
				(this.reason = this.message),
				(this.ruleId = a.ruleId || void 0),
				(this.source = a.source || void 0),
				(this.stack = o && a.cause && typeof a.cause.stack == "string" ? a.cause.stack : ""),
				this.actual,
				this.expected,
				this.note,
				this.url
		}
	}
	oi.prototype.file = ""
	oi.prototype.name = ""
	oi.prototype.reason = ""
	oi.prototype.message = ""
	oi.prototype.stack = ""
	oi.prototype.column = void 0
	oi.prototype.line = void 0
	oi.prototype.ancestors = void 0
	oi.prototype.cause = void 0
	oi.prototype.fatal = void 0
	oi.prototype.place = void 0
	oi.prototype.ruleId = void 0
	oi.prototype.source = void 0
	const mA = {}.hasOwnProperty,
		clt = new Map(),
		dlt = /[A-Z]/g,
		flt = /-([a-z])/g,
		plt = new Set(["table", "tbody", "thead", "tfoot", "tr"]),
		hlt = new Set(["td", "th"]),
		Zq = "https://github.com/syntax-tree/hast-util-to-jsx-runtime"
	function mlt(e, t) {
		if (!t || t.Fragment === void 0) throw new TypeError("Expected `Fragment` in options")
		const n = t.filePath || void 0
		let r
		if (t.development) {
			if (typeof t.jsxDEV != "function")
				throw new TypeError("Expected `jsxDEV` in options when `development: true`")
			r = Clt(n, t.jsxDEV)
		} else {
			if (typeof t.jsx != "function") throw new TypeError("Expected `jsx` in production options")
			if (typeof t.jsxs != "function") throw new TypeError("Expected `jsxs` in production options")
			r = Elt(n, t.jsx, t.jsxs)
		}
		const i = {
				Fragment: t.Fragment,
				ancestors: [],
				components: t.components || {},
				create: r,
				elementAttributeNameCase: t.elementAttributeNameCase || "react",
				evaluater: t.createEvaluater ? t.createEvaluater() : void 0,
				filePath: n,
				ignoreInvalidStyle: t.ignoreInvalidStyle || !1,
				passKeys: t.passKeys !== !1,
				passNode: t.passNode || !1,
				schema: t.space === "svg" ? Zu : gg,
				stylePropertyNameCase: t.stylePropertyNameCase || "dom",
				tableCellAlignToStyle: t.tableCellAlignToStyle !== !1,
			},
			a = eV(i, e, void 0)
		return a && typeof a != "string"
			? a
			: i.create(e, i.Fragment, { children: a || void 0 }, void 0)
	}
	function eV(e, t, n) {
		if (t.type === "element") return vlt(e, t, n)
		if (t.type === "mdxFlowExpression" || t.type === "mdxTextExpression") return glt(e, t)
		if (t.type === "mdxJsxFlowElement" || t.type === "mdxJsxTextElement") return blt(e, t, n)
		if (t.type === "mdxjsEsm") return ylt(e, t)
		if (t.type === "root") return xlt(e, t, n)
		if (t.type === "text") return wlt(e, t)
	}
	function vlt(e, t, n) {
		const r = e.schema
		let i = r
		t.tagName.toLowerCase() === "svg" && r.space === "html" && ((i = Zu), (e.schema = i)),
			e.ancestors.push(t)
		const a = nV(e, t.tagName, !1),
			o = Tlt(e, t)
		let s = gA(e, t)
		return (
			plt.has(t.tagName) &&
				(s = s.filter(function (l) {
					return typeof l == "string" ? !Kst(l) : !0
				})),
			tV(e, o, a, t),
			vA(o, s),
			e.ancestors.pop(),
			(e.schema = r),
			e.create(t, a, o, n)
		)
	}
	function glt(e, t) {
		if (t.data && t.data.estree && e.evaluater) {
			const r = t.data.estree.body[0]
			return r.type, e.evaluater.evaluateExpression(r.expression)
		}
		Mv(e, t.position)
	}
	function ylt(e, t) {
		if (t.data && t.data.estree && e.evaluater) return e.evaluater.evaluateProgram(t.data.estree)
		Mv(e, t.position)
	}
	function blt(e, t, n) {
		const r = e.schema
		let i = r
		t.name === "svg" && r.space === "html" && ((i = Zu), (e.schema = i)), e.ancestors.push(t)
		const a = t.name === null ? e.Fragment : nV(e, t.name, !0),
			o = klt(e, t),
			s = gA(e, t)
		return tV(e, o, a, t), vA(o, s), e.ancestors.pop(), (e.schema = r), e.create(t, a, o, n)
	}
	function xlt(e, t, n) {
		const r = {}
		return vA(r, gA(e, t)), e.create(t, e.Fragment, r, n)
	}
	function wlt(e, t) {
		return t.value
	}
	function tV(e, t, n, r) {
		typeof n != "string" && n !== e.Fragment && e.passNode && (t.node = r)
	}
	function vA(e, t) {
		if (t.length > 0) {
			const n = t.length > 1 ? t : t[0]
			n && (e.children = n)
		}
	}
	function Elt(e, t, n) {
		return r
		function r(i, a, o, s) {
			const u = Array.isArray(o.children) ? n : t
			return s ? u(a, o, s) : u(a, o)
		}
	}
	function Clt(e, t) {
		return n
		function n(r, i, a, o) {
			const s = Array.isArray(a.children),
				l = Os(r)
			return t(
				i,
				a,
				o,
				s,
				{ columnNumber: l ? l.column - 1 : void 0, fileName: e, lineNumber: l ? l.line : void 0 },
				void 0,
			)
		}
	}
	function Tlt(e, t) {
		const n = {}
		let r, i
		for (i in t.properties)
			if (i !== "children" && mA.call(t.properties, i)) {
				const a = Slt(e, i, t.properties[i])
				if (a) {
					const [o, s] = a
					e.tableCellAlignToStyle && o === "align" && typeof s == "string" && hlt.has(t.tagName)
						? (r = s)
						: (n[o] = s)
				}
			}
		if (r) {
			const a = n.style || (n.style = {})
			a[e.stylePropertyNameCase === "css" ? "text-align" : "textAlign"] = r
		}
		return n
	}
	function klt(e, t) {
		const n = {}
		for (const r of t.attributes)
			if (r.type === "mdxJsxExpressionAttribute")
				if (r.data && r.data.estree && e.evaluater) {
					const a = r.data.estree.body[0]
					a.type
					const o = a.expression
					o.type
					const s = o.properties[0]
					s.type, Object.assign(n, e.evaluater.evaluateExpression(s.argument))
				} else Mv(e, t.position)
			else {
				const i = r.name
				let a
				if (r.value && typeof r.value == "object")
					if (r.value.data && r.value.data.estree && e.evaluater) {
						const s = r.value.data.estree.body[0]
						s.type, (a = e.evaluater.evaluateExpression(s.expression))
					} else Mv(e, t.position)
				else a = r.value === null ? !0 : r.value
				n[i] = a
			}
		return n
	}
	function gA(e, t) {
		const n = []
		let r = -1
		const i = e.passKeys ? new Map() : clt
		for (; ++r < t.children.length; ) {
			const a = t.children[r]
			let o
			if (e.passKeys) {
				const l =
					a.type === "element"
						? a.tagName
						: a.type === "mdxJsxFlowElement" || a.type === "mdxJsxTextElement"
						? a.name
						: void 0
				if (l) {
					const u = i.get(l) || 0
					;(o = l + "-" + u), i.set(l, u + 1)
				}
			}
			const s = eV(e, a, o)
			s !== void 0 && n.push(s)
		}
		return n
	}
	function Slt(e, t, n) {
		const r = bw(e.schema, t)
		if (!(n == null || (typeof n == "number" && Number.isNaN(n)))) {
			if ((Array.isArray(n) && (n = r.commaSeparated ? Uq(n) : Xq(n)), r.property === "style")) {
				let i = typeof n == "object" ? n : Dlt(e, String(n))
				return e.stylePropertyNameCase === "css" && (i = _lt(i)), ["style", i]
			}
			return [
				e.elementAttributeNameCase === "react" && r.space
					? ilt[r.property] || r.property
					: r.attribute,
				n,
			]
		}
	}
	function Dlt(e, t) {
		const n = {}
		try {
			llt(t, r)
		} catch (i) {
			if (!e.ignoreInvalidStyle) {
				const a = i,
					o = new oi("Cannot parse `style` attribute", {
						ancestors: e.ancestors,
						cause: a,
						ruleId: "style",
						source: "hast-util-to-jsx-runtime",
					})
				throw ((o.file = e.filePath || void 0), (o.url = Zq + "#cannot-parse-style-attribute"), o)
			}
		}
		return n
		function r(i, a) {
			let o = i
			o.slice(0, 2) !== "--" &&
				(o.slice(0, 4) === "-ms-" && (o = "ms-" + o.slice(4)), (o = o.replace(flt, Alt))),
				(n[o] = a)
		}
	}
	function nV(e, t, n) {
		let r
		if (!n) r = { type: "Literal", value: t }
		else if (t.includes(".")) {
			const i = t.split(".")
			let a = -1,
				o
			for (; ++a < i.length; ) {
				const s = p6(i[a]) ? { type: "Identifier", name: i[a] } : { type: "Literal", value: i[a] }
				o = o
					? {
							type: "MemberExpression",
							object: o,
							property: s,
							computed: !!(a && s.type === "Literal"),
							optional: !1,
					  }
					: s
			}
			r = o
		} else
			r =
				p6(t) && !/^[a-z]/.test(t) ? { type: "Identifier", name: t } : { type: "Literal", value: t }
		if (r.type === "Literal") {
			const i = r.value
			return mA.call(e.components, i) ? e.components[i] : i
		}
		if (e.evaluater) return e.evaluater.evaluateExpression(r)
		Mv(e)
	}
	function Mv(e, t) {
		const n = new oi("Cannot handle MDX estrees without `createEvaluater`", {
			ancestors: e.ancestors,
			place: t,
			ruleId: "mdx-estree",
			source: "hast-util-to-jsx-runtime",
		})
		throw (
			((n.file = e.filePath || void 0),
			(n.url = Zq + "#cannot-handle-mdx-estrees-without-createevaluater"),
			n)
		)
	}
	function _lt(e) {
		const t = {}
		let n
		for (n in e) mA.call(e, n) && (t[Olt(n)] = e[n])
		return t
	}
	function Olt(e) {
		let t = e.replace(dlt, Nlt)
		return t.slice(0, 3) === "ms-" && (t = "-" + t), t
	}
	function Alt(e, t) {
		return t.toUpperCase()
	}
	function Nlt(e) {
		return "-" + e.toLowerCase()
	}
	const Hk = {
			action: ["form"],
			cite: ["blockquote", "del", "ins", "q"],
			data: ["object"],
			formAction: ["button", "input"],
			href: ["a", "area", "base", "link"],
			icon: ["menuitem"],
			itemId: null,
			manifest: ["html"],
			ping: ["a", "area"],
			poster: ["video"],
			src: ["audio", "embed", "iframe", "img", "input", "script", "source", "track", "video"],
		},
		Mlt = {}
	function yA(e, t) {
		const n = Mlt,
			r = typeof n.includeImageAlt == "boolean" ? n.includeImageAlt : !0,
			i = typeof n.includeHtml == "boolean" ? n.includeHtml : !0
		return rV(e, r, i)
	}
	function rV(e, t, n) {
		if (Ilt(e)) {
			if ("value" in e) return e.type === "html" && !n ? "" : e.value
			if (t && "alt" in e && e.alt) return e.alt
			if ("children" in e) return C6(e.children, t, n)
		}
		return Array.isArray(e) ? C6(e, t, n) : ""
	}
	function C6(e, t, n) {
		const r = []
		let i = -1
		for (; ++i < e.length; ) r[i] = rV(e[i], t, n)
		return r.join("")
	}
	function Ilt(e) {
		return !!(e && typeof e == "object")
	}
	const T6 = document.createElement("i")
	function bA(e) {
		const t = "&" + e + ";"
		T6.innerHTML = t
		const n = T6.textContent
		return (n.charCodeAt(n.length - 1) === 59 && e !== "semi") || n === t ? !1 : n
	}
	function va(e, t, n, r) {
		const i = e.length
		let a = 0,
			o
		if (
			(t < 0 ? (t = -t > i ? 0 : i + t) : (t = t > i ? i : t), (n = n > 0 ? n : 0), r.length < 1e4)
		)
			(o = Array.from(r)), o.unshift(t, n), e.splice(...o)
		else
			for (n && e.splice(t, n); a < r.length; )
				(o = r.slice(a, a + 1e4)), o.unshift(t, 0), e.splice(...o), (a += 1e4), (t += 1e4)
	}
	function Fa(e, t) {
		return e.length > 0 ? (va(e, e.length, 0, t), e) : t
	}
	const k6 = {}.hasOwnProperty
	function iV(e) {
		const t = {}
		let n = -1
		for (; ++n < e.length; ) Rlt(t, e[n])
		return t
	}
	function Rlt(e, t) {
		let n
		for (n in t) {
			const i = (k6.call(e, n) ? e[n] : void 0) || (e[n] = {}),
				a = t[n]
			let o
			if (a)
				for (o in a) {
					k6.call(i, o) || (i[o] = [])
					const s = a[o]
					Llt(i[o], Array.isArray(s) ? s : s ? [s] : [])
				}
		}
	}
	function Llt(e, t) {
		let n = -1
		const r = []
		for (; ++n < t.length; ) (t[n].add === "after" ? e : r).push(t[n])
		va(e, 0, 0, r)
	}
	function aV(e, t) {
		const n = Number.parseInt(e, t)
		return n < 9 ||
			n === 11 ||
			(n > 13 && n < 32) ||
			(n > 126 && n < 160) ||
			(n > 55295 && n < 57344) ||
			(n > 64975 && n < 65008) ||
			(n & 65535) === 65535 ||
			(n & 65535) === 65534 ||
			n > 1114111
			? ""
			: String.fromCodePoint(n)
	}
	function To(e) {
		return e
			.replace(/[\t\n\r ]+/g, " ")
			.replace(/^ | $/g, "")
			.toLowerCase()
			.toUpperCase()
	}
	const vi = ec(/[A-Za-z]/),
		Zr = ec(/[\dA-Za-z]/),
		Plt = ec(/[#-'*+\--9=?A-Z^-~]/)
	function Mb(e) {
		return e !== null && (e < 32 || e === 127)
	}
	const uD = ec(/\d/),
		jlt = ec(/[\dA-Fa-f]/),
		Flt = ec(/[!-/:-@[-`{-~]/)
	function ut(e) {
		return e !== null && e < -2
	}
	function un(e) {
		return e !== null && (e < 0 || e === 32)
	}
	function kt(e) {
		return e === -2 || e === -1 || e === 32
	}
	const ww = ec(new RegExp("\\p{P}|\\p{S}", "u")),
		Td = ec(/\s/)
	function ec(e) {
		return t
		function t(n) {
			return n !== null && n > -1 && e.test(String.fromCharCode(n))
		}
	}
	function rh(e) {
		const t = []
		let n = -1,
			r = 0,
			i = 0
		for (; ++n < e.length; ) {
			const a = e.charCodeAt(n)
			let o = ""
			if (a === 37 && Zr(e.charCodeAt(n + 1)) && Zr(e.charCodeAt(n + 2))) i = 2
			else if (a < 128)
				/[!#$&-;=?-Z_a-z~]/.test(String.fromCharCode(a)) || (o = String.fromCharCode(a))
			else if (a > 55295 && a < 57344) {
				const s = e.charCodeAt(n + 1)
				a < 56320 && s > 56319 && s < 57344 ? ((o = String.fromCharCode(a, s)), (i = 1)) : (o = "")
			} else o = String.fromCharCode(a)
			o && (t.push(e.slice(r, n), encodeURIComponent(o)), (r = n + i + 1), (o = "")),
				i && ((n += i), (i = 0))
		}
		return t.join("") + e.slice(r)
	}
	function Nt(e, t, n, r) {
		const i = r ? r - 1 : Number.POSITIVE_INFINITY
		let a = 0
		return o
		function o(l) {
			return kt(l) ? (e.enter(n), s(l)) : t(l)
		}
		function s(l) {
			return kt(l) && a++ < i ? (e.consume(l), s) : (e.exit(n), t(l))
		}
	}
	const Blt = { tokenize: Hlt }
	function Hlt(e) {
		const t = e.attempt(this.parser.constructs.contentInitial, r, i)
		let n
		return t
		function r(s) {
			if (s === null) {
				e.consume(s)
				return
			}
			return e.enter("lineEnding"), e.consume(s), e.exit("lineEnding"), Nt(e, t, "linePrefix")
		}
		function i(s) {
			return e.enter("paragraph"), a(s)
		}
		function a(s) {
			const l = e.enter("chunkText", { contentType: "text", previous: n })
			return n && (n.next = l), (n = l), o(s)
		}
		function o(s) {
			if (s === null) {
				e.exit("chunkText"), e.exit("paragraph"), e.consume(s)
				return
			}
			return ut(s) ? (e.consume(s), e.exit("chunkText"), a) : (e.consume(s), o)
		}
	}
	const $lt = { tokenize: Ult },
		S6 = { tokenize: zlt }
	function Ult(e) {
		const t = this,
			n = []
		let r = 0,
			i,
			a,
			o
		return s
		function s(C) {
			if (r < n.length) {
				const D = n[r]
				return (t.containerState = D[1]), e.attempt(D[0].continuation, l, u)(C)
			}
			return u(C)
		}
		function l(C) {
			if ((r++, t.containerState._closeFlow)) {
				;(t.containerState._closeFlow = void 0), i && T()
				const D = t.events.length
				let O = D,
					A
				for (; O--; )
					if (t.events[O][0] === "exit" && t.events[O][1].type === "chunkFlow") {
						A = t.events[O][1].end
						break
					}
				E(r)
				let N = D
				for (; N < t.events.length; ) (t.events[N][1].end = { ...A }), N++
				return va(t.events, O + 1, 0, t.events.slice(D)), (t.events.length = N), u(C)
			}
			return s(C)
		}
		function u(C) {
			if (r === n.length) {
				if (!i) return m(C)
				if (i.currentConstruct && i.currentConstruct.concrete) return y(C)
				t.interrupt = !!(i.currentConstruct && !i._gfmTableDynamicInterruptHack)
			}
			return (t.containerState = {}), e.check(S6, d, p)(C)
		}
		function d(C) {
			return i && T(), E(r), m(C)
		}
		function p(C) {
			return (t.parser.lazy[t.now().line] = r !== n.length), (o = t.now().offset), y(C)
		}
		function m(C) {
			return (t.containerState = {}), e.attempt(S6, v, y)(C)
		}
		function v(C) {
			return r++, n.push([t.currentConstruct, t.containerState]), m(C)
		}
		function y(C) {
			if (C === null) {
				i && T(), E(0), e.consume(C)
				return
			}
			return (
				(i = i || t.parser.flow(t.now())),
				e.enter("chunkFlow", { _tokenizer: i, contentType: "flow", previous: a }),
				b(C)
			)
		}
		function b(C) {
			if (C === null) {
				x(e.exit("chunkFlow"), !0), E(0), e.consume(C)
				return
			}
			return ut(C)
				? (e.consume(C), x(e.exit("chunkFlow")), (r = 0), (t.interrupt = void 0), s)
				: (e.consume(C), b)
		}
		function x(C, D) {
			const O = t.sliceStream(C)
			if (
				(D && O.push(null),
				(C.previous = a),
				a && (a.next = C),
				(a = C),
				i.defineSkip(C.start),
				i.write(O),
				t.parser.lazy[C.start.line])
			) {
				let A = i.events.length
				for (; A--; )
					if (
						i.events[A][1].start.offset < o &&
						(!i.events[A][1].end || i.events[A][1].end.offset > o)
					)
						return
				const N = t.events.length
				let I = N,
					P,
					L
				for (; I--; )
					if (t.events[I][0] === "exit" && t.events[I][1].type === "chunkFlow") {
						if (P) {
							L = t.events[I][1].end
							break
						}
						P = !0
					}
				for (E(r), A = N; A < t.events.length; ) (t.events[A][1].end = { ...L }), A++
				va(t.events, I + 1, 0, t.events.slice(N)), (t.events.length = A)
			}
		}
		function E(C) {
			let D = n.length
			for (; D-- > C; ) {
				const O = n[D]
				;(t.containerState = O[1]), O[0].exit.call(t, e)
			}
			n.length = C
		}
		function T() {
			i.write([null]), (a = void 0), (i = void 0), (t.containerState._closeFlow = void 0)
		}
	}
	function zlt(e, t, n) {
		return Nt(
			e,
			e.attempt(this.parser.constructs.document, t, n),
			"linePrefix",
			this.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4,
		)
	}
	function Sp(e) {
		if (e === null || un(e) || Td(e)) return 1
		if (ww(e)) return 2
	}
	function Ew(e, t, n) {
		const r = []
		let i = -1
		for (; ++i < e.length; ) {
			const a = e[i].resolveAll
			a && !r.includes(a) && ((t = a(t, n)), r.push(a))
		}
		return t
	}
	const cD = { name: "attention", resolveAll: qlt, tokenize: Vlt }
	function qlt(e, t) {
		let n = -1,
			r,
			i,
			a,
			o,
			s,
			l,
			u,
			d
		for (; ++n < e.length; )
			if (e[n][0] === "enter" && e[n][1].type === "attentionSequence" && e[n][1]._close) {
				for (r = n; r--; )
					if (
						e[r][0] === "exit" &&
						e[r][1].type === "attentionSequence" &&
						e[r][1]._open &&
						t.sliceSerialize(e[r][1]).charCodeAt(0) === t.sliceSerialize(e[n][1]).charCodeAt(0)
					) {
						if (
							(e[r][1]._close || e[n][1]._open) &&
							(e[n][1].end.offset - e[n][1].start.offset) % 3 &&
							!(
								(e[r][1].end.offset -
									e[r][1].start.offset +
									e[n][1].end.offset -
									e[n][1].start.offset) %
								3
							)
						)
							continue
						l =
							e[r][1].end.offset - e[r][1].start.offset > 1 &&
							e[n][1].end.offset - e[n][1].start.offset > 1
								? 2
								: 1
						const p = { ...e[r][1].end },
							m = { ...e[n][1].start }
						D6(p, -l),
							D6(m, l),
							(o = {
								type: l > 1 ? "strongSequence" : "emphasisSequence",
								start: p,
								end: { ...e[r][1].end },
							}),
							(s = {
								type: l > 1 ? "strongSequence" : "emphasisSequence",
								start: { ...e[n][1].start },
								end: m,
							}),
							(a = {
								type: l > 1 ? "strongText" : "emphasisText",
								start: { ...e[r][1].end },
								end: { ...e[n][1].start },
							}),
							(i = {
								type: l > 1 ? "strong" : "emphasis",
								start: { ...o.start },
								end: { ...s.end },
							}),
							(e[r][1].end = { ...o.start }),
							(e[n][1].start = { ...s.end }),
							(u = []),
							e[r][1].end.offset - e[r][1].start.offset &&
								(u = Fa(u, [
									["enter", e[r][1], t],
									["exit", e[r][1], t],
								])),
							(u = Fa(u, [
								["enter", i, t],
								["enter", o, t],
								["exit", o, t],
								["enter", a, t],
							])),
							(u = Fa(u, Ew(t.parser.constructs.insideSpan.null, e.slice(r + 1, n), t))),
							(u = Fa(u, [
								["exit", a, t],
								["enter", s, t],
								["exit", s, t],
								["exit", i, t],
							])),
							e[n][1].end.offset - e[n][1].start.offset
								? ((d = 2),
								  (u = Fa(u, [
										["enter", e[n][1], t],
										["exit", e[n][1], t],
								  ])))
								: (d = 0),
							va(e, r - 1, n - r + 3, u),
							(n = r + u.length - d - 2)
						break
					}
			}
		for (n = -1; ++n < e.length; ) e[n][1].type === "attentionSequence" && (e[n][1].type = "data")
		return e
	}
	function Vlt(e, t) {
		const n = this.parser.constructs.attentionMarkers.null,
			r = this.previous,
			i = Sp(r)
		let a
		return o
		function o(l) {
			return (a = l), e.enter("attentionSequence"), s(l)
		}
		function s(l) {
			if (l === a) return e.consume(l), s
			const u = e.exit("attentionSequence"),
				d = Sp(l),
				p = !d || (d === 2 && i) || n.includes(l),
				m = !i || (i === 2 && d) || n.includes(r)
			return (
				(u._open = !!(a === 42 ? p : p && (i || !m))),
				(u._close = !!(a === 42 ? m : m && (d || !p))),
				t(l)
			)
		}
	}
	function D6(e, t) {
		;(e.column += t), (e.offset += t), (e._bufferIndex += t)
	}
	const Wlt = { name: "autolink", tokenize: Ylt }
	function Ylt(e, t, n) {
		let r = 0
		return i
		function i(v) {
			return (
				e.enter("autolink"),
				e.enter("autolinkMarker"),
				e.consume(v),
				e.exit("autolinkMarker"),
				e.enter("autolinkProtocol"),
				a
			)
		}
		function a(v) {
			return vi(v) ? (e.consume(v), o) : v === 64 ? n(v) : u(v)
		}
		function o(v) {
			return v === 43 || v === 45 || v === 46 || Zr(v) ? ((r = 1), s(v)) : u(v)
		}
		function s(v) {
			return v === 58
				? (e.consume(v), (r = 0), l)
				: (v === 43 || v === 45 || v === 46 || Zr(v)) && r++ < 32
				? (e.consume(v), s)
				: ((r = 0), u(v))
		}
		function l(v) {
			return v === 62
				? (e.exit("autolinkProtocol"),
				  e.enter("autolinkMarker"),
				  e.consume(v),
				  e.exit("autolinkMarker"),
				  e.exit("autolink"),
				  t)
				: v === null || v === 32 || v === 60 || Mb(v)
				? n(v)
				: (e.consume(v), l)
		}
		function u(v) {
			return v === 64 ? (e.consume(v), d) : Plt(v) ? (e.consume(v), u) : n(v)
		}
		function d(v) {
			return Zr(v) ? p(v) : n(v)
		}
		function p(v) {
			return v === 46
				? (e.consume(v), (r = 0), d)
				: v === 62
				? ((e.exit("autolinkProtocol").type = "autolinkEmail"),
				  e.enter("autolinkMarker"),
				  e.consume(v),
				  e.exit("autolinkMarker"),
				  e.exit("autolink"),
				  t)
				: m(v)
		}
		function m(v) {
			if ((v === 45 || Zr(v)) && r++ < 63) {
				const y = v === 45 ? m : p
				return e.consume(v), y
			}
			return n(v)
		}
	}
	const yg = { partial: !0, tokenize: Glt }
	function Glt(e, t, n) {
		return r
		function r(a) {
			return kt(a) ? Nt(e, i, "linePrefix")(a) : i(a)
		}
		function i(a) {
			return a === null || ut(a) ? t(a) : n(a)
		}
	}
	const oV = { continuation: { tokenize: Qlt }, exit: Xlt, name: "blockQuote", tokenize: Klt }
	function Klt(e, t, n) {
		const r = this
		return i
		function i(o) {
			if (o === 62) {
				const s = r.containerState
				return (
					s.open || (e.enter("blockQuote", { _container: !0 }), (s.open = !0)),
					e.enter("blockQuotePrefix"),
					e.enter("blockQuoteMarker"),
					e.consume(o),
					e.exit("blockQuoteMarker"),
					a
				)
			}
			return n(o)
		}
		function a(o) {
			return kt(o)
				? (e.enter("blockQuotePrefixWhitespace"),
				  e.consume(o),
				  e.exit("blockQuotePrefixWhitespace"),
				  e.exit("blockQuotePrefix"),
				  t)
				: (e.exit("blockQuotePrefix"), t(o))
		}
	}
	function Qlt(e, t, n) {
		const r = this
		return i
		function i(o) {
			return kt(o)
				? Nt(
						e,
						a,
						"linePrefix",
						r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4,
				  )(o)
				: a(o)
		}
		function a(o) {
			return e.attempt(oV, t, n)(o)
		}
	}
	function Xlt(e) {
		e.exit("blockQuote")
	}
	const sV = { name: "characterEscape", tokenize: Jlt }
	function Jlt(e, t, n) {
		return r
		function r(a) {
			return (
				e.enter("characterEscape"), e.enter("escapeMarker"), e.consume(a), e.exit("escapeMarker"), i
			)
		}
		function i(a) {
			return Flt(a)
				? (e.enter("characterEscapeValue"),
				  e.consume(a),
				  e.exit("characterEscapeValue"),
				  e.exit("characterEscape"),
				  t)
				: n(a)
		}
	}
	const lV = { name: "characterReference", tokenize: Zlt }
	function Zlt(e, t, n) {
		const r = this
		let i = 0,
			a,
			o
		return s
		function s(p) {
			return (
				e.enter("characterReference"),
				e.enter("characterReferenceMarker"),
				e.consume(p),
				e.exit("characterReferenceMarker"),
				l
			)
		}
		function l(p) {
			return p === 35
				? (e.enter("characterReferenceMarkerNumeric"),
				  e.consume(p),
				  e.exit("characterReferenceMarkerNumeric"),
				  u)
				: (e.enter("characterReferenceValue"), (a = 31), (o = Zr), d(p))
		}
		function u(p) {
			return p === 88 || p === 120
				? (e.enter("characterReferenceMarkerHexadecimal"),
				  e.consume(p),
				  e.exit("characterReferenceMarkerHexadecimal"),
				  e.enter("characterReferenceValue"),
				  (a = 6),
				  (o = jlt),
				  d)
				: (e.enter("characterReferenceValue"), (a = 7), (o = uD), d(p))
		}
		function d(p) {
			if (p === 59 && i) {
				const m = e.exit("characterReferenceValue")
				return o === Zr && !bA(r.sliceSerialize(m))
					? n(p)
					: (e.enter("characterReferenceMarker"),
					  e.consume(p),
					  e.exit("characterReferenceMarker"),
					  e.exit("characterReference"),
					  t)
			}
			return o(p) && i++ < a ? (e.consume(p), d) : n(p)
		}
	}
	const _6 = { partial: !0, tokenize: tut },
		O6 = { concrete: !0, name: "codeFenced", tokenize: eut }
	function eut(e, t, n) {
		const r = this,
			i = { partial: !0, tokenize: O }
		let a = 0,
			o = 0,
			s
		return l
		function l(A) {
			return u(A)
		}
		function u(A) {
			const N = r.events[r.events.length - 1]
			return (
				(a = N && N[1].type === "linePrefix" ? N[2].sliceSerialize(N[1], !0).length : 0),
				(s = A),
				e.enter("codeFenced"),
				e.enter("codeFencedFence"),
				e.enter("codeFencedFenceSequence"),
				d(A)
			)
		}
		function d(A) {
			return A === s
				? (o++, e.consume(A), d)
				: o < 3
				? n(A)
				: (e.exit("codeFencedFenceSequence"), kt(A) ? Nt(e, p, "whitespace")(A) : p(A))
		}
		function p(A) {
			return A === null || ut(A)
				? (e.exit("codeFencedFence"), r.interrupt ? t(A) : e.check(_6, b, D)(A))
				: (e.enter("codeFencedFenceInfo"), e.enter("chunkString", { contentType: "string" }), m(A))
		}
		function m(A) {
			return A === null || ut(A)
				? (e.exit("chunkString"), e.exit("codeFencedFenceInfo"), p(A))
				: kt(A)
				? (e.exit("chunkString"), e.exit("codeFencedFenceInfo"), Nt(e, v, "whitespace")(A))
				: A === 96 && A === s
				? n(A)
				: (e.consume(A), m)
		}
		function v(A) {
			return A === null || ut(A)
				? p(A)
				: (e.enter("codeFencedFenceMeta"), e.enter("chunkString", { contentType: "string" }), y(A))
		}
		function y(A) {
			return A === null || ut(A)
				? (e.exit("chunkString"), e.exit("codeFencedFenceMeta"), p(A))
				: A === 96 && A === s
				? n(A)
				: (e.consume(A), y)
		}
		function b(A) {
			return e.attempt(i, D, x)(A)
		}
		function x(A) {
			return e.enter("lineEnding"), e.consume(A), e.exit("lineEnding"), E
		}
		function E(A) {
			return a > 0 && kt(A) ? Nt(e, T, "linePrefix", a + 1)(A) : T(A)
		}
		function T(A) {
			return A === null || ut(A) ? e.check(_6, b, D)(A) : (e.enter("codeFlowValue"), C(A))
		}
		function C(A) {
			return A === null || ut(A) ? (e.exit("codeFlowValue"), T(A)) : (e.consume(A), C)
		}
		function D(A) {
			return e.exit("codeFenced"), t(A)
		}
		function O(A, N, I) {
			let P = 0
			return L
			function L(ne) {
				return A.enter("lineEnding"), A.consume(ne), A.exit("lineEnding"), B
			}
			function B(ne) {
				return (
					A.enter("codeFencedFence"),
					kt(ne)
						? Nt(
								A,
								z,
								"linePrefix",
								r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4,
						  )(ne)
						: z(ne)
				)
			}
			function z(ne) {
				return ne === s ? (A.enter("codeFencedFenceSequence"), V(ne)) : I(ne)
			}
			function V(ne) {
				return ne === s
					? (P++, A.consume(ne), V)
					: P >= o
					? (A.exit("codeFencedFenceSequence"), kt(ne) ? Nt(A, K, "whitespace")(ne) : K(ne))
					: I(ne)
			}
			function K(ne) {
				return ne === null || ut(ne) ? (A.exit("codeFencedFence"), N(ne)) : I(ne)
			}
		}
	}
	function tut(e, t, n) {
		const r = this
		return i
		function i(o) {
			return o === null ? n(o) : (e.enter("lineEnding"), e.consume(o), e.exit("lineEnding"), a)
		}
		function a(o) {
			return r.parser.lazy[r.now().line] ? n(o) : t(o)
		}
	}
	const $k = { name: "codeIndented", tokenize: rut },
		nut = { partial: !0, tokenize: iut }
	function rut(e, t, n) {
		const r = this
		return i
		function i(u) {
			return e.enter("codeIndented"), Nt(e, a, "linePrefix", 5)(u)
		}
		function a(u) {
			const d = r.events[r.events.length - 1]
			return d && d[1].type === "linePrefix" && d[2].sliceSerialize(d[1], !0).length >= 4
				? o(u)
				: n(u)
		}
		function o(u) {
			return u === null ? l(u) : ut(u) ? e.attempt(nut, o, l)(u) : (e.enter("codeFlowValue"), s(u))
		}
		function s(u) {
			return u === null || ut(u) ? (e.exit("codeFlowValue"), o(u)) : (e.consume(u), s)
		}
		function l(u) {
			return e.exit("codeIndented"), t(u)
		}
	}
	function iut(e, t, n) {
		const r = this
		return i
		function i(o) {
			return r.parser.lazy[r.now().line]
				? n(o)
				: ut(o)
				? (e.enter("lineEnding"), e.consume(o), e.exit("lineEnding"), i)
				: Nt(e, a, "linePrefix", 5)(o)
		}
		function a(o) {
			const s = r.events[r.events.length - 1]
			return s && s[1].type === "linePrefix" && s[2].sliceSerialize(s[1], !0).length >= 4
				? t(o)
				: ut(o)
				? i(o)
				: n(o)
		}
	}
	const aut = { name: "codeText", previous: sut, resolve: out, tokenize: lut }
	function out(e) {
		let t = e.length - 4,
			n = 3,
			r,
			i
		if (
			(e[n][1].type === "lineEnding" || e[n][1].type === "space") &&
			(e[t][1].type === "lineEnding" || e[t][1].type === "space")
		) {
			for (r = n; ++r < t; )
				if (e[r][1].type === "codeTextData") {
					;(e[n][1].type = "codeTextPadding"),
						(e[t][1].type = "codeTextPadding"),
						(n += 2),
						(t -= 2)
					break
				}
		}
		for (r = n - 1, t++; ++r <= t; )
			i === void 0
				? r !== t && e[r][1].type !== "lineEnding" && (i = r)
				: (r === t || e[r][1].type === "lineEnding") &&
				  ((e[i][1].type = "codeTextData"),
				  r !== i + 2 &&
						((e[i][1].end = e[r - 1][1].end),
						e.splice(i + 2, r - i - 2),
						(t -= r - i - 2),
						(r = i + 2)),
				  (i = void 0))
		return e
	}
	function sut(e) {
		return e !== 96 || this.events[this.events.length - 1][1].type === "characterEscape"
	}
	function lut(e, t, n) {
		let r = 0,
			i,
			a
		return o
		function o(p) {
			return e.enter("codeText"), e.enter("codeTextSequence"), s(p)
		}
		function s(p) {
			return p === 96 ? (e.consume(p), r++, s) : (e.exit("codeTextSequence"), l(p))
		}
		function l(p) {
			return p === null
				? n(p)
				: p === 32
				? (e.enter("space"), e.consume(p), e.exit("space"), l)
				: p === 96
				? ((a = e.enter("codeTextSequence")), (i = 0), d(p))
				: ut(p)
				? (e.enter("lineEnding"), e.consume(p), e.exit("lineEnding"), l)
				: (e.enter("codeTextData"), u(p))
		}
		function u(p) {
			return p === null || p === 32 || p === 96 || ut(p)
				? (e.exit("codeTextData"), l(p))
				: (e.consume(p), u)
		}
		function d(p) {
			return p === 96
				? (e.consume(p), i++, d)
				: i === r
				? (e.exit("codeTextSequence"), e.exit("codeText"), t(p))
				: ((a.type = "codeTextData"), u(p))
		}
	}
	class uut {
		constructor(t) {
			;(this.left = t ? [...t] : []), (this.right = [])
		}
		get(t) {
			if (t < 0 || t >= this.left.length + this.right.length)
				throw new RangeError(
					"Cannot access index `" +
						t +
						"` in a splice buffer of size `" +
						(this.left.length + this.right.length) +
						"`",
				)
			return t < this.left.length
				? this.left[t]
				: this.right[this.right.length - t + this.left.length - 1]
		}
		get length() {
			return this.left.length + this.right.length
		}
		shift() {
			return this.setCursor(0), this.right.pop()
		}
		slice(t, n) {
			const r = n ?? Number.POSITIVE_INFINITY
			return r < this.left.length
				? this.left.slice(t, r)
				: t > this.left.length
				? this.right
						.slice(
							this.right.length - r + this.left.length,
							this.right.length - t + this.left.length,
						)
						.reverse()
				: this.left
						.slice(t)
						.concat(this.right.slice(this.right.length - r + this.left.length).reverse())
		}
		splice(t, n, r) {
			const i = n || 0
			this.setCursor(Math.trunc(t))
			const a = this.right.splice(this.right.length - i, Number.POSITIVE_INFINITY)
			return r && um(this.left, r), a.reverse()
		}
		pop() {
			return this.setCursor(Number.POSITIVE_INFINITY), this.left.pop()
		}
		push(t) {
			this.setCursor(Number.POSITIVE_INFINITY), this.left.push(t)
		}
		pushMany(t) {
			this.setCursor(Number.POSITIVE_INFINITY), um(this.left, t)
		}
		unshift(t) {
			this.setCursor(0), this.right.push(t)
		}
		unshiftMany(t) {
			this.setCursor(0), um(this.right, t.reverse())
		}
		setCursor(t) {
			if (
				!(
					t === this.left.length ||
					(t > this.left.length && this.right.length === 0) ||
					(t < 0 && this.left.length === 0)
				)
			)
				if (t < this.left.length) {
					const n = this.left.splice(t, Number.POSITIVE_INFINITY)
					um(this.right, n.reverse())
				} else {
					const n = this.right.splice(
						this.left.length + this.right.length - t,
						Number.POSITIVE_INFINITY,
					)
					um(this.left, n.reverse())
				}
		}
	}
	function um(e, t) {
		let n = 0
		if (t.length < 1e4) e.push(...t)
		else for (; n < t.length; ) e.push(...t.slice(n, n + 1e4)), (n += 1e4)
	}
	function uV(e) {
		const t = {}
		let n = -1,
			r,
			i,
			a,
			o,
			s,
			l,
			u
		const d = new uut(e)
		for (; ++n < d.length; ) {
			for (; n in t; ) n = t[n]
			if (
				((r = d.get(n)),
				n &&
					r[1].type === "chunkFlow" &&
					d.get(n - 1)[1].type === "listItemPrefix" &&
					((l = r[1]._tokenizer.events),
					(a = 0),
					a < l.length && l[a][1].type === "lineEndingBlank" && (a += 2),
					a < l.length && l[a][1].type === "content"))
			)
				for (; ++a < l.length && l[a][1].type !== "content"; )
					l[a][1].type === "chunkText" && ((l[a][1]._isInFirstContentOfListItem = !0), a++)
			if (r[0] === "enter") r[1].contentType && (Object.assign(t, cut(d, n)), (n = t[n]), (u = !0))
			else if (r[1]._container) {
				for (
					a = n, i = void 0;
					a-- && ((o = d.get(a)), o[1].type === "lineEnding" || o[1].type === "lineEndingBlank");

				)
					o[0] === "enter" &&
						(i && (d.get(i)[1].type = "lineEndingBlank"), (o[1].type = "lineEnding"), (i = a))
				i &&
					((r[1].end = { ...d.get(i)[1].start }),
					(s = d.slice(i, n)),
					s.unshift(r),
					d.splice(i, n - i + 1, s))
			}
		}
		return va(e, 0, Number.POSITIVE_INFINITY, d.slice(0)), !u
	}
	function cut(e, t) {
		const n = e.get(t)[1],
			r = e.get(t)[2]
		let i = t - 1
		const a = [],
			o = n._tokenizer || r.parser[n.contentType](n.start),
			s = o.events,
			l = [],
			u = {}
		let d,
			p,
			m = -1,
			v = n,
			y = 0,
			b = 0
		const x = [b]
		for (; v; ) {
			for (; e.get(++i)[1] !== v; );
			a.push(i),
				v._tokenizer ||
					((d = r.sliceStream(v)),
					v.next || d.push(null),
					p && o.defineSkip(v.start),
					v._isInFirstContentOfListItem && (o._gfmTasklistFirstContentOfListItem = !0),
					o.write(d),
					v._isInFirstContentOfListItem && (o._gfmTasklistFirstContentOfListItem = void 0)),
				(p = v),
				(v = v.next)
		}
		for (v = n; ++m < s.length; )
			s[m][0] === "exit" &&
				s[m - 1][0] === "enter" &&
				s[m][1].type === s[m - 1][1].type &&
				s[m][1].start.line !== s[m][1].end.line &&
				((b = m + 1), x.push(b), (v._tokenizer = void 0), (v.previous = void 0), (v = v.next))
		for (
			o.events = [], v ? ((v._tokenizer = void 0), (v.previous = void 0)) : x.pop(), m = x.length;
			m--;

		) {
			const E = s.slice(x[m], x[m + 1]),
				T = a.pop()
			l.push([T, T + E.length - 1]), e.splice(T, 2, E)
		}
		for (l.reverse(), m = -1; ++m < l.length; )
			(u[y + l[m][0]] = y + l[m][1]), (y += l[m][1] - l[m][0] - 1)
		return u
	}
	const dut = { resolve: put, tokenize: hut },
		fut = { partial: !0, tokenize: mut }
	function put(e) {
		return uV(e), e
	}
	function hut(e, t) {
		let n
		return r
		function r(s) {
			return e.enter("content"), (n = e.enter("chunkContent", { contentType: "content" })), i(s)
		}
		function i(s) {
			return s === null ? a(s) : ut(s) ? e.check(fut, o, a)(s) : (e.consume(s), i)
		}
		function a(s) {
			return e.exit("chunkContent"), e.exit("content"), t(s)
		}
		function o(s) {
			return (
				e.consume(s),
				e.exit("chunkContent"),
				(n.next = e.enter("chunkContent", { contentType: "content", previous: n })),
				(n = n.next),
				i
			)
		}
	}
	function mut(e, t, n) {
		const r = this
		return i
		function i(o) {
			return (
				e.exit("chunkContent"),
				e.enter("lineEnding"),
				e.consume(o),
				e.exit("lineEnding"),
				Nt(e, a, "linePrefix")
			)
		}
		function a(o) {
			if (o === null || ut(o)) return n(o)
			const s = r.events[r.events.length - 1]
			return !r.parser.constructs.disable.null.includes("codeIndented") &&
				s &&
				s[1].type === "linePrefix" &&
				s[2].sliceSerialize(s[1], !0).length >= 4
				? t(o)
				: e.interrupt(r.parser.constructs.flow, n, t)(o)
		}
	}
	function cV(e, t, n, r, i, a, o, s, l) {
		const u = l || Number.POSITIVE_INFINITY
		let d = 0
		return p
		function p(E) {
			return E === 60
				? (e.enter(r), e.enter(i), e.enter(a), e.consume(E), e.exit(a), m)
				: E === null || E === 32 || E === 41 || Mb(E)
				? n(E)
				: (e.enter(r),
				  e.enter(o),
				  e.enter(s),
				  e.enter("chunkString", { contentType: "string" }),
				  b(E))
		}
		function m(E) {
			return E === 62
				? (e.enter(a), e.consume(E), e.exit(a), e.exit(i), e.exit(r), t)
				: (e.enter(s), e.enter("chunkString", { contentType: "string" }), v(E))
		}
		function v(E) {
			return E === 62
				? (e.exit("chunkString"), e.exit(s), m(E))
				: E === null || E === 60 || ut(E)
				? n(E)
				: (e.consume(E), E === 92 ? y : v)
		}
		function y(E) {
			return E === 60 || E === 62 || E === 92 ? (e.consume(E), v) : v(E)
		}
		function b(E) {
			return !d && (E === null || E === 41 || un(E))
				? (e.exit("chunkString"), e.exit(s), e.exit(o), e.exit(r), t(E))
				: d < u && E === 40
				? (e.consume(E), d++, b)
				: E === 41
				? (e.consume(E), d--, b)
				: E === null || E === 32 || E === 40 || Mb(E)
				? n(E)
				: (e.consume(E), E === 92 ? x : b)
		}
		function x(E) {
			return E === 40 || E === 41 || E === 92 ? (e.consume(E), b) : b(E)
		}
	}
	function dV(e, t, n, r, i, a) {
		const o = this
		let s = 0,
			l
		return u
		function u(v) {
			return e.enter(r), e.enter(i), e.consume(v), e.exit(i), e.enter(a), d
		}
		function d(v) {
			return s > 999 ||
				v === null ||
				v === 91 ||
				(v === 93 && !l) ||
				(v === 94 && !s && "_hiddenFootnoteSupport" in o.parser.constructs)
				? n(v)
				: v === 93
				? (e.exit(a), e.enter(i), e.consume(v), e.exit(i), e.exit(r), t)
				: ut(v)
				? (e.enter("lineEnding"), e.consume(v), e.exit("lineEnding"), d)
				: (e.enter("chunkString", { contentType: "string" }), p(v))
		}
		function p(v) {
			return v === null || v === 91 || v === 93 || ut(v) || s++ > 999
				? (e.exit("chunkString"), d(v))
				: (e.consume(v), l || (l = !kt(v)), v === 92 ? m : p)
		}
		function m(v) {
			return v === 91 || v === 92 || v === 93 ? (e.consume(v), s++, p) : p(v)
		}
	}
	function fV(e, t, n, r, i, a) {
		let o
		return s
		function s(m) {
			return m === 34 || m === 39 || m === 40
				? (e.enter(r), e.enter(i), e.consume(m), e.exit(i), (o = m === 40 ? 41 : m), l)
				: n(m)
		}
		function l(m) {
			return m === o ? (e.enter(i), e.consume(m), e.exit(i), e.exit(r), t) : (e.enter(a), u(m))
		}
		function u(m) {
			return m === o
				? (e.exit(a), l(o))
				: m === null
				? n(m)
				: ut(m)
				? (e.enter("lineEnding"), e.consume(m), e.exit("lineEnding"), Nt(e, u, "linePrefix"))
				: (e.enter("chunkString", { contentType: "string" }), d(m))
		}
		function d(m) {
			return m === o || m === null || ut(m)
				? (e.exit("chunkString"), u(m))
				: (e.consume(m), m === 92 ? p : d)
		}
		function p(m) {
			return m === o || m === 92 ? (e.consume(m), d) : d(m)
		}
	}
	function Ym(e, t) {
		let n
		return r
		function r(i) {
			return ut(i)
				? (e.enter("lineEnding"), e.consume(i), e.exit("lineEnding"), (n = !0), r)
				: kt(i)
				? Nt(e, r, n ? "linePrefix" : "lineSuffix")(i)
				: t(i)
		}
	}
	const vut = { name: "definition", tokenize: yut },
		gut = { partial: !0, tokenize: but }
	function yut(e, t, n) {
		const r = this
		let i
		return a
		function a(v) {
			return e.enter("definition"), o(v)
		}
		function o(v) {
			return dV.call(
				r,
				e,
				s,
				n,
				"definitionLabel",
				"definitionLabelMarker",
				"definitionLabelString",
			)(v)
		}
		function s(v) {
			return (
				(i = To(r.sliceSerialize(r.events[r.events.length - 1][1]).slice(1, -1))),
				v === 58 ? (e.enter("definitionMarker"), e.consume(v), e.exit("definitionMarker"), l) : n(v)
			)
		}
		function l(v) {
			return un(v) ? Ym(e, u)(v) : u(v)
		}
		function u(v) {
			return cV(
				e,
				d,
				n,
				"definitionDestination",
				"definitionDestinationLiteral",
				"definitionDestinationLiteralMarker",
				"definitionDestinationRaw",
				"definitionDestinationString",
			)(v)
		}
		function d(v) {
			return e.attempt(gut, p, p)(v)
		}
		function p(v) {
			return kt(v) ? Nt(e, m, "whitespace")(v) : m(v)
		}
		function m(v) {
			return v === null || ut(v) ? (e.exit("definition"), r.parser.defined.push(i), t(v)) : n(v)
		}
	}
	function but(e, t, n) {
		return r
		function r(s) {
			return un(s) ? Ym(e, i)(s) : n(s)
		}
		function i(s) {
			return fV(e, a, n, "definitionTitle", "definitionTitleMarker", "definitionTitleString")(s)
		}
		function a(s) {
			return kt(s) ? Nt(e, o, "whitespace")(s) : o(s)
		}
		function o(s) {
			return s === null || ut(s) ? t(s) : n(s)
		}
	}
	const xut = { name: "hardBreakEscape", tokenize: wut }
	function wut(e, t, n) {
		return r
		function r(a) {
			return e.enter("hardBreakEscape"), e.consume(a), i
		}
		function i(a) {
			return ut(a) ? (e.exit("hardBreakEscape"), t(a)) : n(a)
		}
	}
	const Eut = { name: "headingAtx", resolve: Cut, tokenize: Tut }
	function Cut(e, t) {
		let n = e.length - 2,
			r = 3,
			i,
			a
		return (
			e[r][1].type === "whitespace" && (r += 2),
			n - 2 > r && e[n][1].type === "whitespace" && (n -= 2),
			e[n][1].type === "atxHeadingSequence" &&
				(r === n - 1 || (n - 4 > r && e[n - 2][1].type === "whitespace")) &&
				(n -= r + 1 === n ? 2 : 4),
			n > r &&
				((i = { type: "atxHeadingText", start: e[r][1].start, end: e[n][1].end }),
				(a = { type: "chunkText", start: e[r][1].start, end: e[n][1].end, contentType: "text" }),
				va(e, r, n - r + 1, [
					["enter", i, t],
					["enter", a, t],
					["exit", a, t],
					["exit", i, t],
				])),
			e
		)
	}
	function Tut(e, t, n) {
		let r = 0
		return i
		function i(d) {
			return e.enter("atxHeading"), a(d)
		}
		function a(d) {
			return e.enter("atxHeadingSequence"), o(d)
		}
		function o(d) {
			return d === 35 && r++ < 6
				? (e.consume(d), o)
				: d === null || un(d)
				? (e.exit("atxHeadingSequence"), s(d))
				: n(d)
		}
		function s(d) {
			return d === 35
				? (e.enter("atxHeadingSequence"), l(d))
				: d === null || ut(d)
				? (e.exit("atxHeading"), t(d))
				: kt(d)
				? Nt(e, s, "whitespace")(d)
				: (e.enter("atxHeadingText"), u(d))
		}
		function l(d) {
			return d === 35 ? (e.consume(d), l) : (e.exit("atxHeadingSequence"), s(d))
		}
		function u(d) {
			return d === null || d === 35 || un(d) ? (e.exit("atxHeadingText"), s(d)) : (e.consume(d), u)
		}
	}
	const kut = [
			"address",
			"article",
			"aside",
			"base",
			"basefont",
			"blockquote",
			"body",
			"caption",
			"center",
			"col",
			"colgroup",
			"dd",
			"details",
			"dialog",
			"dir",
			"div",
			"dl",
			"dt",
			"fieldset",
			"figcaption",
			"figure",
			"footer",
			"form",
			"frame",
			"frameset",
			"h1",
			"h2",
			"h3",
			"h4",
			"h5",
			"h6",
			"head",
			"header",
			"hr",
			"html",
			"iframe",
			"legend",
			"li",
			"link",
			"main",
			"menu",
			"menuitem",
			"nav",
			"noframes",
			"ol",
			"optgroup",
			"option",
			"p",
			"param",
			"search",
			"section",
			"summary",
			"table",
			"tbody",
			"td",
			"tfoot",
			"th",
			"thead",
			"title",
			"tr",
			"track",
			"ul",
		],
		A6 = ["pre", "script", "style", "textarea"],
		Sut = { concrete: !0, name: "htmlFlow", resolveTo: Out, tokenize: Aut },
		Dut = { partial: !0, tokenize: Mut },
		_ut = { partial: !0, tokenize: Nut }
	function Out(e) {
		let t = e.length
		for (; t-- && !(e[t][0] === "enter" && e[t][1].type === "htmlFlow"); );
		return (
			t > 1 &&
				e[t - 2][1].type === "linePrefix" &&
				((e[t][1].start = e[t - 2][1].start),
				(e[t + 1][1].start = e[t - 2][1].start),
				e.splice(t - 2, 2)),
			e
		)
	}
	function Aut(e, t, n) {
		const r = this
		let i, a, o, s, l
		return u
		function u($) {
			return d($)
		}
		function d($) {
			return e.enter("htmlFlow"), e.enter("htmlFlowData"), e.consume($), p
		}
		function p($) {
			return $ === 33
				? (e.consume($), m)
				: $ === 47
				? (e.consume($), (a = !0), b)
				: $ === 63
				? (e.consume($), (i = 3), r.interrupt ? t : F)
				: vi($)
				? (e.consume($), (o = String.fromCharCode($)), x)
				: n($)
		}
		function m($) {
			return $ === 45
				? (e.consume($), (i = 2), v)
				: $ === 91
				? (e.consume($), (i = 5), (s = 0), y)
				: vi($)
				? (e.consume($), (i = 4), r.interrupt ? t : F)
				: n($)
		}
		function v($) {
			return $ === 45 ? (e.consume($), r.interrupt ? t : F) : n($)
		}
		function y($) {
			const ge = "CDATA["
			return $ === ge.charCodeAt(s++)
				? (e.consume($), s === ge.length ? (r.interrupt ? t : z) : y)
				: n($)
		}
		function b($) {
			return vi($) ? (e.consume($), (o = String.fromCharCode($)), x) : n($)
		}
		function x($) {
			if ($ === null || $ === 47 || $ === 62 || un($)) {
				const ge = $ === 47,
					Se = o.toLowerCase()
				return !ge && !a && A6.includes(Se)
					? ((i = 1), r.interrupt ? t($) : z($))
					: kut.includes(o.toLowerCase())
					? ((i = 6), ge ? (e.consume($), E) : r.interrupt ? t($) : z($))
					: ((i = 7), r.interrupt && !r.parser.lazy[r.now().line] ? n($) : a ? T($) : C($))
			}
			return $ === 45 || Zr($) ? (e.consume($), (o += String.fromCharCode($)), x) : n($)
		}
		function E($) {
			return $ === 62 ? (e.consume($), r.interrupt ? t : z) : n($)
		}
		function T($) {
			return kt($) ? (e.consume($), T) : L($)
		}
		function C($) {
			return $ === 47
				? (e.consume($), L)
				: $ === 58 || $ === 95 || vi($)
				? (e.consume($), D)
				: kt($)
				? (e.consume($), C)
				: L($)
		}
		function D($) {
			return $ === 45 || $ === 46 || $ === 58 || $ === 95 || Zr($) ? (e.consume($), D) : O($)
		}
		function O($) {
			return $ === 61 ? (e.consume($), A) : kt($) ? (e.consume($), O) : C($)
		}
		function A($) {
			return $ === null || $ === 60 || $ === 61 || $ === 62 || $ === 96
				? n($)
				: $ === 34 || $ === 39
				? (e.consume($), (l = $), N)
				: kt($)
				? (e.consume($), A)
				: I($)
		}
		function N($) {
			return $ === l
				? (e.consume($), (l = null), P)
				: $ === null || ut($)
				? n($)
				: (e.consume($), N)
		}
		function I($) {
			return $ === null ||
				$ === 34 ||
				$ === 39 ||
				$ === 47 ||
				$ === 60 ||
				$ === 61 ||
				$ === 62 ||
				$ === 96 ||
				un($)
				? O($)
				: (e.consume($), I)
		}
		function P($) {
			return $ === 47 || $ === 62 || kt($) ? C($) : n($)
		}
		function L($) {
			return $ === 62 ? (e.consume($), B) : n($)
		}
		function B($) {
			return $ === null || ut($) ? z($) : kt($) ? (e.consume($), B) : n($)
		}
		function z($) {
			return $ === 45 && i === 2
				? (e.consume($), re)
				: $ === 60 && i === 1
				? (e.consume($), ie)
				: $ === 62 && i === 4
				? (e.consume($), Y)
				: $ === 63 && i === 3
				? (e.consume($), F)
				: $ === 93 && i === 5
				? (e.consume($), le)
				: ut($) && (i === 6 || i === 7)
				? (e.exit("htmlFlowData"), e.check(Dut, ee, V)($))
				: $ === null || ut($)
				? (e.exit("htmlFlowData"), V($))
				: (e.consume($), z)
		}
		function V($) {
			return e.check(_ut, K, ee)($)
		}
		function K($) {
			return e.enter("lineEnding"), e.consume($), e.exit("lineEnding"), ne
		}
		function ne($) {
			return $ === null || ut($) ? V($) : (e.enter("htmlFlowData"), z($))
		}
		function re($) {
			return $ === 45 ? (e.consume($), F) : z($)
		}
		function ie($) {
			return $ === 47 ? (e.consume($), (o = ""), J) : z($)
		}
		function J($) {
			if ($ === 62) {
				const ge = o.toLowerCase()
				return A6.includes(ge) ? (e.consume($), Y) : z($)
			}
			return vi($) && o.length < 8 ? (e.consume($), (o += String.fromCharCode($)), J) : z($)
		}
		function le($) {
			return $ === 93 ? (e.consume($), F) : z($)
		}
		function F($) {
			return $ === 62 ? (e.consume($), Y) : $ === 45 && i === 2 ? (e.consume($), F) : z($)
		}
		function Y($) {
			return $ === null || ut($) ? (e.exit("htmlFlowData"), ee($)) : (e.consume($), Y)
		}
		function ee($) {
			return e.exit("htmlFlow"), t($)
		}
	}
	function Nut(e, t, n) {
		const r = this
		return i
		function i(o) {
			return ut(o) ? (e.enter("lineEnding"), e.consume(o), e.exit("lineEnding"), a) : n(o)
		}
		function a(o) {
			return r.parser.lazy[r.now().line] ? n(o) : t(o)
		}
	}
	function Mut(e, t, n) {
		return r
		function r(i) {
			return e.enter("lineEnding"), e.consume(i), e.exit("lineEnding"), e.attempt(yg, t, n)
		}
	}
	const Iut = { name: "htmlText", tokenize: Rut }
	function Rut(e, t, n) {
		const r = this
		let i, a, o
		return s
		function s(F) {
			return e.enter("htmlText"), e.enter("htmlTextData"), e.consume(F), l
		}
		function l(F) {
			return F === 33
				? (e.consume(F), u)
				: F === 47
				? (e.consume(F), O)
				: F === 63
				? (e.consume(F), C)
				: vi(F)
				? (e.consume(F), I)
				: n(F)
		}
		function u(F) {
			return F === 45
				? (e.consume(F), d)
				: F === 91
				? (e.consume(F), (a = 0), y)
				: vi(F)
				? (e.consume(F), T)
				: n(F)
		}
		function d(F) {
			return F === 45 ? (e.consume(F), v) : n(F)
		}
		function p(F) {
			return F === null
				? n(F)
				: F === 45
				? (e.consume(F), m)
				: ut(F)
				? ((o = p), ie(F))
				: (e.consume(F), p)
		}
		function m(F) {
			return F === 45 ? (e.consume(F), v) : p(F)
		}
		function v(F) {
			return F === 62 ? re(F) : F === 45 ? m(F) : p(F)
		}
		function y(F) {
			const Y = "CDATA["
			return F === Y.charCodeAt(a++) ? (e.consume(F), a === Y.length ? b : y) : n(F)
		}
		function b(F) {
			return F === null
				? n(F)
				: F === 93
				? (e.consume(F), x)
				: ut(F)
				? ((o = b), ie(F))
				: (e.consume(F), b)
		}
		function x(F) {
			return F === 93 ? (e.consume(F), E) : b(F)
		}
		function E(F) {
			return F === 62 ? re(F) : F === 93 ? (e.consume(F), E) : b(F)
		}
		function T(F) {
			return F === null || F === 62 ? re(F) : ut(F) ? ((o = T), ie(F)) : (e.consume(F), T)
		}
		function C(F) {
			return F === null
				? n(F)
				: F === 63
				? (e.consume(F), D)
				: ut(F)
				? ((o = C), ie(F))
				: (e.consume(F), C)
		}
		function D(F) {
			return F === 62 ? re(F) : C(F)
		}
		function O(F) {
			return vi(F) ? (e.consume(F), A) : n(F)
		}
		function A(F) {
			return F === 45 || Zr(F) ? (e.consume(F), A) : N(F)
		}
		function N(F) {
			return ut(F) ? ((o = N), ie(F)) : kt(F) ? (e.consume(F), N) : re(F)
		}
		function I(F) {
			return F === 45 || Zr(F) ? (e.consume(F), I) : F === 47 || F === 62 || un(F) ? P(F) : n(F)
		}
		function P(F) {
			return F === 47
				? (e.consume(F), re)
				: F === 58 || F === 95 || vi(F)
				? (e.consume(F), L)
				: ut(F)
				? ((o = P), ie(F))
				: kt(F)
				? (e.consume(F), P)
				: re(F)
		}
		function L(F) {
			return F === 45 || F === 46 || F === 58 || F === 95 || Zr(F) ? (e.consume(F), L) : B(F)
		}
		function B(F) {
			return F === 61
				? (e.consume(F), z)
				: ut(F)
				? ((o = B), ie(F))
				: kt(F)
				? (e.consume(F), B)
				: P(F)
		}
		function z(F) {
			return F === null || F === 60 || F === 61 || F === 62 || F === 96
				? n(F)
				: F === 34 || F === 39
				? (e.consume(F), (i = F), V)
				: ut(F)
				? ((o = z), ie(F))
				: kt(F)
				? (e.consume(F), z)
				: (e.consume(F), K)
		}
		function V(F) {
			return F === i
				? (e.consume(F), (i = void 0), ne)
				: F === null
				? n(F)
				: ut(F)
				? ((o = V), ie(F))
				: (e.consume(F), V)
		}
		function K(F) {
			return F === null || F === 34 || F === 39 || F === 60 || F === 61 || F === 96
				? n(F)
				: F === 47 || F === 62 || un(F)
				? P(F)
				: (e.consume(F), K)
		}
		function ne(F) {
			return F === 47 || F === 62 || un(F) ? P(F) : n(F)
		}
		function re(F) {
			return F === 62 ? (e.consume(F), e.exit("htmlTextData"), e.exit("htmlText"), t) : n(F)
		}
		function ie(F) {
			return e.exit("htmlTextData"), e.enter("lineEnding"), e.consume(F), e.exit("lineEnding"), J
		}
		function J(F) {
			return kt(F)
				? Nt(
						e,
						le,
						"linePrefix",
						r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4,
				  )(F)
				: le(F)
		}
		function le(F) {
			return e.enter("htmlTextData"), o(F)
		}
	}
	const xA = { name: "labelEnd", resolveAll: Fut, resolveTo: But, tokenize: Hut },
		Lut = { tokenize: $ut },
		Put = { tokenize: Uut },
		jut = { tokenize: zut }
	function Fut(e) {
		let t = -1
		const n = []
		for (; ++t < e.length; ) {
			const r = e[t][1]
			if (
				(n.push(e[t]), r.type === "labelImage" || r.type === "labelLink" || r.type === "labelEnd")
			) {
				const i = r.type === "labelImage" ? 4 : 2
				;(r.type = "data"), (t += i)
			}
		}
		return e.length !== n.length && va(e, 0, e.length, n), e
	}
	function But(e, t) {
		let n = e.length,
			r = 0,
			i,
			a,
			o,
			s
		for (; n--; )
			if (((i = e[n][1]), a)) {
				if (i.type === "link" || (i.type === "labelLink" && i._inactive)) break
				e[n][0] === "enter" && i.type === "labelLink" && (i._inactive = !0)
			} else if (o) {
				if (
					e[n][0] === "enter" &&
					(i.type === "labelImage" || i.type === "labelLink") &&
					!i._balanced &&
					((a = n), i.type !== "labelLink")
				) {
					r = 2
					break
				}
			} else i.type === "labelEnd" && (o = n)
		const l = {
				type: e[a][1].type === "labelLink" ? "link" : "image",
				start: { ...e[a][1].start },
				end: { ...e[e.length - 1][1].end },
			},
			u = { type: "label", start: { ...e[a][1].start }, end: { ...e[o][1].end } },
			d = { type: "labelText", start: { ...e[a + r + 2][1].end }, end: { ...e[o - 2][1].start } }
		return (
			(s = [
				["enter", l, t],
				["enter", u, t],
			]),
			(s = Fa(s, e.slice(a + 1, a + r + 3))),
			(s = Fa(s, [["enter", d, t]])),
			(s = Fa(s, Ew(t.parser.constructs.insideSpan.null, e.slice(a + r + 4, o - 3), t))),
			(s = Fa(s, [["exit", d, t], e[o - 2], e[o - 1], ["exit", u, t]])),
			(s = Fa(s, e.slice(o + 1))),
			(s = Fa(s, [["exit", l, t]])),
			va(e, a, e.length, s),
			e
		)
	}
	function Hut(e, t, n) {
		const r = this
		let i = r.events.length,
			a,
			o
		for (; i--; )
			if (
				(r.events[i][1].type === "labelImage" || r.events[i][1].type === "labelLink") &&
				!r.events[i][1]._balanced
			) {
				a = r.events[i][1]
				break
			}
		return s
		function s(m) {
			return a
				? a._inactive
					? p(m)
					: ((o = r.parser.defined.includes(To(r.sliceSerialize({ start: a.end, end: r.now() })))),
					  e.enter("labelEnd"),
					  e.enter("labelMarker"),
					  e.consume(m),
					  e.exit("labelMarker"),
					  e.exit("labelEnd"),
					  l)
				: n(m)
		}
		function l(m) {
			return m === 40
				? e.attempt(Lut, d, o ? d : p)(m)
				: m === 91
				? e.attempt(Put, d, o ? u : p)(m)
				: o
				? d(m)
				: p(m)
		}
		function u(m) {
			return e.attempt(jut, d, p)(m)
		}
		function d(m) {
			return t(m)
		}
		function p(m) {
			return (a._balanced = !0), n(m)
		}
	}
	function $ut(e, t, n) {
		return r
		function r(p) {
			return (
				e.enter("resource"), e.enter("resourceMarker"), e.consume(p), e.exit("resourceMarker"), i
			)
		}
		function i(p) {
			return un(p) ? Ym(e, a)(p) : a(p)
		}
		function a(p) {
			return p === 41
				? d(p)
				: cV(
						e,
						o,
						s,
						"resourceDestination",
						"resourceDestinationLiteral",
						"resourceDestinationLiteralMarker",
						"resourceDestinationRaw",
						"resourceDestinationString",
						32,
				  )(p)
		}
		function o(p) {
			return un(p) ? Ym(e, l)(p) : d(p)
		}
		function s(p) {
			return n(p)
		}
		function l(p) {
			return p === 34 || p === 39 || p === 40
				? fV(e, u, n, "resourceTitle", "resourceTitleMarker", "resourceTitleString")(p)
				: d(p)
		}
		function u(p) {
			return un(p) ? Ym(e, d)(p) : d(p)
		}
		function d(p) {
			return p === 41
				? (e.enter("resourceMarker"), e.consume(p), e.exit("resourceMarker"), e.exit("resource"), t)
				: n(p)
		}
	}
	function Uut(e, t, n) {
		const r = this
		return i
		function i(s) {
			return dV.call(r, e, a, o, "reference", "referenceMarker", "referenceString")(s)
		}
		function a(s) {
			return r.parser.defined.includes(
				To(r.sliceSerialize(r.events[r.events.length - 1][1]).slice(1, -1)),
			)
				? t(s)
				: n(s)
		}
		function o(s) {
			return n(s)
		}
	}
	function zut(e, t, n) {
		return r
		function r(a) {
			return (
				e.enter("reference"), e.enter("referenceMarker"), e.consume(a), e.exit("referenceMarker"), i
			)
		}
		function i(a) {
			return a === 93
				? (e.enter("referenceMarker"),
				  e.consume(a),
				  e.exit("referenceMarker"),
				  e.exit("reference"),
				  t)
				: n(a)
		}
	}
	const qut = { name: "labelStartImage", resolveAll: xA.resolveAll, tokenize: Vut }
	function Vut(e, t, n) {
		const r = this
		return i
		function i(s) {
			return (
				e.enter("labelImage"),
				e.enter("labelImageMarker"),
				e.consume(s),
				e.exit("labelImageMarker"),
				a
			)
		}
		function a(s) {
			return s === 91
				? (e.enter("labelMarker"), e.consume(s), e.exit("labelMarker"), e.exit("labelImage"), o)
				: n(s)
		}
		function o(s) {
			return s === 94 && "_hiddenFootnoteSupport" in r.parser.constructs ? n(s) : t(s)
		}
	}
	const Wut = { name: "labelStartLink", resolveAll: xA.resolveAll, tokenize: Yut }
	function Yut(e, t, n) {
		const r = this
		return i
		function i(o) {
			return (
				e.enter("labelLink"),
				e.enter("labelMarker"),
				e.consume(o),
				e.exit("labelMarker"),
				e.exit("labelLink"),
				a
			)
		}
		function a(o) {
			return o === 94 && "_hiddenFootnoteSupport" in r.parser.constructs ? n(o) : t(o)
		}
	}
	const Uk = { name: "lineEnding", tokenize: Gut }
	function Gut(e, t) {
		return n
		function n(r) {
			return e.enter("lineEnding"), e.consume(r), e.exit("lineEnding"), Nt(e, t, "linePrefix")
		}
	}
	const y1 = { name: "thematicBreak", tokenize: Kut }
	function Kut(e, t, n) {
		let r = 0,
			i
		return a
		function a(u) {
			return e.enter("thematicBreak"), o(u)
		}
		function o(u) {
			return (i = u), s(u)
		}
		function s(u) {
			return u === i
				? (e.enter("thematicBreakSequence"), l(u))
				: r >= 3 && (u === null || ut(u))
				? (e.exit("thematicBreak"), t(u))
				: n(u)
		}
		function l(u) {
			return u === i
				? (e.consume(u), r++, l)
				: (e.exit("thematicBreakSequence"), kt(u) ? Nt(e, s, "whitespace")(u) : s(u))
		}
	}
	const Ri = { continuation: { tokenize: Zut }, exit: tct, name: "list", tokenize: Jut },
		Qut = { partial: !0, tokenize: nct },
		Xut = { partial: !0, tokenize: ect }
	function Jut(e, t, n) {
		const r = this,
			i = r.events[r.events.length - 1]
		let a = i && i[1].type === "linePrefix" ? i[2].sliceSerialize(i[1], !0).length : 0,
			o = 0
		return s
		function s(v) {
			const y =
				r.containerState.type ||
				(v === 42 || v === 43 || v === 45 ? "listUnordered" : "listOrdered")
			if (
				y === "listUnordered" ? !r.containerState.marker || v === r.containerState.marker : uD(v)
			) {
				if (
					(r.containerState.type || ((r.containerState.type = y), e.enter(y, { _container: !0 })),
					y === "listUnordered")
				)
					return e.enter("listItemPrefix"), v === 42 || v === 45 ? e.check(y1, n, u)(v) : u(v)
				if (!r.interrupt || v === 49)
					return e.enter("listItemPrefix"), e.enter("listItemValue"), l(v)
			}
			return n(v)
		}
		function l(v) {
			return uD(v) && ++o < 10
				? (e.consume(v), l)
				: (!r.interrupt || o < 2) &&
				  (r.containerState.marker ? v === r.containerState.marker : v === 41 || v === 46)
				? (e.exit("listItemValue"), u(v))
				: n(v)
		}
		function u(v) {
			return (
				e.enter("listItemMarker"),
				e.consume(v),
				e.exit("listItemMarker"),
				(r.containerState.marker = r.containerState.marker || v),
				e.check(yg, r.interrupt ? n : d, e.attempt(Qut, m, p))
			)
		}
		function d(v) {
			return (r.containerState.initialBlankLine = !0), a++, m(v)
		}
		function p(v) {
			return kt(v)
				? (e.enter("listItemPrefixWhitespace"), e.consume(v), e.exit("listItemPrefixWhitespace"), m)
				: n(v)
		}
		function m(v) {
			return (
				(r.containerState.size = a + r.sliceSerialize(e.exit("listItemPrefix"), !0).length), t(v)
			)
		}
	}
	function Zut(e, t, n) {
		const r = this
		return (r.containerState._closeFlow = void 0), e.check(yg, i, a)
		function i(s) {
			return (
				(r.containerState.furtherBlankLines =
					r.containerState.furtherBlankLines || r.containerState.initialBlankLine),
				Nt(e, t, "listItemIndent", r.containerState.size + 1)(s)
			)
		}
		function a(s) {
			return r.containerState.furtherBlankLines || !kt(s)
				? ((r.containerState.furtherBlankLines = void 0),
				  (r.containerState.initialBlankLine = void 0),
				  o(s))
				: ((r.containerState.furtherBlankLines = void 0),
				  (r.containerState.initialBlankLine = void 0),
				  e.attempt(Xut, t, o)(s))
		}
		function o(s) {
			return (
				(r.containerState._closeFlow = !0),
				(r.interrupt = void 0),
				Nt(
					e,
					e.attempt(Ri, t, n),
					"linePrefix",
					r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4,
				)(s)
			)
		}
	}
	function ect(e, t, n) {
		const r = this
		return Nt(e, i, "listItemIndent", r.containerState.size + 1)
		function i(a) {
			const o = r.events[r.events.length - 1]
			return o &&
				o[1].type === "listItemIndent" &&
				o[2].sliceSerialize(o[1], !0).length === r.containerState.size
				? t(a)
				: n(a)
		}
	}
	function tct(e) {
		e.exit(this.containerState.type)
	}
	function nct(e, t, n) {
		const r = this
		return Nt(
			e,
			i,
			"listItemPrefixWhitespace",
			r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 5,
		)
		function i(a) {
			const o = r.events[r.events.length - 1]
			return !kt(a) && o && o[1].type === "listItemPrefixWhitespace" ? t(a) : n(a)
		}
	}
	const N6 = { name: "setextUnderline", resolveTo: rct, tokenize: ict }
	function rct(e, t) {
		let n = e.length,
			r,
			i,
			a
		for (; n--; )
			if (e[n][0] === "enter") {
				if (e[n][1].type === "content") {
					r = n
					break
				}
				e[n][1].type === "paragraph" && (i = n)
			} else
				e[n][1].type === "content" && e.splice(n, 1), !a && e[n][1].type === "definition" && (a = n)
		const o = {
			type: "setextHeading",
			start: { ...e[i][1].start },
			end: { ...e[e.length - 1][1].end },
		}
		return (
			(e[i][1].type = "setextHeadingText"),
			a
				? (e.splice(i, 0, ["enter", o, t]),
				  e.splice(a + 1, 0, ["exit", e[r][1], t]),
				  (e[r][1].end = { ...e[a][1].end }))
				: (e[r][1] = o),
			e.push(["exit", o, t]),
			e
		)
	}
	function ict(e, t, n) {
		const r = this
		let i
		return a
		function a(u) {
			let d = r.events.length,
				p
			for (; d--; )
				if (
					r.events[d][1].type !== "lineEnding" &&
					r.events[d][1].type !== "linePrefix" &&
					r.events[d][1].type !== "content"
				) {
					p = r.events[d][1].type === "paragraph"
					break
				}
			return !r.parser.lazy[r.now().line] && (r.interrupt || p)
				? (e.enter("setextHeadingLine"), (i = u), o(u))
				: n(u)
		}
		function o(u) {
			return e.enter("setextHeadingLineSequence"), s(u)
		}
		function s(u) {
			return u === i
				? (e.consume(u), s)
				: (e.exit("setextHeadingLineSequence"), kt(u) ? Nt(e, l, "lineSuffix")(u) : l(u))
		}
		function l(u) {
			return u === null || ut(u) ? (e.exit("setextHeadingLine"), t(u)) : n(u)
		}
	}
	const act = { tokenize: oct }
	function oct(e) {
		const t = this,
			n = e.attempt(
				yg,
				r,
				e.attempt(
					this.parser.constructs.flowInitial,
					i,
					Nt(e, e.attempt(this.parser.constructs.flow, i, e.attempt(dut, i)), "linePrefix"),
				),
			)
		return n
		function r(a) {
			if (a === null) {
				e.consume(a)
				return
			}
			return (
				e.enter("lineEndingBlank"),
				e.consume(a),
				e.exit("lineEndingBlank"),
				(t.currentConstruct = void 0),
				n
			)
		}
		function i(a) {
			if (a === null) {
				e.consume(a)
				return
			}
			return (
				e.enter("lineEnding"), e.consume(a), e.exit("lineEnding"), (t.currentConstruct = void 0), n
			)
		}
	}
	const sct = { resolveAll: hV() },
		lct = pV("string"),
		uct = pV("text")
	function pV(e) {
		return { resolveAll: hV(e === "text" ? cct : void 0), tokenize: t }
		function t(n) {
			const r = this,
				i = this.parser.constructs[e],
				a = n.attempt(i, o, s)
			return o
			function o(d) {
				return u(d) ? a(d) : s(d)
			}
			function s(d) {
				if (d === null) {
					n.consume(d)
					return
				}
				return n.enter("data"), n.consume(d), l
			}
			function l(d) {
				return u(d) ? (n.exit("data"), a(d)) : (n.consume(d), l)
			}
			function u(d) {
				if (d === null) return !0
				const p = i[d]
				let m = -1
				if (p)
					for (; ++m < p.length; ) {
						const v = p[m]
						if (!v.previous || v.previous.call(r, r.previous)) return !0
					}
				return !1
			}
		}
	}
	function hV(e) {
		return t
		function t(n, r) {
			let i = -1,
				a
			for (; ++i <= n.length; )
				a === void 0
					? n[i] && n[i][1].type === "data" && ((a = i), i++)
					: (!n[i] || n[i][1].type !== "data") &&
					  (i !== a + 2 &&
							((n[a][1].end = n[i - 1][1].end), n.splice(a + 2, i - a - 2), (i = a + 2)),
					  (a = void 0))
			return e ? e(n, r) : n
		}
	}
	function cct(e, t) {
		let n = 0
		for (; ++n <= e.length; )
			if ((n === e.length || e[n][1].type === "lineEnding") && e[n - 1][1].type === "data") {
				const r = e[n - 1][1],
					i = t.sliceStream(r)
				let a = i.length,
					o = -1,
					s = 0,
					l
				for (; a--; ) {
					const u = i[a]
					if (typeof u == "string") {
						for (o = u.length; u.charCodeAt(o - 1) === 32; ) s++, o--
						if (o) break
						o = -1
					} else if (u === -2) (l = !0), s++
					else if (u !== -1) {
						a++
						break
					}
				}
				if (s) {
					const u = {
						type: n === e.length || l || s < 2 ? "lineSuffix" : "hardBreakTrailing",
						start: {
							_bufferIndex: a ? o : r.start._bufferIndex + o,
							_index: r.start._index + a,
							line: r.end.line,
							column: r.end.column - s,
							offset: r.end.offset - s,
						},
						end: { ...r.end },
					}
					;(r.end = { ...u.start }),
						r.start.offset === r.end.offset
							? Object.assign(r, u)
							: (e.splice(n, 0, ["enter", u, t], ["exit", u, t]), (n += 2))
				}
				n++
			}
		return e
	}
	const dct = {
			42: Ri,
			43: Ri,
			45: Ri,
			48: Ri,
			49: Ri,
			50: Ri,
			51: Ri,
			52: Ri,
			53: Ri,
			54: Ri,
			55: Ri,
			56: Ri,
			57: Ri,
			62: oV,
		},
		fct = { 91: vut },
		pct = { [-2]: $k, [-1]: $k, 32: $k },
		hct = { 35: Eut, 42: y1, 45: [N6, y1], 60: Sut, 61: N6, 95: y1, 96: O6, 126: O6 },
		mct = { 38: lV, 92: sV },
		vct = {
			[-5]: Uk,
			[-4]: Uk,
			[-3]: Uk,
			33: qut,
			38: lV,
			42: cD,
			60: [Wlt, Iut],
			91: Wut,
			92: [xut, sV],
			93: xA,
			95: cD,
			96: aut,
		},
		gct = { null: [cD, sct] },
		yct = { null: [42, 95] },
		bct = { null: [] },
		xct = Object.freeze(
			Object.defineProperty(
				{
					__proto__: null,
					attentionMarkers: yct,
					contentInitial: fct,
					disable: bct,
					document: dct,
					flow: hct,
					flowInitial: pct,
					insideSpan: gct,
					string: mct,
					text: vct,
				},
				Symbol.toStringTag,
				{ value: "Module" },
			),
		)
	function wct(e, t, n) {
		let r = {
			_bufferIndex: -1,
			_index: 0,
			line: (n && n.line) || 1,
			column: (n && n.column) || 1,
			offset: (n && n.offset) || 0,
		}
		const i = {},
			a = []
		let o = [],
			s = []
		const l = {
				attempt: N(O),
				check: N(A),
				consume: T,
				enter: C,
				exit: D,
				interrupt: N(A, { interrupt: !0 }),
			},
			u = {
				code: null,
				containerState: {},
				defineSkip: b,
				events: [],
				now: y,
				parser: e,
				previous: null,
				sliceSerialize: m,
				sliceStream: v,
				write: p,
			}
		let d = t.tokenize.call(u, l)
		return t.resolveAll && a.push(t), u
		function p(B) {
			return (
				(o = Fa(o, B)),
				x(),
				o[o.length - 1] !== null ? [] : (I(t, 0), (u.events = Ew(a, u.events, u)), u.events)
			)
		}
		function m(B, z) {
			return Cct(v(B), z)
		}
		function v(B) {
			return Ect(o, B)
		}
		function y() {
			const { _bufferIndex: B, _index: z, line: V, column: K, offset: ne } = r
			return { _bufferIndex: B, _index: z, line: V, column: K, offset: ne }
		}
		function b(B) {
			;(i[B.line] = B.column), L()
		}
		function x() {
			let B
			for (; r._index < o.length; ) {
				const z = o[r._index]
				if (typeof z == "string")
					for (
						B = r._index, r._bufferIndex < 0 && (r._bufferIndex = 0);
						r._index === B && r._bufferIndex < z.length;

					)
						E(z.charCodeAt(r._bufferIndex))
				else E(z)
			}
		}
		function E(B) {
			d = d(B)
		}
		function T(B) {
			ut(B)
				? (r.line++, (r.column = 1), (r.offset += B === -3 ? 2 : 1), L())
				: B !== -1 && (r.column++, r.offset++),
				r._bufferIndex < 0
					? r._index++
					: (r._bufferIndex++,
					  r._bufferIndex === o[r._index].length && ((r._bufferIndex = -1), r._index++)),
				(u.previous = B)
		}
		function C(B, z) {
			const V = z || {}
			return (V.type = B), (V.start = y()), u.events.push(["enter", V, u]), s.push(V), V
		}
		function D(B) {
			const z = s.pop()
			return (z.end = y()), u.events.push(["exit", z, u]), z
		}
		function O(B, z) {
			I(B, z.from)
		}
		function A(B, z) {
			z.restore()
		}
		function N(B, z) {
			return V
			function V(K, ne, re) {
				let ie, J, le, F
				return Array.isArray(K) ? ee(K) : "tokenize" in K ? ee([K]) : Y(K)
				function Y(Ee) {
					return be
					function be(Le) {
						const Be = Le !== null && Ee[Le],
							et = Le !== null && Ee.null,
							pt = [
								...(Array.isArray(Be) ? Be : Be ? [Be] : []),
								...(Array.isArray(et) ? et : et ? [et] : []),
							]
						return ee(pt)(Le)
					}
				}
				function ee(Ee) {
					return (ie = Ee), (J = 0), Ee.length === 0 ? re : $(Ee[J])
				}
				function $(Ee) {
					return be
					function be(Le) {
						return (
							(F = P()),
							(le = Ee),
							Ee.partial || (u.currentConstruct = Ee),
							Ee.name && u.parser.constructs.disable.null.includes(Ee.name)
								? Se()
								: Ee.tokenize.call(z ? Object.assign(Object.create(u), z) : u, l, ge, Se)(Le)
						)
					}
				}
				function ge(Ee) {
					return B(le, F), ne
				}
				function Se(Ee) {
					return F.restore(), ++J < ie.length ? $(ie[J]) : re
				}
			}
		}
		function I(B, z) {
			B.resolveAll && !a.includes(B) && a.push(B),
				B.resolve && va(u.events, z, u.events.length - z, B.resolve(u.events.slice(z), u)),
				B.resolveTo && (u.events = B.resolveTo(u.events, u))
		}
		function P() {
			const B = y(),
				z = u.previous,
				V = u.currentConstruct,
				K = u.events.length,
				ne = Array.from(s)
			return { from: K, restore: re }
			function re() {
				;(r = B), (u.previous = z), (u.currentConstruct = V), (u.events.length = K), (s = ne), L()
			}
		}
		function L() {
			r.line in i && r.column < 2 && ((r.column = i[r.line]), (r.offset += i[r.line] - 1))
		}
	}
	function Ect(e, t) {
		const n = t.start._index,
			r = t.start._bufferIndex,
			i = t.end._index,
			a = t.end._bufferIndex
		let o
		if (n === i) o = [e[n].slice(r, a)]
		else {
			if (((o = e.slice(n, i)), r > -1)) {
				const s = o[0]
				typeof s == "string" ? (o[0] = s.slice(r)) : o.shift()
			}
			a > 0 && o.push(e[i].slice(0, a))
		}
		return o
	}
	function Cct(e, t) {
		let n = -1
		const r = []
		let i
		for (; ++n < e.length; ) {
			const a = e[n]
			let o
			if (typeof a == "string") o = a
			else
				switch (a) {
					case -5: {
						o = "\r"
						break
					}
					case -4: {
						o = `
`
						break
					}
					case -3: {
						o = `\r
`
						break
					}
					case -2: {
						o = t ? " " : "	"
						break
					}
					case -1: {
						if (!t && i) continue
						o = " "
						break
					}
					default:
						o = String.fromCharCode(a)
				}
			;(i = a === -2), r.push(o)
		}
		return r.join("")
	}
	function Tct(e) {
		const r = {
			constructs: iV([xct, ...((e || {}).extensions || [])]),
			content: i(Blt),
			defined: [],
			document: i($lt),
			flow: i(act),
			lazy: {},
			string: i(lct),
			text: i(uct),
		}
		return r
		function i(a) {
			return o
			function o(s) {
				return wct(r, a, s)
			}
		}
	}
	function kct(e) {
		for (; !uV(e); );
		return e
	}
	const M6 = /[\0\t\n\r]/g
	function Sct() {
		let e = 1,
			t = "",
			n = !0,
			r
		return i
		function i(a, o, s) {
			const l = []
			let u, d, p, m, v
			for (
				a = t + (typeof a == "string" ? a.toString() : new TextDecoder(o || void 0).decode(a)),
					p = 0,
					t = "",
					n && (a.charCodeAt(0) === 65279 && p++, (n = void 0));
				p < a.length;

			) {
				if (
					((M6.lastIndex = p),
					(u = M6.exec(a)),
					(m = u && u.index !== void 0 ? u.index : a.length),
					(v = a.charCodeAt(m)),
					!u)
				) {
					t = a.slice(p)
					break
				}
				if (v === 10 && p === m && r) l.push(-3), (r = void 0)
				else
					switch (
						(r && (l.push(-5), (r = void 0)), p < m && (l.push(a.slice(p, m)), (e += m - p)), v)
					) {
						case 0: {
							l.push(65533), e++
							break
						}
						case 9: {
							for (d = Math.ceil(e / 4) * 4, l.push(-2); e++ < d; ) l.push(-1)
							break
						}
						case 10: {
							l.push(-4), (e = 1)
							break
						}
						default:
							;(r = !0), (e = 1)
					}
				p = m + 1
			}
			return s && (r && l.push(-5), t && l.push(t), l.push(null)), l
		}
	}
	const Dct = /\\([!-/:-@[-`{-~])|&(#(?:\d{1,7}|x[\da-f]{1,6})|[\da-z]{1,31});/gi
	function _ct(e) {
		return e.replace(Dct, Oct)
	}
	function Oct(e, t, n) {
		if (t) return t
		if (n.charCodeAt(0) === 35) {
			const i = n.charCodeAt(1),
				a = i === 120 || i === 88
			return aV(n.slice(a ? 2 : 1), a ? 16 : 10)
		}
		return bA(n) || e
	}
	const mV = {}.hasOwnProperty
	function Act(e, t, n) {
		return (
			typeof t != "string" && ((n = t), (t = void 0)),
			Nct(n)(kct(Tct(n).document().write(Sct()(e, t, !0))))
		)
	}
	function Nct(e) {
		const t = {
			transforms: [],
			canContainEols: ["emphasis", "fragment", "heading", "paragraph", "strong"],
			enter: {
				autolink: a(Hn),
				autolinkProtocol: P,
				autolinkEmail: P,
				atxHeading: a(dt),
				blockQuote: a(et),
				characterEscape: P,
				characterReference: P,
				codeFenced: a(pt),
				codeFencedFenceInfo: o,
				codeFencedFenceMeta: o,
				codeIndented: a(pt, o),
				codeText: a(mt, o),
				codeTextData: P,
				data: P,
				codeFlowValue: P,
				definition: a(Xt),
				definitionDestinationString: o,
				definitionLabelString: o,
				definitionTitleString: o,
				emphasis: a(on),
				hardBreakEscape: a(cn),
				hardBreakTrailing: a(cn),
				htmlFlow: a(sn, o),
				htmlFlowData: P,
				htmlText: a(sn, o),
				htmlTextData: P,
				image: a(ur),
				label: o,
				link: a(Hn),
				listItem: a(mn),
				listItemValue: m,
				listOrdered: a(Jt, p),
				listUnordered: a(Jt),
				paragraph: a(ue),
				reference: $,
				referenceString: o,
				resourceDestinationString: o,
				resourceTitleString: o,
				setextHeading: a(dt),
				strong: a(Re),
				thematicBreak: a(ye),
			},
			exit: {
				atxHeading: l(),
				atxHeadingSequence: O,
				autolink: l(),
				autolinkEmail: Be,
				autolinkProtocol: Le,
				blockQuote: l(),
				characterEscapeValue: L,
				characterReferenceMarkerHexadecimal: Se,
				characterReferenceMarkerNumeric: Se,
				characterReferenceValue: Ee,
				characterReference: be,
				codeFenced: l(x),
				codeFencedFence: b,
				codeFencedFenceInfo: v,
				codeFencedFenceMeta: y,
				codeFlowValue: L,
				codeIndented: l(E),
				codeText: l(ne),
				codeTextData: L,
				data: L,
				definition: l(),
				definitionDestinationString: D,
				definitionLabelString: T,
				definitionTitleString: C,
				emphasis: l(),
				hardBreakEscape: l(z),
				hardBreakTrailing: l(z),
				htmlFlow: l(V),
				htmlFlowData: L,
				htmlText: l(K),
				htmlTextData: L,
				image: l(ie),
				label: le,
				labelText: J,
				lineEnding: B,
				link: l(re),
				listItem: l(),
				listOrdered: l(),
				listUnordered: l(),
				paragraph: l(),
				referenceString: ge,
				resourceDestinationString: F,
				resourceTitleString: Y,
				resource: ee,
				setextHeading: l(I),
				setextHeadingLineSequence: N,
				setextHeadingText: A,
				strong: l(),
				thematicBreak: l(),
			},
		}
		vV(t, (e || {}).mdastExtensions || [])
		const n = {}
		return r
		function r(X) {
			let de = { type: "root", children: [] }
			const Me = {
					stack: [de],
					tokenStack: [],
					config: t,
					enter: s,
					exit: u,
					buffer: o,
					resume: d,
					data: n,
				},
				Ze = []
			let ct = -1
			for (; ++ct < X.length; )
				if (X[ct][1].type === "listOrdered" || X[ct][1].type === "listUnordered")
					if (X[ct][0] === "enter") Ze.push(ct)
					else {
						const Ot = Ze.pop()
						ct = i(X, Ot, ct)
					}
			for (ct = -1; ++ct < X.length; ) {
				const Ot = t[X[ct][0]]
				mV.call(Ot, X[ct][1].type) &&
					Ot[X[ct][1].type].call(
						Object.assign({ sliceSerialize: X[ct][2].sliceSerialize }, Me),
						X[ct][1],
					)
			}
			if (Me.tokenStack.length > 0) {
				const Ot = Me.tokenStack[Me.tokenStack.length - 1]
				;(Ot[1] || I6).call(Me, void 0, Ot[0])
			}
			for (
				de.position = {
					start: au(X.length > 0 ? X[0][1].start : { line: 1, column: 1, offset: 0 }),
					end: au(X.length > 0 ? X[X.length - 2][1].end : { line: 1, column: 1, offset: 0 }),
				},
					ct = -1;
				++ct < t.transforms.length;

			)
				de = t.transforms[ct](de) || de
			return de
		}
		function i(X, de, Me) {
			let Ze = de - 1,
				ct = -1,
				Ot = !1,
				tr,
				Wn,
				An,
				li
			for (; ++Ze <= Me; ) {
				const Nn = X[Ze]
				switch (Nn[1].type) {
					case "listUnordered":
					case "listOrdered":
					case "blockQuote": {
						Nn[0] === "enter" ? ct++ : ct--, (li = void 0)
						break
					}
					case "lineEndingBlank": {
						Nn[0] === "enter" && (tr && !li && !ct && !An && (An = Ze), (li = void 0))
						break
					}
					case "linePrefix":
					case "listItemValue":
					case "listItemMarker":
					case "listItemPrefix":
					case "listItemPrefixWhitespace":
						break
					default:
						li = void 0
				}
				if (
					(!ct && Nn[0] === "enter" && Nn[1].type === "listItemPrefix") ||
					(ct === -1 &&
						Nn[0] === "exit" &&
						(Nn[1].type === "listUnordered" || Nn[1].type === "listOrdered"))
				) {
					if (tr) {
						let Yn = Ze
						for (Wn = void 0; Yn--; ) {
							const Tn = X[Yn]
							if (Tn[1].type === "lineEnding" || Tn[1].type === "lineEndingBlank") {
								if (Tn[0] === "exit") continue
								Wn && ((X[Wn][1].type = "lineEndingBlank"), (Ot = !0)),
									(Tn[1].type = "lineEnding"),
									(Wn = Yn)
							} else if (
								!(
									Tn[1].type === "linePrefix" ||
									Tn[1].type === "blockQuotePrefix" ||
									Tn[1].type === "blockQuotePrefixWhitespace" ||
									Tn[1].type === "blockQuoteMarker" ||
									Tn[1].type === "listItemIndent"
								)
							)
								break
						}
						An && (!Wn || An < Wn) && (tr._spread = !0),
							(tr.end = Object.assign({}, Wn ? X[Wn][1].start : Nn[1].end)),
							X.splice(Wn || Ze, 0, ["exit", tr, Nn[2]]),
							Ze++,
							Me++
					}
					if (Nn[1].type === "listItemPrefix") {
						const Yn = {
							type: "listItem",
							_spread: !1,
							start: Object.assign({}, Nn[1].start),
							end: void 0,
						}
						;(tr = Yn), X.splice(Ze, 0, ["enter", Yn, Nn[2]]), Ze++, Me++, (An = void 0), (li = !0)
					}
				}
			}
			return (X[de][1]._spread = Ot), Me
		}
		function a(X, de) {
			return Me
			function Me(Ze) {
				s.call(this, X(Ze), Ze), de && de.call(this, Ze)
			}
		}
		function o() {
			this.stack.push({ type: "fragment", children: [] })
		}
		function s(X, de, Me) {
			this.stack[this.stack.length - 1].children.push(X),
				this.stack.push(X),
				this.tokenStack.push([de, Me || void 0]),
				(X.position = { start: au(de.start), end: void 0 })
		}
		function l(X) {
			return de
			function de(Me) {
				X && X.call(this, Me), u.call(this, Me)
			}
		}
		function u(X, de) {
			const Me = this.stack.pop(),
				Ze = this.tokenStack.pop()
			if (Ze)
				Ze[0].type !== X.type && (de ? de.call(this, X, Ze[0]) : (Ze[1] || I6).call(this, X, Ze[0]))
			else
				throw new Error(
					"Cannot close `" +
						X.type +
						"` (" +
						Wm({ start: X.start, end: X.end }) +
						"): its not open",
				)
			Me.position.end = au(X.end)
		}
		function d() {
			return yA(this.stack.pop())
		}
		function p() {
			this.data.expectingFirstListItemValue = !0
		}
		function m(X) {
			if (this.data.expectingFirstListItemValue) {
				const de = this.stack[this.stack.length - 2]
				;(de.start = Number.parseInt(this.sliceSerialize(X), 10)),
					(this.data.expectingFirstListItemValue = void 0)
			}
		}
		function v() {
			const X = this.resume(),
				de = this.stack[this.stack.length - 1]
			de.lang = X
		}
		function y() {
			const X = this.resume(),
				de = this.stack[this.stack.length - 1]
			de.meta = X
		}
		function b() {
			this.data.flowCodeInside || (this.buffer(), (this.data.flowCodeInside = !0))
		}
		function x() {
			const X = this.resume(),
				de = this.stack[this.stack.length - 1]
			;(de.value = X.replace(/^(\r?\n|\r)|(\r?\n|\r)$/g, "")), (this.data.flowCodeInside = void 0)
		}
		function E() {
			const X = this.resume(),
				de = this.stack[this.stack.length - 1]
			de.value = X.replace(/(\r?\n|\r)$/g, "")
		}
		function T(X) {
			const de = this.resume(),
				Me = this.stack[this.stack.length - 1]
			;(Me.label = de), (Me.identifier = To(this.sliceSerialize(X)).toLowerCase())
		}
		function C() {
			const X = this.resume(),
				de = this.stack[this.stack.length - 1]
			de.title = X
		}
		function D() {
			const X = this.resume(),
				de = this.stack[this.stack.length - 1]
			de.url = X
		}
		function O(X) {
			const de = this.stack[this.stack.length - 1]
			if (!de.depth) {
				const Me = this.sliceSerialize(X).length
				de.depth = Me
			}
		}
		function A() {
			this.data.setextHeadingSlurpLineEnding = !0
		}
		function N(X) {
			const de = this.stack[this.stack.length - 1]
			de.depth = this.sliceSerialize(X).codePointAt(0) === 61 ? 1 : 2
		}
		function I() {
			this.data.setextHeadingSlurpLineEnding = void 0
		}
		function P(X) {
			const Me = this.stack[this.stack.length - 1].children
			let Ze = Me[Me.length - 1]
			;(!Ze || Ze.type !== "text") &&
				((Ze = pe()), (Ze.position = { start: au(X.start), end: void 0 }), Me.push(Ze)),
				this.stack.push(Ze)
		}
		function L(X) {
			const de = this.stack.pop()
			;(de.value += this.sliceSerialize(X)), (de.position.end = au(X.end))
		}
		function B(X) {
			const de = this.stack[this.stack.length - 1]
			if (this.data.atHardBreak) {
				const Me = de.children[de.children.length - 1]
				;(Me.position.end = au(X.end)), (this.data.atHardBreak = void 0)
				return
			}
			!this.data.setextHeadingSlurpLineEnding &&
				t.canContainEols.includes(de.type) &&
				(P.call(this, X), L.call(this, X))
		}
		function z() {
			this.data.atHardBreak = !0
		}
		function V() {
			const X = this.resume(),
				de = this.stack[this.stack.length - 1]
			de.value = X
		}
		function K() {
			const X = this.resume(),
				de = this.stack[this.stack.length - 1]
			de.value = X
		}
		function ne() {
			const X = this.resume(),
				de = this.stack[this.stack.length - 1]
			de.value = X
		}
		function re() {
			const X = this.stack[this.stack.length - 1]
			if (this.data.inReference) {
				const de = this.data.referenceType || "shortcut"
				;(X.type += "Reference"), (X.referenceType = de), delete X.url, delete X.title
			} else delete X.identifier, delete X.label
			this.data.referenceType = void 0
		}
		function ie() {
			const X = this.stack[this.stack.length - 1]
			if (this.data.inReference) {
				const de = this.data.referenceType || "shortcut"
				;(X.type += "Reference"), (X.referenceType = de), delete X.url, delete X.title
			} else delete X.identifier, delete X.label
			this.data.referenceType = void 0
		}
		function J(X) {
			const de = this.sliceSerialize(X),
				Me = this.stack[this.stack.length - 2]
			;(Me.label = _ct(de)), (Me.identifier = To(de).toLowerCase())
		}
		function le() {
			const X = this.stack[this.stack.length - 1],
				de = this.resume(),
				Me = this.stack[this.stack.length - 1]
			if (((this.data.inReference = !0), Me.type === "link")) {
				const Ze = X.children
				Me.children = Ze
			} else Me.alt = de
		}
		function F() {
			const X = this.resume(),
				de = this.stack[this.stack.length - 1]
			de.url = X
		}
		function Y() {
			const X = this.resume(),
				de = this.stack[this.stack.length - 1]
			de.title = X
		}
		function ee() {
			this.data.inReference = void 0
		}
		function $() {
			this.data.referenceType = "collapsed"
		}
		function ge(X) {
			const de = this.resume(),
				Me = this.stack[this.stack.length - 1]
			;(Me.label = de),
				(Me.identifier = To(this.sliceSerialize(X)).toLowerCase()),
				(this.data.referenceType = "full")
		}
		function Se(X) {
			this.data.characterReferenceType = X.type
		}
		function Ee(X) {
			const de = this.sliceSerialize(X),
				Me = this.data.characterReferenceType
			let Ze
			Me
				? ((Ze = aV(de, Me === "characterReferenceMarkerNumeric" ? 10 : 16)),
				  (this.data.characterReferenceType = void 0))
				: (Ze = bA(de))
			const ct = this.stack[this.stack.length - 1]
			ct.value += Ze
		}
		function be(X) {
			const de = this.stack.pop()
			de.position.end = au(X.end)
		}
		function Le(X) {
			L.call(this, X)
			const de = this.stack[this.stack.length - 1]
			de.url = this.sliceSerialize(X)
		}
		function Be(X) {
			L.call(this, X)
			const de = this.stack[this.stack.length - 1]
			de.url = "mailto:" + this.sliceSerialize(X)
		}
		function et() {
			return { type: "blockquote", children: [] }
		}
		function pt() {
			return { type: "code", lang: null, meta: null, value: "" }
		}
		function mt() {
			return { type: "inlineCode", value: "" }
		}
		function Xt() {
			return { type: "definition", identifier: "", label: null, title: null, url: "" }
		}
		function on() {
			return { type: "emphasis", children: [] }
		}
		function dt() {
			return { type: "heading", depth: 0, children: [] }
		}
		function cn() {
			return { type: "break" }
		}
		function sn() {
			return { type: "html", value: "" }
		}
		function ur() {
			return { type: "image", title: null, url: "", alt: null }
		}
		function Hn() {
			return { type: "link", title: null, url: "", children: [] }
		}
		function Jt(X) {
			return {
				type: "list",
				ordered: X.type === "listOrdered",
				start: null,
				spread: X._spread,
				children: [],
			}
		}
		function mn(X) {
			return { type: "listItem", spread: X._spread, checked: null, children: [] }
		}
		function ue() {
			return { type: "paragraph", children: [] }
		}
		function Re() {
			return { type: "strong", children: [] }
		}
		function pe() {
			return { type: "text", value: "" }
		}
		function ye() {
			return { type: "thematicBreak" }
		}
	}
	function au(e) {
		return { line: e.line, column: e.column, offset: e.offset }
	}
	function vV(e, t) {
		let n = -1
		for (; ++n < t.length; ) {
			const r = t[n]
			Array.isArray(r) ? vV(e, r) : Mct(e, r)
		}
	}
	function Mct(e, t) {
		let n
		for (n in t)
			if (mV.call(t, n))
				switch (n) {
					case "canContainEols": {
						const r = t[n]
						r && e[n].push(...r)
						break
					}
					case "transforms": {
						const r = t[n]
						r && e[n].push(...r)
						break
					}
					case "enter":
					case "exit": {
						const r = t[n]
						r && Object.assign(e[n], r)
						break
					}
				}
	}
	function I6(e, t) {
		throw e
			? new Error(
					"Cannot close `" +
						e.type +
						"` (" +
						Wm({ start: e.start, end: e.end }) +
						"): a different token (`" +
						t.type +
						"`, " +
						Wm({ start: t.start, end: t.end }) +
						") is open",
			  )
			: new Error(
					"Cannot close document, a token (`" +
						t.type +
						"`, " +
						Wm({ start: t.start, end: t.end }) +
						") is still open",
			  )
	}
	function Ict(e) {
		const t = this
		t.parser = n
		function n(r) {
			return Act(r, {
				...t.data("settings"),
				...e,
				extensions: t.data("micromarkExtensions") || [],
				mdastExtensions: t.data("fromMarkdownExtensions") || [],
			})
		}
	}
	function Rct(e, t) {
		const n = {
			type: "element",
			tagName: "blockquote",
			properties: {},
			children: e.wrap(e.all(t), !0),
		}
		return e.patch(t, n), e.applyData(t, n)
	}
	function Lct(e, t) {
		const n = { type: "element", tagName: "br", properties: {}, children: [] }
		return (
			e.patch(t, n),
			[
				e.applyData(t, n),
				{
					type: "text",
					value: `
`,
				},
			]
		)
	}
	function Pct(e, t) {
		const n = t.value
				? t.value +
				  `
`
				: "",
			r = {}
		t.lang && (r.className = ["language-" + t.lang])
		let i = {
			type: "element",
			tagName: "code",
			properties: r,
			children: [{ type: "text", value: n }],
		}
		return (
			t.meta && (i.data = { meta: t.meta }),
			e.patch(t, i),
			(i = e.applyData(t, i)),
			(i = { type: "element", tagName: "pre", properties: {}, children: [i] }),
			e.patch(t, i),
			i
		)
	}
	function jct(e, t) {
		const n = { type: "element", tagName: "del", properties: {}, children: e.all(t) }
		return e.patch(t, n), e.applyData(t, n)
	}
	function Fct(e, t) {
		const n = { type: "element", tagName: "em", properties: {}, children: e.all(t) }
		return e.patch(t, n), e.applyData(t, n)
	}
	function Bct(e, t) {
		const n =
				typeof e.options.clobberPrefix == "string" ? e.options.clobberPrefix : "user-content-",
			r = String(t.identifier).toUpperCase(),
			i = rh(r.toLowerCase()),
			a = e.footnoteOrder.indexOf(r)
		let o,
			s = e.footnoteCounts.get(r)
		s === void 0 ? ((s = 0), e.footnoteOrder.push(r), (o = e.footnoteOrder.length)) : (o = a + 1),
			(s += 1),
			e.footnoteCounts.set(r, s)
		const l = {
			type: "element",
			tagName: "a",
			properties: {
				href: "#" + n + "fn-" + i,
				id: n + "fnref-" + i + (s > 1 ? "-" + s : ""),
				dataFootnoteRef: !0,
				ariaDescribedBy: ["footnote-label"],
			},
			children: [{ type: "text", value: String(o) }],
		}
		e.patch(t, l)
		const u = { type: "element", tagName: "sup", properties: {}, children: [l] }
		return e.patch(t, u), e.applyData(t, u)
	}
	function Hct(e, t) {
		const n = { type: "element", tagName: "h" + t.depth, properties: {}, children: e.all(t) }
		return e.patch(t, n), e.applyData(t, n)
	}
	function $ct(e, t) {
		if (e.options.allowDangerousHtml) {
			const n = { type: "raw", value: t.value }
			return e.patch(t, n), e.applyData(t, n)
		}
	}
	function gV(e, t) {
		const n = t.referenceType
		let r = "]"
		if (
			(n === "collapsed"
				? (r += "[]")
				: n === "full" && (r += "[" + (t.label || t.identifier) + "]"),
			t.type === "imageReference")
		)
			return [{ type: "text", value: "![" + t.alt + r }]
		const i = e.all(t),
			a = i[0]
		a && a.type === "text" ? (a.value = "[" + a.value) : i.unshift({ type: "text", value: "[" })
		const o = i[i.length - 1]
		return o && o.type === "text" ? (o.value += r) : i.push({ type: "text", value: r }), i
	}
	function Uct(e, t) {
		const n = String(t.identifier).toUpperCase(),
			r = e.definitionById.get(n)
		if (!r) return gV(e, t)
		const i = { src: rh(r.url || ""), alt: t.alt }
		r.title !== null && r.title !== void 0 && (i.title = r.title)
		const a = { type: "element", tagName: "img", properties: i, children: [] }
		return e.patch(t, a), e.applyData(t, a)
	}
	function zct(e, t) {
		const n = { src: rh(t.url) }
		t.alt !== null && t.alt !== void 0 && (n.alt = t.alt),
			t.title !== null && t.title !== void 0 && (n.title = t.title)
		const r = { type: "element", tagName: "img", properties: n, children: [] }
		return e.patch(t, r), e.applyData(t, r)
	}
	function qct(e, t) {
		const n = { type: "text", value: t.value.replace(/\r?\n|\r/g, " ") }
		e.patch(t, n)
		const r = { type: "element", tagName: "code", properties: {}, children: [n] }
		return e.patch(t, r), e.applyData(t, r)
	}
	function Vct(e, t) {
		const n = String(t.identifier).toUpperCase(),
			r = e.definitionById.get(n)
		if (!r) return gV(e, t)
		const i = { href: rh(r.url || "") }
		r.title !== null && r.title !== void 0 && (i.title = r.title)
		const a = { type: "element", tagName: "a", properties: i, children: e.all(t) }
		return e.patch(t, a), e.applyData(t, a)
	}
	function Wct(e, t) {
		const n = { href: rh(t.url) }
		t.title !== null && t.title !== void 0 && (n.title = t.title)
		const r = { type: "element", tagName: "a", properties: n, children: e.all(t) }
		return e.patch(t, r), e.applyData(t, r)
	}
	function Yct(e, t, n) {
		const r = e.all(t),
			i = n ? Gct(n) : yV(t),
			a = {},
			o = []
		if (typeof t.checked == "boolean") {
			const d = r[0]
			let p
			d && d.type === "element" && d.tagName === "p"
				? (p = d)
				: ((p = { type: "element", tagName: "p", properties: {}, children: [] }), r.unshift(p)),
				p.children.length > 0 && p.children.unshift({ type: "text", value: " " }),
				p.children.unshift({
					type: "element",
					tagName: "input",
					properties: { type: "checkbox", checked: t.checked, disabled: !0 },
					children: [],
				}),
				(a.className = ["task-list-item"])
		}
		let s = -1
		for (; ++s < r.length; ) {
			const d = r[s]
			;(i || s !== 0 || d.type !== "element" || d.tagName !== "p") &&
				o.push({
					type: "text",
					value: `
`,
				}),
				d.type === "element" && d.tagName === "p" && !i ? o.push(...d.children) : o.push(d)
		}
		const l = r[r.length - 1]
		l &&
			(i || l.type !== "element" || l.tagName !== "p") &&
			o.push({
				type: "text",
				value: `
`,
			})
		const u = { type: "element", tagName: "li", properties: a, children: o }
		return e.patch(t, u), e.applyData(t, u)
	}
	function Gct(e) {
		let t = !1
		if (e.type === "list") {
			t = e.spread || !1
			const n = e.children
			let r = -1
			for (; !t && ++r < n.length; ) t = yV(n[r])
		}
		return t
	}
	function yV(e) {
		const t = e.spread
		return t ?? e.children.length > 1
	}
	function Kct(e, t) {
		const n = {},
			r = e.all(t)
		let i = -1
		for (typeof t.start == "number" && t.start !== 1 && (n.start = t.start); ++i < r.length; ) {
			const o = r[i]
			if (
				o.type === "element" &&
				o.tagName === "li" &&
				o.properties &&
				Array.isArray(o.properties.className) &&
				o.properties.className.includes("task-list-item")
			) {
				n.className = ["contains-task-list"]
				break
			}
		}
		const a = {
			type: "element",
			tagName: t.ordered ? "ol" : "ul",
			properties: n,
			children: e.wrap(r, !0),
		}
		return e.patch(t, a), e.applyData(t, a)
	}
	function Qct(e, t) {
		const n = { type: "element", tagName: "p", properties: {}, children: e.all(t) }
		return e.patch(t, n), e.applyData(t, n)
	}
	function Xct(e, t) {
		const n = { type: "root", children: e.wrap(e.all(t)) }
		return e.patch(t, n), e.applyData(t, n)
	}
	function Jct(e, t) {
		const n = { type: "element", tagName: "strong", properties: {}, children: e.all(t) }
		return e.patch(t, n), e.applyData(t, n)
	}
	function Zct(e, t) {
		const n = e.all(t),
			r = n.shift(),
			i = []
		if (r) {
			const o = { type: "element", tagName: "thead", properties: {}, children: e.wrap([r], !0) }
			e.patch(t.children[0], o), i.push(o)
		}
		if (n.length > 0) {
			const o = { type: "element", tagName: "tbody", properties: {}, children: e.wrap(n, !0) },
				s = Os(t.children[1]),
				l = xw(t.children[t.children.length - 1])
			s && l && (o.position = { start: s, end: l }), i.push(o)
		}
		const a = { type: "element", tagName: "table", properties: {}, children: e.wrap(i, !0) }
		return e.patch(t, a), e.applyData(t, a)
	}
	function edt(e, t, n) {
		const r = n ? n.children : void 0,
			a = (r ? r.indexOf(t) : 1) === 0 ? "th" : "td",
			o = n && n.type === "table" ? n.align : void 0,
			s = o ? o.length : t.children.length
		let l = -1
		const u = []
		for (; ++l < s; ) {
			const p = t.children[l],
				m = {},
				v = o ? o[l] : void 0
			v && (m.align = v)
			let y = { type: "element", tagName: a, properties: m, children: [] }
			p && ((y.children = e.all(p)), e.patch(p, y), (y = e.applyData(p, y))), u.push(y)
		}
		const d = { type: "element", tagName: "tr", properties: {}, children: e.wrap(u, !0) }
		return e.patch(t, d), e.applyData(t, d)
	}
	function tdt(e, t) {
		const n = { type: "element", tagName: "td", properties: {}, children: e.all(t) }
		return e.patch(t, n), e.applyData(t, n)
	}
	const R6 = 9,
		L6 = 32
	function ndt(e) {
		const t = String(e),
			n = /\r?\n|\r/g
		let r = n.exec(t),
			i = 0
		const a = []
		for (; r; )
			a.push(P6(t.slice(i, r.index), i > 0, !0), r[0]), (i = r.index + r[0].length), (r = n.exec(t))
		return a.push(P6(t.slice(i), i > 0, !1)), a.join("")
	}
	function P6(e, t, n) {
		let r = 0,
			i = e.length
		if (t) {
			let a = e.codePointAt(r)
			for (; a === R6 || a === L6; ) r++, (a = e.codePointAt(r))
		}
		if (n) {
			let a = e.codePointAt(i - 1)
			for (; a === R6 || a === L6; ) i--, (a = e.codePointAt(i - 1))
		}
		return i > r ? e.slice(r, i) : ""
	}
	function rdt(e, t) {
		const n = { type: "text", value: ndt(String(t.value)) }
		return e.patch(t, n), e.applyData(t, n)
	}
	function idt(e, t) {
		const n = { type: "element", tagName: "hr", properties: {}, children: [] }
		return e.patch(t, n), e.applyData(t, n)
	}
	const adt = {
		blockquote: Rct,
		break: Lct,
		code: Pct,
		delete: jct,
		emphasis: Fct,
		footnoteReference: Bct,
		heading: Hct,
		html: $ct,
		imageReference: Uct,
		image: zct,
		inlineCode: qct,
		linkReference: Vct,
		link: Wct,
		listItem: Yct,
		list: Kct,
		paragraph: Qct,
		root: Xct,
		strong: Jct,
		table: Zct,
		tableCell: tdt,
		tableRow: edt,
		text: rdt,
		thematicBreak: idt,
		toml: my,
		yaml: my,
		definition: my,
		footnoteDefinition: my,
	}
	function my() {}
	const bV = -1,
		Cw = 0,
		Ib = 1,
		Rb = 2,
		wA = 3,
		EA = 4,
		CA = 5,
		TA = 6,
		xV = 7,
		wV = 8,
		j6 = typeof self == "object" ? self : globalThis,
		odt = (e, t) => {
			const n = (i, a) => (e.set(a, i), i),
				r = (i) => {
					if (e.has(i)) return e.get(i)
					const [a, o] = t[i]
					switch (a) {
						case Cw:
						case bV:
							return n(o, i)
						case Ib: {
							const s = n([], i)
							for (const l of o) s.push(r(l))
							return s
						}
						case Rb: {
							const s = n({}, i)
							for (const [l, u] of o) s[r(l)] = r(u)
							return s
						}
						case wA:
							return n(new Date(o), i)
						case EA: {
							const { source: s, flags: l } = o
							return n(new RegExp(s, l), i)
						}
						case CA: {
							const s = n(new Map(), i)
							for (const [l, u] of o) s.set(r(l), r(u))
							return s
						}
						case TA: {
							const s = n(new Set(), i)
							for (const l of o) s.add(r(l))
							return s
						}
						case xV: {
							const { name: s, message: l } = o
							return n(new j6[s](l), i)
						}
						case wV:
							return n(BigInt(o), i)
						case "BigInt":
							return n(Object(BigInt(o)), i)
					}
					return n(new j6[a](o), i)
				}
			return r
		},
		F6 = (e) => odt(new Map(), e)(0),
		Tf = "",
		{ toString: sdt } = {},
		{ keys: ldt } = Object,
		cm = (e) => {
			const t = typeof e
			if (t !== "object" || !e) return [Cw, t]
			const n = sdt.call(e).slice(8, -1)
			switch (n) {
				case "Array":
					return [Ib, Tf]
				case "Object":
					return [Rb, Tf]
				case "Date":
					return [wA, Tf]
				case "RegExp":
					return [EA, Tf]
				case "Map":
					return [CA, Tf]
				case "Set":
					return [TA, Tf]
			}
			return n.includes("Array") ? [Ib, n] : n.includes("Error") ? [xV, n] : [Rb, n]
		},
		vy = ([e, t]) => e === Cw && (t === "function" || t === "symbol"),
		udt = (e, t, n, r) => {
			const i = (o, s) => {
					const l = r.push(o) - 1
					return n.set(s, l), l
				},
				a = (o) => {
					if (n.has(o)) return n.get(o)
					let [s, l] = cm(o)
					switch (s) {
						case Cw: {
							let d = o
							switch (l) {
								case "bigint":
									;(s = wV), (d = o.toString())
									break
								case "function":
								case "symbol":
									if (e) throw new TypeError("unable to serialize " + l)
									d = null
									break
								case "undefined":
									return i([bV], o)
							}
							return i([s, d], o)
						}
						case Ib: {
							if (l) return i([l, [...o]], o)
							const d = [],
								p = i([s, d], o)
							for (const m of o) d.push(a(m))
							return p
						}
						case Rb: {
							if (l)
								switch (l) {
									case "BigInt":
										return i([l, o.toString()], o)
									case "Boolean":
									case "Number":
									case "String":
										return i([l, o.valueOf()], o)
								}
							if (t && "toJSON" in o) return a(o.toJSON())
							const d = [],
								p = i([s, d], o)
							for (const m of ldt(o)) (e || !vy(cm(o[m]))) && d.push([a(m), a(o[m])])
							return p
						}
						case wA:
							return i([s, o.toISOString()], o)
						case EA: {
							const { source: d, flags: p } = o
							return i([s, { source: d, flags: p }], o)
						}
						case CA: {
							const d = [],
								p = i([s, d], o)
							for (const [m, v] of o) (e || !(vy(cm(m)) || vy(cm(v)))) && d.push([a(m), a(v)])
							return p
						}
						case TA: {
							const d = [],
								p = i([s, d], o)
							for (const m of o) (e || !vy(cm(m))) && d.push(a(m))
							return p
						}
					}
					const { message: u } = o
					return i([s, { name: l, message: u }], o)
				}
			return a
		},
		B6 = (e, { json: t, lossy: n } = {}) => {
			const r = []
			return udt(!(t || n), !!t, new Map(), r)(e), r
		},
		Dp =
			typeof structuredClone == "function"
				? (e, t) => (t && ("json" in t || "lossy" in t) ? F6(B6(e, t)) : structuredClone(e))
				: (e, t) => F6(B6(e, t))
	function cdt(e, t) {
		const n = [{ type: "text", value: "" }]
		return (
			t > 1 &&
				n.push({
					type: "element",
					tagName: "sup",
					properties: {},
					children: [{ type: "text", value: String(t) }],
				}),
			n
		)
	}
	function ddt(e, t) {
		return "Back to reference " + (e + 1) + (t > 1 ? "-" + t : "")
	}
	function fdt(e) {
		const t =
				typeof e.options.clobberPrefix == "string" ? e.options.clobberPrefix : "user-content-",
			n = e.options.footnoteBackContent || cdt,
			r = e.options.footnoteBackLabel || ddt,
			i = e.options.footnoteLabel || "Footnotes",
			a = e.options.footnoteLabelTagName || "h2",
			o = e.options.footnoteLabelProperties || { className: ["visually-hidden"] },
			s = []
		let l = -1
		for (; ++l < e.footnoteOrder.length; ) {
			const u = e.footnoteById.get(e.footnoteOrder[l])
			if (!u) continue
			const d = e.all(u),
				p = String(u.identifier).toUpperCase(),
				m = rh(p.toLowerCase())
			let v = 0
			const y = [],
				b = e.footnoteCounts.get(p)
			for (; b !== void 0 && ++v <= b; ) {
				y.length > 0 && y.push({ type: "text", value: " " })
				let T = typeof n == "string" ? n : n(l, v)
				typeof T == "string" && (T = { type: "text", value: T }),
					y.push({
						type: "element",
						tagName: "a",
						properties: {
							href: "#" + t + "fnref-" + m + (v > 1 ? "-" + v : ""),
							dataFootnoteBackref: "",
							ariaLabel: typeof r == "string" ? r : r(l, v),
							className: ["data-footnote-backref"],
						},
						children: Array.isArray(T) ? T : [T],
					})
			}
			const x = d[d.length - 1]
			if (x && x.type === "element" && x.tagName === "p") {
				const T = x.children[x.children.length - 1]
				T && T.type === "text" ? (T.value += " ") : x.children.push({ type: "text", value: " " }),
					x.children.push(...y)
			} else d.push(...y)
			const E = {
				type: "element",
				tagName: "li",
				properties: { id: t + "fn-" + m },
				children: e.wrap(d, !0),
			}
			e.patch(u, E), s.push(E)
		}
		if (s.length !== 0)
			return {
				type: "element",
				tagName: "section",
				properties: { dataFootnotes: !0, className: ["footnotes"] },
				children: [
					{
						type: "element",
						tagName: a,
						properties: { ...Dp(o), id: "footnote-label" },
						children: [{ type: "text", value: i }],
					},
					{
						type: "text",
						value: `
`,
					},
					{ type: "element", tagName: "ol", properties: {}, children: e.wrap(s, !0) },
					{
						type: "text",
						value: `
`,
					},
				],
			}
	}
	const Tw = function (e) {
		if (e == null) return vdt
		if (typeof e == "function") return kw(e)
		if (typeof e == "object") return Array.isArray(e) ? pdt(e) : hdt(e)
		if (typeof e == "string") return mdt(e)
		throw new Error("Expected function, string, or object as test")
	}
	function pdt(e) {
		const t = []
		let n = -1
		for (; ++n < e.length; ) t[n] = Tw(e[n])
		return kw(r)
		function r(...i) {
			let a = -1
			for (; ++a < t.length; ) if (t[a].apply(this, i)) return !0
			return !1
		}
	}
	function hdt(e) {
		const t = e
		return kw(n)
		function n(r) {
			const i = r
			let a
			for (a in e) if (i[a] !== t[a]) return !1
			return !0
		}
	}
	function mdt(e) {
		return kw(t)
		function t(n) {
			return n && n.type === e
		}
	}
	function kw(e) {
		return t
		function t(n, r, i) {
			return !!(gdt(n) && e.call(this, n, typeof r == "number" ? r : void 0, i || void 0))
		}
	}
	function vdt() {
		return !0
	}
	function gdt(e) {
		return e !== null && typeof e == "object" && "type" in e
	}
	const EV = [],
		ydt = !0,
		dD = !1,
		bdt = "skip"
	function CV(e, t, n, r) {
		let i
		typeof t == "function" && typeof n != "function" ? ((r = n), (n = t)) : (i = t)
		const a = Tw(i),
			o = r ? -1 : 1
		s(e, void 0, [])()
		function s(l, u, d) {
			const p = l && typeof l == "object" ? l : {}
			if (typeof p.type == "string") {
				const v =
					typeof p.tagName == "string" ? p.tagName : typeof p.name == "string" ? p.name : void 0
				Object.defineProperty(m, "name", {
					value: "node (" + (l.type + (v ? "<" + v + ">" : "")) + ")",
				})
			}
			return m
			function m() {
				let v = EV,
					y,
					b,
					x
				if ((!t || a(l, u, d[d.length - 1] || void 0)) && ((v = xdt(n(l, d))), v[0] === dD))
					return v
				if ("children" in l && l.children) {
					const E = l
					if (E.children && v[0] !== bdt)
						for (
							b = (r ? E.children.length : -1) + o, x = d.concat(E);
							b > -1 && b < E.children.length;

						) {
							const T = E.children[b]
							if (((y = s(T, b, x)()), y[0] === dD)) return y
							b = typeof y[1] == "number" ? y[1] : b + o
						}
				}
				return v
			}
		}
	}
	function xdt(e) {
		return Array.isArray(e) ? e : typeof e == "number" ? [ydt, e] : e == null ? EV : [e]
	}
	function Sw(e, t, n, r) {
		let i, a, o
		typeof t == "function" && typeof n != "function"
			? ((a = void 0), (o = t), (i = n))
			: ((a = t), (o = n), (i = r)),
			CV(e, a, s, i)
		function s(l, u) {
			const d = u[u.length - 1],
				p = d ? d.children.indexOf(l) : void 0
			return o(l, p, d)
		}
	}
	const fD = {}.hasOwnProperty,
		wdt = {}
	function Edt(e, t) {
		const n = t || wdt,
			r = new Map(),
			i = new Map(),
			a = new Map(),
			o = { ...adt, ...n.handlers },
			s = {
				all: u,
				applyData: Tdt,
				definitionById: r,
				footnoteById: i,
				footnoteCounts: a,
				footnoteOrder: [],
				handlers: o,
				one: l,
				options: n,
				patch: Cdt,
				wrap: Sdt,
			}
		return (
			Sw(e, function (d) {
				if (d.type === "definition" || d.type === "footnoteDefinition") {
					const p = d.type === "definition" ? r : i,
						m = String(d.identifier).toUpperCase()
					p.has(m) || p.set(m, d)
				}
			}),
			s
		)
		function l(d, p) {
			const m = d.type,
				v = s.handlers[m]
			if (fD.call(s.handlers, m) && v) return v(s, d, p)
			if (s.options.passThrough && s.options.passThrough.includes(m)) {
				if ("children" in d) {
					const { children: b, ...x } = d,
						E = Dp(x)
					return (E.children = s.all(d)), E
				}
				return Dp(d)
			}
			return (s.options.unknownHandler || kdt)(s, d, p)
		}
		function u(d) {
			const p = []
			if ("children" in d) {
				const m = d.children
				let v = -1
				for (; ++v < m.length; ) {
					const y = s.one(m[v], d)
					if (y) {
						if (
							v &&
							m[v - 1].type === "break" &&
							(!Array.isArray(y) && y.type === "text" && (y.value = H6(y.value)),
							!Array.isArray(y) && y.type === "element")
						) {
							const b = y.children[0]
							b && b.type === "text" && (b.value = H6(b.value))
						}
						Array.isArray(y) ? p.push(...y) : p.push(y)
					}
				}
			}
			return p
		}
	}
	function Cdt(e, t) {
		e.position && (t.position = ult(e))
	}
	function Tdt(e, t) {
		let n = t
		if (e && e.data) {
			const r = e.data.hName,
				i = e.data.hChildren,
				a = e.data.hProperties
			if (typeof r == "string")
				if (n.type === "element") n.tagName = r
				else {
					const o = "children" in n ? n.children : [n]
					n = { type: "element", tagName: r, properties: {}, children: o }
				}
			n.type === "element" && a && Object.assign(n.properties, Dp(a)),
				"children" in n && n.children && i !== null && i !== void 0 && (n.children = i)
		}
		return n
	}
	function kdt(e, t) {
		const n = t.data || {},
			r =
				"value" in t && !(fD.call(n, "hProperties") || fD.call(n, "hChildren"))
					? { type: "text", value: t.value }
					: { type: "element", tagName: "div", properties: {}, children: e.all(t) }
		return e.patch(t, r), e.applyData(t, r)
	}
	function Sdt(e, t) {
		const n = []
		let r = -1
		for (
			t &&
			n.push({
				type: "text",
				value: `
`,
			});
			++r < e.length;

		)
			r &&
				n.push({
					type: "text",
					value: `
`,
				}),
				n.push(e[r])
		return (
			t &&
				e.length > 0 &&
				n.push({
					type: "text",
					value: `
`,
				}),
			n
		)
	}
	function H6(e) {
		let t = 0,
			n = e.charCodeAt(t)
		for (; n === 9 || n === 32; ) t++, (n = e.charCodeAt(t))
		return e.slice(t)
	}
	function $6(e, t) {
		const n = Edt(e, t),
			r = n.one(e, void 0),
			i = fdt(n),
			a = Array.isArray(r) ? { type: "root", children: r } : r || { type: "root", children: [] }
		return (
			i &&
				a.children.push(
					{
						type: "text",
						value: `
`,
					},
					i,
				),
			a
		)
	}
	function Ddt(e, t) {
		return e && "run" in e
			? async function (n, r) {
					const i = $6(n, { file: r, ...t })
					await e.run(i, r)
			  }
			: function (n, r) {
					return $6(n, { file: r, ...(e || t) })
			  }
	}
	function U6(e) {
		if (e) throw e
	}
	var zk, z6
	function _dt() {
		if (z6) return zk
		z6 = 1
		var e = Object.prototype.hasOwnProperty,
			t = Object.prototype.toString,
			n = Object.defineProperty,
			r = Object.getOwnPropertyDescriptor,
			i = function (u) {
				return typeof Array.isArray == "function"
					? Array.isArray(u)
					: t.call(u) === "[object Array]"
			},
			a = function (u) {
				if (!u || t.call(u) !== "[object Object]") return !1
				var d = e.call(u, "constructor"),
					p =
						u.constructor &&
						u.constructor.prototype &&
						e.call(u.constructor.prototype, "isPrototypeOf")
				if (u.constructor && !d && !p) return !1
				var m
				for (m in u);
				return typeof m > "u" || e.call(u, m)
			},
			o = function (u, d) {
				n && d.name === "__proto__"
					? n(u, d.name, { enumerable: !0, configurable: !0, value: d.newValue, writable: !0 })
					: (u[d.name] = d.newValue)
			},
			s = function (u, d) {
				if (d === "__proto__")
					if (e.call(u, d)) {
						if (r) return r(u, d).value
					} else return
				return u[d]
			}
		return (
			(zk = function l() {
				var u,
					d,
					p,
					m,
					v,
					y,
					b = arguments[0],
					x = 1,
					E = arguments.length,
					T = !1
				for (
					typeof b == "boolean" && ((T = b), (b = arguments[1] || {}), (x = 2)),
						(b == null || (typeof b != "object" && typeof b != "function")) && (b = {});
					x < E;
					++x
				)
					if (((u = arguments[x]), u != null))
						for (d in u)
							(p = s(b, d)),
								(m = s(u, d)),
								b !== m &&
									(T && m && (a(m) || (v = i(m)))
										? (v ? ((v = !1), (y = p && i(p) ? p : [])) : (y = p && a(p) ? p : {}),
										  o(b, { name: d, newValue: l(T, y, m) }))
										: typeof m < "u" && o(b, { name: d, newValue: m }))
				return b
			}),
			zk
		)
	}
	var Odt = _dt()
	const qk = Ti(Odt)
	function pD(e) {
		if (typeof e != "object" || e === null) return !1
		const t = Object.getPrototypeOf(e)
		return (
			(t === null || t === Object.prototype || Object.getPrototypeOf(t) === null) &&
			!(Symbol.toStringTag in e) &&
			!(Symbol.iterator in e)
		)
	}
	function Adt() {
		const e = [],
			t = { run: n, use: r }
		return t
		function n(...i) {
			let a = -1
			const o = i.pop()
			if (typeof o != "function")
				throw new TypeError("Expected function as last argument, not " + o)
			s(null, ...i)
			function s(l, ...u) {
				const d = e[++a]
				let p = -1
				if (l) {
					o(l)
					return
				}
				for (; ++p < i.length; ) (u[p] === null || u[p] === void 0) && (u[p] = i[p])
				;(i = u), d ? Ndt(d, s)(...u) : o(null, ...u)
			}
		}
		function r(i) {
			if (typeof i != "function")
				throw new TypeError("Expected `middelware` to be a function, not " + i)
			return e.push(i), t
		}
	}
	function Ndt(e, t) {
		let n
		return r
		function r(...o) {
			const s = e.length > o.length
			let l
			s && o.push(i)
			try {
				l = e.apply(this, o)
			} catch (u) {
				const d = u
				if (s && n) throw d
				return i(d)
			}
			s ||
				(l && l.then && typeof l.then == "function"
					? l.then(a, i)
					: l instanceof Error
					? i(l)
					: a(l))
		}
		function i(o, ...s) {
			n || ((n = !0), t(o, ...s))
		}
		function a(o) {
			i(null, o)
		}
	}
	const Vo = { basename: Mdt, dirname: Idt, extname: Rdt, join: Ldt, sep: "/" }
	function Mdt(e, t) {
		if (t !== void 0 && typeof t != "string") throw new TypeError('"ext" argument must be a string')
		bg(e)
		let n = 0,
			r = -1,
			i = e.length,
			a
		if (t === void 0 || t.length === 0 || t.length > e.length) {
			for (; i--; )
				if (e.codePointAt(i) === 47) {
					if (a) {
						n = i + 1
						break
					}
				} else r < 0 && ((a = !0), (r = i + 1))
			return r < 0 ? "" : e.slice(n, r)
		}
		if (t === e) return ""
		let o = -1,
			s = t.length - 1
		for (; i--; )
			if (e.codePointAt(i) === 47) {
				if (a) {
					n = i + 1
					break
				}
			} else
				o < 0 && ((a = !0), (o = i + 1)),
					s > -1 &&
						(e.codePointAt(i) === t.codePointAt(s--) ? s < 0 && (r = i) : ((s = -1), (r = o)))
		return n === r ? (r = o) : r < 0 && (r = e.length), e.slice(n, r)
	}
	function Idt(e) {
		if ((bg(e), e.length === 0)) return "."
		let t = -1,
			n = e.length,
			r
		for (; --n; )
			if (e.codePointAt(n) === 47) {
				if (r) {
					t = n
					break
				}
			} else r || (r = !0)
		return t < 0
			? e.codePointAt(0) === 47
				? "/"
				: "."
			: t === 1 && e.codePointAt(0) === 47
			? "//"
			: e.slice(0, t)
	}
	function Rdt(e) {
		bg(e)
		let t = e.length,
			n = -1,
			r = 0,
			i = -1,
			a = 0,
			o
		for (; t--; ) {
			const s = e.codePointAt(t)
			if (s === 47) {
				if (o) {
					r = t + 1
					break
				}
				continue
			}
			n < 0 && ((o = !0), (n = t + 1)),
				s === 46 ? (i < 0 ? (i = t) : a !== 1 && (a = 1)) : i > -1 && (a = -1)
		}
		return i < 0 || n < 0 || a === 0 || (a === 1 && i === n - 1 && i === r + 1) ? "" : e.slice(i, n)
	}
	function Ldt(...e) {
		let t = -1,
			n
		for (; ++t < e.length; ) bg(e[t]), e[t] && (n = n === void 0 ? e[t] : n + "/" + e[t])
		return n === void 0 ? "." : Pdt(n)
	}
	function Pdt(e) {
		bg(e)
		const t = e.codePointAt(0) === 47
		let n = jdt(e, !t)
		return (
			n.length === 0 && !t && (n = "."),
			n.length > 0 && e.codePointAt(e.length - 1) === 47 && (n += "/"),
			t ? "/" + n : n
		)
	}
	function jdt(e, t) {
		let n = "",
			r = 0,
			i = -1,
			a = 0,
			o = -1,
			s,
			l
		for (; ++o <= e.length; ) {
			if (o < e.length) s = e.codePointAt(o)
			else {
				if (s === 47) break
				s = 47
			}
			if (s === 47) {
				if (!(i === o - 1 || a === 1))
					if (i !== o - 1 && a === 2) {
						if (
							n.length < 2 ||
							r !== 2 ||
							n.codePointAt(n.length - 1) !== 46 ||
							n.codePointAt(n.length - 2) !== 46
						) {
							if (n.length > 2) {
								if (((l = n.lastIndexOf("/")), l !== n.length - 1)) {
									l < 0
										? ((n = ""), (r = 0))
										: ((n = n.slice(0, l)), (r = n.length - 1 - n.lastIndexOf("/"))),
										(i = o),
										(a = 0)
									continue
								}
							} else if (n.length > 0) {
								;(n = ""), (r = 0), (i = o), (a = 0)
								continue
							}
						}
						t && ((n = n.length > 0 ? n + "/.." : ".."), (r = 2))
					} else
						n.length > 0 ? (n += "/" + e.slice(i + 1, o)) : (n = e.slice(i + 1, o)), (r = o - i - 1)
				;(i = o), (a = 0)
			} else s === 46 && a > -1 ? a++ : (a = -1)
		}
		return n
	}
	function bg(e) {
		if (typeof e != "string")
			throw new TypeError("Path must be a string. Received " + JSON.stringify(e))
	}
	const Fdt = { cwd: Bdt }
	function Bdt() {
		return "/"
	}
	function hD(e) {
		return !!(
			e !== null &&
			typeof e == "object" &&
			"href" in e &&
			e.href &&
			"protocol" in e &&
			e.protocol &&
			e.auth === void 0
		)
	}
	function Hdt(e) {
		if (typeof e == "string") e = new URL(e)
		else if (!hD(e)) {
			const t = new TypeError(
				'The "path" argument must be of type string or an instance of URL. Received `' + e + "`",
			)
			throw ((t.code = "ERR_INVALID_ARG_TYPE"), t)
		}
		if (e.protocol !== "file:") {
			const t = new TypeError("The URL must be of scheme file")
			throw ((t.code = "ERR_INVALID_URL_SCHEME"), t)
		}
		return $dt(e)
	}
	function $dt(e) {
		if (e.hostname !== "") {
			const r = new TypeError('File URL host must be "localhost" or empty on darwin')
			throw ((r.code = "ERR_INVALID_FILE_URL_HOST"), r)
		}
		const t = e.pathname
		let n = -1
		for (; ++n < t.length; )
			if (t.codePointAt(n) === 37 && t.codePointAt(n + 1) === 50) {
				const r = t.codePointAt(n + 2)
				if (r === 70 || r === 102) {
					const i = new TypeError("File URL path must not include encoded / characters")
					throw ((i.code = "ERR_INVALID_FILE_URL_PATH"), i)
				}
			}
		return decodeURIComponent(t)
	}
	const Vk = ["history", "path", "basename", "stem", "extname", "dirname"]
	class TV {
		constructor(t) {
			let n
			t
				? hD(t)
					? (n = { path: t })
					: typeof t == "string" || Udt(t)
					? (n = { value: t })
					: (n = t)
				: (n = {}),
				(this.cwd = "cwd" in n ? "" : Fdt.cwd()),
				(this.data = {}),
				(this.history = []),
				(this.messages = []),
				this.value,
				this.map,
				this.result,
				this.stored
			let r = -1
			for (; ++r < Vk.length; ) {
				const a = Vk[r]
				a in n && n[a] !== void 0 && n[a] !== null && (this[a] = a === "history" ? [...n[a]] : n[a])
			}
			let i
			for (i in n) Vk.includes(i) || (this[i] = n[i])
		}
		get basename() {
			return typeof this.path == "string" ? Vo.basename(this.path) : void 0
		}
		set basename(t) {
			Yk(t, "basename"), Wk(t, "basename"), (this.path = Vo.join(this.dirname || "", t))
		}
		get dirname() {
			return typeof this.path == "string" ? Vo.dirname(this.path) : void 0
		}
		set dirname(t) {
			q6(this.basename, "dirname"), (this.path = Vo.join(t || "", this.basename))
		}
		get extname() {
			return typeof this.path == "string" ? Vo.extname(this.path) : void 0
		}
		set extname(t) {
			if ((Wk(t, "extname"), q6(this.dirname, "extname"), t)) {
				if (t.codePointAt(0) !== 46) throw new Error("`extname` must start with `.`")
				if (t.includes(".", 1)) throw new Error("`extname` cannot contain multiple dots")
			}
			this.path = Vo.join(this.dirname, this.stem + (t || ""))
		}
		get path() {
			return this.history[this.history.length - 1]
		}
		set path(t) {
			hD(t) && (t = Hdt(t)), Yk(t, "path"), this.path !== t && this.history.push(t)
		}
		get stem() {
			return typeof this.path == "string" ? Vo.basename(this.path, this.extname) : void 0
		}
		set stem(t) {
			Yk(t, "stem"),
				Wk(t, "stem"),
				(this.path = Vo.join(this.dirname || "", t + (this.extname || "")))
		}
		fail(t, n, r) {
			const i = this.message(t, n, r)
			throw ((i.fatal = !0), i)
		}
		info(t, n, r) {
			const i = this.message(t, n, r)
			return (i.fatal = void 0), i
		}
		message(t, n, r) {
			const i = new oi(t, n, r)
			return (
				this.path && ((i.name = this.path + ":" + i.name), (i.file = this.path)),
				(i.fatal = !1),
				this.messages.push(i),
				i
			)
		}
		toString(t) {
			return this.value === void 0
				? ""
				: typeof this.value == "string"
				? this.value
				: new TextDecoder(t || void 0).decode(this.value)
		}
	}
	function Wk(e, t) {
		if (e && e.includes(Vo.sep))
			throw new Error("`" + t + "` cannot be a path: did not expect `" + Vo.sep + "`")
	}
	function Yk(e, t) {
		if (!e) throw new Error("`" + t + "` cannot be empty")
	}
	function q6(e, t) {
		if (!e) throw new Error("Setting `" + t + "` requires `path` to be set too")
	}
	function Udt(e) {
		return !!(e && typeof e == "object" && "byteLength" in e && "byteOffset" in e)
	}
	const zdt = function (e) {
			const r = this.constructor.prototype,
				i = r[e],
				a = function () {
					return i.apply(a, arguments)
				}
			return Object.setPrototypeOf(a, r), a
		},
		qdt = {}.hasOwnProperty
	class kA extends zdt {
		constructor() {
			super("copy"),
				(this.Compiler = void 0),
				(this.Parser = void 0),
				(this.attachers = []),
				(this.compiler = void 0),
				(this.freezeIndex = -1),
				(this.frozen = void 0),
				(this.namespace = {}),
				(this.parser = void 0),
				(this.transformers = Adt())
		}
		copy() {
			const t = new kA()
			let n = -1
			for (; ++n < this.attachers.length; ) {
				const r = this.attachers[n]
				t.use(...r)
			}
			return t.data(qk(!0, {}, this.namespace)), t
		}
		data(t, n) {
			return typeof t == "string"
				? arguments.length === 2
					? (Qk("data", this.frozen), (this.namespace[t] = n), this)
					: (qdt.call(this.namespace, t) && this.namespace[t]) || void 0
				: t
				? (Qk("data", this.frozen), (this.namespace = t), this)
				: this.namespace
		}
		freeze() {
			if (this.frozen) return this
			const t = this
			for (; ++this.freezeIndex < this.attachers.length; ) {
				const [n, ...r] = this.attachers[this.freezeIndex]
				if (r[0] === !1) continue
				r[0] === !0 && (r[0] = void 0)
				const i = n.call(t, ...r)
				typeof i == "function" && this.transformers.use(i)
			}
			return (this.frozen = !0), (this.freezeIndex = Number.POSITIVE_INFINITY), this
		}
		parse(t) {
			this.freeze()
			const n = gy(t),
				r = this.parser || this.Parser
			return Gk("parse", r), r(String(n), n)
		}
		process(t, n) {
			const r = this
			return (
				this.freeze(),
				Gk("process", this.parser || this.Parser),
				Kk("process", this.compiler || this.Compiler),
				n ? i(void 0, n) : new Promise(i)
			)
			function i(a, o) {
				const s = gy(t),
					l = r.parse(s)
				r.run(l, s, function (d, p, m) {
					if (d || !p || !m) return u(d)
					const v = p,
						y = r.stringify(v, m)
					Ydt(y) ? (m.value = y) : (m.result = y), u(d, m)
				})
				function u(d, p) {
					d || !p ? o(d) : a ? a(p) : n(void 0, p)
				}
			}
		}
		processSync(t) {
			let n = !1,
				r
			return (
				this.freeze(),
				Gk("processSync", this.parser || this.Parser),
				Kk("processSync", this.compiler || this.Compiler),
				this.process(t, i),
				W6("processSync", "process", n),
				r
			)
			function i(a, o) {
				;(n = !0), U6(a), (r = o)
			}
		}
		run(t, n, r) {
			V6(t), this.freeze()
			const i = this.transformers
			return (
				!r && typeof n == "function" && ((r = n), (n = void 0)), r ? a(void 0, r) : new Promise(a)
			)
			function a(o, s) {
				const l = gy(n)
				i.run(t, l, u)
				function u(d, p, m) {
					const v = p || t
					d ? s(d) : o ? o(v) : r(void 0, v, m)
				}
			}
		}
		runSync(t, n) {
			let r = !1,
				i
			return this.run(t, n, a), W6("runSync", "run", r), i
			function a(o, s) {
				U6(o), (i = s), (r = !0)
			}
		}
		stringify(t, n) {
			this.freeze()
			const r = gy(n),
				i = this.compiler || this.Compiler
			return Kk("stringify", i), V6(t), i(t, r)
		}
		use(t, ...n) {
			const r = this.attachers,
				i = this.namespace
			if ((Qk("use", this.frozen), t != null))
				if (typeof t == "function") l(t, n)
				else if (typeof t == "object") Array.isArray(t) ? s(t) : o(t)
				else throw new TypeError("Expected usable value, not `" + t + "`")
			return this
			function a(u) {
				if (typeof u == "function") l(u, [])
				else if (typeof u == "object")
					if (Array.isArray(u)) {
						const [d, ...p] = u
						l(d, p)
					} else o(u)
				else throw new TypeError("Expected usable value, not `" + u + "`")
			}
			function o(u) {
				if (!("plugins" in u) && !("settings" in u))
					throw new Error(
						"Expected usable value but received an empty preset, which is probably a mistake: presets typically come with `plugins` and sometimes with `settings`, but this has neither",
					)
				s(u.plugins), u.settings && (i.settings = qk(!0, i.settings, u.settings))
			}
			function s(u) {
				let d = -1
				if (u != null)
					if (Array.isArray(u))
						for (; ++d < u.length; ) {
							const p = u[d]
							a(p)
						}
					else throw new TypeError("Expected a list of plugins, not `" + u + "`")
			}
			function l(u, d) {
				let p = -1,
					m = -1
				for (; ++p < r.length; )
					if (r[p][0] === u) {
						m = p
						break
					}
				if (m === -1) r.push([u, ...d])
				else if (d.length > 0) {
					let [v, ...y] = d
					const b = r[m][1]
					pD(b) && pD(v) && (v = qk(!0, b, v)), (r[m] = [u, v, ...y])
				}
			}
		}
	}
	const Vdt = new kA().freeze()
	function Gk(e, t) {
		if (typeof t != "function") throw new TypeError("Cannot `" + e + "` without `parser`")
	}
	function Kk(e, t) {
		if (typeof t != "function") throw new TypeError("Cannot `" + e + "` without `compiler`")
	}
	function Qk(e, t) {
		if (t)
			throw new Error(
				"Cannot call `" +
					e +
					"` on a frozen processor.\nCreate a new processor first, by calling it: use `processor()` instead of `processor`.",
			)
	}
	function V6(e) {
		if (!pD(e) || typeof e.type != "string") throw new TypeError("Expected node, got `" + e + "`")
	}
	function W6(e, t, n) {
		if (!n) throw new Error("`" + e + "` finished async. Use `" + t + "` instead")
	}
	function gy(e) {
		return Wdt(e) ? e : new TV(e)
	}
	function Wdt(e) {
		return !!(e && typeof e == "object" && "message" in e && "messages" in e)
	}
	function Ydt(e) {
		return typeof e == "string" || Gdt(e)
	}
	function Gdt(e) {
		return !!(e && typeof e == "object" && "byteLength" in e && "byteOffset" in e)
	}
	const Kdt = "https://github.com/remarkjs/react-markdown/blob/main/changelog.md",
		Y6 = [],
		G6 = { allowDangerousHtml: !0 },
		Qdt = /^(https?|ircs?|mailto|xmpp)$/i,
		Xdt = [
			{ from: "astPlugins", id: "remove-buggy-html-in-markdown-parser" },
			{ from: "allowDangerousHtml", id: "remove-buggy-html-in-markdown-parser" },
			{
				from: "allowNode",
				id: "replace-allownode-allowedtypes-and-disallowedtypes",
				to: "allowElement",
			},
			{
				from: "allowedTypes",
				id: "replace-allownode-allowedtypes-and-disallowedtypes",
				to: "allowedElements",
			},
			{
				from: "disallowedTypes",
				id: "replace-allownode-allowedtypes-and-disallowedtypes",
				to: "disallowedElements",
			},
			{ from: "escapeHtml", id: "remove-buggy-html-in-markdown-parser" },
			{ from: "includeElementIndex", id: "#remove-includeelementindex" },
			{ from: "includeNodeIndex", id: "change-includenodeindex-to-includeelementindex" },
			{ from: "linkTarget", id: "remove-linktarget" },
			{ from: "plugins", id: "change-plugins-to-remarkplugins", to: "remarkPlugins" },
			{ from: "rawSourcePos", id: "#remove-rawsourcepos" },
			{ from: "renderers", id: "change-renderers-to-components", to: "components" },
			{ from: "source", id: "change-source-to-children", to: "children" },
			{ from: "sourcePos", id: "#remove-sourcepos" },
			{ from: "transformImageUri", id: "#add-urltransform", to: "urlTransform" },
			{ from: "transformLinkUri", id: "#add-urltransform", to: "urlTransform" },
		]
	function kV(e) {
		const t = e.allowedElements,
			n = e.allowElement,
			r = e.children || "",
			i = e.className,
			a = e.components,
			o = e.disallowedElements,
			s = e.rehypePlugins || Y6,
			l = e.remarkPlugins || Y6,
			u = e.remarkRehypeOptions ? { ...e.remarkRehypeOptions, ...G6 } : G6,
			d = e.skipHtml,
			p = e.unwrapDisallowed,
			m = e.urlTransform || Jdt,
			v = Vdt().use(Ict).use(l).use(Ddt, u).use(s),
			y = new TV()
		typeof r == "string" && (y.value = r)
		for (const T of Xdt)
			Object.hasOwn(e, T.from) &&
				("" + T.from + (T.to ? "use `" + T.to + "` instead" : "remove it") + Kdt + T.id, void 0)
		const b = v.parse(y)
		let x = v.runSync(b, y)
		return (
			i &&
				(x = {
					type: "element",
					tagName: "div",
					properties: { className: i },
					children: x.type === "root" ? x.children : [x],
				}),
			Sw(x, E),
			mlt(x, {
				Fragment: h.Fragment,
				components: a,
				ignoreInvalidStyle: !0,
				jsx: h.jsx,
				jsxs: h.jsxs,
				passKeys: !0,
				passNode: !0,
			})
		)
		function E(T, C, D) {
			if (T.type === "raw" && D && typeof C == "number")
				return d ? D.children.splice(C, 1) : (D.children[C] = { type: "text", value: T.value }), C
			if (T.type === "element") {
				let O
				for (O in Hk)
					if (Object.hasOwn(Hk, O) && Object.hasOwn(T.properties, O)) {
						const A = T.properties[O],
							N = Hk[O]
						;(N === null || N.includes(T.tagName)) && (T.properties[O] = m(String(A || ""), O, T))
					}
			}
			if (T.type === "element") {
				let O = t ? !t.includes(T.tagName) : o ? o.includes(T.tagName) : !1
				if ((!O && n && typeof C == "number" && (O = !n(T, C, D)), O && D && typeof C == "number"))
					return (
						p && T.children ? D.children.splice(C, 1, ...T.children) : D.children.splice(C, 1), C
					)
			}
		}
	}
	function Jdt(e) {
		const t = e.indexOf(":"),
			n = e.indexOf("?"),
			r = e.indexOf("#"),
			i = e.indexOf("/")
		return t < 0 ||
			(i > -1 && t > i) ||
			(n > -1 && t > n) ||
			(r > -1 && t > r) ||
			Qdt.test(e.slice(0, t))
			? e
			: ""
	}
	const K6 = /[#.]/g
	function Zdt(e, t) {
		const n = e || "",
			r = {}
		let i = 0,
			a,
			o
		for (; i < n.length; ) {
			K6.lastIndex = i
			const s = K6.exec(n),
				l = n.slice(i, s ? s.index : n.length)
			l &&
				(a
					? a === "#"
						? (r.id = l)
						: Array.isArray(r.className)
						? r.className.push(l)
						: (r.className = [l])
					: (o = l),
				(i += l.length)),
				s && ((a = s[0]), i++)
		}
		return { type: "element", tagName: o || t || "div", properties: r, children: [] }
	}
	const mD = {}.hasOwnProperty
	function SV(e, t, n) {
		const r = n && rft(n)
		function i(a, o, ...s) {
			let l = -1,
				u
			if (a == null) {
				u = { type: "root", children: [] }
				const d = o
				s.unshift(d)
			} else if (
				((u = Zdt(a, t)),
				(u.tagName = u.tagName.toLowerCase()),
				r && mD.call(r, u.tagName) && (u.tagName = r[u.tagName]),
				eft(o))
			)
				s.unshift(o)
			else {
				let d
				for (d in o) mD.call(o, d) && tft(e, u.properties, d, o[d])
			}
			for (; ++l < s.length; ) vD(u.children, s[l])
			return (
				u.type === "element" &&
					u.tagName === "template" &&
					((u.content = { type: "root", children: u.children }), (u.children = [])),
				u
			)
		}
		return i
	}
	function eft(e) {
		if (e === null || typeof e != "object" || Array.isArray(e)) return !0
		if (typeof e.type != "string") return !1
		const t = e,
			n = Object.keys(e)
		for (const r of n) {
			const i = t[r]
			if (i && typeof i == "object") {
				if (!Array.isArray(i)) return !0
				const a = i
				for (const o of a) if (typeof o != "number" && typeof o != "string") return !0
			}
		}
		return !!("children" in e && Array.isArray(e.children))
	}
	function tft(e, t, n, r) {
		const i = bw(e, n)
		let a = -1,
			o
		if (r != null) {
			if (typeof r == "number") {
				if (Number.isNaN(r)) return
				o = r
			} else
				typeof r == "boolean"
					? (o = r)
					: typeof r == "string"
					? i.spaceSeparated
						? (o = g6(r))
						: i.commaSeparated
						? (o = f6(r))
						: i.commaOrSpaceSeparated
						? (o = g6(f6(r).join(" ")))
						: (o = Q6(i, i.property, r))
					: Array.isArray(r)
					? (o = r.concat())
					: (o = i.property === "style" ? nft(r) : String(r))
			if (Array.isArray(o)) {
				const s = []
				for (; ++a < o.length; ) {
					const l = Q6(i, i.property, o[a])
					s[a] = l
				}
				o = s
			}
			if (i.property === "className" && Array.isArray(t.className)) {
				const s = o
				o = t.className.concat(s)
			}
			t[i.property] = o
		}
	}
	function vD(e, t) {
		let n = -1
		if (t != null)
			if (typeof t == "string" || typeof t == "number") e.push({ type: "text", value: String(t) })
			else if (Array.isArray(t)) for (; ++n < t.length; ) vD(e, t[n])
			else if (typeof t == "object" && "type" in t)
				t.type === "root" ? vD(e, t.children) : e.push(t)
			else throw new Error("Expected node, nodes, or string, got `" + t + "`")
	}
	function Q6(e, t, n) {
		if (typeof n == "string") {
			if (e.number && n && !Number.isNaN(Number(n))) return Number(n)
			if ((e.boolean || e.overloadedBoolean) && (n === "" || Nv(n) === Nv(t))) return !0
		}
		return n
	}
	function nft(e) {
		const t = []
		let n
		for (n in e) mD.call(e, n) && t.push([n, e[n]].join(": "))
		return t.join("; ")
	}
	function rft(e) {
		const t = {}
		let n = -1
		for (; ++n < e.length; ) t[e[n].toLowerCase()] = e[n]
		return t
	}
	const ift = [
			"altGlyph",
			"altGlyphDef",
			"altGlyphItem",
			"animateColor",
			"animateMotion",
			"animateTransform",
			"clipPath",
			"feBlend",
			"feColorMatrix",
			"feComponentTransfer",
			"feComposite",
			"feConvolveMatrix",
			"feDiffuseLighting",
			"feDisplacementMap",
			"feDistantLight",
			"feDropShadow",
			"feFlood",
			"feFuncA",
			"feFuncB",
			"feFuncG",
			"feFuncR",
			"feGaussianBlur",
			"feImage",
			"feMerge",
			"feMergeNode",
			"feMorphology",
			"feOffset",
			"fePointLight",
			"feSpecularLighting",
			"feSpotLight",
			"feTile",
			"feTurbulence",
			"foreignObject",
			"glyphRef",
			"linearGradient",
			"radialGradient",
			"solidColor",
			"textArea",
			"textPath",
		],
		aft = SV(gg, "div"),
		oft = SV(Zu, "g", ift)
	function sft(e) {
		const t = String(e),
			n = []
		return { toOffset: i, toPoint: r }
		function r(a) {
			if (typeof a == "number" && a > -1 && a <= t.length) {
				let o = 0
				for (;;) {
					let s = n[o]
					if (s === void 0) {
						const l = X6(t, n[o - 1])
						;(s = l === -1 ? t.length + 1 : l + 1), (n[o] = s)
					}
					if (s > a) return { line: o + 1, column: a - (o > 0 ? n[o - 1] : 0) + 1, offset: a }
					o++
				}
			}
		}
		function i(a) {
			if (
				a &&
				typeof a.line == "number" &&
				typeof a.column == "number" &&
				!Number.isNaN(a.line) &&
				!Number.isNaN(a.column)
			) {
				for (; n.length < a.line; ) {
					const s = n[n.length - 1],
						l = X6(t, s),
						u = l === -1 ? t.length + 1 : l + 1
					if (s === u) break
					n.push(u)
				}
				const o = (a.line > 1 ? n[a.line - 2] : 0) + a.column - 1
				if (o < n[a.line - 1]) return o
			}
		}
	}
	function X6(e, t) {
		const n = e.indexOf("\r", t),
			r = e.indexOf(
				`
`,
				t,
			)
		return r === -1 ? n : n === -1 || n + 1 === r ? r : n < r ? n : r
	}
	const Uc = {
			html: "http://www.w3.org/1999/xhtml",
			mathml: "http://www.w3.org/1998/Math/MathML",
			svg: "http://www.w3.org/2000/svg",
			xlink: "http://www.w3.org/1999/xlink",
			xml: "http://www.w3.org/XML/1998/namespace",
			xmlns: "http://www.w3.org/2000/xmlns/",
		},
		DV = {}.hasOwnProperty,
		lft = Object.prototype
	function uft(e, t) {
		const n = t || {}
		return SA(
			{
				file: n.file || void 0,
				location: !1,
				schema: n.space === "svg" ? Zu : gg,
				verbose: n.verbose || !1,
			},
			e,
		)
	}
	function SA(e, t) {
		let n
		switch (t.nodeName) {
			case "#comment": {
				const r = t
				return (n = { type: "comment", value: r.data }), b1(e, r, n), n
			}
			case "#document":
			case "#document-fragment": {
				const r = t,
					i = "mode" in r ? r.mode === "quirks" || r.mode === "limited-quirks" : !1
				if (
					((n = { type: "root", children: _V(e, t.childNodes), data: { quirksMode: i } }),
					e.file && e.location)
				) {
					const a = String(e.file),
						o = sft(a),
						s = o.toPoint(0),
						l = o.toPoint(a.length)
					n.position = { start: s, end: l }
				}
				return n
			}
			case "#documentType": {
				const r = t
				return (n = { type: "doctype" }), b1(e, r, n), n
			}
			case "#text": {
				const r = t
				return (n = { type: "text", value: r.value }), b1(e, r, n), n
			}
			default:
				return (n = cft(e, t)), n
		}
	}
	function _V(e, t) {
		let n = -1
		const r = []
		for (; ++n < t.length; ) {
			const i = SA(e, t[n])
			r.push(i)
		}
		return r
	}
	function cft(e, t) {
		const n = e.schema
		e.schema = t.namespaceURI === Uc.svg ? Zu : gg
		let r = -1
		const i = {}
		for (; ++r < t.attrs.length; ) {
			const s = t.attrs[r],
				l = (s.prefix ? s.prefix + ":" : "") + s.name
			DV.call(lft, l) || (i[l] = s.value)
		}
		const o = (e.schema.space === "svg" ? oft : aft)(t.tagName, i, _V(e, t.childNodes))
		if ((b1(e, t, o), o.tagName === "template")) {
			const s = t,
				l = s.sourceCodeLocation,
				u = l && l.startTag && $f(l.startTag),
				d = l && l.endTag && $f(l.endTag),
				p = SA(e, s.content)
			u && d && e.file && (p.position = { start: u.end, end: d.start }), (o.content = p)
		}
		return (e.schema = n), o
	}
	function b1(e, t, n) {
		if ("sourceCodeLocation" in t && t.sourceCodeLocation && e.file) {
			const r = dft(e, n, t.sourceCodeLocation)
			r && ((e.location = !0), (n.position = r))
		}
	}
	function dft(e, t, n) {
		const r = $f(n)
		if (t.type === "element") {
			const i = t.children[t.children.length - 1]
			if (
				(r &&
					!n.endTag &&
					i &&
					i.position &&
					i.position.end &&
					(r.end = Object.assign({}, i.position.end)),
				e.verbose)
			) {
				const a = {}
				let o
				if (n.attrs)
					for (o in n.attrs) DV.call(n.attrs, o) && (a[bw(e.schema, o).property] = $f(n.attrs[o]))
				n.startTag
				const s = $f(n.startTag),
					l = n.endTag ? $f(n.endTag) : void 0,
					u = { opening: s }
				l && (u.closing = l), (u.properties = a), (t.data = { position: u })
			}
		}
		return r
	}
	function $f(e) {
		const t = J6({ line: e.startLine, column: e.startCol, offset: e.startOffset }),
			n = J6({ line: e.endLine, column: e.endCol, offset: e.endOffset })
		return t || n ? { start: t, end: n } : void 0
	}
	function J6(e) {
		return e.line && e.column ? e : void 0
	}
	const Z6 = {}.hasOwnProperty
	function OV(e, t) {
		const n = t || {}
		function r(i, ...a) {
			let o = r.invalid
			const s = r.handlers
			if (i && Z6.call(i, e)) {
				const l = String(i[e])
				o = Z6.call(s, l) ? s[l] : r.unknown
			}
			if (o) return o.call(this, i, ...a)
		}
		return (r.handlers = n.handlers || {}), (r.invalid = n.invalid), (r.unknown = n.unknown), r
	}
	const fft = {},
		pft = {}.hasOwnProperty,
		AV = OV("type", {
			handlers: { root: mft, element: xft, text: yft, comment: bft, doctype: gft },
		})
	function hft(e, t) {
		const r = (t || fft).space
		return AV(e, r === "svg" ? Zu : gg)
	}
	function mft(e, t) {
		const n = {
			nodeName: "#document",
			mode: (e.data || {}).quirksMode ? "quirks" : "no-quirks",
			childNodes: [],
		}
		return (n.childNodes = DA(e.children, n, t)), ih(e, n), n
	}
	function vft(e, t) {
		const n = { nodeName: "#document-fragment", childNodes: [] }
		return (n.childNodes = DA(e.children, n, t)), ih(e, n), n
	}
	function gft(e) {
		const t = {
			nodeName: "#documentType",
			name: "html",
			publicId: "",
			systemId: "",
			parentNode: null,
		}
		return ih(e, t), t
	}
	function yft(e) {
		const t = { nodeName: "#text", value: e.value, parentNode: null }
		return ih(e, t), t
	}
	function bft(e) {
		const t = { nodeName: "#comment", data: e.value, parentNode: null }
		return ih(e, t), t
	}
	function xft(e, t) {
		const n = t
		let r = n
		e.type === "element" && e.tagName.toLowerCase() === "svg" && n.space === "html" && (r = Zu)
		const i = []
		let a
		if (e.properties) {
			for (a in e.properties)
				if (a !== "children" && pft.call(e.properties, a)) {
					const l = wft(r, a, e.properties[a])
					l && i.push(l)
				}
		}
		const o = r.space,
			s = {
				nodeName: e.tagName,
				tagName: e.tagName,
				attrs: i,
				namespaceURI: Uc[o],
				childNodes: [],
				parentNode: null,
			}
		return (
			(s.childNodes = DA(e.children, s, r)),
			ih(e, s),
			e.tagName === "template" && e.content && (s.content = vft(e.content, r)),
			s
		)
	}
	function wft(e, t, n) {
		const r = bw(e, t)
		if (
			n === !1 ||
			n === null ||
			n === void 0 ||
			(typeof n == "number" && Number.isNaN(n)) ||
			(!n && r.boolean)
		)
			return
		Array.isArray(n) && (n = r.commaSeparated ? Uq(n) : Xq(n))
		const i = { name: r.attribute, value: n === !0 ? "" : String(n) }
		if (r.space && r.space !== "html" && r.space !== "svg") {
			const a = i.name.indexOf(":")
			a < 0
				? (i.prefix = "")
				: ((i.name = i.name.slice(a + 1)), (i.prefix = r.attribute.slice(0, a))),
				(i.namespace = Uc[r.space])
		}
		return i
	}
	function DA(e, t, n) {
		let r = -1
		const i = []
		if (e)
			for (; ++r < e.length; ) {
				const a = AV(e[r], n)
				;(a.parentNode = t), i.push(a)
			}
		return i
	}
	function ih(e, t) {
		const n = e.position
		n &&
			n.start &&
			n.end &&
			(n.start.offset,
			n.end.offset,
			(t.sourceCodeLocation = {
				startLine: n.start.line,
				startCol: n.start.column,
				startOffset: n.start.offset,
				endLine: n.end.line,
				endCol: n.end.column,
				endOffset: n.end.offset,
			}))
	}
	const Eft = [
			"area",
			"base",
			"basefont",
			"bgsound",
			"br",
			"col",
			"command",
			"embed",
			"frame",
			"hr",
			"image",
			"img",
			"input",
			"keygen",
			"link",
			"meta",
			"param",
			"source",
			"track",
			"wbr",
		],
		Cft = new Set([
			65534, 65535, 131070, 131071, 196606, 196607, 262142, 262143, 327678, 327679, 393214, 393215,
			458750, 458751, 524286, 524287, 589822, 589823, 655358, 655359, 720894, 720895, 786430,
			786431, 851966, 851967, 917502, 917503, 983038, 983039, 1048574, 1048575, 1114110, 1114111,
		]),
		Sn = ""
	var U
	;(function (e) {
		;(e[(e.EOF = -1)] = "EOF"),
			(e[(e.NULL = 0)] = "NULL"),
			(e[(e.TABULATION = 9)] = "TABULATION"),
			(e[(e.CARRIAGE_RETURN = 13)] = "CARRIAGE_RETURN"),
			(e[(e.LINE_FEED = 10)] = "LINE_FEED"),
			(e[(e.FORM_FEED = 12)] = "FORM_FEED"),
			(e[(e.SPACE = 32)] = "SPACE"),
			(e[(e.EXCLAMATION_MARK = 33)] = "EXCLAMATION_MARK"),
			(e[(e.QUOTATION_MARK = 34)] = "QUOTATION_MARK"),
			(e[(e.AMPERSAND = 38)] = "AMPERSAND"),
			(e[(e.APOSTROPHE = 39)] = "APOSTROPHE"),
			(e[(e.HYPHEN_MINUS = 45)] = "HYPHEN_MINUS"),
			(e[(e.SOLIDUS = 47)] = "SOLIDUS"),
			(e[(e.DIGIT_0 = 48)] = "DIGIT_0"),
			(e[(e.DIGIT_9 = 57)] = "DIGIT_9"),
			(e[(e.SEMICOLON = 59)] = "SEMICOLON"),
			(e[(e.LESS_THAN_SIGN = 60)] = "LESS_THAN_SIGN"),
			(e[(e.EQUALS_SIGN = 61)] = "EQUALS_SIGN"),
			(e[(e.GREATER_THAN_SIGN = 62)] = "GREATER_THAN_SIGN"),
			(e[(e.QUESTION_MARK = 63)] = "QUESTION_MARK"),
			(e[(e.LATIN_CAPITAL_A = 65)] = "LATIN_CAPITAL_A"),
			(e[(e.LATIN_CAPITAL_Z = 90)] = "LATIN_CAPITAL_Z"),
			(e[(e.RIGHT_SQUARE_BRACKET = 93)] = "RIGHT_SQUARE_BRACKET"),
			(e[(e.GRAVE_ACCENT = 96)] = "GRAVE_ACCENT"),
			(e[(e.LATIN_SMALL_A = 97)] = "LATIN_SMALL_A"),
			(e[(e.LATIN_SMALL_Z = 122)] = "LATIN_SMALL_Z")
	})(U || (U = {}))
	const Mi = {
		DASH_DASH: "--",
		CDATA_START: "[CDATA[",
		DOCTYPE: "doctype",
		SCRIPT: "script",
		PUBLIC: "public",
		SYSTEM: "system",
	}
	function NV(e) {
		return e >= 55296 && e <= 57343
	}
	function Tft(e) {
		return e >= 56320 && e <= 57343
	}
	function kft(e, t) {
		return (e - 55296) * 1024 + 9216 + t
	}
	function MV(e) {
		return (
			(e !== 32 && e !== 10 && e !== 13 && e !== 9 && e !== 12 && e >= 1 && e <= 31) ||
			(e >= 127 && e <= 159)
		)
	}
	function IV(e) {
		return (e >= 64976 && e <= 65007) || Cft.has(e)
	}
	var ve
	;(function (e) {
		;(e.controlCharacterInInputStream = "control-character-in-input-stream"),
			(e.noncharacterInInputStream = "noncharacter-in-input-stream"),
			(e.surrogateInInputStream = "surrogate-in-input-stream"),
			(e.nonVoidHtmlElementStartTagWithTrailingSolidus =
				"non-void-html-element-start-tag-with-trailing-solidus"),
			(e.endTagWithAttributes = "end-tag-with-attributes"),
			(e.endTagWithTrailingSolidus = "end-tag-with-trailing-solidus"),
			(e.unexpectedSolidusInTag = "unexpected-solidus-in-tag"),
			(e.unexpectedNullCharacter = "unexpected-null-character"),
			(e.unexpectedQuestionMarkInsteadOfTagName = "unexpected-question-mark-instead-of-tag-name"),
			(e.invalidFirstCharacterOfTagName = "invalid-first-character-of-tag-name"),
			(e.unexpectedEqualsSignBeforeAttributeName = "unexpected-equals-sign-before-attribute-name"),
			(e.missingEndTagName = "missing-end-tag-name"),
			(e.unexpectedCharacterInAttributeName = "unexpected-character-in-attribute-name"),
			(e.unknownNamedCharacterReference = "unknown-named-character-reference"),
			(e.missingSemicolonAfterCharacterReference = "missing-semicolon-after-character-reference"),
			(e.unexpectedCharacterAfterDoctypeSystemIdentifier =
				"unexpected-character-after-doctype-system-identifier"),
			(e.unexpectedCharacterInUnquotedAttributeValue =
				"unexpected-character-in-unquoted-attribute-value"),
			(e.eofBeforeTagName = "eof-before-tag-name"),
			(e.eofInTag = "eof-in-tag"),
			(e.missingAttributeValue = "missing-attribute-value"),
			(e.missingWhitespaceBetweenAttributes = "missing-whitespace-between-attributes"),
			(e.missingWhitespaceAfterDoctypePublicKeyword =
				"missing-whitespace-after-doctype-public-keyword"),
			(e.missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers =
				"missing-whitespace-between-doctype-public-and-system-identifiers"),
			(e.missingWhitespaceAfterDoctypeSystemKeyword =
				"missing-whitespace-after-doctype-system-keyword"),
			(e.missingQuoteBeforeDoctypePublicIdentifier =
				"missing-quote-before-doctype-public-identifier"),
			(e.missingQuoteBeforeDoctypeSystemIdentifier =
				"missing-quote-before-doctype-system-identifier"),
			(e.missingDoctypePublicIdentifier = "missing-doctype-public-identifier"),
			(e.missingDoctypeSystemIdentifier = "missing-doctype-system-identifier"),
			(e.abruptDoctypePublicIdentifier = "abrupt-doctype-public-identifier"),
			(e.abruptDoctypeSystemIdentifier = "abrupt-doctype-system-identifier"),
			(e.cdataInHtmlContent = "cdata-in-html-content"),
			(e.incorrectlyOpenedComment = "incorrectly-opened-comment"),
			(e.eofInScriptHtmlCommentLikeText = "eof-in-script-html-comment-like-text"),
			(e.eofInDoctype = "eof-in-doctype"),
			(e.nestedComment = "nested-comment"),
			(e.abruptClosingOfEmptyComment = "abrupt-closing-of-empty-comment"),
			(e.eofInComment = "eof-in-comment"),
			(e.incorrectlyClosedComment = "incorrectly-closed-comment"),
			(e.eofInCdata = "eof-in-cdata"),
			(e.absenceOfDigitsInNumericCharacterReference =
				"absence-of-digits-in-numeric-character-reference"),
			(e.nullCharacterReference = "null-character-reference"),
			(e.surrogateCharacterReference = "surrogate-character-reference"),
			(e.characterReferenceOutsideUnicodeRange = "character-reference-outside-unicode-range"),
			(e.controlCharacterReference = "control-character-reference"),
			(e.noncharacterCharacterReference = "noncharacter-character-reference"),
			(e.missingWhitespaceBeforeDoctypeName = "missing-whitespace-before-doctype-name"),
			(e.missingDoctypeName = "missing-doctype-name"),
			(e.invalidCharacterSequenceAfterDoctypeName =
				"invalid-character-sequence-after-doctype-name"),
			(e.duplicateAttribute = "duplicate-attribute"),
			(e.nonConformingDoctype = "non-conforming-doctype"),
			(e.missingDoctype = "missing-doctype"),
			(e.misplacedDoctype = "misplaced-doctype"),
			(e.endTagWithoutMatchingOpenElement = "end-tag-without-matching-open-element"),
			(e.closingOfElementWithOpenChildElements = "closing-of-element-with-open-child-elements"),
			(e.disallowedContentInNoscriptInHead = "disallowed-content-in-noscript-in-head"),
			(e.openElementsLeftAfterEof = "open-elements-left-after-eof"),
			(e.abandonedHeadElementChild = "abandoned-head-element-child"),
			(e.misplacedStartTagForHeadElement = "misplaced-start-tag-for-head-element"),
			(e.nestedNoscriptInHead = "nested-noscript-in-head"),
			(e.eofInElementThatCanContainOnlyText = "eof-in-element-that-can-contain-only-text")
	})(ve || (ve = {}))
	const Sft = 65536
	class Dft {
		constructor(t) {
			;(this.handler = t),
				(this.html = ""),
				(this.pos = -1),
				(this.lastGapPos = -2),
				(this.gapStack = []),
				(this.skipNextNewLine = !1),
				(this.lastChunkWritten = !1),
				(this.endOfChunkHit = !1),
				(this.bufferWaterline = Sft),
				(this.isEol = !1),
				(this.lineStartPos = 0),
				(this.droppedBufferSize = 0),
				(this.line = 1),
				(this.lastErrOffset = -1)
		}
		get col() {
			return this.pos - this.lineStartPos + +(this.lastGapPos !== this.pos)
		}
		get offset() {
			return this.droppedBufferSize + this.pos
		}
		getError(t, n) {
			const { line: r, col: i, offset: a } = this,
				o = i + n,
				s = a + n
			return {
				code: t,
				startLine: r,
				endLine: r,
				startCol: o,
				endCol: o,
				startOffset: s,
				endOffset: s,
			}
		}
		_err(t) {
			this.handler.onParseError &&
				this.lastErrOffset !== this.offset &&
				((this.lastErrOffset = this.offset), this.handler.onParseError(this.getError(t, 0)))
		}
		_addGap() {
			this.gapStack.push(this.lastGapPos), (this.lastGapPos = this.pos)
		}
		_processSurrogate(t) {
			if (this.pos !== this.html.length - 1) {
				const n = this.html.charCodeAt(this.pos + 1)
				if (Tft(n)) return this.pos++, this._addGap(), kft(t, n)
			} else if (!this.lastChunkWritten) return (this.endOfChunkHit = !0), U.EOF
			return this._err(ve.surrogateInInputStream), t
		}
		willDropParsedChunk() {
			return this.pos > this.bufferWaterline
		}
		dropParsedChunk() {
			this.willDropParsedChunk() &&
				((this.html = this.html.substring(this.pos)),
				(this.lineStartPos -= this.pos),
				(this.droppedBufferSize += this.pos),
				(this.pos = 0),
				(this.lastGapPos = -2),
				(this.gapStack.length = 0))
		}
		write(t, n) {
			this.html.length > 0 ? (this.html += t) : (this.html = t),
				(this.endOfChunkHit = !1),
				(this.lastChunkWritten = n)
		}
		insertHtmlAtCurrentPos(t) {
			;(this.html = this.html.substring(0, this.pos + 1) + t + this.html.substring(this.pos + 1)),
				(this.endOfChunkHit = !1)
		}
		startsWith(t, n) {
			if (this.pos + t.length > this.html.length)
				return (this.endOfChunkHit = !this.lastChunkWritten), !1
			if (n) return this.html.startsWith(t, this.pos)
			for (let r = 0; r < t.length; r++)
				if ((this.html.charCodeAt(this.pos + r) | 32) !== t.charCodeAt(r)) return !1
			return !0
		}
		peek(t) {
			const n = this.pos + t
			if (n >= this.html.length) return (this.endOfChunkHit = !this.lastChunkWritten), U.EOF
			const r = this.html.charCodeAt(n)
			return r === U.CARRIAGE_RETURN ? U.LINE_FEED : r
		}
		advance() {
			if (
				(this.pos++,
				this.isEol && ((this.isEol = !1), this.line++, (this.lineStartPos = this.pos)),
				this.pos >= this.html.length)
			)
				return (this.endOfChunkHit = !this.lastChunkWritten), U.EOF
			let t = this.html.charCodeAt(this.pos)
			return t === U.CARRIAGE_RETURN
				? ((this.isEol = !0), (this.skipNextNewLine = !0), U.LINE_FEED)
				: t === U.LINE_FEED && ((this.isEol = !0), this.skipNextNewLine)
				? (this.line--, (this.skipNextNewLine = !1), this._addGap(), this.advance())
				: ((this.skipNextNewLine = !1),
				  NV(t) && (t = this._processSurrogate(t)),
				  this.handler.onParseError === null ||
						(t > 31 && t < 127) ||
						t === U.LINE_FEED ||
						t === U.CARRIAGE_RETURN ||
						(t > 159 && t < 64976) ||
						this._checkForProblematicCharacters(t),
				  t)
		}
		_checkForProblematicCharacters(t) {
			MV(t)
				? this._err(ve.controlCharacterInInputStream)
				: IV(t) && this._err(ve.noncharacterInInputStream)
		}
		retreat(t) {
			for (this.pos -= t; this.pos < this.lastGapPos; )
				(this.lastGapPos = this.gapStack.pop()), this.pos--
			this.isEol = !1
		}
	}
	var Ct
	;(function (e) {
		;(e[(e.CHARACTER = 0)] = "CHARACTER"),
			(e[(e.NULL_CHARACTER = 1)] = "NULL_CHARACTER"),
			(e[(e.WHITESPACE_CHARACTER = 2)] = "WHITESPACE_CHARACTER"),
			(e[(e.START_TAG = 3)] = "START_TAG"),
			(e[(e.END_TAG = 4)] = "END_TAG"),
			(e[(e.COMMENT = 5)] = "COMMENT"),
			(e[(e.DOCTYPE = 6)] = "DOCTYPE"),
			(e[(e.EOF = 7)] = "EOF"),
			(e[(e.HIBERNATION = 8)] = "HIBERNATION")
	})(Ct || (Ct = {}))
	function RV(e, t) {
		for (let n = e.attrs.length - 1; n >= 0; n--) if (e.attrs[n].name === t) return e.attrs[n].value
		return null
	}
	const LV = new Uint16Array(
			'<\0\0\0\0\0\0EMabcfglmnoprstu\\bfmsligP&cutereve;iyx}rc;r;ravepha;acr;d;gpon;f;plyFunction;ingcsr;ign;ildemlaceforsucrkslash;;ed;y;crtause;noullis;a;r;pf;eve;cmpeq;HOacdefhilorsucy;PYcpyute;;italDifferentialD;leys;aeioron;dilrc;nint;ot;dnilla;terDot;i;rcleDMPTot;inus;lus;imes;ocskwiseContourIntegral;eCurlyDQoubleQuote;uote;lnpuon;e;gitruent;nt;ourIntegral;fr;oduct;nterClockwiseContourIntegral;oss;cr;p;Cap;DJSZacefios;otrahd;cy;cy;cy;grsger;r;hv;ayron;;l;ta;r;afcmriticalADGTcute;o;bleAcute;rave;ilde;ond;ferentialD;\0\0\0\0f;;DEot;qual;bleCDLRUVontourIntegrao\0\0nArrow;eoftARTrrow;ightArrow;engLReftARrrow;ightArrow;ightArrow;ightATrrow;ee;p\0\0rrow;ownArrow;erticalBar;nABLRTarrow;BUar;pArrow;reve;eft\0\0ightVector;eeVector;ector;Bar;ight\0eeVector;ector;Bar;ee;Arrow;ctr;rok;NTacdfglmopqstuxG;Hcuteaiyron;rc;ot;r;raveement;apcr;ty\0\0mallSquare;erySmallSquare;gpon;f;silon;uail;Tilde;librium;cir;m;a;mlipsts;onentialE;cfiosy;r;lled\0\0mallSquare;erySmallSquare;\0\0\0f;All;riertrf;cJTabcdfgorstcy;>mma;d;reve;eiydil;rc;;ot;r;;pf;eaterEFGLSTqual;Less;ullEqual;reater;ess;lantEqual;ilde;cr;;AacfiosuRDcy;ctek;;irc;r;lbertSpace;\0f;izontalLine;ctrok;mpownHumqual;EJOacdfgmnostucy;lig;cy;cuteiyrc;ot;r;rave;apcgr;inaryI;lie\0;egrral;section;isibleCTomma;imes;gpton;f;a;cr;ilde;\0cy;lcfosuiyrc;;r;pf;\0r;rcy;kcy;HJacfoscy;cy;ppa;eydil;;r;pf;cr;JTaceflmostcy;<cmnprute;bda;g;lacetrf;r;aeyron;dil;;fstACDFRTUVarnrgleBracket;row;BRar;ightArrow;eiling;o\0bleBracket;n\0eeVector;ector;Bar;loor;ightAVrrow;ector;ere;AVrrow;ector;iangle;BEar;qual;pDTVownVector;eeVector;ector;Bar;ector;Bar;ightsEFGLSTqualGreater;ullEqual;reater;ess;lantEqual;ilde;r;;eftarrow;idot;npwgLRlreftARrrow;ightArrow;ightArrow;eftarightightf;erLReftArrow;ightArrow;cht;rok;;acefiosup;y;dliumSpace;lintrf;r;nusPlus;pf;c;Jacefostucy;cute;aeyron;dil;;gswativeMTVediumSpace;hicneryThitedGLreaterGreateessLesLine;r;Bnptreak;BreakingSpace;f;;CDEGHLNPRSTVoungruent;pCap;oubleVerticalBar;lqxement;ual;Tilde;ists;reater;EFGLSTqual;ullEqual;reater;ess;lantEqual;ilde;umpownHump;qual;efstTriangle;BEar;qual;s;EGLSTqual;reater;ess;lantEqual;ilde;estedGLreaterGreater;essLess;recedes;ESqual;lantEqual;eiverseElement;ghtTriangle;BEar;qual;quuareSubpset;Equal;erset;Equal;bcpset;Equal;ceeds;ESTqual;lantEqual;ilde;erset;Equal;ilde;EFTqual;ullEqual;ilde;erticalBar;cr;ilde;Eacdfgmoprstuvlig;cuteiyrc;blac;r;raveaeicr;ga;cron;pf;enCurlyDQoubleQuote;uote;;clr;ashidees;mlerBParr;acek;et;arenthesis;acfhilorsrtialD;y;r;i;;usMinus;ipncareplanf;;eiocedes;ESTqual;lantEqual;ilde;me;dpuct;ortion;al;cir;;UfosOT"r;pf;cr;BEacefhiorsuarr;Gcnrute;g;r;tl;aeyron;dil;;;verseEUlqement;uilibrium;pEquilibrium;ro;ghtACDFTUVanrgleBracket;row;BLar;eftArrow;eiling;o\0bleBracket;n\0eeVector;ector;Bar;loor;ere;AVrrow;ector;iangle;BEar;qual;pDTVownVector;eeVector;ector;Bar;ector;Bar;puf;ndImplies;ightarrow;chr;;leDelayed;HOacfhimoqstuCcHcy;y;FTcy;cute;;aeiyron;dil;rc;;r;ortDLRUownArroweftArrowightArrowpArrow;gma;allCircle;pf;\0\0t;are;ISUntersection;ubpset;Equal;erset;Equal;nion;cr;ar;bcmp;set;Equal;cheeds;ESTqual;lantEqual;ilde;Th;;esrset;Equal;etHRSacfhiorsORNADE;Hccy;y;bu;;aeyron;dil;;r;ei\0efore;a;cnkSpace;Space;lde;EFTqual;ullEqual;ilde;pf;ipleDot;ctr;rok;\0\0\0\0\0\0\0cruter;ocir;r\0y;ve;iyrc;blac;r;raveacr;dierBParr;acek;et;arenthesis;on;Plus;gpon;f;ADETadpsrrow;BDar;ownArrow;ownArrow;quilibrium;ee;Arrow;ownerLReftArrow;ightArrow;i;lon;ing;cr;ilde;mlDbcdefosvash;ar;y;ash;l;er;btyar;;icalBLSTar;ine;eparator;ilde;ThinSpace;r;pf;cr;dash;cefosirc;dge;r;pf;cr;fiosr;;pf;cr;AIUacfosucy;cy;cy;cuteiyrc;;r;pf;cr;ml;Hacdefoscy;cute;ayron;;ot;\0oWidta;r;pf;cr;\0\0\0\0\0\0\0cutereve;;Ediuy;;rcte;lig;r;raveepfpsym;ha;apcclr;g;\0\0;adsvnd;;lope;;;elmrsz;esd;a;;;;;;;;t;vb;d;pth;arr;gpon;f;;Eaeiop;cir;;d;s;rox;eingctyr;;mp;eildemlcioninnt;Nabcdefiklnoprsuot;crkcepsong;psilon;rime;im;eq;ee;ed;gerk;tbrk;oy;quo;cmprtaus;eptyv;snoahw;;een;r;gcostuvwaiurc;pdptot;lus;imes;\0\0cup;ar;riangleduown;p;plus;earow;akocnklstozenge;riangle;dlrown;eft;ight;k;\0\0;;4;ck;eo;q=uiv;t;ptwxf;;tomtie;DHUVbdhmptuvLRlr;;;;;DUdu;;;;LRlr;;;;;HLRhlr;;;;;;ox;LRlr;;;;;DUdu;;;;inus;lus;imes;LRlr;;;;;HLRhlr;;;;;;evbarceior;mi;m;el;bh;sub;l;etp;Ee;;q\0\0\0\0\0\0\0\0\0\0cprute;;abcdsnd;rcup;aup;p;ot;;eot;aeiu\0s;on;dilrc;ps;sm;ot;dmnilptyv;t;err;ceiy;ck;mark;r;Ecefms;;elq;e\0\0rrowlreft;ight;RSacd;st;irc;ash;nint;id;cir;ubs;uit\0on;e;q\0\0a;t;;flemxente\0;dot;nfry;o;sr;aorr;ss;cur;bp;e;;e;dot;delprvwarrlr;;\0\0r;c;arr;p;;bcdosrcap;aup;p;ot;r;;alrvrr;m;yevwq\0\0reuee;edge;enearrowlreftightecioninnt;lcty;AHabcdefhijlorstuwzrar;glrsger;eth;h;varow;aayron;;;aogrr;tseq;glmta;ptyv;irsht;;arlraegsvm;osnd;suit;amma;in;;iode;ontimes;ncy;c\0\0rn;op;lptuwlar;f;;empsq;dot;inus;lus;quare;blebarwedgnadhownarrowarpoonlrefighkaro\0\0rn;op;cotry;;l;rok;drot;i;fahraangle;ciy;grarr;DacdefglmnopqrstuxDoocsuteter;aioyron;r;clon;;ot;Drot;;;rsave;dot;;ilsnters;;;dot;apscr;ty;svetp1;;;gs;p;gpon;f;alsr;sl;us;i;lvon;csuviorc\0\0antgltressaeils;st;v;DD;parsl;Daot;rr;cdir;oah;mrlo;cipl;seoctationential\0\0\0\0\0\0\0llingdotsey;male;ilrlig;\0\0g;ig;;lig;lig;fjaltt;ig;ns;of;\0f;ak;v;artint;aocs\0\0;;;;\0;;\0\0;;5;\0;;8;l;wn;cr;Eabcdefgijlnorstv;l;cmpute;ma;d;reve;iyrc;;ot;;lqs;qslan;cdlc;ot;o;l;;es;r;;gmel;cy;;Eaj;;;Eaes;p;prox;q;qim;pf;cir;m;el;;>;cdlqrci;r;ot;Par;uest;adels\0pror;qlqlesienrtneqq;Aabcefkosyrilmrrsfildrcy;;cwir;;ar;irc;alrrts;uitlip;con;r;sewarow;arow;amoprrr;tht;klreftarrow;ightarrow;f;bar;cltr;asrok;bpull;hen\0\0\0\0\0\0cute;iyrc;cxy;clfr;rave;inoinnt;t;fin;ta;lig;aopcgtr;elpinarh;f;ed;;cfotare;in;tie;do;celpal;grerarhk;rod;cgpty;on;f;a;uestcir;n;Edsv;ot;;v;;ilde;\0cy;lcfmosuiyrc;;r;ath;pf;\0r;rcy;kcy;acfghjosppa;v;eydil;;r;reen;cy;cy;pf;cr;ABEHabcdefghjlmnoprstuvartrail;arr;;g;ar;\0\0\0\0\0\0\0\0\0ute;mptyv;rabda;g;dl;;uor;bfhlpst;fs;s;p;l;im;l;;aeil;;s;abrrr;rk;akcek;;es;ldu;;aeuyron;diil;;cqrsa;uo;rduhar;shar;h;;fgqstahlrtrrow;taarpoonduownpeftarrows;ightahsrrow;sarpoonquigarrohreetimes;;qslan;cdgsc;ot;o;r;;es;adegspproot;qgqgtiilrsht;;;E;rdu;l;lk;cy;;achtrorneard;ri;iodot;ust;acheEaes;p;prox;q;qim;abnoptwznrg;r;rglmreftarightapsto;ightparrowlrefight;aflr;;us;imes;st;;efngear;lt;achmtrornear;d;;ri;achiqtquo;r;m;eg;;buo;r;rok;<;cdhilqrci;r;remes;arr;uest;Piar;;efrdushar;har;enrtneqq;DacdefhilnopsuDot;clprret;;ese;sto;dluowefker;oymma;;ash;asuredangler;o;cdnro;acdsir;otus;bd;u;p;dpels;f;ctr;pos;lmtimap;GLRVabcdefghijlmoprstuvwgt;;veltftarrrow;ightarrow;;;vightarrow;Ddash;ash;bcnptlaute;g;;Eiop;d;s;rour;al;s\0pmp;eaeouy\0;on;dil;ng;dot;p;;ash;;Aadqsxrr;rhrk;;oot;uieiar;ist;sr;Eest;qs;qslani;rAaprrr;ar;;sv;d;cy;AEadestr;rr;r;;fqstarrroightarro;qslan;si;ri;eiptf;;inn;Edv;ot;;;i;v;;aorr;astllel;;lint;;ceu;c;eAaitrrr;cw;;ghtarrowri;echimpqu;ceru;ort\0\0arm;e;qsubpbcp;Ees;et;eq;qc;e;Ees;et;eq;qgilrldeianglelreft;eight;e;m;esro;p;DHadgilrsash;arr;p;ash;et;;>nfin;Aetrr;;;r<ie;Atrr;rie;im;Aanrr;rhrk;;oear;\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0csuteiyr;c;abioslac;v;old;lig;crir;;\0\0\0n;ave;bmar;acitrirr;oss;n;aeicr;ga;cdnron;;pf;aelr;rp;;adiosvr;efmr;ofgof;r;lope;;cloashl;idees;as;mlbar;\0\0\0\0\0\0\0\0\0r;ast;lle\0\0m;;y;rcimptnt;od;il;enk;r;imo;v;mane;;tvchfork;aunckk;h;s;abcdemstcir;ir;ou;;nim;wo;ipuntint;f;nd;Eaceinosu;p;u;c;acenspprourlyeaespprox;qq;im;ime;sEasdfpalslar;ine;urf;;trel;cir;;ncsp;fiopsur;pf;rime;cr;aeoteirnionnt;st;eABHabcdefhilmnoprstuxartrail;arar;cdenqrteu;te;imptyv;g;del;;uor;abcfhlpstwp;;fs;;s;l;im;l;;aiil;o;nalabrrrk;akcek;;es;ldu;;aeuyron;diil;;clqsa;dhar;uo;rh;acgl;ipsnart;ilrsht;;aordu;l;;v;gnshtahlrstrrow;taarpoonduowpeftahrrowarpoonightarrows;quigarrohreetimes;g;ingdotseahmra;oust;achemid;abptnrg;r;raflr;;us;imes;apr;gt;olint;arachqquo;r;buo;rhirremes;i;efltri;luhar;;\0\0\0\0\0\0\0cute;qu;Eaceinpsy;\0;on;u;dil;rc;Eas;p;im;olint;i;ot;be;Aacmstxrr;rhr;oti;war;minnut;r;oacoyrp;hycy;;rt\0\0iaragmma;fv;;deglnprot;;q;E;;E;e;lus;arr;araeitlslsetmhp;parsl;dle;;e;s;flptcy;;b;ar;f;adres;uitcsuaup;s;p;s;ubp;eset;e;eset;e;afrarcemtr;tmiararr;fanighteppsilohsbcmnp;Edemnprs;ot;;dot;ult;Ee;;lus;arr;eiut;enq;qeq;qm;bp;;c;acenspprourlyeaespproqg;123;Edehlmnps;ost;ub;;dot;soul;b;arr;ult;Ee;;lus;eiut;enq;qeq;qm;bp;;Aanrr;rhr;owar;lig\0\0\0\0\0\0\0\0\0\0\0\0get;;raeyron;dil;;lrec;r;eiko\0e4fa;svym;cnkaspproimsasrnes;bd;ar;;eps;bcfot;ir;;ork;rime;aipdadempstngle;dlqrowneft;e;ight;eot;inus;lus;b;ime;ezium;chtry;;cy;rok;ioxheadlreftarroightarrowAHabcdfghlmoprstuwrar;cruter\0y;ve;iyrc;abhrlac;airsht;;raverlrlk;ct\0\0rn;erop;ri;alcr;gpon;f;adhlsuownarpoonlrefighi;hlonparrows;cit\0\0rn;erop;ng;ri;cr;dirot;lde;i;famrlangle;ABDacdeflnoprszrar;v;asnrgrt;eknprstappothinhirop;hiugmbpsetneq;q;setneq;q;hretianglelreftighty;ashelr;bear;q;lip;btar;trsubppf;rotrcur;bpnEenEeigzag;cefoprsirc;dibgar;e;q;erp;r;pf;;eatcr;\0\0\0\0\0\0\0trr;Aarr;Aarrais;dptfl;imAarrcqr;ptracefiosucuyte;iyrc;;nr;cy;pf;cr;cmy;lacdefhioswcute;ayron;;ot;ettra;r;cy;grarr;pf;cr;jn;j;'
				.split("")
				.map((e) => e.charCodeAt(0)),
		),
		_ft = new Uint16Array(
			"aglq	\x1B\0\0p;os;t;t;uot;".split("").map((e) => e.charCodeAt(0)),
		)
	var Xk
	const Oft = new Map([
			[0, 65533],
			[128, 8364],
			[130, 8218],
			[131, 402],
			[132, 8222],
			[133, 8230],
			[134, 8224],
			[135, 8225],
			[136, 710],
			[137, 8240],
			[138, 352],
			[139, 8249],
			[140, 338],
			[142, 381],
			[145, 8216],
			[146, 8217],
			[147, 8220],
			[148, 8221],
			[149, 8226],
			[150, 8211],
			[151, 8212],
			[152, 732],
			[153, 8482],
			[154, 353],
			[155, 8250],
			[156, 339],
			[158, 382],
			[159, 376],
		]),
		Aft =
			(Xk = String.fromCodePoint) !== null && Xk !== void 0
				? Xk
				: function (e) {
						let t = ""
						return (
							e > 65535 &&
								((e -= 65536),
								(t += String.fromCharCode(((e >>> 10) & 1023) | 55296)),
								(e = 56320 | (e & 1023))),
							(t += String.fromCharCode(e)),
							t
						)
				  }
	function Nft(e) {
		var t
		return (e >= 55296 && e <= 57343) || e > 1114111
			? 65533
			: (t = Oft.get(e)) !== null && t !== void 0
			? t
			: e
	}
	var _r
	;(function (e) {
		;(e[(e.NUM = 35)] = "NUM"),
			(e[(e.SEMI = 59)] = "SEMI"),
			(e[(e.EQUALS = 61)] = "EQUALS"),
			(e[(e.ZERO = 48)] = "ZERO"),
			(e[(e.NINE = 57)] = "NINE"),
			(e[(e.LOWER_A = 97)] = "LOWER_A"),
			(e[(e.LOWER_F = 102)] = "LOWER_F"),
			(e[(e.LOWER_X = 120)] = "LOWER_X"),
			(e[(e.LOWER_Z = 122)] = "LOWER_Z"),
			(e[(e.UPPER_A = 65)] = "UPPER_A"),
			(e[(e.UPPER_F = 70)] = "UPPER_F"),
			(e[(e.UPPER_Z = 90)] = "UPPER_Z")
	})(_r || (_r = {}))
	const Mft = 32
	var xu
	;(function (e) {
		;(e[(e.VALUE_LENGTH = 49152)] = "VALUE_LENGTH"),
			(e[(e.BRANCH_LENGTH = 16256)] = "BRANCH_LENGTH"),
			(e[(e.JUMP_TABLE = 127)] = "JUMP_TABLE")
	})(xu || (xu = {}))
	function gD(e) {
		return e >= _r.ZERO && e <= _r.NINE
	}
	function Ift(e) {
		return (e >= _r.UPPER_A && e <= _r.UPPER_F) || (e >= _r.LOWER_A && e <= _r.LOWER_F)
	}
	function Rft(e) {
		return (e >= _r.UPPER_A && e <= _r.UPPER_Z) || (e >= _r.LOWER_A && e <= _r.LOWER_Z) || gD(e)
	}
	function Lft(e) {
		return e === _r.EQUALS || Rft(e)
	}
	var Tr
	;(function (e) {
		;(e[(e.EntityStart = 0)] = "EntityStart"),
			(e[(e.NumericStart = 1)] = "NumericStart"),
			(e[(e.NumericDecimal = 2)] = "NumericDecimal"),
			(e[(e.NumericHex = 3)] = "NumericHex"),
			(e[(e.NamedEntity = 4)] = "NamedEntity")
	})(Tr || (Tr = {}))
	var tl
	;(function (e) {
		;(e[(e.Legacy = 0)] = "Legacy"),
			(e[(e.Strict = 1)] = "Strict"),
			(e[(e.Attribute = 2)] = "Attribute")
	})(tl || (tl = {}))
	class PV {
		constructor(t, n, r) {
			;(this.decodeTree = t),
				(this.emitCodePoint = n),
				(this.errors = r),
				(this.state = Tr.EntityStart),
				(this.consumed = 1),
				(this.result = 0),
				(this.treeIndex = 0),
				(this.excess = 1),
				(this.decodeMode = tl.Strict)
		}
		startEntity(t) {
			;(this.decodeMode = t),
				(this.state = Tr.EntityStart),
				(this.result = 0),
				(this.treeIndex = 0),
				(this.excess = 1),
				(this.consumed = 1)
		}
		write(t, n) {
			switch (this.state) {
				case Tr.EntityStart:
					return t.charCodeAt(n) === _r.NUM
						? ((this.state = Tr.NumericStart),
						  (this.consumed += 1),
						  this.stateNumericStart(t, n + 1))
						: ((this.state = Tr.NamedEntity), this.stateNamedEntity(t, n))
				case Tr.NumericStart:
					return this.stateNumericStart(t, n)
				case Tr.NumericDecimal:
					return this.stateNumericDecimal(t, n)
				case Tr.NumericHex:
					return this.stateNumericHex(t, n)
				case Tr.NamedEntity:
					return this.stateNamedEntity(t, n)
			}
		}
		stateNumericStart(t, n) {
			return n >= t.length
				? -1
				: (t.charCodeAt(n) | Mft) === _r.LOWER_X
				? ((this.state = Tr.NumericHex), (this.consumed += 1), this.stateNumericHex(t, n + 1))
				: ((this.state = Tr.NumericDecimal), this.stateNumericDecimal(t, n))
		}
		addToNumericResult(t, n, r, i) {
			if (n !== r) {
				const a = r - n
				;(this.result = this.result * Math.pow(i, a) + parseInt(t.substr(n, a), i)),
					(this.consumed += a)
			}
		}
		stateNumericHex(t, n) {
			const r = n
			for (; n < t.length; ) {
				const i = t.charCodeAt(n)
				if (gD(i) || Ift(i)) n += 1
				else return this.addToNumericResult(t, r, n, 16), this.emitNumericEntity(i, 3)
			}
			return this.addToNumericResult(t, r, n, 16), -1
		}
		stateNumericDecimal(t, n) {
			const r = n
			for (; n < t.length; ) {
				const i = t.charCodeAt(n)
				if (gD(i)) n += 1
				else return this.addToNumericResult(t, r, n, 10), this.emitNumericEntity(i, 2)
			}
			return this.addToNumericResult(t, r, n, 10), -1
		}
		emitNumericEntity(t, n) {
			var r
			if (this.consumed <= n)
				return (
					(r = this.errors) === null ||
						r === void 0 ||
						r.absenceOfDigitsInNumericCharacterReference(this.consumed),
					0
				)
			if (t === _r.SEMI) this.consumed += 1
			else if (this.decodeMode === tl.Strict) return 0
			return (
				this.emitCodePoint(Nft(this.result), this.consumed),
				this.errors &&
					(t !== _r.SEMI && this.errors.missingSemicolonAfterCharacterReference(),
					this.errors.validateNumericCharacterReference(this.result)),
				this.consumed
			)
		}
		stateNamedEntity(t, n) {
			const { decodeTree: r } = this
			let i = r[this.treeIndex],
				a = (i & xu.VALUE_LENGTH) >> 14
			for (; n < t.length; n++, this.excess++) {
				const o = t.charCodeAt(n)
				if (((this.treeIndex = Pft(r, i, this.treeIndex + Math.max(1, a), o)), this.treeIndex < 0))
					return this.result === 0 || (this.decodeMode === tl.Attribute && (a === 0 || Lft(o)))
						? 0
						: this.emitNotTerminatedNamedEntity()
				if (((i = r[this.treeIndex]), (a = (i & xu.VALUE_LENGTH) >> 14), a !== 0)) {
					if (o === _r.SEMI)
						return this.emitNamedEntityData(this.treeIndex, a, this.consumed + this.excess)
					this.decodeMode !== tl.Strict &&
						((this.result = this.treeIndex), (this.consumed += this.excess), (this.excess = 0))
				}
			}
			return -1
		}
		emitNotTerminatedNamedEntity() {
			var t
			const { result: n, decodeTree: r } = this,
				i = (r[n] & xu.VALUE_LENGTH) >> 14
			return (
				this.emitNamedEntityData(n, i, this.consumed),
				(t = this.errors) === null || t === void 0 || t.missingSemicolonAfterCharacterReference(),
				this.consumed
			)
		}
		emitNamedEntityData(t, n, r) {
			const { decodeTree: i } = this
			return (
				this.emitCodePoint(n === 1 ? i[t] & ~xu.VALUE_LENGTH : i[t + 1], r),
				n === 3 && this.emitCodePoint(i[t + 2], r),
				r
			)
		}
		end() {
			var t
			switch (this.state) {
				case Tr.NamedEntity:
					return this.result !== 0 &&
						(this.decodeMode !== tl.Attribute || this.result === this.treeIndex)
						? this.emitNotTerminatedNamedEntity()
						: 0
				case Tr.NumericDecimal:
					return this.emitNumericEntity(0, 2)
				case Tr.NumericHex:
					return this.emitNumericEntity(0, 3)
				case Tr.NumericStart:
					return (
						(t = this.errors) === null ||
							t === void 0 ||
							t.absenceOfDigitsInNumericCharacterReference(this.consumed),
						0
					)
				case Tr.EntityStart:
					return 0
			}
		}
	}
	function jV(e) {
		let t = ""
		const n = new PV(e, (r) => (t += Aft(r)))
		return function (i, a) {
			let o = 0,
				s = 0
			for (; (s = i.indexOf("&", s)) >= 0; ) {
				;(t += i.slice(o, s)), n.startEntity(a)
				const u = n.write(i, s + 1)
				if (u < 0) {
					o = s + n.end()
					break
				}
				;(o = s + u), (s = u === 0 ? o + 1 : o)
			}
			const l = t + i.slice(o)
			return (t = ""), l
		}
	}
	function Pft(e, t, n, r) {
		const i = (t & xu.BRANCH_LENGTH) >> 7,
			a = t & xu.JUMP_TABLE
		if (i === 0) return a !== 0 && r === a ? n : -1
		if (a) {
			const l = r - a
			return l < 0 || l >= i ? -1 : e[n + l] - 1
		}
		let o = n,
			s = o + i - 1
		for (; o <= s; ) {
			const l = (o + s) >>> 1,
				u = e[l]
			if (u < r) o = l + 1
			else if (u > r) s = l - 1
			else return e[l + i]
		}
		return -1
	}
	jV(LV)
	jV(_ft)
	var we
	;(function (e) {
		;(e.HTML = "http://www.w3.org/1999/xhtml"),
			(e.MATHML = "http://www.w3.org/1998/Math/MathML"),
			(e.SVG = "http://www.w3.org/2000/svg"),
			(e.XLINK = "http://www.w3.org/1999/xlink"),
			(e.XML = "http://www.w3.org/XML/1998/namespace"),
			(e.XMLNS = "http://www.w3.org/2000/xmlns/")
	})(we || (we = {}))
	var nd
	;(function (e) {
		;(e.TYPE = "type"),
			(e.ACTION = "action"),
			(e.ENCODING = "encoding"),
			(e.PROMPT = "prompt"),
			(e.NAME = "name"),
			(e.COLOR = "color"),
			(e.FACE = "face"),
			(e.SIZE = "size")
	})(nd || (nd = {}))
	var Ba
	;(function (e) {
		;(e.NO_QUIRKS = "no-quirks"), (e.QUIRKS = "quirks"), (e.LIMITED_QUIRKS = "limited-quirks")
	})(Ba || (Ba = {}))
	var se
	;(function (e) {
		;(e.A = "a"),
			(e.ADDRESS = "address"),
			(e.ANNOTATION_XML = "annotation-xml"),
			(e.APPLET = "applet"),
			(e.AREA = "area"),
			(e.ARTICLE = "article"),
			(e.ASIDE = "aside"),
			(e.B = "b"),
			(e.BASE = "base"),
			(e.BASEFONT = "basefont"),
			(e.BGSOUND = "bgsound"),
			(e.BIG = "big"),
			(e.BLOCKQUOTE = "blockquote"),
			(e.BODY = "body"),
			(e.BR = "br"),
			(e.BUTTON = "button"),
			(e.CAPTION = "caption"),
			(e.CENTER = "center"),
			(e.CODE = "code"),
			(e.COL = "col"),
			(e.COLGROUP = "colgroup"),
			(e.DD = "dd"),
			(e.DESC = "desc"),
			(e.DETAILS = "details"),
			(e.DIALOG = "dialog"),
			(e.DIR = "dir"),
			(e.DIV = "div"),
			(e.DL = "dl"),
			(e.DT = "dt"),
			(e.EM = "em"),
			(e.EMBED = "embed"),
			(e.FIELDSET = "fieldset"),
			(e.FIGCAPTION = "figcaption"),
			(e.FIGURE = "figure"),
			(e.FONT = "font"),
			(e.FOOTER = "footer"),
			(e.FOREIGN_OBJECT = "foreignObject"),
			(e.FORM = "form"),
			(e.FRAME = "frame"),
			(e.FRAMESET = "frameset"),
			(e.H1 = "h1"),
			(e.H2 = "h2"),
			(e.H3 = "h3"),
			(e.H4 = "h4"),
			(e.H5 = "h5"),
			(e.H6 = "h6"),
			(e.HEAD = "head"),
			(e.HEADER = "header"),
			(e.HGROUP = "hgroup"),
			(e.HR = "hr"),
			(e.HTML = "html"),
			(e.I = "i"),
			(e.IMG = "img"),
			(e.IMAGE = "image"),
			(e.INPUT = "input"),
			(e.IFRAME = "iframe"),
			(e.KEYGEN = "keygen"),
			(e.LABEL = "label"),
			(e.LI = "li"),
			(e.LINK = "link"),
			(e.LISTING = "listing"),
			(e.MAIN = "main"),
			(e.MALIGNMARK = "malignmark"),
			(e.MARQUEE = "marquee"),
			(e.MATH = "math"),
			(e.MENU = "menu"),
			(e.META = "meta"),
			(e.MGLYPH = "mglyph"),
			(e.MI = "mi"),
			(e.MO = "mo"),
			(e.MN = "mn"),
			(e.MS = "ms"),
			(e.MTEXT = "mtext"),
			(e.NAV = "nav"),
			(e.NOBR = "nobr"),
			(e.NOFRAMES = "noframes"),
			(e.NOEMBED = "noembed"),
			(e.NOSCRIPT = "noscript"),
			(e.OBJECT = "object"),
			(e.OL = "ol"),
			(e.OPTGROUP = "optgroup"),
			(e.OPTION = "option"),
			(e.P = "p"),
			(e.PARAM = "param"),
			(e.PLAINTEXT = "plaintext"),
			(e.PRE = "pre"),
			(e.RB = "rb"),
			(e.RP = "rp"),
			(e.RT = "rt"),
			(e.RTC = "rtc"),
			(e.RUBY = "ruby"),
			(e.S = "s"),
			(e.SCRIPT = "script"),
			(e.SEARCH = "search"),
			(e.SECTION = "section"),
			(e.SELECT = "select"),
			(e.SOURCE = "source"),
			(e.SMALL = "small"),
			(e.SPAN = "span"),
			(e.STRIKE = "strike"),
			(e.STRONG = "strong"),
			(e.STYLE = "style"),
			(e.SUB = "sub"),
			(e.SUMMARY = "summary"),
			(e.SUP = "sup"),
			(e.TABLE = "table"),
			(e.TBODY = "tbody"),
			(e.TEMPLATE = "template"),
			(e.TEXTAREA = "textarea"),
			(e.TFOOT = "tfoot"),
			(e.TD = "td"),
			(e.TH = "th"),
			(e.THEAD = "thead"),
			(e.TITLE = "title"),
			(e.TR = "tr"),
			(e.TRACK = "track"),
			(e.TT = "tt"),
			(e.U = "u"),
			(e.UL = "ul"),
			(e.SVG = "svg"),
			(e.VAR = "var"),
			(e.WBR = "wbr"),
			(e.XMP = "xmp")
	})(se || (se = {}))
	var k
	;(function (e) {
		;(e[(e.UNKNOWN = 0)] = "UNKNOWN"),
			(e[(e.A = 1)] = "A"),
			(e[(e.ADDRESS = 2)] = "ADDRESS"),
			(e[(e.ANNOTATION_XML = 3)] = "ANNOTATION_XML"),
			(e[(e.APPLET = 4)] = "APPLET"),
			(e[(e.AREA = 5)] = "AREA"),
			(e[(e.ARTICLE = 6)] = "ARTICLE"),
			(e[(e.ASIDE = 7)] = "ASIDE"),
			(e[(e.B = 8)] = "B"),
			(e[(e.BASE = 9)] = "BASE"),
			(e[(e.BASEFONT = 10)] = "BASEFONT"),
			(e[(e.BGSOUND = 11)] = "BGSOUND"),
			(e[(e.BIG = 12)] = "BIG"),
			(e[(e.BLOCKQUOTE = 13)] = "BLOCKQUOTE"),
			(e[(e.BODY = 14)] = "BODY"),
			(e[(e.BR = 15)] = "BR"),
			(e[(e.BUTTON = 16)] = "BUTTON"),
			(e[(e.CAPTION = 17)] = "CAPTION"),
			(e[(e.CENTER = 18)] = "CENTER"),
			(e[(e.CODE = 19)] = "CODE"),
			(e[(e.COL = 20)] = "COL"),
			(e[(e.COLGROUP = 21)] = "COLGROUP"),
			(e[(e.DD = 22)] = "DD"),
			(e[(e.DESC = 23)] = "DESC"),
			(e[(e.DETAILS = 24)] = "DETAILS"),
			(e[(e.DIALOG = 25)] = "DIALOG"),
			(e[(e.DIR = 26)] = "DIR"),
			(e[(e.DIV = 27)] = "DIV"),
			(e[(e.DL = 28)] = "DL"),
			(e[(e.DT = 29)] = "DT"),
			(e[(e.EM = 30)] = "EM"),
			(e[(e.EMBED = 31)] = "EMBED"),
			(e[(e.FIELDSET = 32)] = "FIELDSET"),
			(e[(e.FIGCAPTION = 33)] = "FIGCAPTION"),
			(e[(e.FIGURE = 34)] = "FIGURE"),
			(e[(e.FONT = 35)] = "FONT"),
			(e[(e.FOOTER = 36)] = "FOOTER"),
			(e[(e.FOREIGN_OBJECT = 37)] = "FOREIGN_OBJECT"),
			(e[(e.FORM = 38)] = "FORM"),
			(e[(e.FRAME = 39)] = "FRAME"),
			(e[(e.FRAMESET = 40)] = "FRAMESET"),
			(e[(e.H1 = 41)] = "H1"),
			(e[(e.H2 = 42)] = "H2"),
			(e[(e.H3 = 43)] = "H3"),
			(e[(e.H4 = 44)] = "H4"),
			(e[(e.H5 = 45)] = "H5"),
			(e[(e.H6 = 46)] = "H6"),
			(e[(e.HEAD = 47)] = "HEAD"),
			(e[(e.HEADER = 48)] = "HEADER"),
			(e[(e.HGROUP = 49)] = "HGROUP"),
			(e[(e.HR = 50)] = "HR"),
			(e[(e.HTML = 51)] = "HTML"),
			(e[(e.I = 52)] = "I"),
			(e[(e.IMG = 53)] = "IMG"),
			(e[(e.IMAGE = 54)] = "IMAGE"),
			(e[(e.INPUT = 55)] = "INPUT"),
			(e[(e.IFRAME = 56)] = "IFRAME"),
			(e[(e.KEYGEN = 57)] = "KEYGEN"),
			(e[(e.LABEL = 58)] = "LABEL"),
			(e[(e.LI = 59)] = "LI"),
			(e[(e.LINK = 60)] = "LINK"),
			(e[(e.LISTING = 61)] = "LISTING"),
			(e[(e.MAIN = 62)] = "MAIN"),
			(e[(e.MALIGNMARK = 63)] = "MALIGNMARK"),
			(e[(e.MARQUEE = 64)] = "MARQUEE"),
			(e[(e.MATH = 65)] = "MATH"),
			(e[(e.MENU = 66)] = "MENU"),
			(e[(e.META = 67)] = "META"),
			(e[(e.MGLYPH = 68)] = "MGLYPH"),
			(e[(e.MI = 69)] = "MI"),
			(e[(e.MO = 70)] = "MO"),
			(e[(e.MN = 71)] = "MN"),
			(e[(e.MS = 72)] = "MS"),
			(e[(e.MTEXT = 73)] = "MTEXT"),
			(e[(e.NAV = 74)] = "NAV"),
			(e[(e.NOBR = 75)] = "NOBR"),
			(e[(e.NOFRAMES = 76)] = "NOFRAMES"),
			(e[(e.NOEMBED = 77)] = "NOEMBED"),
			(e[(e.NOSCRIPT = 78)] = "NOSCRIPT"),
			(e[(e.OBJECT = 79)] = "OBJECT"),
			(e[(e.OL = 80)] = "OL"),
			(e[(e.OPTGROUP = 81)] = "OPTGROUP"),
			(e[(e.OPTION = 82)] = "OPTION"),
			(e[(e.P = 83)] = "P"),
			(e[(e.PARAM = 84)] = "PARAM"),
			(e[(e.PLAINTEXT = 85)] = "PLAINTEXT"),
			(e[(e.PRE = 86)] = "PRE"),
			(e[(e.RB = 87)] = "RB"),
			(e[(e.RP = 88)] = "RP"),
			(e[(e.RT = 89)] = "RT"),
			(e[(e.RTC = 90)] = "RTC"),
			(e[(e.RUBY = 91)] = "RUBY"),
			(e[(e.S = 92)] = "S"),
			(e[(e.SCRIPT = 93)] = "SCRIPT"),
			(e[(e.SEARCH = 94)] = "SEARCH"),
			(e[(e.SECTION = 95)] = "SECTION"),
			(e[(e.SELECT = 96)] = "SELECT"),
			(e[(e.SOURCE = 97)] = "SOURCE"),
			(e[(e.SMALL = 98)] = "SMALL"),
			(e[(e.SPAN = 99)] = "SPAN"),
			(e[(e.STRIKE = 100)] = "STRIKE"),
			(e[(e.STRONG = 101)] = "STRONG"),
			(e[(e.STYLE = 102)] = "STYLE"),
			(e[(e.SUB = 103)] = "SUB"),
			(e[(e.SUMMARY = 104)] = "SUMMARY"),
			(e[(e.SUP = 105)] = "SUP"),
			(e[(e.TABLE = 106)] = "TABLE"),
			(e[(e.TBODY = 107)] = "TBODY"),
			(e[(e.TEMPLATE = 108)] = "TEMPLATE"),
			(e[(e.TEXTAREA = 109)] = "TEXTAREA"),
			(e[(e.TFOOT = 110)] = "TFOOT"),
			(e[(e.TD = 111)] = "TD"),
			(e[(e.TH = 112)] = "TH"),
			(e[(e.THEAD = 113)] = "THEAD"),
			(e[(e.TITLE = 114)] = "TITLE"),
			(e[(e.TR = 115)] = "TR"),
			(e[(e.TRACK = 116)] = "TRACK"),
			(e[(e.TT = 117)] = "TT"),
			(e[(e.U = 118)] = "U"),
			(e[(e.UL = 119)] = "UL"),
			(e[(e.SVG = 120)] = "SVG"),
			(e[(e.VAR = 121)] = "VAR"),
			(e[(e.WBR = 122)] = "WBR"),
			(e[(e.XMP = 123)] = "XMP")
	})(k || (k = {}))
	const jft = new Map([
		[se.A, k.A],
		[se.ADDRESS, k.ADDRESS],
		[se.ANNOTATION_XML, k.ANNOTATION_XML],
		[se.APPLET, k.APPLET],
		[se.AREA, k.AREA],
		[se.ARTICLE, k.ARTICLE],
		[se.ASIDE, k.ASIDE],
		[se.B, k.B],
		[se.BASE, k.BASE],
		[se.BASEFONT, k.BASEFONT],
		[se.BGSOUND, k.BGSOUND],
		[se.BIG, k.BIG],
		[se.BLOCKQUOTE, k.BLOCKQUOTE],
		[se.BODY, k.BODY],
		[se.BR, k.BR],
		[se.BUTTON, k.BUTTON],
		[se.CAPTION, k.CAPTION],
		[se.CENTER, k.CENTER],
		[se.CODE, k.CODE],
		[se.COL, k.COL],
		[se.COLGROUP, k.COLGROUP],
		[se.DD, k.DD],
		[se.DESC, k.DESC],
		[se.DETAILS, k.DETAILS],
		[se.DIALOG, k.DIALOG],
		[se.DIR, k.DIR],
		[se.DIV, k.DIV],
		[se.DL, k.DL],
		[se.DT, k.DT],
		[se.EM, k.EM],
		[se.EMBED, k.EMBED],
		[se.FIELDSET, k.FIELDSET],
		[se.FIGCAPTION, k.FIGCAPTION],
		[se.FIGURE, k.FIGURE],
		[se.FONT, k.FONT],
		[se.FOOTER, k.FOOTER],
		[se.FOREIGN_OBJECT, k.FOREIGN_OBJECT],
		[se.FORM, k.FORM],
		[se.FRAME, k.FRAME],
		[se.FRAMESET, k.FRAMESET],
		[se.H1, k.H1],
		[se.H2, k.H2],
		[se.H3, k.H3],
		[se.H4, k.H4],
		[se.H5, k.H5],
		[se.H6, k.H6],
		[se.HEAD, k.HEAD],
		[se.HEADER, k.HEADER],
		[se.HGROUP, k.HGROUP],
		[se.HR, k.HR],
		[se.HTML, k.HTML],
		[se.I, k.I],
		[se.IMG, k.IMG],
		[se.IMAGE, k.IMAGE],
		[se.INPUT, k.INPUT],
		[se.IFRAME, k.IFRAME],
		[se.KEYGEN, k.KEYGEN],
		[se.LABEL, k.LABEL],
		[se.LI, k.LI],
		[se.LINK, k.LINK],
		[se.LISTING, k.LISTING],
		[se.MAIN, k.MAIN],
		[se.MALIGNMARK, k.MALIGNMARK],
		[se.MARQUEE, k.MARQUEE],
		[se.MATH, k.MATH],
		[se.MENU, k.MENU],
		[se.META, k.META],
		[se.MGLYPH, k.MGLYPH],
		[se.MI, k.MI],
		[se.MO, k.MO],
		[se.MN, k.MN],
		[se.MS, k.MS],
		[se.MTEXT, k.MTEXT],
		[se.NAV, k.NAV],
		[se.NOBR, k.NOBR],
		[se.NOFRAMES, k.NOFRAMES],
		[se.NOEMBED, k.NOEMBED],
		[se.NOSCRIPT, k.NOSCRIPT],
		[se.OBJECT, k.OBJECT],
		[se.OL, k.OL],
		[se.OPTGROUP, k.OPTGROUP],
		[se.OPTION, k.OPTION],
		[se.P, k.P],
		[se.PARAM, k.PARAM],
		[se.PLAINTEXT, k.PLAINTEXT],
		[se.PRE, k.PRE],
		[se.RB, k.RB],
		[se.RP, k.RP],
		[se.RT, k.RT],
		[se.RTC, k.RTC],
		[se.RUBY, k.RUBY],
		[se.S, k.S],
		[se.SCRIPT, k.SCRIPT],
		[se.SEARCH, k.SEARCH],
		[se.SECTION, k.SECTION],
		[se.SELECT, k.SELECT],
		[se.SOURCE, k.SOURCE],
		[se.SMALL, k.SMALL],
		[se.SPAN, k.SPAN],
		[se.STRIKE, k.STRIKE],
		[se.STRONG, k.STRONG],
		[se.STYLE, k.STYLE],
		[se.SUB, k.SUB],
		[se.SUMMARY, k.SUMMARY],
		[se.SUP, k.SUP],
		[se.TABLE, k.TABLE],
		[se.TBODY, k.TBODY],
		[se.TEMPLATE, k.TEMPLATE],
		[se.TEXTAREA, k.TEXTAREA],
		[se.TFOOT, k.TFOOT],
		[se.TD, k.TD],
		[se.TH, k.TH],
		[se.THEAD, k.THEAD],
		[se.TITLE, k.TITLE],
		[se.TR, k.TR],
		[se.TRACK, k.TRACK],
		[se.TT, k.TT],
		[se.U, k.U],
		[se.UL, k.UL],
		[se.SVG, k.SVG],
		[se.VAR, k.VAR],
		[se.WBR, k.WBR],
		[se.XMP, k.XMP],
	])
	function ah(e) {
		var t
		return (t = jft.get(e)) !== null && t !== void 0 ? t : k.UNKNOWN
	}
	const _e = k,
		Fft = {
			[we.HTML]: new Set([
				_e.ADDRESS,
				_e.APPLET,
				_e.AREA,
				_e.ARTICLE,
				_e.ASIDE,
				_e.BASE,
				_e.BASEFONT,
				_e.BGSOUND,
				_e.BLOCKQUOTE,
				_e.BODY,
				_e.BR,
				_e.BUTTON,
				_e.CAPTION,
				_e.CENTER,
				_e.COL,
				_e.COLGROUP,
				_e.DD,
				_e.DETAILS,
				_e.DIR,
				_e.DIV,
				_e.DL,
				_e.DT,
				_e.EMBED,
				_e.FIELDSET,
				_e.FIGCAPTION,
				_e.FIGURE,
				_e.FOOTER,
				_e.FORM,
				_e.FRAME,
				_e.FRAMESET,
				_e.H1,
				_e.H2,
				_e.H3,
				_e.H4,
				_e.H5,
				_e.H6,
				_e.HEAD,
				_e.HEADER,
				_e.HGROUP,
				_e.HR,
				_e.HTML,
				_e.IFRAME,
				_e.IMG,
				_e.INPUT,
				_e.LI,
				_e.LINK,
				_e.LISTING,
				_e.MAIN,
				_e.MARQUEE,
				_e.MENU,
				_e.META,
				_e.NAV,
				_e.NOEMBED,
				_e.NOFRAMES,
				_e.NOSCRIPT,
				_e.OBJECT,
				_e.OL,
				_e.P,
				_e.PARAM,
				_e.PLAINTEXT,
				_e.PRE,
				_e.SCRIPT,
				_e.SECTION,
				_e.SELECT,
				_e.SOURCE,
				_e.STYLE,
				_e.SUMMARY,
				_e.TABLE,
				_e.TBODY,
				_e.TD,
				_e.TEMPLATE,
				_e.TEXTAREA,
				_e.TFOOT,
				_e.TH,
				_e.THEAD,
				_e.TITLE,
				_e.TR,
				_e.TRACK,
				_e.UL,
				_e.WBR,
				_e.XMP,
			]),
			[we.MATHML]: new Set([_e.MI, _e.MO, _e.MN, _e.MS, _e.MTEXT, _e.ANNOTATION_XML]),
			[we.SVG]: new Set([_e.TITLE, _e.FOREIGN_OBJECT, _e.DESC]),
			[we.XLINK]: new Set(),
			[we.XML]: new Set(),
			[we.XMLNS]: new Set(),
		},
		yD = new Set([_e.H1, _e.H2, _e.H3, _e.H4, _e.H5, _e.H6])
	se.STYLE, se.SCRIPT, se.XMP, se.IFRAME, se.NOEMBED, se.NOFRAMES, se.PLAINTEXT
	var W
	;(function (e) {
		;(e[(e.DATA = 0)] = "DATA"),
			(e[(e.RCDATA = 1)] = "RCDATA"),
			(e[(e.RAWTEXT = 2)] = "RAWTEXT"),
			(e[(e.SCRIPT_DATA = 3)] = "SCRIPT_DATA"),
			(e[(e.PLAINTEXT = 4)] = "PLAINTEXT"),
			(e[(e.TAG_OPEN = 5)] = "TAG_OPEN"),
			(e[(e.END_TAG_OPEN = 6)] = "END_TAG_OPEN"),
			(e[(e.TAG_NAME = 7)] = "TAG_NAME"),
			(e[(e.RCDATA_LESS_THAN_SIGN = 8)] = "RCDATA_LESS_THAN_SIGN"),
			(e[(e.RCDATA_END_TAG_OPEN = 9)] = "RCDATA_END_TAG_OPEN"),
			(e[(e.RCDATA_END_TAG_NAME = 10)] = "RCDATA_END_TAG_NAME"),
			(e[(e.RAWTEXT_LESS_THAN_SIGN = 11)] = "RAWTEXT_LESS_THAN_SIGN"),
			(e[(e.RAWTEXT_END_TAG_OPEN = 12)] = "RAWTEXT_END_TAG_OPEN"),
			(e[(e.RAWTEXT_END_TAG_NAME = 13)] = "RAWTEXT_END_TAG_NAME"),
			(e[(e.SCRIPT_DATA_LESS_THAN_SIGN = 14)] = "SCRIPT_DATA_LESS_THAN_SIGN"),
			(e[(e.SCRIPT_DATA_END_TAG_OPEN = 15)] = "SCRIPT_DATA_END_TAG_OPEN"),
			(e[(e.SCRIPT_DATA_END_TAG_NAME = 16)] = "SCRIPT_DATA_END_TAG_NAME"),
			(e[(e.SCRIPT_DATA_ESCAPE_START = 17)] = "SCRIPT_DATA_ESCAPE_START"),
			(e[(e.SCRIPT_DATA_ESCAPE_START_DASH = 18)] = "SCRIPT_DATA_ESCAPE_START_DASH"),
			(e[(e.SCRIPT_DATA_ESCAPED = 19)] = "SCRIPT_DATA_ESCAPED"),
			(e[(e.SCRIPT_DATA_ESCAPED_DASH = 20)] = "SCRIPT_DATA_ESCAPED_DASH"),
			(e[(e.SCRIPT_DATA_ESCAPED_DASH_DASH = 21)] = "SCRIPT_DATA_ESCAPED_DASH_DASH"),
			(e[(e.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN = 22)] = "SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN"),
			(e[(e.SCRIPT_DATA_ESCAPED_END_TAG_OPEN = 23)] = "SCRIPT_DATA_ESCAPED_END_TAG_OPEN"),
			(e[(e.SCRIPT_DATA_ESCAPED_END_TAG_NAME = 24)] = "SCRIPT_DATA_ESCAPED_END_TAG_NAME"),
			(e[(e.SCRIPT_DATA_DOUBLE_ESCAPE_START = 25)] = "SCRIPT_DATA_DOUBLE_ESCAPE_START"),
			(e[(e.SCRIPT_DATA_DOUBLE_ESCAPED = 26)] = "SCRIPT_DATA_DOUBLE_ESCAPED"),
			(e[(e.SCRIPT_DATA_DOUBLE_ESCAPED_DASH = 27)] = "SCRIPT_DATA_DOUBLE_ESCAPED_DASH"),
			(e[(e.SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH = 28)] = "SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH"),
			(e[(e.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN = 29)] =
				"SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN"),
			(e[(e.SCRIPT_DATA_DOUBLE_ESCAPE_END = 30)] = "SCRIPT_DATA_DOUBLE_ESCAPE_END"),
			(e[(e.BEFORE_ATTRIBUTE_NAME = 31)] = "BEFORE_ATTRIBUTE_NAME"),
			(e[(e.ATTRIBUTE_NAME = 32)] = "ATTRIBUTE_NAME"),
			(e[(e.AFTER_ATTRIBUTE_NAME = 33)] = "AFTER_ATTRIBUTE_NAME"),
			(e[(e.BEFORE_ATTRIBUTE_VALUE = 34)] = "BEFORE_ATTRIBUTE_VALUE"),
			(e[(e.ATTRIBUTE_VALUE_DOUBLE_QUOTED = 35)] = "ATTRIBUTE_VALUE_DOUBLE_QUOTED"),
			(e[(e.ATTRIBUTE_VALUE_SINGLE_QUOTED = 36)] = "ATTRIBUTE_VALUE_SINGLE_QUOTED"),
			(e[(e.ATTRIBUTE_VALUE_UNQUOTED = 37)] = "ATTRIBUTE_VALUE_UNQUOTED"),
			(e[(e.AFTER_ATTRIBUTE_VALUE_QUOTED = 38)] = "AFTER_ATTRIBUTE_VALUE_QUOTED"),
			(e[(e.SELF_CLOSING_START_TAG = 39)] = "SELF_CLOSING_START_TAG"),
			(e[(e.BOGUS_COMMENT = 40)] = "BOGUS_COMMENT"),
			(e[(e.MARKUP_DECLARATION_OPEN = 41)] = "MARKUP_DECLARATION_OPEN"),
			(e[(e.COMMENT_START = 42)] = "COMMENT_START"),
			(e[(e.COMMENT_START_DASH = 43)] = "COMMENT_START_DASH"),
			(e[(e.COMMENT = 44)] = "COMMENT"),
			(e[(e.COMMENT_LESS_THAN_SIGN = 45)] = "COMMENT_LESS_THAN_SIGN"),
			(e[(e.COMMENT_LESS_THAN_SIGN_BANG = 46)] = "COMMENT_LESS_THAN_SIGN_BANG"),
			(e[(e.COMMENT_LESS_THAN_SIGN_BANG_DASH = 47)] = "COMMENT_LESS_THAN_SIGN_BANG_DASH"),
			(e[(e.COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH = 48)] = "COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH"),
			(e[(e.COMMENT_END_DASH = 49)] = "COMMENT_END_DASH"),
			(e[(e.COMMENT_END = 50)] = "COMMENT_END"),
			(e[(e.COMMENT_END_BANG = 51)] = "COMMENT_END_BANG"),
			(e[(e.DOCTYPE = 52)] = "DOCTYPE"),
			(e[(e.BEFORE_DOCTYPE_NAME = 53)] = "BEFORE_DOCTYPE_NAME"),
			(e[(e.DOCTYPE_NAME = 54)] = "DOCTYPE_NAME"),
			(e[(e.AFTER_DOCTYPE_NAME = 55)] = "AFTER_DOCTYPE_NAME"),
			(e[(e.AFTER_DOCTYPE_PUBLIC_KEYWORD = 56)] = "AFTER_DOCTYPE_PUBLIC_KEYWORD"),
			(e[(e.BEFORE_DOCTYPE_PUBLIC_IDENTIFIER = 57)] = "BEFORE_DOCTYPE_PUBLIC_IDENTIFIER"),
			(e[(e.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED = 58)] =
				"DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED"),
			(e[(e.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED = 59)] =
				"DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED"),
			(e[(e.AFTER_DOCTYPE_PUBLIC_IDENTIFIER = 60)] = "AFTER_DOCTYPE_PUBLIC_IDENTIFIER"),
			(e[(e.BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS = 61)] =
				"BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS"),
			(e[(e.AFTER_DOCTYPE_SYSTEM_KEYWORD = 62)] = "AFTER_DOCTYPE_SYSTEM_KEYWORD"),
			(e[(e.BEFORE_DOCTYPE_SYSTEM_IDENTIFIER = 63)] = "BEFORE_DOCTYPE_SYSTEM_IDENTIFIER"),
			(e[(e.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED = 64)] =
				"DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED"),
			(e[(e.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED = 65)] =
				"DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED"),
			(e[(e.AFTER_DOCTYPE_SYSTEM_IDENTIFIER = 66)] = "AFTER_DOCTYPE_SYSTEM_IDENTIFIER"),
			(e[(e.BOGUS_DOCTYPE = 67)] = "BOGUS_DOCTYPE"),
			(e[(e.CDATA_SECTION = 68)] = "CDATA_SECTION"),
			(e[(e.CDATA_SECTION_BRACKET = 69)] = "CDATA_SECTION_BRACKET"),
			(e[(e.CDATA_SECTION_END = 70)] = "CDATA_SECTION_END"),
			(e[(e.CHARACTER_REFERENCE = 71)] = "CHARACTER_REFERENCE"),
			(e[(e.AMBIGUOUS_AMPERSAND = 72)] = "AMBIGUOUS_AMPERSAND")
	})(W || (W = {}))
	const Jn = {
		DATA: W.DATA,
		RCDATA: W.RCDATA,
		RAWTEXT: W.RAWTEXT,
		SCRIPT_DATA: W.SCRIPT_DATA,
		PLAINTEXT: W.PLAINTEXT,
		CDATA_SECTION: W.CDATA_SECTION,
	}
	function Bft(e) {
		return e >= U.DIGIT_0 && e <= U.DIGIT_9
	}
	function km(e) {
		return e >= U.LATIN_CAPITAL_A && e <= U.LATIN_CAPITAL_Z
	}
	function Hft(e) {
		return e >= U.LATIN_SMALL_A && e <= U.LATIN_SMALL_Z
	}
	function du(e) {
		return Hft(e) || km(e)
	}
	function eF(e) {
		return du(e) || Bft(e)
	}
	function yy(e) {
		return e + 32
	}
	function FV(e) {
		return e === U.SPACE || e === U.LINE_FEED || e === U.TABULATION || e === U.FORM_FEED
	}
	function tF(e) {
		return FV(e) || e === U.SOLIDUS || e === U.GREATER_THAN_SIGN
	}
	function $ft(e) {
		return e === U.NULL
			? ve.nullCharacterReference
			: e > 1114111
			? ve.characterReferenceOutsideUnicodeRange
			: NV(e)
			? ve.surrogateCharacterReference
			: IV(e)
			? ve.noncharacterCharacterReference
			: MV(e) || e === U.CARRIAGE_RETURN
			? ve.controlCharacterReference
			: null
	}
	class Uft {
		constructor(t, n) {
			;(this.options = t),
				(this.handler = n),
				(this.paused = !1),
				(this.inLoop = !1),
				(this.inForeignNode = !1),
				(this.lastStartTagName = ""),
				(this.active = !1),
				(this.state = W.DATA),
				(this.returnState = W.DATA),
				(this.entityStartPos = 0),
				(this.consumedAfterSnapshot = -1),
				(this.currentCharacterToken = null),
				(this.currentToken = null),
				(this.currentAttr = { name: "", value: "" }),
				(this.preprocessor = new Dft(n)),
				(this.currentLocation = this.getCurrentLocation(-1)),
				(this.entityDecoder = new PV(
					LV,
					(r, i) => {
						;(this.preprocessor.pos = this.entityStartPos + i - 1),
							this._flushCodePointConsumedAsCharacterReference(r)
					},
					n.onParseError
						? {
								missingSemicolonAfterCharacterReference: () => {
									this._err(ve.missingSemicolonAfterCharacterReference, 1)
								},
								absenceOfDigitsInNumericCharacterReference: (r) => {
									this._err(
										ve.absenceOfDigitsInNumericCharacterReference,
										this.entityStartPos - this.preprocessor.pos + r,
									)
								},
								validateNumericCharacterReference: (r) => {
									const i = $ft(r)
									i && this._err(i, 1)
								},
						  }
						: void 0,
				))
		}
		_err(t, n = 0) {
			var r, i
			;(i = (r = this.handler).onParseError) === null ||
				i === void 0 ||
				i.call(r, this.preprocessor.getError(t, n))
		}
		getCurrentLocation(t) {
			return this.options.sourceCodeLocationInfo
				? {
						startLine: this.preprocessor.line,
						startCol: this.preprocessor.col - t,
						startOffset: this.preprocessor.offset - t,
						endLine: -1,
						endCol: -1,
						endOffset: -1,
				  }
				: null
		}
		_runParsingLoop() {
			if (!this.inLoop) {
				for (this.inLoop = !0; this.active && !this.paused; ) {
					this.consumedAfterSnapshot = 0
					const t = this._consume()
					this._ensureHibernation() || this._callState(t)
				}
				this.inLoop = !1
			}
		}
		pause() {
			this.paused = !0
		}
		resume(t) {
			if (!this.paused) throw new Error("Parser was already resumed")
			;(this.paused = !1), !this.inLoop && (this._runParsingLoop(), this.paused || t == null || t())
		}
		write(t, n, r) {
			;(this.active = !0),
				this.preprocessor.write(t, n),
				this._runParsingLoop(),
				this.paused || r == null || r()
		}
		insertHtmlAtCurrentPos(t) {
			;(this.active = !0), this.preprocessor.insertHtmlAtCurrentPos(t), this._runParsingLoop()
		}
		_ensureHibernation() {
			return this.preprocessor.endOfChunkHit
				? (this.preprocessor.retreat(this.consumedAfterSnapshot),
				  (this.consumedAfterSnapshot = 0),
				  (this.active = !1),
				  !0)
				: !1
		}
		_consume() {
			return this.consumedAfterSnapshot++, this.preprocessor.advance()
		}
		_advanceBy(t) {
			this.consumedAfterSnapshot += t
			for (let n = 0; n < t; n++) this.preprocessor.advance()
		}
		_consumeSequenceIfMatch(t, n) {
			return this.preprocessor.startsWith(t, n) ? (this._advanceBy(t.length - 1), !0) : !1
		}
		_createStartTagToken() {
			this.currentToken = {
				type: Ct.START_TAG,
				tagName: "",
				tagID: k.UNKNOWN,
				selfClosing: !1,
				ackSelfClosing: !1,
				attrs: [],
				location: this.getCurrentLocation(1),
			}
		}
		_createEndTagToken() {
			this.currentToken = {
				type: Ct.END_TAG,
				tagName: "",
				tagID: k.UNKNOWN,
				selfClosing: !1,
				ackSelfClosing: !1,
				attrs: [],
				location: this.getCurrentLocation(2),
			}
		}
		_createCommentToken(t) {
			this.currentToken = { type: Ct.COMMENT, data: "", location: this.getCurrentLocation(t) }
		}
		_createDoctypeToken(t) {
			this.currentToken = {
				type: Ct.DOCTYPE,
				name: t,
				forceQuirks: !1,
				publicId: null,
				systemId: null,
				location: this.currentLocation,
			}
		}
		_createCharacterToken(t, n) {
			this.currentCharacterToken = { type: t, chars: n, location: this.currentLocation }
		}
		_createAttr(t) {
			;(this.currentAttr = { name: t, value: "" }),
				(this.currentLocation = this.getCurrentLocation(0))
		}
		_leaveAttrName() {
			var t, n
			const r = this.currentToken
			if (RV(r, this.currentAttr.name) === null) {
				if ((r.attrs.push(this.currentAttr), r.location && this.currentLocation)) {
					const i =
						(t = (n = r.location).attrs) !== null && t !== void 0
							? t
							: (n.attrs = Object.create(null))
					;(i[this.currentAttr.name] = this.currentLocation), this._leaveAttrValue()
				}
			} else this._err(ve.duplicateAttribute)
		}
		_leaveAttrValue() {
			this.currentLocation &&
				((this.currentLocation.endLine = this.preprocessor.line),
				(this.currentLocation.endCol = this.preprocessor.col),
				(this.currentLocation.endOffset = this.preprocessor.offset))
		}
		prepareToken(t) {
			this._emitCurrentCharacterToken(t.location),
				(this.currentToken = null),
				t.location &&
					((t.location.endLine = this.preprocessor.line),
					(t.location.endCol = this.preprocessor.col + 1),
					(t.location.endOffset = this.preprocessor.offset + 1)),
				(this.currentLocation = this.getCurrentLocation(-1))
		}
		emitCurrentTagToken() {
			const t = this.currentToken
			this.prepareToken(t),
				(t.tagID = ah(t.tagName)),
				t.type === Ct.START_TAG
					? ((this.lastStartTagName = t.tagName), this.handler.onStartTag(t))
					: (t.attrs.length > 0 && this._err(ve.endTagWithAttributes),
					  t.selfClosing && this._err(ve.endTagWithTrailingSolidus),
					  this.handler.onEndTag(t)),
				this.preprocessor.dropParsedChunk()
		}
		emitCurrentComment(t) {
			this.prepareToken(t), this.handler.onComment(t), this.preprocessor.dropParsedChunk()
		}
		emitCurrentDoctype(t) {
			this.prepareToken(t), this.handler.onDoctype(t), this.preprocessor.dropParsedChunk()
		}
		_emitCurrentCharacterToken(t) {
			if (this.currentCharacterToken) {
				switch (
					(t &&
						this.currentCharacterToken.location &&
						((this.currentCharacterToken.location.endLine = t.startLine),
						(this.currentCharacterToken.location.endCol = t.startCol),
						(this.currentCharacterToken.location.endOffset = t.startOffset)),
					this.currentCharacterToken.type)
				) {
					case Ct.CHARACTER: {
						this.handler.onCharacter(this.currentCharacterToken)
						break
					}
					case Ct.NULL_CHARACTER: {
						this.handler.onNullCharacter(this.currentCharacterToken)
						break
					}
					case Ct.WHITESPACE_CHARACTER: {
						this.handler.onWhitespaceCharacter(this.currentCharacterToken)
						break
					}
				}
				this.currentCharacterToken = null
			}
		}
		_emitEOFToken() {
			const t = this.getCurrentLocation(0)
			t && ((t.endLine = t.startLine), (t.endCol = t.startCol), (t.endOffset = t.startOffset)),
				this._emitCurrentCharacterToken(t),
				this.handler.onEof({ type: Ct.EOF, location: t }),
				(this.active = !1)
		}
		_appendCharToCurrentCharacterToken(t, n) {
			if (this.currentCharacterToken)
				if (this.currentCharacterToken.type === t) {
					this.currentCharacterToken.chars += n
					return
				} else
					(this.currentLocation = this.getCurrentLocation(0)),
						this._emitCurrentCharacterToken(this.currentLocation),
						this.preprocessor.dropParsedChunk()
			this._createCharacterToken(t, n)
		}
		_emitCodePoint(t) {
			const n = FV(t) ? Ct.WHITESPACE_CHARACTER : t === U.NULL ? Ct.NULL_CHARACTER : Ct.CHARACTER
			this._appendCharToCurrentCharacterToken(n, String.fromCodePoint(t))
		}
		_emitChars(t) {
			this._appendCharToCurrentCharacterToken(Ct.CHARACTER, t)
		}
		_startCharacterReference() {
			;(this.returnState = this.state),
				(this.state = W.CHARACTER_REFERENCE),
				(this.entityStartPos = this.preprocessor.pos),
				this.entityDecoder.startEntity(
					this._isCharacterReferenceInAttribute() ? tl.Attribute : tl.Legacy,
				)
		}
		_isCharacterReferenceInAttribute() {
			return (
				this.returnState === W.ATTRIBUTE_VALUE_DOUBLE_QUOTED ||
				this.returnState === W.ATTRIBUTE_VALUE_SINGLE_QUOTED ||
				this.returnState === W.ATTRIBUTE_VALUE_UNQUOTED
			)
		}
		_flushCodePointConsumedAsCharacterReference(t) {
			this._isCharacterReferenceInAttribute()
				? (this.currentAttr.value += String.fromCodePoint(t))
				: this._emitCodePoint(t)
		}
		_callState(t) {
			switch (this.state) {
				case W.DATA: {
					this._stateData(t)
					break
				}
				case W.RCDATA: {
					this._stateRcdata(t)
					break
				}
				case W.RAWTEXT: {
					this._stateRawtext(t)
					break
				}
				case W.SCRIPT_DATA: {
					this._stateScriptData(t)
					break
				}
				case W.PLAINTEXT: {
					this._statePlaintext(t)
					break
				}
				case W.TAG_OPEN: {
					this._stateTagOpen(t)
					break
				}
				case W.END_TAG_OPEN: {
					this._stateEndTagOpen(t)
					break
				}
				case W.TAG_NAME: {
					this._stateTagName(t)
					break
				}
				case W.RCDATA_LESS_THAN_SIGN: {
					this._stateRcdataLessThanSign(t)
					break
				}
				case W.RCDATA_END_TAG_OPEN: {
					this._stateRcdataEndTagOpen(t)
					break
				}
				case W.RCDATA_END_TAG_NAME: {
					this._stateRcdataEndTagName(t)
					break
				}
				case W.RAWTEXT_LESS_THAN_SIGN: {
					this._stateRawtextLessThanSign(t)
					break
				}
				case W.RAWTEXT_END_TAG_OPEN: {
					this._stateRawtextEndTagOpen(t)
					break
				}
				case W.RAWTEXT_END_TAG_NAME: {
					this._stateRawtextEndTagName(t)
					break
				}
				case W.SCRIPT_DATA_LESS_THAN_SIGN: {
					this._stateScriptDataLessThanSign(t)
					break
				}
				case W.SCRIPT_DATA_END_TAG_OPEN: {
					this._stateScriptDataEndTagOpen(t)
					break
				}
				case W.SCRIPT_DATA_END_TAG_NAME: {
					this._stateScriptDataEndTagName(t)
					break
				}
				case W.SCRIPT_DATA_ESCAPE_START: {
					this._stateScriptDataEscapeStart(t)
					break
				}
				case W.SCRIPT_DATA_ESCAPE_START_DASH: {
					this._stateScriptDataEscapeStartDash(t)
					break
				}
				case W.SCRIPT_DATA_ESCAPED: {
					this._stateScriptDataEscaped(t)
					break
				}
				case W.SCRIPT_DATA_ESCAPED_DASH: {
					this._stateScriptDataEscapedDash(t)
					break
				}
				case W.SCRIPT_DATA_ESCAPED_DASH_DASH: {
					this._stateScriptDataEscapedDashDash(t)
					break
				}
				case W.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN: {
					this._stateScriptDataEscapedLessThanSign(t)
					break
				}
				case W.SCRIPT_DATA_ESCAPED_END_TAG_OPEN: {
					this._stateScriptDataEscapedEndTagOpen(t)
					break
				}
				case W.SCRIPT_DATA_ESCAPED_END_TAG_NAME: {
					this._stateScriptDataEscapedEndTagName(t)
					break
				}
				case W.SCRIPT_DATA_DOUBLE_ESCAPE_START: {
					this._stateScriptDataDoubleEscapeStart(t)
					break
				}
				case W.SCRIPT_DATA_DOUBLE_ESCAPED: {
					this._stateScriptDataDoubleEscaped(t)
					break
				}
				case W.SCRIPT_DATA_DOUBLE_ESCAPED_DASH: {
					this._stateScriptDataDoubleEscapedDash(t)
					break
				}
				case W.SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH: {
					this._stateScriptDataDoubleEscapedDashDash(t)
					break
				}
				case W.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN: {
					this._stateScriptDataDoubleEscapedLessThanSign(t)
					break
				}
				case W.SCRIPT_DATA_DOUBLE_ESCAPE_END: {
					this._stateScriptDataDoubleEscapeEnd(t)
					break
				}
				case W.BEFORE_ATTRIBUTE_NAME: {
					this._stateBeforeAttributeName(t)
					break
				}
				case W.ATTRIBUTE_NAME: {
					this._stateAttributeName(t)
					break
				}
				case W.AFTER_ATTRIBUTE_NAME: {
					this._stateAfterAttributeName(t)
					break
				}
				case W.BEFORE_ATTRIBUTE_VALUE: {
					this._stateBeforeAttributeValue(t)
					break
				}
				case W.ATTRIBUTE_VALUE_DOUBLE_QUOTED: {
					this._stateAttributeValueDoubleQuoted(t)
					break
				}
				case W.ATTRIBUTE_VALUE_SINGLE_QUOTED: {
					this._stateAttributeValueSingleQuoted(t)
					break
				}
				case W.ATTRIBUTE_VALUE_UNQUOTED: {
					this._stateAttributeValueUnquoted(t)
					break
				}
				case W.AFTER_ATTRIBUTE_VALUE_QUOTED: {
					this._stateAfterAttributeValueQuoted(t)
					break
				}
				case W.SELF_CLOSING_START_TAG: {
					this._stateSelfClosingStartTag(t)
					break
				}
				case W.BOGUS_COMMENT: {
					this._stateBogusComment(t)
					break
				}
				case W.MARKUP_DECLARATION_OPEN: {
					this._stateMarkupDeclarationOpen(t)
					break
				}
				case W.COMMENT_START: {
					this._stateCommentStart(t)
					break
				}
				case W.COMMENT_START_DASH: {
					this._stateCommentStartDash(t)
					break
				}
				case W.COMMENT: {
					this._stateComment(t)
					break
				}
				case W.COMMENT_LESS_THAN_SIGN: {
					this._stateCommentLessThanSign(t)
					break
				}
				case W.COMMENT_LESS_THAN_SIGN_BANG: {
					this._stateCommentLessThanSignBang(t)
					break
				}
				case W.COMMENT_LESS_THAN_SIGN_BANG_DASH: {
					this._stateCommentLessThanSignBangDash(t)
					break
				}
				case W.COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH: {
					this._stateCommentLessThanSignBangDashDash(t)
					break
				}
				case W.COMMENT_END_DASH: {
					this._stateCommentEndDash(t)
					break
				}
				case W.COMMENT_END: {
					this._stateCommentEnd(t)
					break
				}
				case W.COMMENT_END_BANG: {
					this._stateCommentEndBang(t)
					break
				}
				case W.DOCTYPE: {
					this._stateDoctype(t)
					break
				}
				case W.BEFORE_DOCTYPE_NAME: {
					this._stateBeforeDoctypeName(t)
					break
				}
				case W.DOCTYPE_NAME: {
					this._stateDoctypeName(t)
					break
				}
				case W.AFTER_DOCTYPE_NAME: {
					this._stateAfterDoctypeName(t)
					break
				}
				case W.AFTER_DOCTYPE_PUBLIC_KEYWORD: {
					this._stateAfterDoctypePublicKeyword(t)
					break
				}
				case W.BEFORE_DOCTYPE_PUBLIC_IDENTIFIER: {
					this._stateBeforeDoctypePublicIdentifier(t)
					break
				}
				case W.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED: {
					this._stateDoctypePublicIdentifierDoubleQuoted(t)
					break
				}
				case W.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED: {
					this._stateDoctypePublicIdentifierSingleQuoted(t)
					break
				}
				case W.AFTER_DOCTYPE_PUBLIC_IDENTIFIER: {
					this._stateAfterDoctypePublicIdentifier(t)
					break
				}
				case W.BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS: {
					this._stateBetweenDoctypePublicAndSystemIdentifiers(t)
					break
				}
				case W.AFTER_DOCTYPE_SYSTEM_KEYWORD: {
					this._stateAfterDoctypeSystemKeyword(t)
					break
				}
				case W.BEFORE_DOCTYPE_SYSTEM_IDENTIFIER: {
					this._stateBeforeDoctypeSystemIdentifier(t)
					break
				}
				case W.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED: {
					this._stateDoctypeSystemIdentifierDoubleQuoted(t)
					break
				}
				case W.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED: {
					this._stateDoctypeSystemIdentifierSingleQuoted(t)
					break
				}
				case W.AFTER_DOCTYPE_SYSTEM_IDENTIFIER: {
					this._stateAfterDoctypeSystemIdentifier(t)
					break
				}
				case W.BOGUS_DOCTYPE: {
					this._stateBogusDoctype(t)
					break
				}
				case W.CDATA_SECTION: {
					this._stateCdataSection(t)
					break
				}
				case W.CDATA_SECTION_BRACKET: {
					this._stateCdataSectionBracket(t)
					break
				}
				case W.CDATA_SECTION_END: {
					this._stateCdataSectionEnd(t)
					break
				}
				case W.CHARACTER_REFERENCE: {
					this._stateCharacterReference()
					break
				}
				case W.AMBIGUOUS_AMPERSAND: {
					this._stateAmbiguousAmpersand(t)
					break
				}
				default:
					throw new Error("Unknown state")
			}
		}
		_stateData(t) {
			switch (t) {
				case U.LESS_THAN_SIGN: {
					this.state = W.TAG_OPEN
					break
				}
				case U.AMPERSAND: {
					this._startCharacterReference()
					break
				}
				case U.NULL: {
					this._err(ve.unexpectedNullCharacter), this._emitCodePoint(t)
					break
				}
				case U.EOF: {
					this._emitEOFToken()
					break
				}
				default:
					this._emitCodePoint(t)
			}
		}
		_stateRcdata(t) {
			switch (t) {
				case U.AMPERSAND: {
					this._startCharacterReference()
					break
				}
				case U.LESS_THAN_SIGN: {
					this.state = W.RCDATA_LESS_THAN_SIGN
					break
				}
				case U.NULL: {
					this._err(ve.unexpectedNullCharacter), this._emitChars(Sn)
					break
				}
				case U.EOF: {
					this._emitEOFToken()
					break
				}
				default:
					this._emitCodePoint(t)
			}
		}
		_stateRawtext(t) {
			switch (t) {
				case U.LESS_THAN_SIGN: {
					this.state = W.RAWTEXT_LESS_THAN_SIGN
					break
				}
				case U.NULL: {
					this._err(ve.unexpectedNullCharacter), this._emitChars(Sn)
					break
				}
				case U.EOF: {
					this._emitEOFToken()
					break
				}
				default:
					this._emitCodePoint(t)
			}
		}
		_stateScriptData(t) {
			switch (t) {
				case U.LESS_THAN_SIGN: {
					this.state = W.SCRIPT_DATA_LESS_THAN_SIGN
					break
				}
				case U.NULL: {
					this._err(ve.unexpectedNullCharacter), this._emitChars(Sn)
					break
				}
				case U.EOF: {
					this._emitEOFToken()
					break
				}
				default:
					this._emitCodePoint(t)
			}
		}
		_statePlaintext(t) {
			switch (t) {
				case U.NULL: {
					this._err(ve.unexpectedNullCharacter), this._emitChars(Sn)
					break
				}
				case U.EOF: {
					this._emitEOFToken()
					break
				}
				default:
					this._emitCodePoint(t)
			}
		}
		_stateTagOpen(t) {
			if (du(t)) this._createStartTagToken(), (this.state = W.TAG_NAME), this._stateTagName(t)
			else
				switch (t) {
					case U.EXCLAMATION_MARK: {
						this.state = W.MARKUP_DECLARATION_OPEN
						break
					}
					case U.SOLIDUS: {
						this.state = W.END_TAG_OPEN
						break
					}
					case U.QUESTION_MARK: {
						this._err(ve.unexpectedQuestionMarkInsteadOfTagName),
							this._createCommentToken(1),
							(this.state = W.BOGUS_COMMENT),
							this._stateBogusComment(t)
						break
					}
					case U.EOF: {
						this._err(ve.eofBeforeTagName), this._emitChars("<"), this._emitEOFToken()
						break
					}
					default:
						this._err(ve.invalidFirstCharacterOfTagName),
							this._emitChars("<"),
							(this.state = W.DATA),
							this._stateData(t)
				}
		}
		_stateEndTagOpen(t) {
			if (du(t)) this._createEndTagToken(), (this.state = W.TAG_NAME), this._stateTagName(t)
			else
				switch (t) {
					case U.GREATER_THAN_SIGN: {
						this._err(ve.missingEndTagName), (this.state = W.DATA)
						break
					}
					case U.EOF: {
						this._err(ve.eofBeforeTagName), this._emitChars("</"), this._emitEOFToken()
						break
					}
					default:
						this._err(ve.invalidFirstCharacterOfTagName),
							this._createCommentToken(2),
							(this.state = W.BOGUS_COMMENT),
							this._stateBogusComment(t)
				}
		}
		_stateTagName(t) {
			const n = this.currentToken
			switch (t) {
				case U.SPACE:
				case U.LINE_FEED:
				case U.TABULATION:
				case U.FORM_FEED: {
					this.state = W.BEFORE_ATTRIBUTE_NAME
					break
				}
				case U.SOLIDUS: {
					this.state = W.SELF_CLOSING_START_TAG
					break
				}
				case U.GREATER_THAN_SIGN: {
					;(this.state = W.DATA), this.emitCurrentTagToken()
					break
				}
				case U.NULL: {
					this._err(ve.unexpectedNullCharacter), (n.tagName += Sn)
					break
				}
				case U.EOF: {
					this._err(ve.eofInTag), this._emitEOFToken()
					break
				}
				default:
					n.tagName += String.fromCodePoint(km(t) ? yy(t) : t)
			}
		}
		_stateRcdataLessThanSign(t) {
			t === U.SOLIDUS
				? (this.state = W.RCDATA_END_TAG_OPEN)
				: (this._emitChars("<"), (this.state = W.RCDATA), this._stateRcdata(t))
		}
		_stateRcdataEndTagOpen(t) {
			du(t)
				? ((this.state = W.RCDATA_END_TAG_NAME), this._stateRcdataEndTagName(t))
				: (this._emitChars("</"), (this.state = W.RCDATA), this._stateRcdata(t))
		}
		handleSpecialEndTag(t) {
			if (!this.preprocessor.startsWith(this.lastStartTagName, !1))
				return !this._ensureHibernation()
			this._createEndTagToken()
			const n = this.currentToken
			switch (
				((n.tagName = this.lastStartTagName), this.preprocessor.peek(this.lastStartTagName.length))
			) {
				case U.SPACE:
				case U.LINE_FEED:
				case U.TABULATION:
				case U.FORM_FEED:
					return (
						this._advanceBy(this.lastStartTagName.length),
						(this.state = W.BEFORE_ATTRIBUTE_NAME),
						!1
					)
				case U.SOLIDUS:
					return (
						this._advanceBy(this.lastStartTagName.length),
						(this.state = W.SELF_CLOSING_START_TAG),
						!1
					)
				case U.GREATER_THAN_SIGN:
					return (
						this._advanceBy(this.lastStartTagName.length),
						this.emitCurrentTagToken(),
						(this.state = W.DATA),
						!1
					)
				default:
					return !this._ensureHibernation()
			}
		}
		_stateRcdataEndTagName(t) {
			this.handleSpecialEndTag(t) &&
				(this._emitChars("</"), (this.state = W.RCDATA), this._stateRcdata(t))
		}
		_stateRawtextLessThanSign(t) {
			t === U.SOLIDUS
				? (this.state = W.RAWTEXT_END_TAG_OPEN)
				: (this._emitChars("<"), (this.state = W.RAWTEXT), this._stateRawtext(t))
		}
		_stateRawtextEndTagOpen(t) {
			du(t)
				? ((this.state = W.RAWTEXT_END_TAG_NAME), this._stateRawtextEndTagName(t))
				: (this._emitChars("</"), (this.state = W.RAWTEXT), this._stateRawtext(t))
		}
		_stateRawtextEndTagName(t) {
			this.handleSpecialEndTag(t) &&
				(this._emitChars("</"), (this.state = W.RAWTEXT), this._stateRawtext(t))
		}
		_stateScriptDataLessThanSign(t) {
			switch (t) {
				case U.SOLIDUS: {
					this.state = W.SCRIPT_DATA_END_TAG_OPEN
					break
				}
				case U.EXCLAMATION_MARK: {
					;(this.state = W.SCRIPT_DATA_ESCAPE_START), this._emitChars("<!")
					break
				}
				default:
					this._emitChars("<"), (this.state = W.SCRIPT_DATA), this._stateScriptData(t)
			}
		}
		_stateScriptDataEndTagOpen(t) {
			du(t)
				? ((this.state = W.SCRIPT_DATA_END_TAG_NAME), this._stateScriptDataEndTagName(t))
				: (this._emitChars("</"), (this.state = W.SCRIPT_DATA), this._stateScriptData(t))
		}
		_stateScriptDataEndTagName(t) {
			this.handleSpecialEndTag(t) &&
				(this._emitChars("</"), (this.state = W.SCRIPT_DATA), this._stateScriptData(t))
		}
		_stateScriptDataEscapeStart(t) {
			t === U.HYPHEN_MINUS
				? ((this.state = W.SCRIPT_DATA_ESCAPE_START_DASH), this._emitChars("-"))
				: ((this.state = W.SCRIPT_DATA), this._stateScriptData(t))
		}
		_stateScriptDataEscapeStartDash(t) {
			t === U.HYPHEN_MINUS
				? ((this.state = W.SCRIPT_DATA_ESCAPED_DASH_DASH), this._emitChars("-"))
				: ((this.state = W.SCRIPT_DATA), this._stateScriptData(t))
		}
		_stateScriptDataEscaped(t) {
			switch (t) {
				case U.HYPHEN_MINUS: {
					;(this.state = W.SCRIPT_DATA_ESCAPED_DASH), this._emitChars("-")
					break
				}
				case U.LESS_THAN_SIGN: {
					this.state = W.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN
					break
				}
				case U.NULL: {
					this._err(ve.unexpectedNullCharacter), this._emitChars(Sn)
					break
				}
				case U.EOF: {
					this._err(ve.eofInScriptHtmlCommentLikeText), this._emitEOFToken()
					break
				}
				default:
					this._emitCodePoint(t)
			}
		}
		_stateScriptDataEscapedDash(t) {
			switch (t) {
				case U.HYPHEN_MINUS: {
					;(this.state = W.SCRIPT_DATA_ESCAPED_DASH_DASH), this._emitChars("-")
					break
				}
				case U.LESS_THAN_SIGN: {
					this.state = W.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN
					break
				}
				case U.NULL: {
					this._err(ve.unexpectedNullCharacter),
						(this.state = W.SCRIPT_DATA_ESCAPED),
						this._emitChars(Sn)
					break
				}
				case U.EOF: {
					this._err(ve.eofInScriptHtmlCommentLikeText), this._emitEOFToken()
					break
				}
				default:
					;(this.state = W.SCRIPT_DATA_ESCAPED), this._emitCodePoint(t)
			}
		}
		_stateScriptDataEscapedDashDash(t) {
			switch (t) {
				case U.HYPHEN_MINUS: {
					this._emitChars("-")
					break
				}
				case U.LESS_THAN_SIGN: {
					this.state = W.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN
					break
				}
				case U.GREATER_THAN_SIGN: {
					;(this.state = W.SCRIPT_DATA), this._emitChars(">")
					break
				}
				case U.NULL: {
					this._err(ve.unexpectedNullCharacter),
						(this.state = W.SCRIPT_DATA_ESCAPED),
						this._emitChars(Sn)
					break
				}
				case U.EOF: {
					this._err(ve.eofInScriptHtmlCommentLikeText), this._emitEOFToken()
					break
				}
				default:
					;(this.state = W.SCRIPT_DATA_ESCAPED), this._emitCodePoint(t)
			}
		}
		_stateScriptDataEscapedLessThanSign(t) {
			t === U.SOLIDUS
				? (this.state = W.SCRIPT_DATA_ESCAPED_END_TAG_OPEN)
				: du(t)
				? (this._emitChars("<"),
				  (this.state = W.SCRIPT_DATA_DOUBLE_ESCAPE_START),
				  this._stateScriptDataDoubleEscapeStart(t))
				: (this._emitChars("<"),
				  (this.state = W.SCRIPT_DATA_ESCAPED),
				  this._stateScriptDataEscaped(t))
		}
		_stateScriptDataEscapedEndTagOpen(t) {
			du(t)
				? ((this.state = W.SCRIPT_DATA_ESCAPED_END_TAG_NAME),
				  this._stateScriptDataEscapedEndTagName(t))
				: (this._emitChars("</"),
				  (this.state = W.SCRIPT_DATA_ESCAPED),
				  this._stateScriptDataEscaped(t))
		}
		_stateScriptDataEscapedEndTagName(t) {
			this.handleSpecialEndTag(t) &&
				(this._emitChars("</"),
				(this.state = W.SCRIPT_DATA_ESCAPED),
				this._stateScriptDataEscaped(t))
		}
		_stateScriptDataDoubleEscapeStart(t) {
			if (
				this.preprocessor.startsWith(Mi.SCRIPT, !1) &&
				tF(this.preprocessor.peek(Mi.SCRIPT.length))
			) {
				this._emitCodePoint(t)
				for (let n = 0; n < Mi.SCRIPT.length; n++) this._emitCodePoint(this._consume())
				this.state = W.SCRIPT_DATA_DOUBLE_ESCAPED
			} else
				this._ensureHibernation() ||
					((this.state = W.SCRIPT_DATA_ESCAPED), this._stateScriptDataEscaped(t))
		}
		_stateScriptDataDoubleEscaped(t) {
			switch (t) {
				case U.HYPHEN_MINUS: {
					;(this.state = W.SCRIPT_DATA_DOUBLE_ESCAPED_DASH), this._emitChars("-")
					break
				}
				case U.LESS_THAN_SIGN: {
					;(this.state = W.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN), this._emitChars("<")
					break
				}
				case U.NULL: {
					this._err(ve.unexpectedNullCharacter), this._emitChars(Sn)
					break
				}
				case U.EOF: {
					this._err(ve.eofInScriptHtmlCommentLikeText), this._emitEOFToken()
					break
				}
				default:
					this._emitCodePoint(t)
			}
		}
		_stateScriptDataDoubleEscapedDash(t) {
			switch (t) {
				case U.HYPHEN_MINUS: {
					;(this.state = W.SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH), this._emitChars("-")
					break
				}
				case U.LESS_THAN_SIGN: {
					;(this.state = W.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN), this._emitChars("<")
					break
				}
				case U.NULL: {
					this._err(ve.unexpectedNullCharacter),
						(this.state = W.SCRIPT_DATA_DOUBLE_ESCAPED),
						this._emitChars(Sn)
					break
				}
				case U.EOF: {
					this._err(ve.eofInScriptHtmlCommentLikeText), this._emitEOFToken()
					break
				}
				default:
					;(this.state = W.SCRIPT_DATA_DOUBLE_ESCAPED), this._emitCodePoint(t)
			}
		}
		_stateScriptDataDoubleEscapedDashDash(t) {
			switch (t) {
				case U.HYPHEN_MINUS: {
					this._emitChars("-")
					break
				}
				case U.LESS_THAN_SIGN: {
					;(this.state = W.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN), this._emitChars("<")
					break
				}
				case U.GREATER_THAN_SIGN: {
					;(this.state = W.SCRIPT_DATA), this._emitChars(">")
					break
				}
				case U.NULL: {
					this._err(ve.unexpectedNullCharacter),
						(this.state = W.SCRIPT_DATA_DOUBLE_ESCAPED),
						this._emitChars(Sn)
					break
				}
				case U.EOF: {
					this._err(ve.eofInScriptHtmlCommentLikeText), this._emitEOFToken()
					break
				}
				default:
					;(this.state = W.SCRIPT_DATA_DOUBLE_ESCAPED), this._emitCodePoint(t)
			}
		}
		_stateScriptDataDoubleEscapedLessThanSign(t) {
			t === U.SOLIDUS
				? ((this.state = W.SCRIPT_DATA_DOUBLE_ESCAPE_END), this._emitChars("/"))
				: ((this.state = W.SCRIPT_DATA_DOUBLE_ESCAPED), this._stateScriptDataDoubleEscaped(t))
		}
		_stateScriptDataDoubleEscapeEnd(t) {
			if (
				this.preprocessor.startsWith(Mi.SCRIPT, !1) &&
				tF(this.preprocessor.peek(Mi.SCRIPT.length))
			) {
				this._emitCodePoint(t)
				for (let n = 0; n < Mi.SCRIPT.length; n++) this._emitCodePoint(this._consume())
				this.state = W.SCRIPT_DATA_ESCAPED
			} else
				this._ensureHibernation() ||
					((this.state = W.SCRIPT_DATA_DOUBLE_ESCAPED), this._stateScriptDataDoubleEscaped(t))
		}
		_stateBeforeAttributeName(t) {
			switch (t) {
				case U.SPACE:
				case U.LINE_FEED:
				case U.TABULATION:
				case U.FORM_FEED:
					break
				case U.SOLIDUS:
				case U.GREATER_THAN_SIGN:
				case U.EOF: {
					;(this.state = W.AFTER_ATTRIBUTE_NAME), this._stateAfterAttributeName(t)
					break
				}
				case U.EQUALS_SIGN: {
					this._err(ve.unexpectedEqualsSignBeforeAttributeName),
						this._createAttr("="),
						(this.state = W.ATTRIBUTE_NAME)
					break
				}
				default:
					this._createAttr(""), (this.state = W.ATTRIBUTE_NAME), this._stateAttributeName(t)
			}
		}
		_stateAttributeName(t) {
			switch (t) {
				case U.SPACE:
				case U.LINE_FEED:
				case U.TABULATION:
				case U.FORM_FEED:
				case U.SOLIDUS:
				case U.GREATER_THAN_SIGN:
				case U.EOF: {
					this._leaveAttrName(),
						(this.state = W.AFTER_ATTRIBUTE_NAME),
						this._stateAfterAttributeName(t)
					break
				}
				case U.EQUALS_SIGN: {
					this._leaveAttrName(), (this.state = W.BEFORE_ATTRIBUTE_VALUE)
					break
				}
				case U.QUOTATION_MARK:
				case U.APOSTROPHE:
				case U.LESS_THAN_SIGN: {
					this._err(ve.unexpectedCharacterInAttributeName),
						(this.currentAttr.name += String.fromCodePoint(t))
					break
				}
				case U.NULL: {
					this._err(ve.unexpectedNullCharacter), (this.currentAttr.name += Sn)
					break
				}
				default:
					this.currentAttr.name += String.fromCodePoint(km(t) ? yy(t) : t)
			}
		}
		_stateAfterAttributeName(t) {
			switch (t) {
				case U.SPACE:
				case U.LINE_FEED:
				case U.TABULATION:
				case U.FORM_FEED:
					break
				case U.SOLIDUS: {
					this.state = W.SELF_CLOSING_START_TAG
					break
				}
				case U.EQUALS_SIGN: {
					this.state = W.BEFORE_ATTRIBUTE_VALUE
					break
				}
				case U.GREATER_THAN_SIGN: {
					;(this.state = W.DATA), this.emitCurrentTagToken()
					break
				}
				case U.EOF: {
					this._err(ve.eofInTag), this._emitEOFToken()
					break
				}
				default:
					this._createAttr(""), (this.state = W.ATTRIBUTE_NAME), this._stateAttributeName(t)
			}
		}
		_stateBeforeAttributeValue(t) {
			switch (t) {
				case U.SPACE:
				case U.LINE_FEED:
				case U.TABULATION:
				case U.FORM_FEED:
					break
				case U.QUOTATION_MARK: {
					this.state = W.ATTRIBUTE_VALUE_DOUBLE_QUOTED
					break
				}
				case U.APOSTROPHE: {
					this.state = W.ATTRIBUTE_VALUE_SINGLE_QUOTED
					break
				}
				case U.GREATER_THAN_SIGN: {
					this._err(ve.missingAttributeValue), (this.state = W.DATA), this.emitCurrentTagToken()
					break
				}
				default:
					;(this.state = W.ATTRIBUTE_VALUE_UNQUOTED), this._stateAttributeValueUnquoted(t)
			}
		}
		_stateAttributeValueDoubleQuoted(t) {
			switch (t) {
				case U.QUOTATION_MARK: {
					this.state = W.AFTER_ATTRIBUTE_VALUE_QUOTED
					break
				}
				case U.AMPERSAND: {
					this._startCharacterReference()
					break
				}
				case U.NULL: {
					this._err(ve.unexpectedNullCharacter), (this.currentAttr.value += Sn)
					break
				}
				case U.EOF: {
					this._err(ve.eofInTag), this._emitEOFToken()
					break
				}
				default:
					this.currentAttr.value += String.fromCodePoint(t)
			}
		}
		_stateAttributeValueSingleQuoted(t) {
			switch (t) {
				case U.APOSTROPHE: {
					this.state = W.AFTER_ATTRIBUTE_VALUE_QUOTED
					break
				}
				case U.AMPERSAND: {
					this._startCharacterReference()
					break
				}
				case U.NULL: {
					this._err(ve.unexpectedNullCharacter), (this.currentAttr.value += Sn)
					break
				}
				case U.EOF: {
					this._err(ve.eofInTag), this._emitEOFToken()
					break
				}
				default:
					this.currentAttr.value += String.fromCodePoint(t)
			}
		}
		_stateAttributeValueUnquoted(t) {
			switch (t) {
				case U.SPACE:
				case U.LINE_FEED:
				case U.TABULATION:
				case U.FORM_FEED: {
					this._leaveAttrValue(), (this.state = W.BEFORE_ATTRIBUTE_NAME)
					break
				}
				case U.AMPERSAND: {
					this._startCharacterReference()
					break
				}
				case U.GREATER_THAN_SIGN: {
					this._leaveAttrValue(), (this.state = W.DATA), this.emitCurrentTagToken()
					break
				}
				case U.NULL: {
					this._err(ve.unexpectedNullCharacter), (this.currentAttr.value += Sn)
					break
				}
				case U.QUOTATION_MARK:
				case U.APOSTROPHE:
				case U.LESS_THAN_SIGN:
				case U.EQUALS_SIGN:
				case U.GRAVE_ACCENT: {
					this._err(ve.unexpectedCharacterInUnquotedAttributeValue),
						(this.currentAttr.value += String.fromCodePoint(t))
					break
				}
				case U.EOF: {
					this._err(ve.eofInTag), this._emitEOFToken()
					break
				}
				default:
					this.currentAttr.value += String.fromCodePoint(t)
			}
		}
		_stateAfterAttributeValueQuoted(t) {
			switch (t) {
				case U.SPACE:
				case U.LINE_FEED:
				case U.TABULATION:
				case U.FORM_FEED: {
					this._leaveAttrValue(), (this.state = W.BEFORE_ATTRIBUTE_NAME)
					break
				}
				case U.SOLIDUS: {
					this._leaveAttrValue(), (this.state = W.SELF_CLOSING_START_TAG)
					break
				}
				case U.GREATER_THAN_SIGN: {
					this._leaveAttrValue(), (this.state = W.DATA), this.emitCurrentTagToken()
					break
				}
				case U.EOF: {
					this._err(ve.eofInTag), this._emitEOFToken()
					break
				}
				default:
					this._err(ve.missingWhitespaceBetweenAttributes),
						(this.state = W.BEFORE_ATTRIBUTE_NAME),
						this._stateBeforeAttributeName(t)
			}
		}
		_stateSelfClosingStartTag(t) {
			switch (t) {
				case U.GREATER_THAN_SIGN: {
					const n = this.currentToken
					;(n.selfClosing = !0), (this.state = W.DATA), this.emitCurrentTagToken()
					break
				}
				case U.EOF: {
					this._err(ve.eofInTag), this._emitEOFToken()
					break
				}
				default:
					this._err(ve.unexpectedSolidusInTag),
						(this.state = W.BEFORE_ATTRIBUTE_NAME),
						this._stateBeforeAttributeName(t)
			}
		}
		_stateBogusComment(t) {
			const n = this.currentToken
			switch (t) {
				case U.GREATER_THAN_SIGN: {
					;(this.state = W.DATA), this.emitCurrentComment(n)
					break
				}
				case U.EOF: {
					this.emitCurrentComment(n), this._emitEOFToken()
					break
				}
				case U.NULL: {
					this._err(ve.unexpectedNullCharacter), (n.data += Sn)
					break
				}
				default:
					n.data += String.fromCodePoint(t)
			}
		}
		_stateMarkupDeclarationOpen(t) {
			this._consumeSequenceIfMatch(Mi.DASH_DASH, !0)
				? (this._createCommentToken(Mi.DASH_DASH.length + 1), (this.state = W.COMMENT_START))
				: this._consumeSequenceIfMatch(Mi.DOCTYPE, !1)
				? ((this.currentLocation = this.getCurrentLocation(Mi.DOCTYPE.length + 1)),
				  (this.state = W.DOCTYPE))
				: this._consumeSequenceIfMatch(Mi.CDATA_START, !0)
				? this.inForeignNode
					? (this.state = W.CDATA_SECTION)
					: (this._err(ve.cdataInHtmlContent),
					  this._createCommentToken(Mi.CDATA_START.length + 1),
					  (this.currentToken.data = "[CDATA["),
					  (this.state = W.BOGUS_COMMENT))
				: this._ensureHibernation() ||
				  (this._err(ve.incorrectlyOpenedComment),
				  this._createCommentToken(2),
				  (this.state = W.BOGUS_COMMENT),
				  this._stateBogusComment(t))
		}
		_stateCommentStart(t) {
			switch (t) {
				case U.HYPHEN_MINUS: {
					this.state = W.COMMENT_START_DASH
					break
				}
				case U.GREATER_THAN_SIGN: {
					this._err(ve.abruptClosingOfEmptyComment), (this.state = W.DATA)
					const n = this.currentToken
					this.emitCurrentComment(n)
					break
				}
				default:
					;(this.state = W.COMMENT), this._stateComment(t)
			}
		}
		_stateCommentStartDash(t) {
			const n = this.currentToken
			switch (t) {
				case U.HYPHEN_MINUS: {
					this.state = W.COMMENT_END
					break
				}
				case U.GREATER_THAN_SIGN: {
					this._err(ve.abruptClosingOfEmptyComment),
						(this.state = W.DATA),
						this.emitCurrentComment(n)
					break
				}
				case U.EOF: {
					this._err(ve.eofInComment), this.emitCurrentComment(n), this._emitEOFToken()
					break
				}
				default:
					;(n.data += "-"), (this.state = W.COMMENT), this._stateComment(t)
			}
		}
		_stateComment(t) {
			const n = this.currentToken
			switch (t) {
				case U.HYPHEN_MINUS: {
					this.state = W.COMMENT_END_DASH
					break
				}
				case U.LESS_THAN_SIGN: {
					;(n.data += "<"), (this.state = W.COMMENT_LESS_THAN_SIGN)
					break
				}
				case U.NULL: {
					this._err(ve.unexpectedNullCharacter), (n.data += Sn)
					break
				}
				case U.EOF: {
					this._err(ve.eofInComment), this.emitCurrentComment(n), this._emitEOFToken()
					break
				}
				default:
					n.data += String.fromCodePoint(t)
			}
		}
		_stateCommentLessThanSign(t) {
			const n = this.currentToken
			switch (t) {
				case U.EXCLAMATION_MARK: {
					;(n.data += "!"), (this.state = W.COMMENT_LESS_THAN_SIGN_BANG)
					break
				}
				case U.LESS_THAN_SIGN: {
					n.data += "<"
					break
				}
				default:
					;(this.state = W.COMMENT), this._stateComment(t)
			}
		}
		_stateCommentLessThanSignBang(t) {
			t === U.HYPHEN_MINUS
				? (this.state = W.COMMENT_LESS_THAN_SIGN_BANG_DASH)
				: ((this.state = W.COMMENT), this._stateComment(t))
		}
		_stateCommentLessThanSignBangDash(t) {
			t === U.HYPHEN_MINUS
				? (this.state = W.COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH)
				: ((this.state = W.COMMENT_END_DASH), this._stateCommentEndDash(t))
		}
		_stateCommentLessThanSignBangDashDash(t) {
			t !== U.GREATER_THAN_SIGN && t !== U.EOF && this._err(ve.nestedComment),
				(this.state = W.COMMENT_END),
				this._stateCommentEnd(t)
		}
		_stateCommentEndDash(t) {
			const n = this.currentToken
			switch (t) {
				case U.HYPHEN_MINUS: {
					this.state = W.COMMENT_END
					break
				}
				case U.EOF: {
					this._err(ve.eofInComment), this.emitCurrentComment(n), this._emitEOFToken()
					break
				}
				default:
					;(n.data += "-"), (this.state = W.COMMENT), this._stateComment(t)
			}
		}
		_stateCommentEnd(t) {
			const n = this.currentToken
			switch (t) {
				case U.GREATER_THAN_SIGN: {
					;(this.state = W.DATA), this.emitCurrentComment(n)
					break
				}
				case U.EXCLAMATION_MARK: {
					this.state = W.COMMENT_END_BANG
					break
				}
				case U.HYPHEN_MINUS: {
					n.data += "-"
					break
				}
				case U.EOF: {
					this._err(ve.eofInComment), this.emitCurrentComment(n), this._emitEOFToken()
					break
				}
				default:
					;(n.data += "--"), (this.state = W.COMMENT), this._stateComment(t)
			}
		}
		_stateCommentEndBang(t) {
			const n = this.currentToken
			switch (t) {
				case U.HYPHEN_MINUS: {
					;(n.data += "--!"), (this.state = W.COMMENT_END_DASH)
					break
				}
				case U.GREATER_THAN_SIGN: {
					this._err(ve.incorrectlyClosedComment), (this.state = W.DATA), this.emitCurrentComment(n)
					break
				}
				case U.EOF: {
					this._err(ve.eofInComment), this.emitCurrentComment(n), this._emitEOFToken()
					break
				}
				default:
					;(n.data += "--!"), (this.state = W.COMMENT), this._stateComment(t)
			}
		}
		_stateDoctype(t) {
			switch (t) {
				case U.SPACE:
				case U.LINE_FEED:
				case U.TABULATION:
				case U.FORM_FEED: {
					this.state = W.BEFORE_DOCTYPE_NAME
					break
				}
				case U.GREATER_THAN_SIGN: {
					;(this.state = W.BEFORE_DOCTYPE_NAME), this._stateBeforeDoctypeName(t)
					break
				}
				case U.EOF: {
					this._err(ve.eofInDoctype), this._createDoctypeToken(null)
					const n = this.currentToken
					;(n.forceQuirks = !0), this.emitCurrentDoctype(n), this._emitEOFToken()
					break
				}
				default:
					this._err(ve.missingWhitespaceBeforeDoctypeName),
						(this.state = W.BEFORE_DOCTYPE_NAME),
						this._stateBeforeDoctypeName(t)
			}
		}
		_stateBeforeDoctypeName(t) {
			if (km(t)) this._createDoctypeToken(String.fromCharCode(yy(t))), (this.state = W.DOCTYPE_NAME)
			else
				switch (t) {
					case U.SPACE:
					case U.LINE_FEED:
					case U.TABULATION:
					case U.FORM_FEED:
						break
					case U.NULL: {
						this._err(ve.unexpectedNullCharacter),
							this._createDoctypeToken(Sn),
							(this.state = W.DOCTYPE_NAME)
						break
					}
					case U.GREATER_THAN_SIGN: {
						this._err(ve.missingDoctypeName), this._createDoctypeToken(null)
						const n = this.currentToken
						;(n.forceQuirks = !0), this.emitCurrentDoctype(n), (this.state = W.DATA)
						break
					}
					case U.EOF: {
						this._err(ve.eofInDoctype), this._createDoctypeToken(null)
						const n = this.currentToken
						;(n.forceQuirks = !0), this.emitCurrentDoctype(n), this._emitEOFToken()
						break
					}
					default:
						this._createDoctypeToken(String.fromCodePoint(t)), (this.state = W.DOCTYPE_NAME)
				}
		}
		_stateDoctypeName(t) {
			const n = this.currentToken
			switch (t) {
				case U.SPACE:
				case U.LINE_FEED:
				case U.TABULATION:
				case U.FORM_FEED: {
					this.state = W.AFTER_DOCTYPE_NAME
					break
				}
				case U.GREATER_THAN_SIGN: {
					;(this.state = W.DATA), this.emitCurrentDoctype(n)
					break
				}
				case U.NULL: {
					this._err(ve.unexpectedNullCharacter), (n.name += Sn)
					break
				}
				case U.EOF: {
					this._err(ve.eofInDoctype),
						(n.forceQuirks = !0),
						this.emitCurrentDoctype(n),
						this._emitEOFToken()
					break
				}
				default:
					n.name += String.fromCodePoint(km(t) ? yy(t) : t)
			}
		}
		_stateAfterDoctypeName(t) {
			const n = this.currentToken
			switch (t) {
				case U.SPACE:
				case U.LINE_FEED:
				case U.TABULATION:
				case U.FORM_FEED:
					break
				case U.GREATER_THAN_SIGN: {
					;(this.state = W.DATA), this.emitCurrentDoctype(n)
					break
				}
				case U.EOF: {
					this._err(ve.eofInDoctype),
						(n.forceQuirks = !0),
						this.emitCurrentDoctype(n),
						this._emitEOFToken()
					break
				}
				default:
					this._consumeSequenceIfMatch(Mi.PUBLIC, !1)
						? (this.state = W.AFTER_DOCTYPE_PUBLIC_KEYWORD)
						: this._consumeSequenceIfMatch(Mi.SYSTEM, !1)
						? (this.state = W.AFTER_DOCTYPE_SYSTEM_KEYWORD)
						: this._ensureHibernation() ||
						  (this._err(ve.invalidCharacterSequenceAfterDoctypeName),
						  (n.forceQuirks = !0),
						  (this.state = W.BOGUS_DOCTYPE),
						  this._stateBogusDoctype(t))
			}
		}
		_stateAfterDoctypePublicKeyword(t) {
			const n = this.currentToken
			switch (t) {
				case U.SPACE:
				case U.LINE_FEED:
				case U.TABULATION:
				case U.FORM_FEED: {
					this.state = W.BEFORE_DOCTYPE_PUBLIC_IDENTIFIER
					break
				}
				case U.QUOTATION_MARK: {
					this._err(ve.missingWhitespaceAfterDoctypePublicKeyword),
						(n.publicId = ""),
						(this.state = W.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED)
					break
				}
				case U.APOSTROPHE: {
					this._err(ve.missingWhitespaceAfterDoctypePublicKeyword),
						(n.publicId = ""),
						(this.state = W.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED)
					break
				}
				case U.GREATER_THAN_SIGN: {
					this._err(ve.missingDoctypePublicIdentifier),
						(n.forceQuirks = !0),
						(this.state = W.DATA),
						this.emitCurrentDoctype(n)
					break
				}
				case U.EOF: {
					this._err(ve.eofInDoctype),
						(n.forceQuirks = !0),
						this.emitCurrentDoctype(n),
						this._emitEOFToken()
					break
				}
				default:
					this._err(ve.missingQuoteBeforeDoctypePublicIdentifier),
						(n.forceQuirks = !0),
						(this.state = W.BOGUS_DOCTYPE),
						this._stateBogusDoctype(t)
			}
		}
		_stateBeforeDoctypePublicIdentifier(t) {
			const n = this.currentToken
			switch (t) {
				case U.SPACE:
				case U.LINE_FEED:
				case U.TABULATION:
				case U.FORM_FEED:
					break
				case U.QUOTATION_MARK: {
					;(n.publicId = ""), (this.state = W.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED)
					break
				}
				case U.APOSTROPHE: {
					;(n.publicId = ""), (this.state = W.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED)
					break
				}
				case U.GREATER_THAN_SIGN: {
					this._err(ve.missingDoctypePublicIdentifier),
						(n.forceQuirks = !0),
						(this.state = W.DATA),
						this.emitCurrentDoctype(n)
					break
				}
				case U.EOF: {
					this._err(ve.eofInDoctype),
						(n.forceQuirks = !0),
						this.emitCurrentDoctype(n),
						this._emitEOFToken()
					break
				}
				default:
					this._err(ve.missingQuoteBeforeDoctypePublicIdentifier),
						(n.forceQuirks = !0),
						(this.state = W.BOGUS_DOCTYPE),
						this._stateBogusDoctype(t)
			}
		}
		_stateDoctypePublicIdentifierDoubleQuoted(t) {
			const n = this.currentToken
			switch (t) {
				case U.QUOTATION_MARK: {
					this.state = W.AFTER_DOCTYPE_PUBLIC_IDENTIFIER
					break
				}
				case U.NULL: {
					this._err(ve.unexpectedNullCharacter), (n.publicId += Sn)
					break
				}
				case U.GREATER_THAN_SIGN: {
					this._err(ve.abruptDoctypePublicIdentifier),
						(n.forceQuirks = !0),
						this.emitCurrentDoctype(n),
						(this.state = W.DATA)
					break
				}
				case U.EOF: {
					this._err(ve.eofInDoctype),
						(n.forceQuirks = !0),
						this.emitCurrentDoctype(n),
						this._emitEOFToken()
					break
				}
				default:
					n.publicId += String.fromCodePoint(t)
			}
		}
		_stateDoctypePublicIdentifierSingleQuoted(t) {
			const n = this.currentToken
			switch (t) {
				case U.APOSTROPHE: {
					this.state = W.AFTER_DOCTYPE_PUBLIC_IDENTIFIER
					break
				}
				case U.NULL: {
					this._err(ve.unexpectedNullCharacter), (n.publicId += Sn)
					break
				}
				case U.GREATER_THAN_SIGN: {
					this._err(ve.abruptDoctypePublicIdentifier),
						(n.forceQuirks = !0),
						this.emitCurrentDoctype(n),
						(this.state = W.DATA)
					break
				}
				case U.EOF: {
					this._err(ve.eofInDoctype),
						(n.forceQuirks = !0),
						this.emitCurrentDoctype(n),
						this._emitEOFToken()
					break
				}
				default:
					n.publicId += String.fromCodePoint(t)
			}
		}
		_stateAfterDoctypePublicIdentifier(t) {
			const n = this.currentToken
			switch (t) {
				case U.SPACE:
				case U.LINE_FEED:
				case U.TABULATION:
				case U.FORM_FEED: {
					this.state = W.BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS
					break
				}
				case U.GREATER_THAN_SIGN: {
					;(this.state = W.DATA), this.emitCurrentDoctype(n)
					break
				}
				case U.QUOTATION_MARK: {
					this._err(ve.missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers),
						(n.systemId = ""),
						(this.state = W.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED)
					break
				}
				case U.APOSTROPHE: {
					this._err(ve.missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers),
						(n.systemId = ""),
						(this.state = W.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED)
					break
				}
				case U.EOF: {
					this._err(ve.eofInDoctype),
						(n.forceQuirks = !0),
						this.emitCurrentDoctype(n),
						this._emitEOFToken()
					break
				}
				default:
					this._err(ve.missingQuoteBeforeDoctypeSystemIdentifier),
						(n.forceQuirks = !0),
						(this.state = W.BOGUS_DOCTYPE),
						this._stateBogusDoctype(t)
			}
		}
		_stateBetweenDoctypePublicAndSystemIdentifiers(t) {
			const n = this.currentToken
			switch (t) {
				case U.SPACE:
				case U.LINE_FEED:
				case U.TABULATION:
				case U.FORM_FEED:
					break
				case U.GREATER_THAN_SIGN: {
					this.emitCurrentDoctype(n), (this.state = W.DATA)
					break
				}
				case U.QUOTATION_MARK: {
					;(n.systemId = ""), (this.state = W.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED)
					break
				}
				case U.APOSTROPHE: {
					;(n.systemId = ""), (this.state = W.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED)
					break
				}
				case U.EOF: {
					this._err(ve.eofInDoctype),
						(n.forceQuirks = !0),
						this.emitCurrentDoctype(n),
						this._emitEOFToken()
					break
				}
				default:
					this._err(ve.missingQuoteBeforeDoctypeSystemIdentifier),
						(n.forceQuirks = !0),
						(this.state = W.BOGUS_DOCTYPE),
						this._stateBogusDoctype(t)
			}
		}
		_stateAfterDoctypeSystemKeyword(t) {
			const n = this.currentToken
			switch (t) {
				case U.SPACE:
				case U.LINE_FEED:
				case U.TABULATION:
				case U.FORM_FEED: {
					this.state = W.BEFORE_DOCTYPE_SYSTEM_IDENTIFIER
					break
				}
				case U.QUOTATION_MARK: {
					this._err(ve.missingWhitespaceAfterDoctypeSystemKeyword),
						(n.systemId = ""),
						(this.state = W.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED)
					break
				}
				case U.APOSTROPHE: {
					this._err(ve.missingWhitespaceAfterDoctypeSystemKeyword),
						(n.systemId = ""),
						(this.state = W.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED)
					break
				}
				case U.GREATER_THAN_SIGN: {
					this._err(ve.missingDoctypeSystemIdentifier),
						(n.forceQuirks = !0),
						(this.state = W.DATA),
						this.emitCurrentDoctype(n)
					break
				}
				case U.EOF: {
					this._err(ve.eofInDoctype),
						(n.forceQuirks = !0),
						this.emitCurrentDoctype(n),
						this._emitEOFToken()
					break
				}
				default:
					this._err(ve.missingQuoteBeforeDoctypeSystemIdentifier),
						(n.forceQuirks = !0),
						(this.state = W.BOGUS_DOCTYPE),
						this._stateBogusDoctype(t)
			}
		}
		_stateBeforeDoctypeSystemIdentifier(t) {
			const n = this.currentToken
			switch (t) {
				case U.SPACE:
				case U.LINE_FEED:
				case U.TABULATION:
				case U.FORM_FEED:
					break
				case U.QUOTATION_MARK: {
					;(n.systemId = ""), (this.state = W.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED)
					break
				}
				case U.APOSTROPHE: {
					;(n.systemId = ""), (this.state = W.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED)
					break
				}
				case U.GREATER_THAN_SIGN: {
					this._err(ve.missingDoctypeSystemIdentifier),
						(n.forceQuirks = !0),
						(this.state = W.DATA),
						this.emitCurrentDoctype(n)
					break
				}
				case U.EOF: {
					this._err(ve.eofInDoctype),
						(n.forceQuirks = !0),
						this.emitCurrentDoctype(n),
						this._emitEOFToken()
					break
				}
				default:
					this._err(ve.missingQuoteBeforeDoctypeSystemIdentifier),
						(n.forceQuirks = !0),
						(this.state = W.BOGUS_DOCTYPE),
						this._stateBogusDoctype(t)
			}
		}
		_stateDoctypeSystemIdentifierDoubleQuoted(t) {
			const n = this.currentToken
			switch (t) {
				case U.QUOTATION_MARK: {
					this.state = W.AFTER_DOCTYPE_SYSTEM_IDENTIFIER
					break
				}
				case U.NULL: {
					this._err(ve.unexpectedNullCharacter), (n.systemId += Sn)
					break
				}
				case U.GREATER_THAN_SIGN: {
					this._err(ve.abruptDoctypeSystemIdentifier),
						(n.forceQuirks = !0),
						this.emitCurrentDoctype(n),
						(this.state = W.DATA)
					break
				}
				case U.EOF: {
					this._err(ve.eofInDoctype),
						(n.forceQuirks = !0),
						this.emitCurrentDoctype(n),
						this._emitEOFToken()
					break
				}
				default:
					n.systemId += String.fromCodePoint(t)
			}
		}
		_stateDoctypeSystemIdentifierSingleQuoted(t) {
			const n = this.currentToken
			switch (t) {
				case U.APOSTROPHE: {
					this.state = W.AFTER_DOCTYPE_SYSTEM_IDENTIFIER
					break
				}
				case U.NULL: {
					this._err(ve.unexpectedNullCharacter), (n.systemId += Sn)
					break
				}
				case U.GREATER_THAN_SIGN: {
					this._err(ve.abruptDoctypeSystemIdentifier),
						(n.forceQuirks = !0),
						this.emitCurrentDoctype(n),
						(this.state = W.DATA)
					break
				}
				case U.EOF: {
					this._err(ve.eofInDoctype),
						(n.forceQuirks = !0),
						this.emitCurrentDoctype(n),
						this._emitEOFToken()
					break
				}
				default:
					n.systemId += String.fromCodePoint(t)
			}
		}
		_stateAfterDoctypeSystemIdentifier(t) {
			const n = this.currentToken
			switch (t) {
				case U.SPACE:
				case U.LINE_FEED:
				case U.TABULATION:
				case U.FORM_FEED:
					break
				case U.GREATER_THAN_SIGN: {
					this.emitCurrentDoctype(n), (this.state = W.DATA)
					break
				}
				case U.EOF: {
					this._err(ve.eofInDoctype),
						(n.forceQuirks = !0),
						this.emitCurrentDoctype(n),
						this._emitEOFToken()
					break
				}
				default:
					this._err(ve.unexpectedCharacterAfterDoctypeSystemIdentifier),
						(this.state = W.BOGUS_DOCTYPE),
						this._stateBogusDoctype(t)
			}
		}
		_stateBogusDoctype(t) {
			const n = this.currentToken
			switch (t) {
				case U.GREATER_THAN_SIGN: {
					this.emitCurrentDoctype(n), (this.state = W.DATA)
					break
				}
				case U.NULL: {
					this._err(ve.unexpectedNullCharacter)
					break
				}
				case U.EOF: {
					this.emitCurrentDoctype(n), this._emitEOFToken()
					break
				}
			}
		}
		_stateCdataSection(t) {
			switch (t) {
				case U.RIGHT_SQUARE_BRACKET: {
					this.state = W.CDATA_SECTION_BRACKET
					break
				}
				case U.EOF: {
					this._err(ve.eofInCdata), this._emitEOFToken()
					break
				}
				default:
					this._emitCodePoint(t)
			}
		}
		_stateCdataSectionBracket(t) {
			t === U.RIGHT_SQUARE_BRACKET
				? (this.state = W.CDATA_SECTION_END)
				: (this._emitChars("]"), (this.state = W.CDATA_SECTION), this._stateCdataSection(t))
		}
		_stateCdataSectionEnd(t) {
			switch (t) {
				case U.GREATER_THAN_SIGN: {
					this.state = W.DATA
					break
				}
				case U.RIGHT_SQUARE_BRACKET: {
					this._emitChars("]")
					break
				}
				default:
					this._emitChars("]]"), (this.state = W.CDATA_SECTION), this._stateCdataSection(t)
			}
		}
		_stateCharacterReference() {
			let t = this.entityDecoder.write(this.preprocessor.html, this.preprocessor.pos)
			if (t < 0)
				if (this.preprocessor.lastChunkWritten) t = this.entityDecoder.end()
				else {
					;(this.active = !1),
						(this.preprocessor.pos = this.preprocessor.html.length - 1),
						(this.consumedAfterSnapshot = 0),
						(this.preprocessor.endOfChunkHit = !0)
					return
				}
			t === 0
				? ((this.preprocessor.pos = this.entityStartPos),
				  this._flushCodePointConsumedAsCharacterReference(U.AMPERSAND),
				  (this.state =
						!this._isCharacterReferenceInAttribute() && eF(this.preprocessor.peek(1))
							? W.AMBIGUOUS_AMPERSAND
							: this.returnState))
				: (this.state = this.returnState)
		}
		_stateAmbiguousAmpersand(t) {
			eF(t)
				? this._flushCodePointConsumedAsCharacterReference(t)
				: (t === U.SEMICOLON && this._err(ve.unknownNamedCharacterReference),
				  (this.state = this.returnState),
				  this._callState(t))
		}
	}
	const BV = new Set([k.DD, k.DT, k.LI, k.OPTGROUP, k.OPTION, k.P, k.RB, k.RP, k.RT, k.RTC]),
		nF = new Set([...BV, k.CAPTION, k.COLGROUP, k.TBODY, k.TD, k.TFOOT, k.TH, k.THEAD, k.TR]),
		Lb = new Set([
			k.APPLET,
			k.CAPTION,
			k.HTML,
			k.MARQUEE,
			k.OBJECT,
			k.TABLE,
			k.TD,
			k.TEMPLATE,
			k.TH,
		]),
		zft = new Set([...Lb, k.OL, k.UL]),
		qft = new Set([...Lb, k.BUTTON]),
		rF = new Set([k.ANNOTATION_XML, k.MI, k.MN, k.MO, k.MS, k.MTEXT]),
		iF = new Set([k.DESC, k.FOREIGN_OBJECT, k.TITLE]),
		Vft = new Set([k.TR, k.TEMPLATE, k.HTML]),
		Wft = new Set([k.TBODY, k.TFOOT, k.THEAD, k.TEMPLATE, k.HTML]),
		Yft = new Set([k.TABLE, k.TEMPLATE, k.HTML]),
		Gft = new Set([k.TD, k.TH])
	class Kft {
		get currentTmplContentOrNode() {
			return this._isInTemplate() ? this.treeAdapter.getTemplateContent(this.current) : this.current
		}
		constructor(t, n, r) {
			;(this.treeAdapter = n),
				(this.handler = r),
				(this.items = []),
				(this.tagIDs = []),
				(this.stackTop = -1),
				(this.tmplCount = 0),
				(this.currentTagId = k.UNKNOWN),
				(this.current = t)
		}
		_indexOf(t) {
			return this.items.lastIndexOf(t, this.stackTop)
		}
		_isInTemplate() {
			return (
				this.currentTagId === k.TEMPLATE &&
				this.treeAdapter.getNamespaceURI(this.current) === we.HTML
			)
		}
		_updateCurrentElement() {
			;(this.current = this.items[this.stackTop]), (this.currentTagId = this.tagIDs[this.stackTop])
		}
		push(t, n) {
			this.stackTop++,
				(this.items[this.stackTop] = t),
				(this.current = t),
				(this.tagIDs[this.stackTop] = n),
				(this.currentTagId = n),
				this._isInTemplate() && this.tmplCount++,
				this.handler.onItemPush(t, n, !0)
		}
		pop() {
			const t = this.current
			this.tmplCount > 0 && this._isInTemplate() && this.tmplCount--,
				this.stackTop--,
				this._updateCurrentElement(),
				this.handler.onItemPop(t, !0)
		}
		replace(t, n) {
			const r = this._indexOf(t)
			;(this.items[r] = n), r === this.stackTop && (this.current = n)
		}
		insertAfter(t, n, r) {
			const i = this._indexOf(t) + 1
			this.items.splice(i, 0, n),
				this.tagIDs.splice(i, 0, r),
				this.stackTop++,
				i === this.stackTop && this._updateCurrentElement(),
				this.handler.onItemPush(this.current, this.currentTagId, i === this.stackTop)
		}
		popUntilTagNamePopped(t) {
			let n = this.stackTop + 1
			do n = this.tagIDs.lastIndexOf(t, n - 1)
			while (n > 0 && this.treeAdapter.getNamespaceURI(this.items[n]) !== we.HTML)
			this.shortenToLength(n < 0 ? 0 : n)
		}
		shortenToLength(t) {
			for (; this.stackTop >= t; ) {
				const n = this.current
				this.tmplCount > 0 && this._isInTemplate() && (this.tmplCount -= 1),
					this.stackTop--,
					this._updateCurrentElement(),
					this.handler.onItemPop(n, this.stackTop < t)
			}
		}
		popUntilElementPopped(t) {
			const n = this._indexOf(t)
			this.shortenToLength(n < 0 ? 0 : n)
		}
		popUntilPopped(t, n) {
			const r = this._indexOfTagNames(t, n)
			this.shortenToLength(r < 0 ? 0 : r)
		}
		popUntilNumberedHeaderPopped() {
			this.popUntilPopped(yD, we.HTML)
		}
		popUntilTableCellPopped() {
			this.popUntilPopped(Gft, we.HTML)
		}
		popAllUpToHtmlElement() {
			;(this.tmplCount = 0), this.shortenToLength(1)
		}
		_indexOfTagNames(t, n) {
			for (let r = this.stackTop; r >= 0; r--)
				if (t.has(this.tagIDs[r]) && this.treeAdapter.getNamespaceURI(this.items[r]) === n) return r
			return -1
		}
		clearBackTo(t, n) {
			const r = this._indexOfTagNames(t, n)
			this.shortenToLength(r + 1)
		}
		clearBackToTableContext() {
			this.clearBackTo(Yft, we.HTML)
		}
		clearBackToTableBodyContext() {
			this.clearBackTo(Wft, we.HTML)
		}
		clearBackToTableRowContext() {
			this.clearBackTo(Vft, we.HTML)
		}
		remove(t) {
			const n = this._indexOf(t)
			n >= 0 &&
				(n === this.stackTop
					? this.pop()
					: (this.items.splice(n, 1),
					  this.tagIDs.splice(n, 1),
					  this.stackTop--,
					  this._updateCurrentElement(),
					  this.handler.onItemPop(t, !1)))
		}
		tryPeekProperlyNestedBodyElement() {
			return this.stackTop >= 1 && this.tagIDs[1] === k.BODY ? this.items[1] : null
		}
		contains(t) {
			return this._indexOf(t) > -1
		}
		getCommonAncestor(t) {
			const n = this._indexOf(t) - 1
			return n >= 0 ? this.items[n] : null
		}
		isRootHtmlElementCurrent() {
			return this.stackTop === 0 && this.tagIDs[0] === k.HTML
		}
		hasInDynamicScope(t, n) {
			for (let r = this.stackTop; r >= 0; r--) {
				const i = this.tagIDs[r]
				switch (this.treeAdapter.getNamespaceURI(this.items[r])) {
					case we.HTML: {
						if (i === t) return !0
						if (n.has(i)) return !1
						break
					}
					case we.SVG: {
						if (iF.has(i)) return !1
						break
					}
					case we.MATHML: {
						if (rF.has(i)) return !1
						break
					}
				}
			}
			return !0
		}
		hasInScope(t) {
			return this.hasInDynamicScope(t, Lb)
		}
		hasInListItemScope(t) {
			return this.hasInDynamicScope(t, zft)
		}
		hasInButtonScope(t) {
			return this.hasInDynamicScope(t, qft)
		}
		hasNumberedHeaderInScope() {
			for (let t = this.stackTop; t >= 0; t--) {
				const n = this.tagIDs[t]
				switch (this.treeAdapter.getNamespaceURI(this.items[t])) {
					case we.HTML: {
						if (yD.has(n)) return !0
						if (Lb.has(n)) return !1
						break
					}
					case we.SVG: {
						if (iF.has(n)) return !1
						break
					}
					case we.MATHML: {
						if (rF.has(n)) return !1
						break
					}
				}
			}
			return !0
		}
		hasInTableScope(t) {
			for (let n = this.stackTop; n >= 0; n--)
				if (this.treeAdapter.getNamespaceURI(this.items[n]) === we.HTML)
					switch (this.tagIDs[n]) {
						case t:
							return !0
						case k.TABLE:
						case k.HTML:
							return !1
					}
			return !0
		}
		hasTableBodyContextInTableScope() {
			for (let t = this.stackTop; t >= 0; t--)
				if (this.treeAdapter.getNamespaceURI(this.items[t]) === we.HTML)
					switch (this.tagIDs[t]) {
						case k.TBODY:
						case k.THEAD:
						case k.TFOOT:
							return !0
						case k.TABLE:
						case k.HTML:
							return !1
					}
			return !0
		}
		hasInSelectScope(t) {
			for (let n = this.stackTop; n >= 0; n--)
				if (this.treeAdapter.getNamespaceURI(this.items[n]) === we.HTML)
					switch (this.tagIDs[n]) {
						case t:
							return !0
						case k.OPTION:
						case k.OPTGROUP:
							break
						default:
							return !1
					}
			return !0
		}
		generateImpliedEndTags() {
			for (; BV.has(this.currentTagId); ) this.pop()
		}
		generateImpliedEndTagsThoroughly() {
			for (; nF.has(this.currentTagId); ) this.pop()
		}
		generateImpliedEndTagsWithExclusion(t) {
			for (; this.currentTagId !== t && nF.has(this.currentTagId); ) this.pop()
		}
	}
	const Jk = 3
	var Qo
	;(function (e) {
		;(e[(e.Marker = 0)] = "Marker"), (e[(e.Element = 1)] = "Element")
	})(Qo || (Qo = {}))
	const aF = { type: Qo.Marker }
	class Qft {
		constructor(t) {
			;(this.treeAdapter = t), (this.entries = []), (this.bookmark = null)
		}
		_getNoahArkConditionCandidates(t, n) {
			const r = [],
				i = n.length,
				a = this.treeAdapter.getTagName(t),
				o = this.treeAdapter.getNamespaceURI(t)
			for (let s = 0; s < this.entries.length; s++) {
				const l = this.entries[s]
				if (l.type === Qo.Marker) break
				const { element: u } = l
				if (this.treeAdapter.getTagName(u) === a && this.treeAdapter.getNamespaceURI(u) === o) {
					const d = this.treeAdapter.getAttrList(u)
					d.length === i && r.push({ idx: s, attrs: d })
				}
			}
			return r
		}
		_ensureNoahArkCondition(t) {
			if (this.entries.length < Jk) return
			const n = this.treeAdapter.getAttrList(t),
				r = this._getNoahArkConditionCandidates(t, n)
			if (r.length < Jk) return
			const i = new Map(n.map((o) => [o.name, o.value]))
			let a = 0
			for (let o = 0; o < r.length; o++) {
				const s = r[o]
				s.attrs.every((l) => i.get(l.name) === l.value) &&
					((a += 1), a >= Jk && this.entries.splice(s.idx, 1))
			}
		}
		insertMarker() {
			this.entries.unshift(aF)
		}
		pushElement(t, n) {
			this._ensureNoahArkCondition(t),
				this.entries.unshift({ type: Qo.Element, element: t, token: n })
		}
		insertElementAfterBookmark(t, n) {
			const r = this.entries.indexOf(this.bookmark)
			this.entries.splice(r, 0, { type: Qo.Element, element: t, token: n })
		}
		removeEntry(t) {
			const n = this.entries.indexOf(t)
			n >= 0 && this.entries.splice(n, 1)
		}
		clearToLastMarker() {
			const t = this.entries.indexOf(aF)
			t >= 0 ? this.entries.splice(0, t + 1) : (this.entries.length = 0)
		}
		getElementEntryInScopeWithTagName(t) {
			const n = this.entries.find(
				(r) => r.type === Qo.Marker || this.treeAdapter.getTagName(r.element) === t,
			)
			return n && n.type === Qo.Element ? n : null
		}
		getElementEntry(t) {
			return this.entries.find((n) => n.type === Qo.Element && n.element === t)
		}
	}
	const fu = {
			createDocument() {
				return { nodeName: "#document", mode: Ba.NO_QUIRKS, childNodes: [] }
			},
			createDocumentFragment() {
				return { nodeName: "#document-fragment", childNodes: [] }
			},
			createElement(e, t, n) {
				return {
					nodeName: e,
					tagName: e,
					attrs: n,
					namespaceURI: t,
					childNodes: [],
					parentNode: null,
				}
			},
			createCommentNode(e) {
				return { nodeName: "#comment", data: e, parentNode: null }
			},
			createTextNode(e) {
				return { nodeName: "#text", value: e, parentNode: null }
			},
			appendChild(e, t) {
				e.childNodes.push(t), (t.parentNode = e)
			},
			insertBefore(e, t, n) {
				const r = e.childNodes.indexOf(n)
				e.childNodes.splice(r, 0, t), (t.parentNode = e)
			},
			setTemplateContent(e, t) {
				e.content = t
			},
			getTemplateContent(e) {
				return e.content
			},
			setDocumentType(e, t, n, r) {
				const i = e.childNodes.find((a) => a.nodeName === "#documentType")
				if (i) (i.name = t), (i.publicId = n), (i.systemId = r)
				else {
					const a = {
						nodeName: "#documentType",
						name: t,
						publicId: n,
						systemId: r,
						parentNode: null,
					}
					fu.appendChild(e, a)
				}
			},
			setDocumentMode(e, t) {
				e.mode = t
			},
			getDocumentMode(e) {
				return e.mode
			},
			detachNode(e) {
				if (e.parentNode) {
					const t = e.parentNode.childNodes.indexOf(e)
					e.parentNode.childNodes.splice(t, 1), (e.parentNode = null)
				}
			},
			insertText(e, t) {
				if (e.childNodes.length > 0) {
					const n = e.childNodes[e.childNodes.length - 1]
					if (fu.isTextNode(n)) {
						n.value += t
						return
					}
				}
				fu.appendChild(e, fu.createTextNode(t))
			},
			insertTextBefore(e, t, n) {
				const r = e.childNodes[e.childNodes.indexOf(n) - 1]
				r && fu.isTextNode(r) ? (r.value += t) : fu.insertBefore(e, fu.createTextNode(t), n)
			},
			adoptAttributes(e, t) {
				const n = new Set(e.attrs.map((r) => r.name))
				for (let r = 0; r < t.length; r++) n.has(t[r].name) || e.attrs.push(t[r])
			},
			getFirstChild(e) {
				return e.childNodes[0]
			},
			getChildNodes(e) {
				return e.childNodes
			},
			getParentNode(e) {
				return e.parentNode
			},
			getAttrList(e) {
				return e.attrs
			},
			getTagName(e) {
				return e.tagName
			},
			getNamespaceURI(e) {
				return e.namespaceURI
			},
			getTextNodeContent(e) {
				return e.value
			},
			getCommentNodeContent(e) {
				return e.data
			},
			getDocumentTypeNodeName(e) {
				return e.name
			},
			getDocumentTypeNodePublicId(e) {
				return e.publicId
			},
			getDocumentTypeNodeSystemId(e) {
				return e.systemId
			},
			isTextNode(e) {
				return e.nodeName === "#text"
			},
			isCommentNode(e) {
				return e.nodeName === "#comment"
			},
			isDocumentTypeNode(e) {
				return e.nodeName === "#documentType"
			},
			isElementNode(e) {
				return Object.prototype.hasOwnProperty.call(e, "tagName")
			},
			setNodeSourceCodeLocation(e, t) {
				e.sourceCodeLocation = t
			},
			getNodeSourceCodeLocation(e) {
				return e.sourceCodeLocation
			},
			updateNodeSourceCodeLocation(e, t) {
				e.sourceCodeLocation = { ...e.sourceCodeLocation, ...t }
			},
		},
		HV = "html",
		Xft = "about:legacy-compat",
		Jft = "http://www.ibm.com/data/dtd/v11/ibmxhtml1-transitional.dtd",
		$V = [
			"+//silmaril//dtd html pro v0r11 19970101//",
			"-//as//dtd html 3.0 aswedit + extensions//",
			"-//advasoft ltd//dtd html 3.0 aswedit + extensions//",
			"-//ietf//dtd html 2.0 level 1//",
			"-//ietf//dtd html 2.0 level 2//",
			"-//ietf//dtd html 2.0 strict level 1//",
			"-//ietf//dtd html 2.0 strict level 2//",
			"-//ietf//dtd html 2.0 strict//",
			"-//ietf//dtd html 2.0//",
			"-//ietf//dtd html 2.1e//",
			"-//ietf//dtd html 3.0//",
			"-//ietf//dtd html 3.2 final//",
			"-//ietf//dtd html 3.2//",
			"-//ietf//dtd html 3//",
			"-//ietf//dtd html level 0//",
			"-//ietf//dtd html level 1//",
			"-//ietf//dtd html level 2//",
			"-//ietf//dtd html level 3//",
			"-//ietf//dtd html strict level 0//",
			"-//ietf//dtd html strict level 1//",
			"-//ietf//dtd html strict level 2//",
			"-//ietf//dtd html strict level 3//",
			"-//ietf//dtd html strict//",
			"-//ietf//dtd html//",
			"-//metrius//dtd metrius presentational//",
			"-//microsoft//dtd internet explorer 2.0 html strict//",
			"-//microsoft//dtd internet explorer 2.0 html//",
			"-//microsoft//dtd internet explorer 2.0 tables//",
			"-//microsoft//dtd internet explorer 3.0 html strict//",
			"-//microsoft//dtd internet explorer 3.0 html//",
			"-//microsoft//dtd internet explorer 3.0 tables//",
			"-//netscape comm. corp.//dtd html//",
			"-//netscape comm. corp.//dtd strict html//",
			"-//o'reilly and associates//dtd html 2.0//",
			"-//o'reilly and associates//dtd html extended 1.0//",
			"-//o'reilly and associates//dtd html extended relaxed 1.0//",
			"-//sq//dtd html 2.0 hotmetal + extensions//",
			"-//softquad software//dtd hotmetal pro 6.0::19990601::extensions to html 4.0//",
			"-//softquad//dtd hotmetal pro 4.0::19971010::extensions to html 4.0//",
			"-//spyglass//dtd html 2.0 extended//",
			"-//sun microsystems corp.//dtd hotjava html//",
			"-//sun microsystems corp.//dtd hotjava strict html//",
			"-//w3c//dtd html 3 1995-03-24//",
			"-//w3c//dtd html 3.2 draft//",
			"-//w3c//dtd html 3.2 final//",
			"-//w3c//dtd html 3.2//",
			"-//w3c//dtd html 3.2s draft//",
			"-//w3c//dtd html 4.0 frameset//",
			"-//w3c//dtd html 4.0 transitional//",
			"-//w3c//dtd html experimental 19960712//",
			"-//w3c//dtd html experimental 970421//",
			"-//w3c//dtd w3 html//",
			"-//w3o//dtd w3 html 3.0//",
			"-//webtechs//dtd mozilla html 2.0//",
			"-//webtechs//dtd mozilla html//",
		],
		Zft = [...$V, "-//w3c//dtd html 4.01 frameset//", "-//w3c//dtd html 4.01 transitional//"],
		ept = new Set([
			"-//w3o//dtd w3 html strict 3.0//en//",
			"-/w3c/dtd html 4.0 transitional/en",
			"html",
		]),
		UV = ["-//w3c//dtd xhtml 1.0 frameset//", "-//w3c//dtd xhtml 1.0 transitional//"],
		tpt = [...UV, "-//w3c//dtd html 4.01 frameset//", "-//w3c//dtd html 4.01 transitional//"]
	function oF(e, t) {
		return t.some((n) => e.startsWith(n))
	}
	function npt(e) {
		return e.name === HV && e.publicId === null && (e.systemId === null || e.systemId === Xft)
	}
	function rpt(e) {
		if (e.name !== HV) return Ba.QUIRKS
		const { systemId: t } = e
		if (t && t.toLowerCase() === Jft) return Ba.QUIRKS
		let { publicId: n } = e
		if (n !== null) {
			if (((n = n.toLowerCase()), ept.has(n))) return Ba.QUIRKS
			let r = t === null ? Zft : $V
			if (oF(n, r)) return Ba.QUIRKS
			if (((r = t === null ? UV : tpt), oF(n, r))) return Ba.LIMITED_QUIRKS
		}
		return Ba.NO_QUIRKS
	}
	const sF = { TEXT_HTML: "text/html", APPLICATION_XML: "application/xhtml+xml" },
		ipt = "definitionurl",
		apt = "definitionURL",
		opt = new Map(
			[
				"attributeName",
				"attributeType",
				"baseFrequency",
				"baseProfile",
				"calcMode",
				"clipPathUnits",
				"diffuseConstant",
				"edgeMode",
				"filterUnits",
				"glyphRef",
				"gradientTransform",
				"gradientUnits",
				"kernelMatrix",
				"kernelUnitLength",
				"keyPoints",
				"keySplines",
				"keyTimes",
				"lengthAdjust",
				"limitingConeAngle",
				"markerHeight",
				"markerUnits",
				"markerWidth",
				"maskContentUnits",
				"maskUnits",
				"numOctaves",
				"pathLength",
				"patternContentUnits",
				"patternTransform",
				"patternUnits",
				"pointsAtX",
				"pointsAtY",
				"pointsAtZ",
				"preserveAlpha",
				"preserveAspectRatio",
				"primitiveUnits",
				"refX",
				"refY",
				"repeatCount",
				"repeatDur",
				"requiredExtensions",
				"requiredFeatures",
				"specularConstant",
				"specularExponent",
				"spreadMethod",
				"startOffset",
				"stdDeviation",
				"stitchTiles",
				"surfaceScale",
				"systemLanguage",
				"tableValues",
				"targetX",
				"targetY",
				"textLength",
				"viewBox",
				"viewTarget",
				"xChannelSelector",
				"yChannelSelector",
				"zoomAndPan",
			].map((e) => [e.toLowerCase(), e]),
		),
		spt = new Map([
			["xlink:actuate", { prefix: "xlink", name: "actuate", namespace: we.XLINK }],
			["xlink:arcrole", { prefix: "xlink", name: "arcrole", namespace: we.XLINK }],
			["xlink:href", { prefix: "xlink", name: "href", namespace: we.XLINK }],
			["xlink:role", { prefix: "xlink", name: "role", namespace: we.XLINK }],
			["xlink:show", { prefix: "xlink", name: "show", namespace: we.XLINK }],
			["xlink:title", { prefix: "xlink", name: "title", namespace: we.XLINK }],
			["xlink:type", { prefix: "xlink", name: "type", namespace: we.XLINK }],
			["xml:lang", { prefix: "xml", name: "lang", namespace: we.XML }],
			["xml:space", { prefix: "xml", name: "space", namespace: we.XML }],
			["xmlns", { prefix: "", name: "xmlns", namespace: we.XMLNS }],
			["xmlns:xlink", { prefix: "xmlns", name: "xlink", namespace: we.XMLNS }],
		]),
		lpt = new Map(
			[
				"altGlyph",
				"altGlyphDef",
				"altGlyphItem",
				"animateColor",
				"animateMotion",
				"animateTransform",
				"clipPath",
				"feBlend",
				"feColorMatrix",
				"feComponentTransfer",
				"feComposite",
				"feConvolveMatrix",
				"feDiffuseLighting",
				"feDisplacementMap",
				"feDistantLight",
				"feFlood",
				"feFuncA",
				"feFuncB",
				"feFuncG",
				"feFuncR",
				"feGaussianBlur",
				"feImage",
				"feMerge",
				"feMergeNode",
				"feMorphology",
				"feOffset",
				"fePointLight",
				"feSpecularLighting",
				"feSpotLight",
				"feTile",
				"feTurbulence",
				"foreignObject",
				"glyphRef",
				"linearGradient",
				"radialGradient",
				"textPath",
			].map((e) => [e.toLowerCase(), e]),
		),
		upt = new Set([
			k.B,
			k.BIG,
			k.BLOCKQUOTE,
			k.BODY,
			k.BR,
			k.CENTER,
			k.CODE,
			k.DD,
			k.DIV,
			k.DL,
			k.DT,
			k.EM,
			k.EMBED,
			k.H1,
			k.H2,
			k.H3,
			k.H4,
			k.H5,
			k.H6,
			k.HEAD,
			k.HR,
			k.I,
			k.IMG,
			k.LI,
			k.LISTING,
			k.MENU,
			k.META,
			k.NOBR,
			k.OL,
			k.P,
			k.PRE,
			k.RUBY,
			k.S,
			k.SMALL,
			k.SPAN,
			k.STRONG,
			k.STRIKE,
			k.SUB,
			k.SUP,
			k.TABLE,
			k.TT,
			k.U,
			k.UL,
			k.VAR,
		])
	function cpt(e) {
		const t = e.tagID
		return (
			(t === k.FONT &&
				e.attrs.some(({ name: r }) => r === nd.COLOR || r === nd.SIZE || r === nd.FACE)) ||
			upt.has(t)
		)
	}
	function zV(e) {
		for (let t = 0; t < e.attrs.length; t++)
			if (e.attrs[t].name === ipt) {
				e.attrs[t].name = apt
				break
			}
	}
	function qV(e) {
		for (let t = 0; t < e.attrs.length; t++) {
			const n = opt.get(e.attrs[t].name)
			n != null && (e.attrs[t].name = n)
		}
	}
	function _A(e) {
		for (let t = 0; t < e.attrs.length; t++) {
			const n = spt.get(e.attrs[t].name)
			n &&
				((e.attrs[t].prefix = n.prefix),
				(e.attrs[t].name = n.name),
				(e.attrs[t].namespace = n.namespace))
		}
	}
	function dpt(e) {
		const t = lpt.get(e.tagName)
		t != null && ((e.tagName = t), (e.tagID = ah(e.tagName)))
	}
	function fpt(e, t) {
		return (
			t === we.MATHML && (e === k.MI || e === k.MO || e === k.MN || e === k.MS || e === k.MTEXT)
		)
	}
	function ppt(e, t, n) {
		if (t === we.MATHML && e === k.ANNOTATION_XML) {
			for (let r = 0; r < n.length; r++)
				if (n[r].name === nd.ENCODING) {
					const i = n[r].value.toLowerCase()
					return i === sF.TEXT_HTML || i === sF.APPLICATION_XML
				}
		}
		return t === we.SVG && (e === k.FOREIGN_OBJECT || e === k.DESC || e === k.TITLE)
	}
	function hpt(e, t, n, r) {
		return ((!r || r === we.HTML) && ppt(e, t, n)) || ((!r || r === we.MATHML) && fpt(e, t))
	}
	const mpt = "hidden",
		vpt = 8,
		gpt = 3
	var Q
	;(function (e) {
		;(e[(e.INITIAL = 0)] = "INITIAL"),
			(e[(e.BEFORE_HTML = 1)] = "BEFORE_HTML"),
			(e[(e.BEFORE_HEAD = 2)] = "BEFORE_HEAD"),
			(e[(e.IN_HEAD = 3)] = "IN_HEAD"),
			(e[(e.IN_HEAD_NO_SCRIPT = 4)] = "IN_HEAD_NO_SCRIPT"),
			(e[(e.AFTER_HEAD = 5)] = "AFTER_HEAD"),
			(e[(e.IN_BODY = 6)] = "IN_BODY"),
			(e[(e.TEXT = 7)] = "TEXT"),
			(e[(e.IN_TABLE = 8)] = "IN_TABLE"),
			(e[(e.IN_TABLE_TEXT = 9)] = "IN_TABLE_TEXT"),
			(e[(e.IN_CAPTION = 10)] = "IN_CAPTION"),
			(e[(e.IN_COLUMN_GROUP = 11)] = "IN_COLUMN_GROUP"),
			(e[(e.IN_TABLE_BODY = 12)] = "IN_TABLE_BODY"),
			(e[(e.IN_ROW = 13)] = "IN_ROW"),
			(e[(e.IN_CELL = 14)] = "IN_CELL"),
			(e[(e.IN_SELECT = 15)] = "IN_SELECT"),
			(e[(e.IN_SELECT_IN_TABLE = 16)] = "IN_SELECT_IN_TABLE"),
			(e[(e.IN_TEMPLATE = 17)] = "IN_TEMPLATE"),
			(e[(e.AFTER_BODY = 18)] = "AFTER_BODY"),
			(e[(e.IN_FRAMESET = 19)] = "IN_FRAMESET"),
			(e[(e.AFTER_FRAMESET = 20)] = "AFTER_FRAMESET"),
			(e[(e.AFTER_AFTER_BODY = 21)] = "AFTER_AFTER_BODY"),
			(e[(e.AFTER_AFTER_FRAMESET = 22)] = "AFTER_AFTER_FRAMESET")
	})(Q || (Q = {}))
	const ypt = {
			startLine: -1,
			startCol: -1,
			startOffset: -1,
			endLine: -1,
			endCol: -1,
			endOffset: -1,
		},
		VV = new Set([k.TABLE, k.TBODY, k.TFOOT, k.THEAD, k.TR]),
		lF = { scriptingEnabled: !0, sourceCodeLocationInfo: !1, treeAdapter: fu, onParseError: null }
	let uF = class {
		constructor(t, n, r = null, i = null) {
			;(this.fragmentContext = r),
				(this.scriptHandler = i),
				(this.currentToken = null),
				(this.stopped = !1),
				(this.insertionMode = Q.INITIAL),
				(this.originalInsertionMode = Q.INITIAL),
				(this.headElement = null),
				(this.formElement = null),
				(this.currentNotInHTML = !1),
				(this.tmplInsertionModeStack = []),
				(this.pendingCharacterTokens = []),
				(this.hasNonWhitespacePendingCharacterToken = !1),
				(this.framesetOk = !0),
				(this.skipNextNewLine = !1),
				(this.fosterParentingEnabled = !1),
				(this.options = { ...lF, ...t }),
				(this.treeAdapter = this.options.treeAdapter),
				(this.onParseError = this.options.onParseError),
				this.onParseError && (this.options.sourceCodeLocationInfo = !0),
				(this.document = n ?? this.treeAdapter.createDocument()),
				(this.tokenizer = new Uft(this.options, this)),
				(this.activeFormattingElements = new Qft(this.treeAdapter)),
				(this.fragmentContextID = r ? ah(this.treeAdapter.getTagName(r)) : k.UNKNOWN),
				this._setContextModes(r ?? this.document, this.fragmentContextID),
				(this.openElements = new Kft(this.document, this.treeAdapter, this))
		}
		static parse(t, n) {
			const r = new this(n)
			return r.tokenizer.write(t, !0), r.document
		}
		static getFragmentParser(t, n) {
			const r = { ...lF, ...n }
			t ?? (t = r.treeAdapter.createElement(se.TEMPLATE, we.HTML, []))
			const i = r.treeAdapter.createElement("documentmock", we.HTML, []),
				a = new this(r, i, t)
			return (
				a.fragmentContextID === k.TEMPLATE && a.tmplInsertionModeStack.unshift(Q.IN_TEMPLATE),
				a._initTokenizerForFragmentParsing(),
				a._insertFakeRootElement(),
				a._resetInsertionMode(),
				a._findFormInFragmentContext(),
				a
			)
		}
		getFragment() {
			const t = this.treeAdapter.getFirstChild(this.document),
				n = this.treeAdapter.createDocumentFragment()
			return this._adoptNodes(t, n), n
		}
		_err(t, n, r) {
			var i
			if (!this.onParseError) return
			const a = (i = t.location) !== null && i !== void 0 ? i : ypt,
				o = {
					code: n,
					startLine: a.startLine,
					startCol: a.startCol,
					startOffset: a.startOffset,
					endLine: r ? a.startLine : a.endLine,
					endCol: r ? a.startCol : a.endCol,
					endOffset: r ? a.startOffset : a.endOffset,
				}
			this.onParseError(o)
		}
		onItemPush(t, n, r) {
			var i, a
			;(a = (i = this.treeAdapter).onItemPush) === null || a === void 0 || a.call(i, t),
				r && this.openElements.stackTop > 0 && this._setContextModes(t, n)
		}
		onItemPop(t, n) {
			var r, i
			if (
				(this.options.sourceCodeLocationInfo && this._setEndLocation(t, this.currentToken),
				(i = (r = this.treeAdapter).onItemPop) === null ||
					i === void 0 ||
					i.call(r, t, this.openElements.current),
				n)
			) {
				let a, o
				this.openElements.stackTop === 0 && this.fragmentContext
					? ((a = this.fragmentContext), (o = this.fragmentContextID))
					: ({ current: a, currentTagId: o } = this.openElements),
					this._setContextModes(a, o)
			}
		}
		_setContextModes(t, n) {
			const r = t === this.document || this.treeAdapter.getNamespaceURI(t) === we.HTML
			;(this.currentNotInHTML = !r),
				(this.tokenizer.inForeignNode = !r && !this._isIntegrationPoint(n, t))
		}
		_switchToTextParsing(t, n) {
			this._insertElement(t, we.HTML),
				(this.tokenizer.state = n),
				(this.originalInsertionMode = this.insertionMode),
				(this.insertionMode = Q.TEXT)
		}
		switchToPlaintextParsing() {
			;(this.insertionMode = Q.TEXT),
				(this.originalInsertionMode = Q.IN_BODY),
				(this.tokenizer.state = Jn.PLAINTEXT)
		}
		_getAdjustedCurrentElement() {
			return this.openElements.stackTop === 0 && this.fragmentContext
				? this.fragmentContext
				: this.openElements.current
		}
		_findFormInFragmentContext() {
			let t = this.fragmentContext
			for (; t; ) {
				if (this.treeAdapter.getTagName(t) === se.FORM) {
					this.formElement = t
					break
				}
				t = this.treeAdapter.getParentNode(t)
			}
		}
		_initTokenizerForFragmentParsing() {
			if (
				!(
					!this.fragmentContext ||
					this.treeAdapter.getNamespaceURI(this.fragmentContext) !== we.HTML
				)
			)
				switch (this.fragmentContextID) {
					case k.TITLE:
					case k.TEXTAREA: {
						this.tokenizer.state = Jn.RCDATA
						break
					}
					case k.STYLE:
					case k.XMP:
					case k.IFRAME:
					case k.NOEMBED:
					case k.NOFRAMES:
					case k.NOSCRIPT: {
						this.tokenizer.state = Jn.RAWTEXT
						break
					}
					case k.SCRIPT: {
						this.tokenizer.state = Jn.SCRIPT_DATA
						break
					}
					case k.PLAINTEXT: {
						this.tokenizer.state = Jn.PLAINTEXT
						break
					}
				}
		}
		_setDocumentType(t) {
			const n = t.name || "",
				r = t.publicId || "",
				i = t.systemId || ""
			if ((this.treeAdapter.setDocumentType(this.document, n, r, i), t.location)) {
				const o = this.treeAdapter
					.getChildNodes(this.document)
					.find((s) => this.treeAdapter.isDocumentTypeNode(s))
				o && this.treeAdapter.setNodeSourceCodeLocation(o, t.location)
			}
		}
		_attachElementToTree(t, n) {
			if (this.options.sourceCodeLocationInfo) {
				const r = n && { ...n, startTag: n }
				this.treeAdapter.setNodeSourceCodeLocation(t, r)
			}
			if (this._shouldFosterParentOnInsertion()) this._fosterParentElement(t)
			else {
				const r = this.openElements.currentTmplContentOrNode
				this.treeAdapter.appendChild(r, t)
			}
		}
		_appendElement(t, n) {
			const r = this.treeAdapter.createElement(t.tagName, n, t.attrs)
			this._attachElementToTree(r, t.location)
		}
		_insertElement(t, n) {
			const r = this.treeAdapter.createElement(t.tagName, n, t.attrs)
			this._attachElementToTree(r, t.location), this.openElements.push(r, t.tagID)
		}
		_insertFakeElement(t, n) {
			const r = this.treeAdapter.createElement(t, we.HTML, [])
			this._attachElementToTree(r, null), this.openElements.push(r, n)
		}
		_insertTemplate(t) {
			const n = this.treeAdapter.createElement(t.tagName, we.HTML, t.attrs),
				r = this.treeAdapter.createDocumentFragment()
			this.treeAdapter.setTemplateContent(n, r),
				this._attachElementToTree(n, t.location),
				this.openElements.push(n, t.tagID),
				this.options.sourceCodeLocationInfo && this.treeAdapter.setNodeSourceCodeLocation(r, null)
		}
		_insertFakeRootElement() {
			const t = this.treeAdapter.createElement(se.HTML, we.HTML, [])
			this.options.sourceCodeLocationInfo && this.treeAdapter.setNodeSourceCodeLocation(t, null),
				this.treeAdapter.appendChild(this.openElements.current, t),
				this.openElements.push(t, k.HTML)
		}
		_appendCommentNode(t, n) {
			const r = this.treeAdapter.createCommentNode(t.data)
			this.treeAdapter.appendChild(n, r),
				this.options.sourceCodeLocationInfo &&
					this.treeAdapter.setNodeSourceCodeLocation(r, t.location)
		}
		_insertCharacters(t) {
			let n, r
			if (
				(this._shouldFosterParentOnInsertion()
					? (({ parent: n, beforeElement: r } = this._findFosterParentingLocation()),
					  r
							? this.treeAdapter.insertTextBefore(n, t.chars, r)
							: this.treeAdapter.insertText(n, t.chars))
					: ((n = this.openElements.currentTmplContentOrNode),
					  this.treeAdapter.insertText(n, t.chars)),
				!t.location)
			)
				return
			const i = this.treeAdapter.getChildNodes(n),
				a = r ? i.lastIndexOf(r) : i.length,
				o = i[a - 1]
			if (this.treeAdapter.getNodeSourceCodeLocation(o)) {
				const { endLine: l, endCol: u, endOffset: d } = t.location
				this.treeAdapter.updateNodeSourceCodeLocation(o, { endLine: l, endCol: u, endOffset: d })
			} else
				this.options.sourceCodeLocationInfo &&
					this.treeAdapter.setNodeSourceCodeLocation(o, t.location)
		}
		_adoptNodes(t, n) {
			for (let r = this.treeAdapter.getFirstChild(t); r; r = this.treeAdapter.getFirstChild(t))
				this.treeAdapter.detachNode(r), this.treeAdapter.appendChild(n, r)
		}
		_setEndLocation(t, n) {
			if (this.treeAdapter.getNodeSourceCodeLocation(t) && n.location) {
				const r = n.location,
					i = this.treeAdapter.getTagName(t),
					a =
						n.type === Ct.END_TAG && i === n.tagName
							? { endTag: { ...r }, endLine: r.endLine, endCol: r.endCol, endOffset: r.endOffset }
							: { endLine: r.startLine, endCol: r.startCol, endOffset: r.startOffset }
				this.treeAdapter.updateNodeSourceCodeLocation(t, a)
			}
		}
		shouldProcessStartTagTokenInForeignContent(t) {
			if (!this.currentNotInHTML) return !1
			let n, r
			return (
				this.openElements.stackTop === 0 && this.fragmentContext
					? ((n = this.fragmentContext), (r = this.fragmentContextID))
					: ({ current: n, currentTagId: r } = this.openElements),
				t.tagID === k.SVG &&
				this.treeAdapter.getTagName(n) === se.ANNOTATION_XML &&
				this.treeAdapter.getNamespaceURI(n) === we.MATHML
					? !1
					: this.tokenizer.inForeignNode ||
					  ((t.tagID === k.MGLYPH || t.tagID === k.MALIGNMARK) &&
							!this._isIntegrationPoint(r, n, we.HTML))
			)
		}
		_processToken(t) {
			switch (t.type) {
				case Ct.CHARACTER: {
					this.onCharacter(t)
					break
				}
				case Ct.NULL_CHARACTER: {
					this.onNullCharacter(t)
					break
				}
				case Ct.COMMENT: {
					this.onComment(t)
					break
				}
				case Ct.DOCTYPE: {
					this.onDoctype(t)
					break
				}
				case Ct.START_TAG: {
					this._processStartTag(t)
					break
				}
				case Ct.END_TAG: {
					this.onEndTag(t)
					break
				}
				case Ct.EOF: {
					this.onEof(t)
					break
				}
				case Ct.WHITESPACE_CHARACTER: {
					this.onWhitespaceCharacter(t)
					break
				}
			}
		}
		_isIntegrationPoint(t, n, r) {
			const i = this.treeAdapter.getNamespaceURI(n),
				a = this.treeAdapter.getAttrList(n)
			return hpt(t, i, a, r)
		}
		_reconstructActiveFormattingElements() {
			const t = this.activeFormattingElements.entries.length
			if (t) {
				const n = this.activeFormattingElements.entries.findIndex(
						(i) => i.type === Qo.Marker || this.openElements.contains(i.element),
					),
					r = n < 0 ? t - 1 : n - 1
				for (let i = r; i >= 0; i--) {
					const a = this.activeFormattingElements.entries[i]
					this._insertElement(a.token, this.treeAdapter.getNamespaceURI(a.element)),
						(a.element = this.openElements.current)
				}
			}
		}
		_closeTableCell() {
			this.openElements.generateImpliedEndTags(),
				this.openElements.popUntilTableCellPopped(),
				this.activeFormattingElements.clearToLastMarker(),
				(this.insertionMode = Q.IN_ROW)
		}
		_closePElement() {
			this.openElements.generateImpliedEndTagsWithExclusion(k.P),
				this.openElements.popUntilTagNamePopped(k.P)
		}
		_resetInsertionMode() {
			for (let t = this.openElements.stackTop; t >= 0; t--)
				switch (
					t === 0 && this.fragmentContext ? this.fragmentContextID : this.openElements.tagIDs[t]
				) {
					case k.TR: {
						this.insertionMode = Q.IN_ROW
						return
					}
					case k.TBODY:
					case k.THEAD:
					case k.TFOOT: {
						this.insertionMode = Q.IN_TABLE_BODY
						return
					}
					case k.CAPTION: {
						this.insertionMode = Q.IN_CAPTION
						return
					}
					case k.COLGROUP: {
						this.insertionMode = Q.IN_COLUMN_GROUP
						return
					}
					case k.TABLE: {
						this.insertionMode = Q.IN_TABLE
						return
					}
					case k.BODY: {
						this.insertionMode = Q.IN_BODY
						return
					}
					case k.FRAMESET: {
						this.insertionMode = Q.IN_FRAMESET
						return
					}
					case k.SELECT: {
						this._resetInsertionModeForSelect(t)
						return
					}
					case k.TEMPLATE: {
						this.insertionMode = this.tmplInsertionModeStack[0]
						return
					}
					case k.HTML: {
						this.insertionMode = this.headElement ? Q.AFTER_HEAD : Q.BEFORE_HEAD
						return
					}
					case k.TD:
					case k.TH: {
						if (t > 0) {
							this.insertionMode = Q.IN_CELL
							return
						}
						break
					}
					case k.HEAD: {
						if (t > 0) {
							this.insertionMode = Q.IN_HEAD
							return
						}
						break
					}
				}
			this.insertionMode = Q.IN_BODY
		}
		_resetInsertionModeForSelect(t) {
			if (t > 0)
				for (let n = t - 1; n > 0; n--) {
					const r = this.openElements.tagIDs[n]
					if (r === k.TEMPLATE) break
					if (r === k.TABLE) {
						this.insertionMode = Q.IN_SELECT_IN_TABLE
						return
					}
				}
			this.insertionMode = Q.IN_SELECT
		}
		_isElementCausesFosterParenting(t) {
			return VV.has(t)
		}
		_shouldFosterParentOnInsertion() {
			return (
				this.fosterParentingEnabled &&
				this._isElementCausesFosterParenting(this.openElements.currentTagId)
			)
		}
		_findFosterParentingLocation() {
			for (let t = this.openElements.stackTop; t >= 0; t--) {
				const n = this.openElements.items[t]
				switch (this.openElements.tagIDs[t]) {
					case k.TEMPLATE: {
						if (this.treeAdapter.getNamespaceURI(n) === we.HTML)
							return { parent: this.treeAdapter.getTemplateContent(n), beforeElement: null }
						break
					}
					case k.TABLE: {
						const r = this.treeAdapter.getParentNode(n)
						return r
							? { parent: r, beforeElement: n }
							: { parent: this.openElements.items[t - 1], beforeElement: null }
					}
				}
			}
			return { parent: this.openElements.items[0], beforeElement: null }
		}
		_fosterParentElement(t) {
			const n = this._findFosterParentingLocation()
			n.beforeElement
				? this.treeAdapter.insertBefore(n.parent, t, n.beforeElement)
				: this.treeAdapter.appendChild(n.parent, t)
		}
		_isSpecialElement(t, n) {
			const r = this.treeAdapter.getNamespaceURI(t)
			return Fft[r].has(n)
		}
		onCharacter(t) {
			if (((this.skipNextNewLine = !1), this.tokenizer.inForeignNode)) {
				Ght(this, t)
				return
			}
			switch (this.insertionMode) {
				case Q.INITIAL: {
					dm(this, t)
					break
				}
				case Q.BEFORE_HTML: {
					Gm(this, t)
					break
				}
				case Q.BEFORE_HEAD: {
					Km(this, t)
					break
				}
				case Q.IN_HEAD: {
					Qm(this, t)
					break
				}
				case Q.IN_HEAD_NO_SCRIPT: {
					Xm(this, t)
					break
				}
				case Q.AFTER_HEAD: {
					Jm(this, t)
					break
				}
				case Q.IN_BODY:
				case Q.IN_CAPTION:
				case Q.IN_CELL:
				case Q.IN_TEMPLATE: {
					YV(this, t)
					break
				}
				case Q.TEXT:
				case Q.IN_SELECT:
				case Q.IN_SELECT_IN_TABLE: {
					this._insertCharacters(t)
					break
				}
				case Q.IN_TABLE:
				case Q.IN_TABLE_BODY:
				case Q.IN_ROW: {
					Zk(this, t)
					break
				}
				case Q.IN_TABLE_TEXT: {
					ZV(this, t)
					break
				}
				case Q.IN_COLUMN_GROUP: {
					Pb(this, t)
					break
				}
				case Q.AFTER_BODY: {
					jb(this, t)
					break
				}
				case Q.AFTER_AFTER_BODY: {
					x1(this, t)
					break
				}
			}
		}
		onNullCharacter(t) {
			if (((this.skipNextNewLine = !1), this.tokenizer.inForeignNode)) {
				Yht(this, t)
				return
			}
			switch (this.insertionMode) {
				case Q.INITIAL: {
					dm(this, t)
					break
				}
				case Q.BEFORE_HTML: {
					Gm(this, t)
					break
				}
				case Q.BEFORE_HEAD: {
					Km(this, t)
					break
				}
				case Q.IN_HEAD: {
					Qm(this, t)
					break
				}
				case Q.IN_HEAD_NO_SCRIPT: {
					Xm(this, t)
					break
				}
				case Q.AFTER_HEAD: {
					Jm(this, t)
					break
				}
				case Q.TEXT: {
					this._insertCharacters(t)
					break
				}
				case Q.IN_TABLE:
				case Q.IN_TABLE_BODY:
				case Q.IN_ROW: {
					Zk(this, t)
					break
				}
				case Q.IN_COLUMN_GROUP: {
					Pb(this, t)
					break
				}
				case Q.AFTER_BODY: {
					jb(this, t)
					break
				}
				case Q.AFTER_AFTER_BODY: {
					x1(this, t)
					break
				}
			}
		}
		onComment(t) {
			if (((this.skipNextNewLine = !1), this.currentNotInHTML)) {
				bD(this, t)
				return
			}
			switch (this.insertionMode) {
				case Q.INITIAL:
				case Q.BEFORE_HTML:
				case Q.BEFORE_HEAD:
				case Q.IN_HEAD:
				case Q.IN_HEAD_NO_SCRIPT:
				case Q.AFTER_HEAD:
				case Q.IN_BODY:
				case Q.IN_TABLE:
				case Q.IN_CAPTION:
				case Q.IN_COLUMN_GROUP:
				case Q.IN_TABLE_BODY:
				case Q.IN_ROW:
				case Q.IN_CELL:
				case Q.IN_SELECT:
				case Q.IN_SELECT_IN_TABLE:
				case Q.IN_TEMPLATE:
				case Q.IN_FRAMESET:
				case Q.AFTER_FRAMESET: {
					bD(this, t)
					break
				}
				case Q.IN_TABLE_TEXT: {
					fm(this, t)
					break
				}
				case Q.AFTER_BODY: {
					kpt(this, t)
					break
				}
				case Q.AFTER_AFTER_BODY:
				case Q.AFTER_AFTER_FRAMESET: {
					Spt(this, t)
					break
				}
			}
		}
		onDoctype(t) {
			switch (((this.skipNextNewLine = !1), this.insertionMode)) {
				case Q.INITIAL: {
					Dpt(this, t)
					break
				}
				case Q.BEFORE_HEAD:
				case Q.IN_HEAD:
				case Q.IN_HEAD_NO_SCRIPT:
				case Q.AFTER_HEAD: {
					this._err(t, ve.misplacedDoctype)
					break
				}
				case Q.IN_TABLE_TEXT: {
					fm(this, t)
					break
				}
			}
		}
		onStartTag(t) {
			;(this.skipNextNewLine = !1),
				(this.currentToken = t),
				this._processStartTag(t),
				t.selfClosing &&
					!t.ackSelfClosing &&
					this._err(t, ve.nonVoidHtmlElementStartTagWithTrailingSolidus)
		}
		_processStartTag(t) {
			this.shouldProcessStartTagTokenInForeignContent(t)
				? Kht(this, t)
				: this._startTagOutsideForeignContent(t)
		}
		_startTagOutsideForeignContent(t) {
			switch (this.insertionMode) {
				case Q.INITIAL: {
					dm(this, t)
					break
				}
				case Q.BEFORE_HTML: {
					_pt(this, t)
					break
				}
				case Q.BEFORE_HEAD: {
					Apt(this, t)
					break
				}
				case Q.IN_HEAD: {
					Ro(this, t)
					break
				}
				case Q.IN_HEAD_NO_SCRIPT: {
					Ipt(this, t)
					break
				}
				case Q.AFTER_HEAD: {
					Lpt(this, t)
					break
				}
				case Q.IN_BODY: {
					si(this, t)
					break
				}
				case Q.IN_TABLE: {
					_p(this, t)
					break
				}
				case Q.IN_TABLE_TEXT: {
					fm(this, t)
					break
				}
				case Q.IN_CAPTION: {
					Nht(this, t)
					break
				}
				case Q.IN_COLUMN_GROUP: {
					NA(this, t)
					break
				}
				case Q.IN_TABLE_BODY: {
					Ow(this, t)
					break
				}
				case Q.IN_ROW: {
					Aw(this, t)
					break
				}
				case Q.IN_CELL: {
					Rht(this, t)
					break
				}
				case Q.IN_SELECT: {
					nW(this, t)
					break
				}
				case Q.IN_SELECT_IN_TABLE: {
					Pht(this, t)
					break
				}
				case Q.IN_TEMPLATE: {
					Fht(this, t)
					break
				}
				case Q.AFTER_BODY: {
					Hht(this, t)
					break
				}
				case Q.IN_FRAMESET: {
					$ht(this, t)
					break
				}
				case Q.AFTER_FRAMESET: {
					zht(this, t)
					break
				}
				case Q.AFTER_AFTER_BODY: {
					Vht(this, t)
					break
				}
				case Q.AFTER_AFTER_FRAMESET: {
					Wht(this, t)
					break
				}
			}
		}
		onEndTag(t) {
			;(this.skipNextNewLine = !1),
				(this.currentToken = t),
				this.currentNotInHTML ? Qht(this, t) : this._endTagOutsideForeignContent(t)
		}
		_endTagOutsideForeignContent(t) {
			switch (this.insertionMode) {
				case Q.INITIAL: {
					dm(this, t)
					break
				}
				case Q.BEFORE_HTML: {
					Opt(this, t)
					break
				}
				case Q.BEFORE_HEAD: {
					Npt(this, t)
					break
				}
				case Q.IN_HEAD: {
					Mpt(this, t)
					break
				}
				case Q.IN_HEAD_NO_SCRIPT: {
					Rpt(this, t)
					break
				}
				case Q.AFTER_HEAD: {
					Ppt(this, t)
					break
				}
				case Q.IN_BODY: {
					_w(this, t)
					break
				}
				case Q.TEXT: {
					wht(this, t)
					break
				}
				case Q.IN_TABLE: {
					Iv(this, t)
					break
				}
				case Q.IN_TABLE_TEXT: {
					fm(this, t)
					break
				}
				case Q.IN_CAPTION: {
					Mht(this, t)
					break
				}
				case Q.IN_COLUMN_GROUP: {
					Iht(this, t)
					break
				}
				case Q.IN_TABLE_BODY: {
					xD(this, t)
					break
				}
				case Q.IN_ROW: {
					tW(this, t)
					break
				}
				case Q.IN_CELL: {
					Lht(this, t)
					break
				}
				case Q.IN_SELECT: {
					rW(this, t)
					break
				}
				case Q.IN_SELECT_IN_TABLE: {
					jht(this, t)
					break
				}
				case Q.IN_TEMPLATE: {
					Bht(this, t)
					break
				}
				case Q.AFTER_BODY: {
					aW(this, t)
					break
				}
				case Q.IN_FRAMESET: {
					Uht(this, t)
					break
				}
				case Q.AFTER_FRAMESET: {
					qht(this, t)
					break
				}
				case Q.AFTER_AFTER_BODY: {
					x1(this, t)
					break
				}
			}
		}
		onEof(t) {
			switch (this.insertionMode) {
				case Q.INITIAL: {
					dm(this, t)
					break
				}
				case Q.BEFORE_HTML: {
					Gm(this, t)
					break
				}
				case Q.BEFORE_HEAD: {
					Km(this, t)
					break
				}
				case Q.IN_HEAD: {
					Qm(this, t)
					break
				}
				case Q.IN_HEAD_NO_SCRIPT: {
					Xm(this, t)
					break
				}
				case Q.AFTER_HEAD: {
					Jm(this, t)
					break
				}
				case Q.IN_BODY:
				case Q.IN_TABLE:
				case Q.IN_CAPTION:
				case Q.IN_COLUMN_GROUP:
				case Q.IN_TABLE_BODY:
				case Q.IN_ROW:
				case Q.IN_CELL:
				case Q.IN_SELECT:
				case Q.IN_SELECT_IN_TABLE: {
					XV(this, t)
					break
				}
				case Q.TEXT: {
					Eht(this, t)
					break
				}
				case Q.IN_TABLE_TEXT: {
					fm(this, t)
					break
				}
				case Q.IN_TEMPLATE: {
					iW(this, t)
					break
				}
				case Q.AFTER_BODY:
				case Q.IN_FRAMESET:
				case Q.AFTER_FRAMESET:
				case Q.AFTER_AFTER_BODY:
				case Q.AFTER_AFTER_FRAMESET: {
					AA(this, t)
					break
				}
			}
		}
		onWhitespaceCharacter(t) {
			if (
				this.skipNextNewLine &&
				((this.skipNextNewLine = !1), t.chars.charCodeAt(0) === U.LINE_FEED)
			) {
				if (t.chars.length === 1) return
				t.chars = t.chars.substr(1)
			}
			if (this.tokenizer.inForeignNode) {
				this._insertCharacters(t)
				return
			}
			switch (this.insertionMode) {
				case Q.IN_HEAD:
				case Q.IN_HEAD_NO_SCRIPT:
				case Q.AFTER_HEAD:
				case Q.TEXT:
				case Q.IN_COLUMN_GROUP:
				case Q.IN_SELECT:
				case Q.IN_SELECT_IN_TABLE:
				case Q.IN_FRAMESET:
				case Q.AFTER_FRAMESET: {
					this._insertCharacters(t)
					break
				}
				case Q.IN_BODY:
				case Q.IN_CAPTION:
				case Q.IN_CELL:
				case Q.IN_TEMPLATE:
				case Q.AFTER_BODY:
				case Q.AFTER_AFTER_BODY:
				case Q.AFTER_AFTER_FRAMESET: {
					WV(this, t)
					break
				}
				case Q.IN_TABLE:
				case Q.IN_TABLE_BODY:
				case Q.IN_ROW: {
					Zk(this, t)
					break
				}
				case Q.IN_TABLE_TEXT: {
					JV(this, t)
					break
				}
			}
		}
	}
	function bpt(e, t) {
		let n = e.activeFormattingElements.getElementEntryInScopeWithTagName(t.tagName)
		return (
			n
				? e.openElements.contains(n.element)
					? e.openElements.hasInScope(t.tagID) || (n = null)
					: (e.activeFormattingElements.removeEntry(n), (n = null))
				: QV(e, t),
			n
		)
	}
	function xpt(e, t) {
		let n = null,
			r = e.openElements.stackTop
		for (; r >= 0; r--) {
			const i = e.openElements.items[r]
			if (i === t.element) break
			e._isSpecialElement(i, e.openElements.tagIDs[r]) && (n = i)
		}
		return (
			n ||
				(e.openElements.shortenToLength(r < 0 ? 0 : r), e.activeFormattingElements.removeEntry(t)),
			n
		)
	}
	function wpt(e, t, n) {
		let r = t,
			i = e.openElements.getCommonAncestor(t)
		for (let a = 0, o = i; o !== n; a++, o = i) {
			i = e.openElements.getCommonAncestor(o)
			const s = e.activeFormattingElements.getElementEntry(o),
				l = s && a >= gpt
			!s || l
				? (l && e.activeFormattingElements.removeEntry(s), e.openElements.remove(o))
				: ((o = Ept(e, s)),
				  r === t && (e.activeFormattingElements.bookmark = s),
				  e.treeAdapter.detachNode(r),
				  e.treeAdapter.appendChild(o, r),
				  (r = o))
		}
		return r
	}
	function Ept(e, t) {
		const n = e.treeAdapter.getNamespaceURI(t.element),
			r = e.treeAdapter.createElement(t.token.tagName, n, t.token.attrs)
		return e.openElements.replace(t.element, r), (t.element = r), r
	}
	function Cpt(e, t, n) {
		const r = e.treeAdapter.getTagName(t),
			i = ah(r)
		if (e._isElementCausesFosterParenting(i)) e._fosterParentElement(n)
		else {
			const a = e.treeAdapter.getNamespaceURI(t)
			i === k.TEMPLATE && a === we.HTML && (t = e.treeAdapter.getTemplateContent(t)),
				e.treeAdapter.appendChild(t, n)
		}
	}
	function Tpt(e, t, n) {
		const r = e.treeAdapter.getNamespaceURI(n.element),
			{ token: i } = n,
			a = e.treeAdapter.createElement(i.tagName, r, i.attrs)
		e._adoptNodes(t, a),
			e.treeAdapter.appendChild(t, a),
			e.activeFormattingElements.insertElementAfterBookmark(a, i),
			e.activeFormattingElements.removeEntry(n),
			e.openElements.remove(n.element),
			e.openElements.insertAfter(t, a, i.tagID)
	}
	function OA(e, t) {
		for (let n = 0; n < vpt; n++) {
			const r = bpt(e, t)
			if (!r) break
			const i = xpt(e, r)
			if (!i) break
			e.activeFormattingElements.bookmark = r
			const a = wpt(e, i, r.element),
				o = e.openElements.getCommonAncestor(r.element)
			e.treeAdapter.detachNode(a), o && Cpt(e, o, a), Tpt(e, i, r)
		}
	}
	function bD(e, t) {
		e._appendCommentNode(t, e.openElements.currentTmplContentOrNode)
	}
	function kpt(e, t) {
		e._appendCommentNode(t, e.openElements.items[0])
	}
	function Spt(e, t) {
		e._appendCommentNode(t, e.document)
	}
	function AA(e, t) {
		if (((e.stopped = !0), t.location)) {
			const n = e.fragmentContext ? 0 : 2
			for (let r = e.openElements.stackTop; r >= n; r--)
				e._setEndLocation(e.openElements.items[r], t)
			if (!e.fragmentContext && e.openElements.stackTop >= 0) {
				const r = e.openElements.items[0],
					i = e.treeAdapter.getNodeSourceCodeLocation(r)
				if (i && !i.endTag && (e._setEndLocation(r, t), e.openElements.stackTop >= 1)) {
					const a = e.openElements.items[1],
						o = e.treeAdapter.getNodeSourceCodeLocation(a)
					o && !o.endTag && e._setEndLocation(a, t)
				}
			}
		}
	}
	function Dpt(e, t) {
		e._setDocumentType(t)
		const n = t.forceQuirks ? Ba.QUIRKS : rpt(t)
		npt(t) || e._err(t, ve.nonConformingDoctype),
			e.treeAdapter.setDocumentMode(e.document, n),
			(e.insertionMode = Q.BEFORE_HTML)
	}
	function dm(e, t) {
		e._err(t, ve.missingDoctype, !0),
			e.treeAdapter.setDocumentMode(e.document, Ba.QUIRKS),
			(e.insertionMode = Q.BEFORE_HTML),
			e._processToken(t)
	}
	function _pt(e, t) {
		t.tagID === k.HTML
			? (e._insertElement(t, we.HTML), (e.insertionMode = Q.BEFORE_HEAD))
			: Gm(e, t)
	}
	function Opt(e, t) {
		const n = t.tagID
		;(n === k.HTML || n === k.HEAD || n === k.BODY || n === k.BR) && Gm(e, t)
	}
	function Gm(e, t) {
		e._insertFakeRootElement(), (e.insertionMode = Q.BEFORE_HEAD), e._processToken(t)
	}
	function Apt(e, t) {
		switch (t.tagID) {
			case k.HTML: {
				si(e, t)
				break
			}
			case k.HEAD: {
				e._insertElement(t, we.HTML),
					(e.headElement = e.openElements.current),
					(e.insertionMode = Q.IN_HEAD)
				break
			}
			default:
				Km(e, t)
		}
	}
	function Npt(e, t) {
		const n = t.tagID
		n === k.HEAD || n === k.BODY || n === k.HTML || n === k.BR
			? Km(e, t)
			: e._err(t, ve.endTagWithoutMatchingOpenElement)
	}
	function Km(e, t) {
		e._insertFakeElement(se.HEAD, k.HEAD),
			(e.headElement = e.openElements.current),
			(e.insertionMode = Q.IN_HEAD),
			e._processToken(t)
	}
	function Ro(e, t) {
		switch (t.tagID) {
			case k.HTML: {
				si(e, t)
				break
			}
			case k.BASE:
			case k.BASEFONT:
			case k.BGSOUND:
			case k.LINK:
			case k.META: {
				e._appendElement(t, we.HTML), (t.ackSelfClosing = !0)
				break
			}
			case k.TITLE: {
				e._switchToTextParsing(t, Jn.RCDATA)
				break
			}
			case k.NOSCRIPT: {
				e.options.scriptingEnabled
					? e._switchToTextParsing(t, Jn.RAWTEXT)
					: (e._insertElement(t, we.HTML), (e.insertionMode = Q.IN_HEAD_NO_SCRIPT))
				break
			}
			case k.NOFRAMES:
			case k.STYLE: {
				e._switchToTextParsing(t, Jn.RAWTEXT)
				break
			}
			case k.SCRIPT: {
				e._switchToTextParsing(t, Jn.SCRIPT_DATA)
				break
			}
			case k.TEMPLATE: {
				e._insertTemplate(t),
					e.activeFormattingElements.insertMarker(),
					(e.framesetOk = !1),
					(e.insertionMode = Q.IN_TEMPLATE),
					e.tmplInsertionModeStack.unshift(Q.IN_TEMPLATE)
				break
			}
			case k.HEAD: {
				e._err(t, ve.misplacedStartTagForHeadElement)
				break
			}
			default:
				Qm(e, t)
		}
	}
	function Mpt(e, t) {
		switch (t.tagID) {
			case k.HEAD: {
				e.openElements.pop(), (e.insertionMode = Q.AFTER_HEAD)
				break
			}
			case k.BODY:
			case k.BR:
			case k.HTML: {
				Qm(e, t)
				break
			}
			case k.TEMPLATE: {
				Ld(e, t)
				break
			}
			default:
				e._err(t, ve.endTagWithoutMatchingOpenElement)
		}
	}
	function Ld(e, t) {
		e.openElements.tmplCount > 0
			? (e.openElements.generateImpliedEndTagsThoroughly(),
			  e.openElements.currentTagId !== k.TEMPLATE &&
					e._err(t, ve.closingOfElementWithOpenChildElements),
			  e.openElements.popUntilTagNamePopped(k.TEMPLATE),
			  e.activeFormattingElements.clearToLastMarker(),
			  e.tmplInsertionModeStack.shift(),
			  e._resetInsertionMode())
			: e._err(t, ve.endTagWithoutMatchingOpenElement)
	}
	function Qm(e, t) {
		e.openElements.pop(), (e.insertionMode = Q.AFTER_HEAD), e._processToken(t)
	}
	function Ipt(e, t) {
		switch (t.tagID) {
			case k.HTML: {
				si(e, t)
				break
			}
			case k.BASEFONT:
			case k.BGSOUND:
			case k.HEAD:
			case k.LINK:
			case k.META:
			case k.NOFRAMES:
			case k.STYLE: {
				Ro(e, t)
				break
			}
			case k.NOSCRIPT: {
				e._err(t, ve.nestedNoscriptInHead)
				break
			}
			default:
				Xm(e, t)
		}
	}
	function Rpt(e, t) {
		switch (t.tagID) {
			case k.NOSCRIPT: {
				e.openElements.pop(), (e.insertionMode = Q.IN_HEAD)
				break
			}
			case k.BR: {
				Xm(e, t)
				break
			}
			default:
				e._err(t, ve.endTagWithoutMatchingOpenElement)
		}
	}
	function Xm(e, t) {
		const n = t.type === Ct.EOF ? ve.openElementsLeftAfterEof : ve.disallowedContentInNoscriptInHead
		e._err(t, n), e.openElements.pop(), (e.insertionMode = Q.IN_HEAD), e._processToken(t)
	}
	function Lpt(e, t) {
		switch (t.tagID) {
			case k.HTML: {
				si(e, t)
				break
			}
			case k.BODY: {
				e._insertElement(t, we.HTML), (e.framesetOk = !1), (e.insertionMode = Q.IN_BODY)
				break
			}
			case k.FRAMESET: {
				e._insertElement(t, we.HTML), (e.insertionMode = Q.IN_FRAMESET)
				break
			}
			case k.BASE:
			case k.BASEFONT:
			case k.BGSOUND:
			case k.LINK:
			case k.META:
			case k.NOFRAMES:
			case k.SCRIPT:
			case k.STYLE:
			case k.TEMPLATE:
			case k.TITLE: {
				e._err(t, ve.abandonedHeadElementChild),
					e.openElements.push(e.headElement, k.HEAD),
					Ro(e, t),
					e.openElements.remove(e.headElement)
				break
			}
			case k.HEAD: {
				e._err(t, ve.misplacedStartTagForHeadElement)
				break
			}
			default:
				Jm(e, t)
		}
	}
	function Ppt(e, t) {
		switch (t.tagID) {
			case k.BODY:
			case k.HTML:
			case k.BR: {
				Jm(e, t)
				break
			}
			case k.TEMPLATE: {
				Ld(e, t)
				break
			}
			default:
				e._err(t, ve.endTagWithoutMatchingOpenElement)
		}
	}
	function Jm(e, t) {
		e._insertFakeElement(se.BODY, k.BODY), (e.insertionMode = Q.IN_BODY), Dw(e, t)
	}
	function Dw(e, t) {
		switch (t.type) {
			case Ct.CHARACTER: {
				YV(e, t)
				break
			}
			case Ct.WHITESPACE_CHARACTER: {
				WV(e, t)
				break
			}
			case Ct.COMMENT: {
				bD(e, t)
				break
			}
			case Ct.START_TAG: {
				si(e, t)
				break
			}
			case Ct.END_TAG: {
				_w(e, t)
				break
			}
			case Ct.EOF: {
				XV(e, t)
				break
			}
		}
	}
	function WV(e, t) {
		e._reconstructActiveFormattingElements(), e._insertCharacters(t)
	}
	function YV(e, t) {
		e._reconstructActiveFormattingElements(), e._insertCharacters(t), (e.framesetOk = !1)
	}
	function jpt(e, t) {
		e.openElements.tmplCount === 0 &&
			e.treeAdapter.adoptAttributes(e.openElements.items[0], t.attrs)
	}
	function Fpt(e, t) {
		const n = e.openElements.tryPeekProperlyNestedBodyElement()
		n &&
			e.openElements.tmplCount === 0 &&
			((e.framesetOk = !1), e.treeAdapter.adoptAttributes(n, t.attrs))
	}
	function Bpt(e, t) {
		const n = e.openElements.tryPeekProperlyNestedBodyElement()
		e.framesetOk &&
			n &&
			(e.treeAdapter.detachNode(n),
			e.openElements.popAllUpToHtmlElement(),
			e._insertElement(t, we.HTML),
			(e.insertionMode = Q.IN_FRAMESET))
	}
	function Hpt(e, t) {
		e.openElements.hasInButtonScope(k.P) && e._closePElement(), e._insertElement(t, we.HTML)
	}
	function $pt(e, t) {
		e.openElements.hasInButtonScope(k.P) && e._closePElement(),
			yD.has(e.openElements.currentTagId) && e.openElements.pop(),
			e._insertElement(t, we.HTML)
	}
	function Upt(e, t) {
		e.openElements.hasInButtonScope(k.P) && e._closePElement(),
			e._insertElement(t, we.HTML),
			(e.skipNextNewLine = !0),
			(e.framesetOk = !1)
	}
	function zpt(e, t) {
		const n = e.openElements.tmplCount > 0
		;(!e.formElement || n) &&
			(e.openElements.hasInButtonScope(k.P) && e._closePElement(),
			e._insertElement(t, we.HTML),
			n || (e.formElement = e.openElements.current))
	}
	function qpt(e, t) {
		e.framesetOk = !1
		const n = t.tagID
		for (let r = e.openElements.stackTop; r >= 0; r--) {
			const i = e.openElements.tagIDs[r]
			if (
				(n === k.LI && i === k.LI) ||
				((n === k.DD || n === k.DT) && (i === k.DD || i === k.DT))
			) {
				e.openElements.generateImpliedEndTagsWithExclusion(i),
					e.openElements.popUntilTagNamePopped(i)
				break
			}
			if (
				i !== k.ADDRESS &&
				i !== k.DIV &&
				i !== k.P &&
				e._isSpecialElement(e.openElements.items[r], i)
			)
				break
		}
		e.openElements.hasInButtonScope(k.P) && e._closePElement(), e._insertElement(t, we.HTML)
	}
	function Vpt(e, t) {
		e.openElements.hasInButtonScope(k.P) && e._closePElement(),
			e._insertElement(t, we.HTML),
			(e.tokenizer.state = Jn.PLAINTEXT)
	}
	function Wpt(e, t) {
		e.openElements.hasInScope(k.BUTTON) &&
			(e.openElements.generateImpliedEndTags(), e.openElements.popUntilTagNamePopped(k.BUTTON)),
			e._reconstructActiveFormattingElements(),
			e._insertElement(t, we.HTML),
			(e.framesetOk = !1)
	}
	function Ypt(e, t) {
		const n = e.activeFormattingElements.getElementEntryInScopeWithTagName(se.A)
		n && (OA(e, t), e.openElements.remove(n.element), e.activeFormattingElements.removeEntry(n)),
			e._reconstructActiveFormattingElements(),
			e._insertElement(t, we.HTML),
			e.activeFormattingElements.pushElement(e.openElements.current, t)
	}
	function Gpt(e, t) {
		e._reconstructActiveFormattingElements(),
			e._insertElement(t, we.HTML),
			e.activeFormattingElements.pushElement(e.openElements.current, t)
	}
	function Kpt(e, t) {
		e._reconstructActiveFormattingElements(),
			e.openElements.hasInScope(k.NOBR) && (OA(e, t), e._reconstructActiveFormattingElements()),
			e._insertElement(t, we.HTML),
			e.activeFormattingElements.pushElement(e.openElements.current, t)
	}
	function Qpt(e, t) {
		e._reconstructActiveFormattingElements(),
			e._insertElement(t, we.HTML),
			e.activeFormattingElements.insertMarker(),
			(e.framesetOk = !1)
	}
	function Xpt(e, t) {
		e.treeAdapter.getDocumentMode(e.document) !== Ba.QUIRKS &&
			e.openElements.hasInButtonScope(k.P) &&
			e._closePElement(),
			e._insertElement(t, we.HTML),
			(e.framesetOk = !1),
			(e.insertionMode = Q.IN_TABLE)
	}
	function GV(e, t) {
		e._reconstructActiveFormattingElements(),
			e._appendElement(t, we.HTML),
			(e.framesetOk = !1),
			(t.ackSelfClosing = !0)
	}
	function KV(e) {
		const t = RV(e, nd.TYPE)
		return t != null && t.toLowerCase() === mpt
	}
	function Jpt(e, t) {
		e._reconstructActiveFormattingElements(),
			e._appendElement(t, we.HTML),
			KV(t) || (e.framesetOk = !1),
			(t.ackSelfClosing = !0)
	}
	function Zpt(e, t) {
		e._appendElement(t, we.HTML), (t.ackSelfClosing = !0)
	}
	function eht(e, t) {
		e.openElements.hasInButtonScope(k.P) && e._closePElement(),
			e._appendElement(t, we.HTML),
			(e.framesetOk = !1),
			(t.ackSelfClosing = !0)
	}
	function tht(e, t) {
		;(t.tagName = se.IMG), (t.tagID = k.IMG), GV(e, t)
	}
	function nht(e, t) {
		e._insertElement(t, we.HTML),
			(e.skipNextNewLine = !0),
			(e.tokenizer.state = Jn.RCDATA),
			(e.originalInsertionMode = e.insertionMode),
			(e.framesetOk = !1),
			(e.insertionMode = Q.TEXT)
	}
	function rht(e, t) {
		e.openElements.hasInButtonScope(k.P) && e._closePElement(),
			e._reconstructActiveFormattingElements(),
			(e.framesetOk = !1),
			e._switchToTextParsing(t, Jn.RAWTEXT)
	}
	function iht(e, t) {
		;(e.framesetOk = !1), e._switchToTextParsing(t, Jn.RAWTEXT)
	}
	function cF(e, t) {
		e._switchToTextParsing(t, Jn.RAWTEXT)
	}
	function aht(e, t) {
		e._reconstructActiveFormattingElements(),
			e._insertElement(t, we.HTML),
			(e.framesetOk = !1),
			(e.insertionMode =
				e.insertionMode === Q.IN_TABLE ||
				e.insertionMode === Q.IN_CAPTION ||
				e.insertionMode === Q.IN_TABLE_BODY ||
				e.insertionMode === Q.IN_ROW ||
				e.insertionMode === Q.IN_CELL
					? Q.IN_SELECT_IN_TABLE
					: Q.IN_SELECT)
	}
	function oht(e, t) {
		e.openElements.currentTagId === k.OPTION && e.openElements.pop(),
			e._reconstructActiveFormattingElements(),
			e._insertElement(t, we.HTML)
	}
	function sht(e, t) {
		e.openElements.hasInScope(k.RUBY) && e.openElements.generateImpliedEndTags(),
			e._insertElement(t, we.HTML)
	}
	function lht(e, t) {
		e.openElements.hasInScope(k.RUBY) && e.openElements.generateImpliedEndTagsWithExclusion(k.RTC),
			e._insertElement(t, we.HTML)
	}
	function uht(e, t) {
		e._reconstructActiveFormattingElements(),
			zV(t),
			_A(t),
			t.selfClosing ? e._appendElement(t, we.MATHML) : e._insertElement(t, we.MATHML),
			(t.ackSelfClosing = !0)
	}
	function cht(e, t) {
		e._reconstructActiveFormattingElements(),
			qV(t),
			_A(t),
			t.selfClosing ? e._appendElement(t, we.SVG) : e._insertElement(t, we.SVG),
			(t.ackSelfClosing = !0)
	}
	function dF(e, t) {
		e._reconstructActiveFormattingElements(), e._insertElement(t, we.HTML)
	}
	function si(e, t) {
		switch (t.tagID) {
			case k.I:
			case k.S:
			case k.B:
			case k.U:
			case k.EM:
			case k.TT:
			case k.BIG:
			case k.CODE:
			case k.FONT:
			case k.SMALL:
			case k.STRIKE:
			case k.STRONG: {
				Gpt(e, t)
				break
			}
			case k.A: {
				Ypt(e, t)
				break
			}
			case k.H1:
			case k.H2:
			case k.H3:
			case k.H4:
			case k.H5:
			case k.H6: {
				$pt(e, t)
				break
			}
			case k.P:
			case k.DL:
			case k.OL:
			case k.UL:
			case k.DIV:
			case k.DIR:
			case k.NAV:
			case k.MAIN:
			case k.MENU:
			case k.ASIDE:
			case k.CENTER:
			case k.FIGURE:
			case k.FOOTER:
			case k.HEADER:
			case k.HGROUP:
			case k.DIALOG:
			case k.DETAILS:
			case k.ADDRESS:
			case k.ARTICLE:
			case k.SEARCH:
			case k.SECTION:
			case k.SUMMARY:
			case k.FIELDSET:
			case k.BLOCKQUOTE:
			case k.FIGCAPTION: {
				Hpt(e, t)
				break
			}
			case k.LI:
			case k.DD:
			case k.DT: {
				qpt(e, t)
				break
			}
			case k.BR:
			case k.IMG:
			case k.WBR:
			case k.AREA:
			case k.EMBED:
			case k.KEYGEN: {
				GV(e, t)
				break
			}
			case k.HR: {
				eht(e, t)
				break
			}
			case k.RB:
			case k.RTC: {
				sht(e, t)
				break
			}
			case k.RT:
			case k.RP: {
				lht(e, t)
				break
			}
			case k.PRE:
			case k.LISTING: {
				Upt(e, t)
				break
			}
			case k.XMP: {
				rht(e, t)
				break
			}
			case k.SVG: {
				cht(e, t)
				break
			}
			case k.HTML: {
				jpt(e, t)
				break
			}
			case k.BASE:
			case k.LINK:
			case k.META:
			case k.STYLE:
			case k.TITLE:
			case k.SCRIPT:
			case k.BGSOUND:
			case k.BASEFONT:
			case k.TEMPLATE: {
				Ro(e, t)
				break
			}
			case k.BODY: {
				Fpt(e, t)
				break
			}
			case k.FORM: {
				zpt(e, t)
				break
			}
			case k.NOBR: {
				Kpt(e, t)
				break
			}
			case k.MATH: {
				uht(e, t)
				break
			}
			case k.TABLE: {
				Xpt(e, t)
				break
			}
			case k.INPUT: {
				Jpt(e, t)
				break
			}
			case k.PARAM:
			case k.TRACK:
			case k.SOURCE: {
				Zpt(e, t)
				break
			}
			case k.IMAGE: {
				tht(e, t)
				break
			}
			case k.BUTTON: {
				Wpt(e, t)
				break
			}
			case k.APPLET:
			case k.OBJECT:
			case k.MARQUEE: {
				Qpt(e, t)
				break
			}
			case k.IFRAME: {
				iht(e, t)
				break
			}
			case k.SELECT: {
				aht(e, t)
				break
			}
			case k.OPTION:
			case k.OPTGROUP: {
				oht(e, t)
				break
			}
			case k.NOEMBED:
			case k.NOFRAMES: {
				cF(e, t)
				break
			}
			case k.FRAMESET: {
				Bpt(e, t)
				break
			}
			case k.TEXTAREA: {
				nht(e, t)
				break
			}
			case k.NOSCRIPT: {
				e.options.scriptingEnabled ? cF(e, t) : dF(e, t)
				break
			}
			case k.PLAINTEXT: {
				Vpt(e, t)
				break
			}
			case k.COL:
			case k.TH:
			case k.TD:
			case k.TR:
			case k.HEAD:
			case k.FRAME:
			case k.TBODY:
			case k.TFOOT:
			case k.THEAD:
			case k.CAPTION:
			case k.COLGROUP:
				break
			default:
				dF(e, t)
		}
	}
	function dht(e, t) {
		if (
			e.openElements.hasInScope(k.BODY) &&
			((e.insertionMode = Q.AFTER_BODY), e.options.sourceCodeLocationInfo)
		) {
			const n = e.openElements.tryPeekProperlyNestedBodyElement()
			n && e._setEndLocation(n, t)
		}
	}
	function fht(e, t) {
		e.openElements.hasInScope(k.BODY) && ((e.insertionMode = Q.AFTER_BODY), aW(e, t))
	}
	function pht(e, t) {
		const n = t.tagID
		e.openElements.hasInScope(n) &&
			(e.openElements.generateImpliedEndTags(), e.openElements.popUntilTagNamePopped(n))
	}
	function hht(e) {
		const t = e.openElements.tmplCount > 0,
			{ formElement: n } = e
		t || (e.formElement = null),
			(n || t) &&
				e.openElements.hasInScope(k.FORM) &&
				(e.openElements.generateImpliedEndTags(),
				t ? e.openElements.popUntilTagNamePopped(k.FORM) : n && e.openElements.remove(n))
	}
	function mht(e) {
		e.openElements.hasInButtonScope(k.P) || e._insertFakeElement(se.P, k.P), e._closePElement()
	}
	function vht(e) {
		e.openElements.hasInListItemScope(k.LI) &&
			(e.openElements.generateImpliedEndTagsWithExclusion(k.LI),
			e.openElements.popUntilTagNamePopped(k.LI))
	}
	function ght(e, t) {
		const n = t.tagID
		e.openElements.hasInScope(n) &&
			(e.openElements.generateImpliedEndTagsWithExclusion(n),
			e.openElements.popUntilTagNamePopped(n))
	}
	function yht(e) {
		e.openElements.hasNumberedHeaderInScope() &&
			(e.openElements.generateImpliedEndTags(), e.openElements.popUntilNumberedHeaderPopped())
	}
	function bht(e, t) {
		const n = t.tagID
		e.openElements.hasInScope(n) &&
			(e.openElements.generateImpliedEndTags(),
			e.openElements.popUntilTagNamePopped(n),
			e.activeFormattingElements.clearToLastMarker())
	}
	function xht(e) {
		e._reconstructActiveFormattingElements(),
			e._insertFakeElement(se.BR, k.BR),
			e.openElements.pop(),
			(e.framesetOk = !1)
	}
	function QV(e, t) {
		const n = t.tagName,
			r = t.tagID
		for (let i = e.openElements.stackTop; i > 0; i--) {
			const a = e.openElements.items[i],
				o = e.openElements.tagIDs[i]
			if (r === o && (r !== k.UNKNOWN || e.treeAdapter.getTagName(a) === n)) {
				e.openElements.generateImpliedEndTagsWithExclusion(r),
					e.openElements.stackTop >= i && e.openElements.shortenToLength(i)
				break
			}
			if (e._isSpecialElement(a, o)) break
		}
	}
	function _w(e, t) {
		switch (t.tagID) {
			case k.A:
			case k.B:
			case k.I:
			case k.S:
			case k.U:
			case k.EM:
			case k.TT:
			case k.BIG:
			case k.CODE:
			case k.FONT:
			case k.NOBR:
			case k.SMALL:
			case k.STRIKE:
			case k.STRONG: {
				OA(e, t)
				break
			}
			case k.P: {
				mht(e)
				break
			}
			case k.DL:
			case k.UL:
			case k.OL:
			case k.DIR:
			case k.DIV:
			case k.NAV:
			case k.PRE:
			case k.MAIN:
			case k.MENU:
			case k.ASIDE:
			case k.BUTTON:
			case k.CENTER:
			case k.FIGURE:
			case k.FOOTER:
			case k.HEADER:
			case k.HGROUP:
			case k.DIALOG:
			case k.ADDRESS:
			case k.ARTICLE:
			case k.DETAILS:
			case k.SEARCH:
			case k.SECTION:
			case k.SUMMARY:
			case k.LISTING:
			case k.FIELDSET:
			case k.BLOCKQUOTE:
			case k.FIGCAPTION: {
				pht(e, t)
				break
			}
			case k.LI: {
				vht(e)
				break
			}
			case k.DD:
			case k.DT: {
				ght(e, t)
				break
			}
			case k.H1:
			case k.H2:
			case k.H3:
			case k.H4:
			case k.H5:
			case k.H6: {
				yht(e)
				break
			}
			case k.BR: {
				xht(e)
				break
			}
			case k.BODY: {
				dht(e, t)
				break
			}
			case k.HTML: {
				fht(e, t)
				break
			}
			case k.FORM: {
				hht(e)
				break
			}
			case k.APPLET:
			case k.OBJECT:
			case k.MARQUEE: {
				bht(e, t)
				break
			}
			case k.TEMPLATE: {
				Ld(e, t)
				break
			}
			default:
				QV(e, t)
		}
	}
	function XV(e, t) {
		e.tmplInsertionModeStack.length > 0 ? iW(e, t) : AA(e, t)
	}
	function wht(e, t) {
		var n
		t.tagID === k.SCRIPT &&
			((n = e.scriptHandler) === null || n === void 0 || n.call(e, e.openElements.current)),
			e.openElements.pop(),
			(e.insertionMode = e.originalInsertionMode)
	}
	function Eht(e, t) {
		e._err(t, ve.eofInElementThatCanContainOnlyText),
			e.openElements.pop(),
			(e.insertionMode = e.originalInsertionMode),
			e.onEof(t)
	}
	function Zk(e, t) {
		if (VV.has(e.openElements.currentTagId))
			switch (
				((e.pendingCharacterTokens.length = 0),
				(e.hasNonWhitespacePendingCharacterToken = !1),
				(e.originalInsertionMode = e.insertionMode),
				(e.insertionMode = Q.IN_TABLE_TEXT),
				t.type)
			) {
				case Ct.CHARACTER: {
					ZV(e, t)
					break
				}
				case Ct.WHITESPACE_CHARACTER: {
					JV(e, t)
					break
				}
			}
		else xg(e, t)
	}
	function Cht(e, t) {
		e.openElements.clearBackToTableContext(),
			e.activeFormattingElements.insertMarker(),
			e._insertElement(t, we.HTML),
			(e.insertionMode = Q.IN_CAPTION)
	}
	function Tht(e, t) {
		e.openElements.clearBackToTableContext(),
			e._insertElement(t, we.HTML),
			(e.insertionMode = Q.IN_COLUMN_GROUP)
	}
	function kht(e, t) {
		e.openElements.clearBackToTableContext(),
			e._insertFakeElement(se.COLGROUP, k.COLGROUP),
			(e.insertionMode = Q.IN_COLUMN_GROUP),
			NA(e, t)
	}
	function Sht(e, t) {
		e.openElements.clearBackToTableContext(),
			e._insertElement(t, we.HTML),
			(e.insertionMode = Q.IN_TABLE_BODY)
	}
	function Dht(e, t) {
		e.openElements.clearBackToTableContext(),
			e._insertFakeElement(se.TBODY, k.TBODY),
			(e.insertionMode = Q.IN_TABLE_BODY),
			Ow(e, t)
	}
	function _ht(e, t) {
		e.openElements.hasInTableScope(k.TABLE) &&
			(e.openElements.popUntilTagNamePopped(k.TABLE),
			e._resetInsertionMode(),
			e._processStartTag(t))
	}
	function Oht(e, t) {
		KV(t) ? e._appendElement(t, we.HTML) : xg(e, t), (t.ackSelfClosing = !0)
	}
	function Aht(e, t) {
		!e.formElement &&
			e.openElements.tmplCount === 0 &&
			(e._insertElement(t, we.HTML), (e.formElement = e.openElements.current), e.openElements.pop())
	}
	function _p(e, t) {
		switch (t.tagID) {
			case k.TD:
			case k.TH:
			case k.TR: {
				Dht(e, t)
				break
			}
			case k.STYLE:
			case k.SCRIPT:
			case k.TEMPLATE: {
				Ro(e, t)
				break
			}
			case k.COL: {
				kht(e, t)
				break
			}
			case k.FORM: {
				Aht(e, t)
				break
			}
			case k.TABLE: {
				_ht(e, t)
				break
			}
			case k.TBODY:
			case k.TFOOT:
			case k.THEAD: {
				Sht(e, t)
				break
			}
			case k.INPUT: {
				Oht(e, t)
				break
			}
			case k.CAPTION: {
				Cht(e, t)
				break
			}
			case k.COLGROUP: {
				Tht(e, t)
				break
			}
			default:
				xg(e, t)
		}
	}
	function Iv(e, t) {
		switch (t.tagID) {
			case k.TABLE: {
				e.openElements.hasInTableScope(k.TABLE) &&
					(e.openElements.popUntilTagNamePopped(k.TABLE), e._resetInsertionMode())
				break
			}
			case k.TEMPLATE: {
				Ld(e, t)
				break
			}
			case k.BODY:
			case k.CAPTION:
			case k.COL:
			case k.COLGROUP:
			case k.HTML:
			case k.TBODY:
			case k.TD:
			case k.TFOOT:
			case k.TH:
			case k.THEAD:
			case k.TR:
				break
			default:
				xg(e, t)
		}
	}
	function xg(e, t) {
		const n = e.fosterParentingEnabled
		;(e.fosterParentingEnabled = !0), Dw(e, t), (e.fosterParentingEnabled = n)
	}
	function JV(e, t) {
		e.pendingCharacterTokens.push(t)
	}
	function ZV(e, t) {
		e.pendingCharacterTokens.push(t), (e.hasNonWhitespacePendingCharacterToken = !0)
	}
	function fm(e, t) {
		let n = 0
		if (e.hasNonWhitespacePendingCharacterToken)
			for (; n < e.pendingCharacterTokens.length; n++) xg(e, e.pendingCharacterTokens[n])
		else
			for (; n < e.pendingCharacterTokens.length; n++)
				e._insertCharacters(e.pendingCharacterTokens[n])
		;(e.insertionMode = e.originalInsertionMode), e._processToken(t)
	}
	const eW = new Set([k.CAPTION, k.COL, k.COLGROUP, k.TBODY, k.TD, k.TFOOT, k.TH, k.THEAD, k.TR])
	function Nht(e, t) {
		const n = t.tagID
		eW.has(n)
			? e.openElements.hasInTableScope(k.CAPTION) &&
			  (e.openElements.generateImpliedEndTags(),
			  e.openElements.popUntilTagNamePopped(k.CAPTION),
			  e.activeFormattingElements.clearToLastMarker(),
			  (e.insertionMode = Q.IN_TABLE),
			  _p(e, t))
			: si(e, t)
	}
	function Mht(e, t) {
		const n = t.tagID
		switch (n) {
			case k.CAPTION:
			case k.TABLE: {
				e.openElements.hasInTableScope(k.CAPTION) &&
					(e.openElements.generateImpliedEndTags(),
					e.openElements.popUntilTagNamePopped(k.CAPTION),
					e.activeFormattingElements.clearToLastMarker(),
					(e.insertionMode = Q.IN_TABLE),
					n === k.TABLE && Iv(e, t))
				break
			}
			case k.BODY:
			case k.COL:
			case k.COLGROUP:
			case k.HTML:
			case k.TBODY:
			case k.TD:
			case k.TFOOT:
			case k.TH:
			case k.THEAD:
			case k.TR:
				break
			default:
				_w(e, t)
		}
	}
	function NA(e, t) {
		switch (t.tagID) {
			case k.HTML: {
				si(e, t)
				break
			}
			case k.COL: {
				e._appendElement(t, we.HTML), (t.ackSelfClosing = !0)
				break
			}
			case k.TEMPLATE: {
				Ro(e, t)
				break
			}
			default:
				Pb(e, t)
		}
	}
	function Iht(e, t) {
		switch (t.tagID) {
			case k.COLGROUP: {
				e.openElements.currentTagId === k.COLGROUP &&
					(e.openElements.pop(), (e.insertionMode = Q.IN_TABLE))
				break
			}
			case k.TEMPLATE: {
				Ld(e, t)
				break
			}
			case k.COL:
				break
			default:
				Pb(e, t)
		}
	}
	function Pb(e, t) {
		e.openElements.currentTagId === k.COLGROUP &&
			(e.openElements.pop(), (e.insertionMode = Q.IN_TABLE), e._processToken(t))
	}
	function Ow(e, t) {
		switch (t.tagID) {
			case k.TR: {
				e.openElements.clearBackToTableBodyContext(),
					e._insertElement(t, we.HTML),
					(e.insertionMode = Q.IN_ROW)
				break
			}
			case k.TH:
			case k.TD: {
				e.openElements.clearBackToTableBodyContext(),
					e._insertFakeElement(se.TR, k.TR),
					(e.insertionMode = Q.IN_ROW),
					Aw(e, t)
				break
			}
			case k.CAPTION:
			case k.COL:
			case k.COLGROUP:
			case k.TBODY:
			case k.TFOOT:
			case k.THEAD: {
				e.openElements.hasTableBodyContextInTableScope() &&
					(e.openElements.clearBackToTableBodyContext(),
					e.openElements.pop(),
					(e.insertionMode = Q.IN_TABLE),
					_p(e, t))
				break
			}
			default:
				_p(e, t)
		}
	}
	function xD(e, t) {
		const n = t.tagID
		switch (t.tagID) {
			case k.TBODY:
			case k.TFOOT:
			case k.THEAD: {
				e.openElements.hasInTableScope(n) &&
					(e.openElements.clearBackToTableBodyContext(),
					e.openElements.pop(),
					(e.insertionMode = Q.IN_TABLE))
				break
			}
			case k.TABLE: {
				e.openElements.hasTableBodyContextInTableScope() &&
					(e.openElements.clearBackToTableBodyContext(),
					e.openElements.pop(),
					(e.insertionMode = Q.IN_TABLE),
					Iv(e, t))
				break
			}
			case k.BODY:
			case k.CAPTION:
			case k.COL:
			case k.COLGROUP:
			case k.HTML:
			case k.TD:
			case k.TH:
			case k.TR:
				break
			default:
				Iv(e, t)
		}
	}
	function Aw(e, t) {
		switch (t.tagID) {
			case k.TH:
			case k.TD: {
				e.openElements.clearBackToTableRowContext(),
					e._insertElement(t, we.HTML),
					(e.insertionMode = Q.IN_CELL),
					e.activeFormattingElements.insertMarker()
				break
			}
			case k.CAPTION:
			case k.COL:
			case k.COLGROUP:
			case k.TBODY:
			case k.TFOOT:
			case k.THEAD:
			case k.TR: {
				e.openElements.hasInTableScope(k.TR) &&
					(e.openElements.clearBackToTableRowContext(),
					e.openElements.pop(),
					(e.insertionMode = Q.IN_TABLE_BODY),
					Ow(e, t))
				break
			}
			default:
				_p(e, t)
		}
	}
	function tW(e, t) {
		switch (t.tagID) {
			case k.TR: {
				e.openElements.hasInTableScope(k.TR) &&
					(e.openElements.clearBackToTableRowContext(),
					e.openElements.pop(),
					(e.insertionMode = Q.IN_TABLE_BODY))
				break
			}
			case k.TABLE: {
				e.openElements.hasInTableScope(k.TR) &&
					(e.openElements.clearBackToTableRowContext(),
					e.openElements.pop(),
					(e.insertionMode = Q.IN_TABLE_BODY),
					xD(e, t))
				break
			}
			case k.TBODY:
			case k.TFOOT:
			case k.THEAD: {
				;(e.openElements.hasInTableScope(t.tagID) || e.openElements.hasInTableScope(k.TR)) &&
					(e.openElements.clearBackToTableRowContext(),
					e.openElements.pop(),
					(e.insertionMode = Q.IN_TABLE_BODY),
					xD(e, t))
				break
			}
			case k.BODY:
			case k.CAPTION:
			case k.COL:
			case k.COLGROUP:
			case k.HTML:
			case k.TD:
			case k.TH:
				break
			default:
				Iv(e, t)
		}
	}
	function Rht(e, t) {
		const n = t.tagID
		eW.has(n)
			? (e.openElements.hasInTableScope(k.TD) || e.openElements.hasInTableScope(k.TH)) &&
			  (e._closeTableCell(), Aw(e, t))
			: si(e, t)
	}
	function Lht(e, t) {
		const n = t.tagID
		switch (n) {
			case k.TD:
			case k.TH: {
				e.openElements.hasInTableScope(n) &&
					(e.openElements.generateImpliedEndTags(),
					e.openElements.popUntilTagNamePopped(n),
					e.activeFormattingElements.clearToLastMarker(),
					(e.insertionMode = Q.IN_ROW))
				break
			}
			case k.TABLE:
			case k.TBODY:
			case k.TFOOT:
			case k.THEAD:
			case k.TR: {
				e.openElements.hasInTableScope(n) && (e._closeTableCell(), tW(e, t))
				break
			}
			case k.BODY:
			case k.CAPTION:
			case k.COL:
			case k.COLGROUP:
			case k.HTML:
				break
			default:
				_w(e, t)
		}
	}
	function nW(e, t) {
		switch (t.tagID) {
			case k.HTML: {
				si(e, t)
				break
			}
			case k.OPTION: {
				e.openElements.currentTagId === k.OPTION && e.openElements.pop(),
					e._insertElement(t, we.HTML)
				break
			}
			case k.OPTGROUP: {
				e.openElements.currentTagId === k.OPTION && e.openElements.pop(),
					e.openElements.currentTagId === k.OPTGROUP && e.openElements.pop(),
					e._insertElement(t, we.HTML)
				break
			}
			case k.HR: {
				e.openElements.currentTagId === k.OPTION && e.openElements.pop(),
					e.openElements.currentTagId === k.OPTGROUP && e.openElements.pop(),
					e._appendElement(t, we.HTML),
					(t.ackSelfClosing = !0)
				break
			}
			case k.INPUT:
			case k.KEYGEN:
			case k.TEXTAREA:
			case k.SELECT: {
				e.openElements.hasInSelectScope(k.SELECT) &&
					(e.openElements.popUntilTagNamePopped(k.SELECT),
					e._resetInsertionMode(),
					t.tagID !== k.SELECT && e._processStartTag(t))
				break
			}
			case k.SCRIPT:
			case k.TEMPLATE: {
				Ro(e, t)
				break
			}
		}
	}
	function rW(e, t) {
		switch (t.tagID) {
			case k.OPTGROUP: {
				e.openElements.stackTop > 0 &&
					e.openElements.currentTagId === k.OPTION &&
					e.openElements.tagIDs[e.openElements.stackTop - 1] === k.OPTGROUP &&
					e.openElements.pop(),
					e.openElements.currentTagId === k.OPTGROUP && e.openElements.pop()
				break
			}
			case k.OPTION: {
				e.openElements.currentTagId === k.OPTION && e.openElements.pop()
				break
			}
			case k.SELECT: {
				e.openElements.hasInSelectScope(k.SELECT) &&
					(e.openElements.popUntilTagNamePopped(k.SELECT), e._resetInsertionMode())
				break
			}
			case k.TEMPLATE: {
				Ld(e, t)
				break
			}
		}
	}
	function Pht(e, t) {
		const n = t.tagID
		n === k.CAPTION ||
		n === k.TABLE ||
		n === k.TBODY ||
		n === k.TFOOT ||
		n === k.THEAD ||
		n === k.TR ||
		n === k.TD ||
		n === k.TH
			? (e.openElements.popUntilTagNamePopped(k.SELECT),
			  e._resetInsertionMode(),
			  e._processStartTag(t))
			: nW(e, t)
	}
	function jht(e, t) {
		const n = t.tagID
		n === k.CAPTION ||
		n === k.TABLE ||
		n === k.TBODY ||
		n === k.TFOOT ||
		n === k.THEAD ||
		n === k.TR ||
		n === k.TD ||
		n === k.TH
			? e.openElements.hasInTableScope(n) &&
			  (e.openElements.popUntilTagNamePopped(k.SELECT), e._resetInsertionMode(), e.onEndTag(t))
			: rW(e, t)
	}
	function Fht(e, t) {
		switch (t.tagID) {
			case k.BASE:
			case k.BASEFONT:
			case k.BGSOUND:
			case k.LINK:
			case k.META:
			case k.NOFRAMES:
			case k.SCRIPT:
			case k.STYLE:
			case k.TEMPLATE:
			case k.TITLE: {
				Ro(e, t)
				break
			}
			case k.CAPTION:
			case k.COLGROUP:
			case k.TBODY:
			case k.TFOOT:
			case k.THEAD: {
				;(e.tmplInsertionModeStack[0] = Q.IN_TABLE), (e.insertionMode = Q.IN_TABLE), _p(e, t)
				break
			}
			case k.COL: {
				;(e.tmplInsertionModeStack[0] = Q.IN_COLUMN_GROUP),
					(e.insertionMode = Q.IN_COLUMN_GROUP),
					NA(e, t)
				break
			}
			case k.TR: {
				;(e.tmplInsertionModeStack[0] = Q.IN_TABLE_BODY),
					(e.insertionMode = Q.IN_TABLE_BODY),
					Ow(e, t)
				break
			}
			case k.TD:
			case k.TH: {
				;(e.tmplInsertionModeStack[0] = Q.IN_ROW), (e.insertionMode = Q.IN_ROW), Aw(e, t)
				break
			}
			default:
				;(e.tmplInsertionModeStack[0] = Q.IN_BODY), (e.insertionMode = Q.IN_BODY), si(e, t)
		}
	}
	function Bht(e, t) {
		t.tagID === k.TEMPLATE && Ld(e, t)
	}
	function iW(e, t) {
		e.openElements.tmplCount > 0
			? (e.openElements.popUntilTagNamePopped(k.TEMPLATE),
			  e.activeFormattingElements.clearToLastMarker(),
			  e.tmplInsertionModeStack.shift(),
			  e._resetInsertionMode(),
			  e.onEof(t))
			: AA(e, t)
	}
	function Hht(e, t) {
		t.tagID === k.HTML ? si(e, t) : jb(e, t)
	}
	function aW(e, t) {
		var n
		if (t.tagID === k.HTML) {
			if (
				(e.fragmentContext || (e.insertionMode = Q.AFTER_AFTER_BODY),
				e.options.sourceCodeLocationInfo && e.openElements.tagIDs[0] === k.HTML)
			) {
				e._setEndLocation(e.openElements.items[0], t)
				const r = e.openElements.items[1]
				r &&
					!(
						!((n = e.treeAdapter.getNodeSourceCodeLocation(r)) === null || n === void 0) && n.endTag
					) &&
					e._setEndLocation(r, t)
			}
		} else jb(e, t)
	}
	function jb(e, t) {
		;(e.insertionMode = Q.IN_BODY), Dw(e, t)
	}
	function $ht(e, t) {
		switch (t.tagID) {
			case k.HTML: {
				si(e, t)
				break
			}
			case k.FRAMESET: {
				e._insertElement(t, we.HTML)
				break
			}
			case k.FRAME: {
				e._appendElement(t, we.HTML), (t.ackSelfClosing = !0)
				break
			}
			case k.NOFRAMES: {
				Ro(e, t)
				break
			}
		}
	}
	function Uht(e, t) {
		t.tagID === k.FRAMESET &&
			!e.openElements.isRootHtmlElementCurrent() &&
			(e.openElements.pop(),
			!e.fragmentContext &&
				e.openElements.currentTagId !== k.FRAMESET &&
				(e.insertionMode = Q.AFTER_FRAMESET))
	}
	function zht(e, t) {
		switch (t.tagID) {
			case k.HTML: {
				si(e, t)
				break
			}
			case k.NOFRAMES: {
				Ro(e, t)
				break
			}
		}
	}
	function qht(e, t) {
		t.tagID === k.HTML && (e.insertionMode = Q.AFTER_AFTER_FRAMESET)
	}
	function Vht(e, t) {
		t.tagID === k.HTML ? si(e, t) : x1(e, t)
	}
	function x1(e, t) {
		;(e.insertionMode = Q.IN_BODY), Dw(e, t)
	}
	function Wht(e, t) {
		switch (t.tagID) {
			case k.HTML: {
				si(e, t)
				break
			}
			case k.NOFRAMES: {
				Ro(e, t)
				break
			}
		}
	}
	function Yht(e, t) {
		;(t.chars = Sn), e._insertCharacters(t)
	}
	function Ght(e, t) {
		e._insertCharacters(t), (e.framesetOk = !1)
	}
	function oW(e) {
		for (
			;
			e.treeAdapter.getNamespaceURI(e.openElements.current) !== we.HTML &&
			!e._isIntegrationPoint(e.openElements.currentTagId, e.openElements.current);

		)
			e.openElements.pop()
	}
	function Kht(e, t) {
		if (cpt(t)) oW(e), e._startTagOutsideForeignContent(t)
		else {
			const n = e._getAdjustedCurrentElement(),
				r = e.treeAdapter.getNamespaceURI(n)
			r === we.MATHML ? zV(t) : r === we.SVG && (dpt(t), qV(t)),
				_A(t),
				t.selfClosing ? e._appendElement(t, r) : e._insertElement(t, r),
				(t.ackSelfClosing = !0)
		}
	}
	function Qht(e, t) {
		if (t.tagID === k.P || t.tagID === k.BR) {
			oW(e), e._endTagOutsideForeignContent(t)
			return
		}
		for (let n = e.openElements.stackTop; n > 0; n--) {
			const r = e.openElements.items[n]
			if (e.treeAdapter.getNamespaceURI(r) === we.HTML) {
				e._endTagOutsideForeignContent(t)
				break
			}
			const i = e.treeAdapter.getTagName(r)
			if (i.toLowerCase() === t.tagName) {
				;(t.tagName = i), e.openElements.shortenToLength(n)
				break
			}
		}
	}
	se.AREA,
		se.BASE,
		se.BASEFONT,
		se.BGSOUND,
		se.BR,
		se.COL,
		se.EMBED,
		se.FRAME,
		se.HR,
		se.IMG,
		se.INPUT,
		se.KEYGEN,
		se.LINK,
		se.META,
		se.PARAM,
		se.SOURCE,
		se.TRACK,
		se.WBR
	const Xht =
			/<(\/?)(iframe|noembed|noframes|plaintext|script|style|textarea|title|xmp)(?=[\t\n\f\r />])/gi,
		Jht = new Set([
			"mdxFlowExpression",
			"mdxJsxFlowElement",
			"mdxJsxTextElement",
			"mdxTextExpression",
			"mdxjsEsm",
		]),
		fF = { sourceCodeLocationInfo: !0, scriptingEnabled: !1 }
	function sW(e, t) {
		const n = lmt(e),
			r = OV("type", {
				handlers: { root: Zht, element: emt, text: tmt, comment: uW, doctype: nmt, raw: imt },
				unknown: amt,
			}),
			i = {
				parser: n ? new uF(fF) : uF.getFragmentParser(void 0, fF),
				handle(s) {
					r(s, i)
				},
				stitches: !1,
				options: t || {},
			}
		r(e, i), oh(i, Os())
		const a = n ? i.parser.document : i.parser.getFragment(),
			o = uft(a, { file: i.options.file })
		return (
			i.stitches &&
				Sw(o, "comment", function (s, l, u) {
					const d = s
					if (d.value.stitch && u && l !== void 0) {
						const p = u.children
						return (p[l] = d.value.stitch), l
					}
				}),
			o.type === "root" && o.children.length === 1 && o.children[0].type === e.type
				? o.children[0]
				: o
		)
	}
	function lW(e, t) {
		let n = -1
		if (e) for (; ++n < e.length; ) t.handle(e[n])
	}
	function Zht(e, t) {
		lW(e.children, t)
	}
	function emt(e, t) {
		omt(e, t), lW(e.children, t), smt(e, t)
	}
	function tmt(e, t) {
		t.parser.tokenizer.state > 4 && (t.parser.tokenizer.state = 0)
		const n = { type: Ct.CHARACTER, chars: e.value, location: wg(e) }
		oh(t, Os(e)), (t.parser.currentToken = n), t.parser._processToken(t.parser.currentToken)
	}
	function nmt(e, t) {
		const n = {
			type: Ct.DOCTYPE,
			name: "html",
			forceQuirks: !1,
			publicId: "",
			systemId: "",
			location: wg(e),
		}
		oh(t, Os(e)), (t.parser.currentToken = n), t.parser._processToken(t.parser.currentToken)
	}
	function rmt(e, t) {
		t.stitches = !0
		const n = umt(e)
		if ("children" in e && "children" in n) {
			const r = sW({ type: "root", children: e.children }, t.options)
			n.children = r.children
		}
		uW({ type: "comment", value: { stitch: n } }, t)
	}
	function uW(e, t) {
		const n = e.value,
			r = { type: Ct.COMMENT, data: n, location: wg(e) }
		oh(t, Os(e)), (t.parser.currentToken = r), t.parser._processToken(t.parser.currentToken)
	}
	function imt(e, t) {
		if (
			((t.parser.tokenizer.preprocessor.html = ""),
			(t.parser.tokenizer.preprocessor.pos = -1),
			(t.parser.tokenizer.preprocessor.lastGapPos = -2),
			(t.parser.tokenizer.preprocessor.gapStack = []),
			(t.parser.tokenizer.preprocessor.skipNextNewLine = !1),
			(t.parser.tokenizer.preprocessor.lastChunkWritten = !1),
			(t.parser.tokenizer.preprocessor.endOfChunkHit = !1),
			(t.parser.tokenizer.preprocessor.isEol = !1),
			cW(t, Os(e)),
			t.parser.tokenizer.write(
				t.options.tagfilter ? e.value.replace(Xht, "&lt;$1$2") : e.value,
				!1,
			),
			t.parser.tokenizer._runParsingLoop(),
			t.parser.tokenizer.state === 72 || t.parser.tokenizer.state === 78)
		) {
			t.parser.tokenizer.preprocessor.lastChunkWritten = !0
			const n = t.parser.tokenizer._consume()
			t.parser.tokenizer._callState(n)
		}
	}
	function amt(e, t) {
		const n = e
		if (t.options.passThrough && t.options.passThrough.includes(n.type)) rmt(n, t)
		else {
			let r = ""
			throw (
				(Jht.has(n.type) &&
					(r =
						". It looks like you are using MDX nodes with `hast-util-raw` (or `rehype-raw`). If you use this because you are using remark or rehype plugins that inject `'html'` nodes, then please raise an issue with that plugin, as its a bad and slow idea. If you use this because you are using markdown syntax, then you have to configure this utility (or plugin) to pass through these nodes (see `passThrough` in docs), but you can also migrate to use the MDX syntax"),
				new Error("Cannot compile `" + n.type + "` node" + r))
			)
		}
	}
	function oh(e, t) {
		cW(e, t)
		const n = e.parser.tokenizer.currentCharacterToken
		n &&
			n.location &&
			((n.location.endLine = e.parser.tokenizer.preprocessor.line),
			(n.location.endCol = e.parser.tokenizer.preprocessor.col + 1),
			(n.location.endOffset = e.parser.tokenizer.preprocessor.offset + 1),
			(e.parser.currentToken = n),
			e.parser._processToken(e.parser.currentToken)),
			(e.parser.tokenizer.paused = !1),
			(e.parser.tokenizer.inLoop = !1),
			(e.parser.tokenizer.active = !1),
			(e.parser.tokenizer.returnState = Jn.DATA),
			(e.parser.tokenizer.charRefCode = -1),
			(e.parser.tokenizer.consumedAfterSnapshot = -1),
			(e.parser.tokenizer.currentLocation = null),
			(e.parser.tokenizer.currentCharacterToken = null),
			(e.parser.tokenizer.currentToken = null),
			(e.parser.tokenizer.currentAttr = { name: "", value: "" })
	}
	function cW(e, t) {
		if (t && t.offset !== void 0) {
			const n = {
				startLine: t.line,
				startCol: t.column,
				startOffset: t.offset,
				endLine: -1,
				endCol: -1,
				endOffset: -1,
			}
			;(e.parser.tokenizer.preprocessor.lineStartPos = -t.column + 1),
				(e.parser.tokenizer.preprocessor.droppedBufferSize = t.offset),
				(e.parser.tokenizer.preprocessor.line = t.line),
				(e.parser.tokenizer.currentLocation = n)
		}
	}
	function omt(e, t) {
		const n = e.tagName.toLowerCase()
		if (t.parser.tokenizer.state === Jn.PLAINTEXT) return
		oh(t, Os(e))
		const r = t.parser.openElements.current
		let i = "namespaceURI" in r ? r.namespaceURI : Uc.html
		i === Uc.html && n === "svg" && (i = Uc.svg)
		const a = hft({ ...e, children: [] }, { space: i === Uc.svg ? "svg" : "html" }),
			o = {
				type: Ct.START_TAG,
				tagName: n,
				tagID: ah(n),
				selfClosing: !1,
				ackSelfClosing: !1,
				attrs: "attrs" in a ? a.attrs : [],
				location: wg(e),
			}
		;(t.parser.currentToken = o),
			t.parser._processToken(t.parser.currentToken),
			(t.parser.tokenizer.lastStartTagName = n)
	}
	function smt(e, t) {
		const n = e.tagName.toLowerCase()
		if (
			(!t.parser.tokenizer.inForeignNode && Eft.includes(n)) ||
			t.parser.tokenizer.state === Jn.PLAINTEXT
		)
			return
		oh(t, xw(e))
		const r = {
			type: Ct.END_TAG,
			tagName: n,
			tagID: ah(n),
			selfClosing: !1,
			ackSelfClosing: !1,
			attrs: [],
			location: wg(e),
		}
		;(t.parser.currentToken = r),
			t.parser._processToken(t.parser.currentToken),
			n === t.parser.tokenizer.lastStartTagName &&
				(t.parser.tokenizer.state === Jn.RCDATA ||
					t.parser.tokenizer.state === Jn.RAWTEXT ||
					t.parser.tokenizer.state === Jn.SCRIPT_DATA) &&
				(t.parser.tokenizer.state = Jn.DATA)
	}
	function lmt(e) {
		const t = e.type === "root" ? e.children[0] : e
		return !!(
			t &&
			(t.type === "doctype" || (t.type === "element" && t.tagName.toLowerCase() === "html"))
		)
	}
	function wg(e) {
		const t = Os(e) || { line: void 0, column: void 0, offset: void 0 },
			n = xw(e) || { line: void 0, column: void 0, offset: void 0 }
		return {
			startLine: t.line,
			startCol: t.column,
			startOffset: t.offset,
			endLine: n.line,
			endCol: n.column,
			endOffset: n.offset,
		}
	}
	function umt(e) {
		return "children" in e ? Dp({ ...e, children: [] }) : Dp(e)
	}
	function cmt(e) {
		return function (t, n) {
			return sW(t, { ...e, file: n })
		}
	}
	function pF(e, t) {
		const n = String(e)
		if (typeof t != "string") throw new TypeError("Expected character")
		let r = 0,
			i = n.indexOf(t)
		for (; i !== -1; ) r++, (i = n.indexOf(t, i + t.length))
		return r
	}
	function dmt(e) {
		if (typeof e != "string") throw new TypeError("Expected a string")
		return e.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d")
	}
	function fmt(e, t, n) {
		const i = Tw((n || {}).ignore || []),
			a = pmt(t)
		let o = -1
		for (; ++o < a.length; ) CV(e, "text", s)
		function s(u, d) {
			let p = -1,
				m
			for (; ++p < d.length; ) {
				const v = d[p],
					y = m ? m.children : void 0
				if (i(v, y ? y.indexOf(v) : void 0, m)) return
				m = v
			}
			if (m) return l(u, d)
		}
		function l(u, d) {
			const p = d[d.length - 1],
				m = a[o][0],
				v = a[o][1]
			let y = 0
			const x = p.children.indexOf(u)
			let E = !1,
				T = []
			m.lastIndex = 0
			let C = m.exec(u.value)
			for (; C; ) {
				const D = C.index,
					O = { index: C.index, input: C.input, stack: [...d, u] }
				let A = v(...C, O)
				if (
					(typeof A == "string" && (A = A.length > 0 ? { type: "text", value: A } : void 0),
					A === !1
						? (m.lastIndex = D + 1)
						: (y !== D && T.push({ type: "text", value: u.value.slice(y, D) }),
						  Array.isArray(A) ? T.push(...A) : A && T.push(A),
						  (y = D + C[0].length),
						  (E = !0)),
					!m.global)
				)
					break
				C = m.exec(u.value)
			}
			return (
				E
					? (y < u.value.length && T.push({ type: "text", value: u.value.slice(y) }),
					  p.children.splice(x, 1, ...T))
					: (T = [u]),
				x + T.length
			)
		}
	}
	function pmt(e) {
		const t = []
		if (!Array.isArray(e)) throw new TypeError("Expected find and replace tuple or list of tuples")
		const n = !e[0] || Array.isArray(e[0]) ? e : [e]
		let r = -1
		for (; ++r < n.length; ) {
			const i = n[r]
			t.push([hmt(i[0]), mmt(i[1])])
		}
		return t
	}
	function hmt(e) {
		return typeof e == "string" ? new RegExp(dmt(e), "g") : e
	}
	function mmt(e) {
		return typeof e == "function"
			? e
			: function () {
					return e
			  }
	}
	const eS = "phrasing",
		tS = ["autolink", "link", "image", "label"]
	function vmt() {
		return {
			transforms: [Cmt],
			enter: {
				literalAutolink: ymt,
				literalAutolinkEmail: nS,
				literalAutolinkHttp: nS,
				literalAutolinkWww: nS,
			},
			exit: {
				literalAutolink: Emt,
				literalAutolinkEmail: wmt,
				literalAutolinkHttp: bmt,
				literalAutolinkWww: xmt,
			},
		}
	}
	function gmt() {
		return {
			unsafe: [
				{
					character: "@",
					before: "[+\\-.\\w]",
					after: "[\\-.\\w]",
					inConstruct: eS,
					notInConstruct: tS,
				},
				{ character: ".", before: "[Ww]", after: "[\\-.\\w]", inConstruct: eS, notInConstruct: tS },
				{ character: ":", before: "[ps]", after: "\\/", inConstruct: eS, notInConstruct: tS },
			],
		}
	}
	function ymt(e) {
		this.enter({ type: "link", title: null, url: "", children: [] }, e)
	}
	function nS(e) {
		this.config.enter.autolinkProtocol.call(this, e)
	}
	function bmt(e) {
		this.config.exit.autolinkProtocol.call(this, e)
	}
	function xmt(e) {
		this.config.exit.data.call(this, e)
		const t = this.stack[this.stack.length - 1]
		t.type, (t.url = "http://" + this.sliceSerialize(e))
	}
	function wmt(e) {
		this.config.exit.autolinkEmail.call(this, e)
	}
	function Emt(e) {
		this.exit(e)
	}
	function Cmt(e) {
		fmt(
			e,
			[
				[/(https?:\/\/|www(?=\.))([-.\w]+)([^ \t\r\n]*)/gi, Tmt],
				[new RegExp("(?<=^|\\s|\\p{P}|\\p{S})([-.\\w+]+)@([-\\w]+(?:\\.[-\\w]+)+)", "gu"), kmt],
			],
			{ ignore: ["link", "linkReference"] },
		)
	}
	function Tmt(e, t, n, r, i) {
		let a = ""
		if (!dW(i) || (/^w/i.test(t) && ((n = t + n), (t = ""), (a = "http://")), !Smt(n))) return !1
		const o = Dmt(n + r)
		if (!o[0]) return !1
		const s = {
			type: "link",
			title: null,
			url: a + t + o[0],
			children: [{ type: "text", value: t + o[0] }],
		}
		return o[1] ? [s, { type: "text", value: o[1] }] : s
	}
	function kmt(e, t, n, r) {
		return !dW(r, !0) || /[-\d_]$/.test(n)
			? !1
			: {
					type: "link",
					title: null,
					url: "mailto:" + t + "@" + n,
					children: [{ type: "text", value: t + "@" + n }],
			  }
	}
	function Smt(e) {
		const t = e.split(".")
		return !(
			t.length < 2 ||
			(t[t.length - 1] && (/_/.test(t[t.length - 1]) || !/[a-zA-Z\d]/.test(t[t.length - 1]))) ||
			(t[t.length - 2] && (/_/.test(t[t.length - 2]) || !/[a-zA-Z\d]/.test(t[t.length - 2])))
		)
	}
	function Dmt(e) {
		const t = /[!"&'),.:;<>?\]}]+$/.exec(e)
		if (!t) return [e, void 0]
		e = e.slice(0, t.index)
		let n = t[0],
			r = n.indexOf(")")
		const i = pF(e, "(")
		let a = pF(e, ")")
		for (; r !== -1 && i > a; )
			(e += n.slice(0, r + 1)), (n = n.slice(r + 1)), (r = n.indexOf(")")), a++
		return [e, n]
	}
	function dW(e, t) {
		const n = e.input.charCodeAt(e.index - 1)
		return (e.index === 0 || Td(n) || ww(n)) && (!t || n !== 47)
	}
	fW.peek = Fmt
	function _mt() {
		return {
			enter: {
				gfmFootnoteDefinition: Amt,
				gfmFootnoteDefinitionLabelString: Nmt,
				gfmFootnoteCall: Rmt,
				gfmFootnoteCallString: Lmt,
			},
			exit: {
				gfmFootnoteDefinition: Imt,
				gfmFootnoteDefinitionLabelString: Mmt,
				gfmFootnoteCall: jmt,
				gfmFootnoteCallString: Pmt,
			},
		}
	}
	function Omt() {
		return {
			unsafe: [{ character: "[", inConstruct: ["phrasing", "label", "reference"] }],
			handlers: { footnoteDefinition: Bmt, footnoteReference: fW },
		}
	}
	function Amt(e) {
		this.enter({ type: "footnoteDefinition", identifier: "", label: "", children: [] }, e)
	}
	function Nmt() {
		this.buffer()
	}
	function Mmt(e) {
		const t = this.resume(),
			n = this.stack[this.stack.length - 1]
		n.type, (n.label = t), (n.identifier = To(this.sliceSerialize(e)).toLowerCase())
	}
	function Imt(e) {
		this.exit(e)
	}
	function Rmt(e) {
		this.enter({ type: "footnoteReference", identifier: "", label: "" }, e)
	}
	function Lmt() {
		this.buffer()
	}
	function Pmt(e) {
		const t = this.resume(),
			n = this.stack[this.stack.length - 1]
		n.type, (n.label = t), (n.identifier = To(this.sliceSerialize(e)).toLowerCase())
	}
	function jmt(e) {
		this.exit(e)
	}
	function fW(e, t, n, r) {
		const i = n.createTracker(r)
		let a = i.move("[^")
		const o = n.enter("footnoteReference"),
			s = n.enter("reference")
		return (
			(a += i.move(n.safe(n.associationId(e), { ...i.current(), before: a, after: "]" }))),
			s(),
			o(),
			(a += i.move("]")),
			a
		)
	}
	function Fmt() {
		return "["
	}
	function Bmt(e, t, n, r) {
		const i = n.createTracker(r)
		let a = i.move("[^")
		const o = n.enter("footnoteDefinition"),
			s = n.enter("label")
		return (
			(a += i.move(n.safe(n.associationId(e), { ...i.current(), before: a, after: "]" }))),
			s(),
			(a += i.move("]:" + (e.children && e.children.length > 0 ? " " : ""))),
			i.shift(4),
			(a += i.move(n.indentLines(n.containerFlow(e, i.current()), Hmt))),
			o(),
			a
		)
	}
	function Hmt(e, t, n) {
		return t === 0 ? e : (n ? "" : "    ") + e
	}
	const $mt = [
		"autolink",
		"destinationLiteral",
		"destinationRaw",
		"reference",
		"titleQuote",
		"titleApostrophe",
	]
	pW.peek = Wmt
	function Umt() {
		return {
			canContainEols: ["delete"],
			enter: { strikethrough: qmt },
			exit: { strikethrough: Vmt },
		}
	}
	function zmt() {
		return {
			unsafe: [{ character: "~", inConstruct: "phrasing", notInConstruct: $mt }],
			handlers: { delete: pW },
		}
	}
	function qmt(e) {
		this.enter({ type: "delete", children: [] }, e)
	}
	function Vmt(e) {
		this.exit(e)
	}
	function pW(e, t, n, r) {
		const i = n.createTracker(r),
			a = n.enter("strikethrough")
		let o = i.move("~~")
		return (
			(o += n.containerPhrasing(e, { ...i.current(), before: o, after: "~" })),
			(o += i.move("~~")),
			a(),
			o
		)
	}
	function Wmt() {
		return "~"
	}
	function Ymt(e) {
		return e.length
	}
	function Gmt(e, t) {
		const n = t || {},
			r = (n.align || []).concat(),
			i = n.stringLength || Ymt,
			a = [],
			o = [],
			s = [],
			l = []
		let u = 0,
			d = -1
		for (; ++d < e.length; ) {
			const b = [],
				x = []
			let E = -1
			for (e[d].length > u && (u = e[d].length); ++E < e[d].length; ) {
				const T = Kmt(e[d][E])
				if (n.alignDelimiters !== !1) {
					const C = i(T)
					;(x[E] = C), (l[E] === void 0 || C > l[E]) && (l[E] = C)
				}
				b.push(T)
			}
			;(o[d] = b), (s[d] = x)
		}
		let p = -1
		if (typeof r == "object" && "length" in r) for (; ++p < u; ) a[p] = hF(r[p])
		else {
			const b = hF(r)
			for (; ++p < u; ) a[p] = b
		}
		p = -1
		const m = [],
			v = []
		for (; ++p < u; ) {
			const b = a[p]
			let x = "",
				E = ""
			b === 99 ? ((x = ":"), (E = ":")) : b === 108 ? (x = ":") : b === 114 && (E = ":")
			let T = n.alignDelimiters === !1 ? 1 : Math.max(1, l[p] - x.length - E.length)
			const C = x + "-".repeat(T) + E
			n.alignDelimiters !== !1 &&
				((T = x.length + T + E.length), T > l[p] && (l[p] = T), (v[p] = T)),
				(m[p] = C)
		}
		o.splice(1, 0, m), s.splice(1, 0, v), (d = -1)
		const y = []
		for (; ++d < o.length; ) {
			const b = o[d],
				x = s[d]
			p = -1
			const E = []
			for (; ++p < u; ) {
				const T = b[p] || ""
				let C = "",
					D = ""
				if (n.alignDelimiters !== !1) {
					const O = l[p] - (x[p] || 0),
						A = a[p]
					A === 114
						? (C = " ".repeat(O))
						: A === 99
						? O % 2
							? ((C = " ".repeat(O / 2 + 0.5)), (D = " ".repeat(O / 2 - 0.5)))
							: ((C = " ".repeat(O / 2)), (D = C))
						: (D = " ".repeat(O))
				}
				n.delimiterStart !== !1 && !p && E.push("|"),
					n.padding !== !1 &&
						!(n.alignDelimiters === !1 && T === "") &&
						(n.delimiterStart !== !1 || p) &&
						E.push(" "),
					n.alignDelimiters !== !1 && E.push(C),
					E.push(T),
					n.alignDelimiters !== !1 && E.push(D),
					n.padding !== !1 && E.push(" "),
					(n.delimiterEnd !== !1 || p !== u - 1) && E.push("|")
			}
			y.push(n.delimiterEnd === !1 ? E.join("").replace(/ +$/, "") : E.join(""))
		}
		return y.join(`
`)
	}
	function Kmt(e) {
		return e == null ? "" : String(e)
	}
	function hF(e) {
		const t = typeof e == "string" ? e.codePointAt(0) : 0
		return t === 67 || t === 99 ? 99 : t === 76 || t === 108 ? 108 : t === 82 || t === 114 ? 114 : 0
	}
	function Qmt(e, t, n, r) {
		const i = n.enter("blockquote"),
			a = n.createTracker(r)
		a.move("> "), a.shift(2)
		const o = n.indentLines(n.containerFlow(e, a.current()), Xmt)
		return i(), o
	}
	function Xmt(e, t, n) {
		return ">" + (n ? "" : " ") + e
	}
	function Jmt(e, t) {
		return mF(e, t.inConstruct, !0) && !mF(e, t.notInConstruct, !1)
	}
	function mF(e, t, n) {
		if ((typeof t == "string" && (t = [t]), !t || t.length === 0)) return n
		let r = -1
		for (; ++r < t.length; ) if (e.includes(t[r])) return !0
		return !1
	}
	function vF(e, t, n, r) {
		let i = -1
		for (; ++i < n.unsafe.length; )
			if (
				n.unsafe[i].character ===
					`
` &&
				Jmt(n.stack, n.unsafe[i])
			)
				return /[ \t]/.test(r.before) ? "" : " "
		return `\\
`
	}
	function Zmt(e, t) {
		const n = String(e)
		let r = n.indexOf(t),
			i = r,
			a = 0,
			o = 0
		if (typeof t != "string") throw new TypeError("Expected substring")
		for (; r !== -1; )
			r === i ? ++a > o && (o = a) : (a = 1), (i = r + t.length), (r = n.indexOf(t, i))
		return o
	}
	function evt(e, t) {
		return !!(
			t.options.fences === !1 &&
			e.value &&
			!e.lang &&
			/[^ \r\n]/.test(e.value) &&
			!/^[\t ]*(?:[\r\n]|$)|(?:^|[\r\n])[\t ]*$/.test(e.value)
		)
	}
	function tvt(e) {
		const t = e.options.fence || "`"
		if (t !== "`" && t !== "~")
			throw new Error(
				"Cannot serialize code with `" + t + "` for `options.fence`, expected `` ` `` or `~`",
			)
		return t
	}
	function nvt(e, t, n, r) {
		const i = tvt(n),
			a = e.value || "",
			o = i === "`" ? "GraveAccent" : "Tilde"
		if (evt(e, n)) {
			const p = n.enter("codeIndented"),
				m = n.indentLines(a, rvt)
			return p(), m
		}
		const s = n.createTracker(r),
			l = i.repeat(Math.max(Zmt(a, i) + 1, 3)),
			u = n.enter("codeFenced")
		let d = s.move(l)
		if (e.lang) {
			const p = n.enter(`codeFencedLang${o}`)
			;(d += s.move(n.safe(e.lang, { before: d, after: " ", encode: ["`"], ...s.current() }))), p()
		}
		if (e.lang && e.meta) {
			const p = n.enter(`codeFencedMeta${o}`)
			;(d += s.move(" ")),
				(d += s.move(
					n.safe(e.meta, {
						before: d,
						after: `
`,
						encode: ["`"],
						...s.current(),
					}),
				)),
				p()
		}
		return (
			(d += s.move(`
`)),
			a &&
				(d += s.move(
					a +
						`
`,
				)),
			(d += s.move(l)),
			u(),
			d
		)
	}
	function rvt(e, t, n) {
		return (n ? "" : "    ") + e
	}
	function MA(e) {
		const t = e.options.quote || '"'
		if (t !== '"' && t !== "'")
			throw new Error(
				"Cannot serialize title with `" + t + "` for `options.quote`, expected `\"`, or `'`",
			)
		return t
	}
	function ivt(e, t, n, r) {
		const i = MA(n),
			a = i === '"' ? "Quote" : "Apostrophe",
			o = n.enter("definition")
		let s = n.enter("label")
		const l = n.createTracker(r)
		let u = l.move("[")
		return (
			(u += l.move(n.safe(n.associationId(e), { before: u, after: "]", ...l.current() }))),
			(u += l.move("]: ")),
			s(),
			!e.url || /[\0- \u007F]/.test(e.url)
				? ((s = n.enter("destinationLiteral")),
				  (u += l.move("<")),
				  (u += l.move(n.safe(e.url, { before: u, after: ">", ...l.current() }))),
				  (u += l.move(">")))
				: ((s = n.enter("destinationRaw")),
				  (u += l.move(
						n.safe(e.url, {
							before: u,
							after: e.title
								? " "
								: `
`,
							...l.current(),
						}),
				  ))),
			s(),
			e.title &&
				((s = n.enter(`title${a}`)),
				(u += l.move(" " + i)),
				(u += l.move(n.safe(e.title, { before: u, after: i, ...l.current() }))),
				(u += l.move(i)),
				s()),
			o(),
			u
		)
	}
	function avt(e) {
		const t = e.options.emphasis || "*"
		if (t !== "*" && t !== "_")
			throw new Error(
				"Cannot serialize emphasis with `" + t + "` for `options.emphasis`, expected `*`, or `_`",
			)
		return t
	}
	function Rv(e) {
		return "&#x" + e.toString(16).toUpperCase() + ";"
	}
	function Fb(e, t, n) {
		const r = Sp(e),
			i = Sp(t)
		return r === void 0
			? i === void 0
				? n === "_"
					? { inside: !0, outside: !0 }
					: { inside: !1, outside: !1 }
				: i === 1
				? { inside: !0, outside: !0 }
				: { inside: !1, outside: !0 }
			: r === 1
			? i === void 0
				? { inside: !1, outside: !1 }
				: i === 1
				? { inside: !0, outside: !0 }
				: { inside: !1, outside: !1 }
			: i === void 0
			? { inside: !1, outside: !1 }
			: i === 1
			? { inside: !0, outside: !1 }
			: { inside: !1, outside: !1 }
	}
	hW.peek = ovt
	function hW(e, t, n, r) {
		const i = avt(n),
			a = n.enter("emphasis"),
			o = n.createTracker(r),
			s = o.move(i)
		let l = o.move(n.containerPhrasing(e, { after: i, before: s, ...o.current() }))
		const u = l.charCodeAt(0),
			d = Fb(r.before.charCodeAt(r.before.length - 1), u, i)
		d.inside && (l = Rv(u) + l.slice(1))
		const p = l.charCodeAt(l.length - 1),
			m = Fb(r.after.charCodeAt(0), p, i)
		m.inside && (l = l.slice(0, -1) + Rv(p))
		const v = o.move(i)
		return (
			a(), (n.attentionEncodeSurroundingInfo = { after: m.outside, before: d.outside }), s + l + v
		)
	}
	function ovt(e, t, n) {
		return n.options.emphasis || "*"
	}
	function svt(e, t) {
		let n = !1
		return (
			Sw(e, function (r) {
				if (("value" in r && /\r?\n|\r/.test(r.value)) || r.type === "break") return (n = !0), dD
			}),
			!!((!e.depth || e.depth < 3) && yA(e) && (t.options.setext || n))
		)
	}
	function lvt(e, t, n, r) {
		const i = Math.max(Math.min(6, e.depth || 1), 1),
			a = n.createTracker(r)
		if (svt(e, n)) {
			const d = n.enter("headingSetext"),
				p = n.enter("phrasing"),
				m = n.containerPhrasing(e, {
					...a.current(),
					before: `
`,
					after: `
`,
				})
			return (
				p(),
				d(),
				m +
					`
` +
					(i === 1 ? "=" : "-").repeat(
						m.length -
							(Math.max(
								m.lastIndexOf("\r"),
								m.lastIndexOf(`
`),
							) +
								1),
					)
			)
		}
		const o = "#".repeat(i),
			s = n.enter("headingAtx"),
			l = n.enter("phrasing")
		a.move(o + " ")
		let u = n.containerPhrasing(e, {
			before: "# ",
			after: `
`,
			...a.current(),
		})
		return (
			/^[\t ]/.test(u) && (u = Rv(u.charCodeAt(0)) + u.slice(1)),
			(u = u ? o + " " + u : o),
			n.options.closeAtx && (u += " " + o),
			l(),
			s(),
			u
		)
	}
	mW.peek = uvt
	function mW(e) {
		return e.value || ""
	}
	function uvt() {
		return "<"
	}
	vW.peek = cvt
	function vW(e, t, n, r) {
		const i = MA(n),
			a = i === '"' ? "Quote" : "Apostrophe",
			o = n.enter("image")
		let s = n.enter("label")
		const l = n.createTracker(r)
		let u = l.move("![")
		return (
			(u += l.move(n.safe(e.alt, { before: u, after: "]", ...l.current() }))),
			(u += l.move("](")),
			s(),
			(!e.url && e.title) || /[\0- \u007F]/.test(e.url)
				? ((s = n.enter("destinationLiteral")),
				  (u += l.move("<")),
				  (u += l.move(n.safe(e.url, { before: u, after: ">", ...l.current() }))),
				  (u += l.move(">")))
				: ((s = n.enter("destinationRaw")),
				  (u += l.move(n.safe(e.url, { before: u, after: e.title ? " " : ")", ...l.current() })))),
			s(),
			e.title &&
				((s = n.enter(`title${a}`)),
				(u += l.move(" " + i)),
				(u += l.move(n.safe(e.title, { before: u, after: i, ...l.current() }))),
				(u += l.move(i)),
				s()),
			(u += l.move(")")),
			o(),
			u
		)
	}
	function cvt() {
		return "!"
	}
	gW.peek = dvt
	function gW(e, t, n, r) {
		const i = e.referenceType,
			a = n.enter("imageReference")
		let o = n.enter("label")
		const s = n.createTracker(r)
		let l = s.move("![")
		const u = n.safe(e.alt, { before: l, after: "]", ...s.current() })
		;(l += s.move(u + "][")), o()
		const d = n.stack
		;(n.stack = []), (o = n.enter("reference"))
		const p = n.safe(n.associationId(e), { before: l, after: "]", ...s.current() })
		return (
			o(),
			(n.stack = d),
			a(),
			i === "full" || !u || u !== p
				? (l += s.move(p + "]"))
				: i === "shortcut"
				? (l = l.slice(0, -1))
				: (l += s.move("]")),
			l
		)
	}
	function dvt() {
		return "!"
	}
	yW.peek = fvt
	function yW(e, t, n) {
		let r = e.value || "",
			i = "`",
			a = -1
		for (; new RegExp("(^|[^`])" + i + "([^`]|$)").test(r); ) i += "`"
		for (
			/[^ \r\n]/.test(r) &&
			((/^[ \r\n]/.test(r) && /[ \r\n]$/.test(r)) || /^`|`$/.test(r)) &&
			(r = " " + r + " ");
			++a < n.unsafe.length;

		) {
			const o = n.unsafe[a],
				s = n.compilePattern(o)
			let l
			if (o.atBreak)
				for (; (l = s.exec(r)); ) {
					let u = l.index
					r.charCodeAt(u) === 10 && r.charCodeAt(u - 1) === 13 && u--,
						(r = r.slice(0, u) + " " + r.slice(l.index + 1))
				}
		}
		return i + r + i
	}
	function fvt() {
		return "`"
	}
	function bW(e, t) {
		const n = yA(e)
		return !!(
			!t.options.resourceLink &&
			e.url &&
			!e.title &&
			e.children &&
			e.children.length === 1 &&
			e.children[0].type === "text" &&
			(n === e.url || "mailto:" + n === e.url) &&
			/^[a-z][a-z+.-]+:/i.test(e.url) &&
			!/[\0- <>\u007F]/.test(e.url)
		)
	}
	xW.peek = pvt
	function xW(e, t, n, r) {
		const i = MA(n),
			a = i === '"' ? "Quote" : "Apostrophe",
			o = n.createTracker(r)
		let s, l
		if (bW(e, n)) {
			const d = n.stack
			;(n.stack = []), (s = n.enter("autolink"))
			let p = o.move("<")
			return (
				(p += o.move(n.containerPhrasing(e, { before: p, after: ">", ...o.current() }))),
				(p += o.move(">")),
				s(),
				(n.stack = d),
				p
			)
		}
		;(s = n.enter("link")), (l = n.enter("label"))
		let u = o.move("[")
		return (
			(u += o.move(n.containerPhrasing(e, { before: u, after: "](", ...o.current() }))),
			(u += o.move("](")),
			l(),
			(!e.url && e.title) || /[\0- \u007F]/.test(e.url)
				? ((l = n.enter("destinationLiteral")),
				  (u += o.move("<")),
				  (u += o.move(n.safe(e.url, { before: u, after: ">", ...o.current() }))),
				  (u += o.move(">")))
				: ((l = n.enter("destinationRaw")),
				  (u += o.move(n.safe(e.url, { before: u, after: e.title ? " " : ")", ...o.current() })))),
			l(),
			e.title &&
				((l = n.enter(`title${a}`)),
				(u += o.move(" " + i)),
				(u += o.move(n.safe(e.title, { before: u, after: i, ...o.current() }))),
				(u += o.move(i)),
				l()),
			(u += o.move(")")),
			s(),
			u
		)
	}
	function pvt(e, t, n) {
		return bW(e, n) ? "<" : "["
	}
	wW.peek = hvt
	function wW(e, t, n, r) {
		const i = e.referenceType,
			a = n.enter("linkReference")
		let o = n.enter("label")
		const s = n.createTracker(r)
		let l = s.move("[")
		const u = n.containerPhrasing(e, { before: l, after: "]", ...s.current() })
		;(l += s.move(u + "][")), o()
		const d = n.stack
		;(n.stack = []), (o = n.enter("reference"))
		const p = n.safe(n.associationId(e), { before: l, after: "]", ...s.current() })
		return (
			o(),
			(n.stack = d),
			a(),
			i === "full" || !u || u !== p
				? (l += s.move(p + "]"))
				: i === "shortcut"
				? (l = l.slice(0, -1))
				: (l += s.move("]")),
			l
		)
	}
	function hvt() {
		return "["
	}
	function IA(e) {
		const t = e.options.bullet || "*"
		if (t !== "*" && t !== "+" && t !== "-")
			throw new Error(
				"Cannot serialize items with `" + t + "` for `options.bullet`, expected `*`, `+`, or `-`",
			)
		return t
	}
	function mvt(e) {
		const t = IA(e),
			n = e.options.bulletOther
		if (!n) return t === "*" ? "-" : "*"
		if (n !== "*" && n !== "+" && n !== "-")
			throw new Error(
				"Cannot serialize items with `" +
					n +
					"` for `options.bulletOther`, expected `*`, `+`, or `-`",
			)
		if (n === t)
			throw new Error(
				"Expected `bullet` (`" + t + "`) and `bulletOther` (`" + n + "`) to be different",
			)
		return n
	}
	function vvt(e) {
		const t = e.options.bulletOrdered || "."
		if (t !== "." && t !== ")")
			throw new Error(
				"Cannot serialize items with `" + t + "` for `options.bulletOrdered`, expected `.` or `)`",
			)
		return t
	}
	function EW(e) {
		const t = e.options.rule || "*"
		if (t !== "*" && t !== "-" && t !== "_")
			throw new Error(
				"Cannot serialize rules with `" + t + "` for `options.rule`, expected `*`, `-`, or `_`",
			)
		return t
	}
	function gvt(e, t, n, r) {
		const i = n.enter("list"),
			a = n.bulletCurrent
		let o = e.ordered ? vvt(n) : IA(n)
		const s = e.ordered ? (o === "." ? ")" : ".") : mvt(n)
		let l = t && n.bulletLastUsed ? o === n.bulletLastUsed : !1
		if (!e.ordered) {
			const d = e.children ? e.children[0] : void 0
			if (
				((o === "*" || o === "-") &&
					d &&
					(!d.children || !d.children[0]) &&
					n.stack[n.stack.length - 1] === "list" &&
					n.stack[n.stack.length - 2] === "listItem" &&
					n.stack[n.stack.length - 3] === "list" &&
					n.stack[n.stack.length - 4] === "listItem" &&
					n.indexStack[n.indexStack.length - 1] === 0 &&
					n.indexStack[n.indexStack.length - 2] === 0 &&
					n.indexStack[n.indexStack.length - 3] === 0 &&
					(l = !0),
				EW(n) === o && d)
			) {
				let p = -1
				for (; ++p < e.children.length; ) {
					const m = e.children[p]
					if (
						m &&
						m.type === "listItem" &&
						m.children &&
						m.children[0] &&
						m.children[0].type === "thematicBreak"
					) {
						l = !0
						break
					}
				}
			}
		}
		l && (o = s), (n.bulletCurrent = o)
		const u = n.containerFlow(e, r)
		return (n.bulletLastUsed = o), (n.bulletCurrent = a), i(), u
	}
	function yvt(e) {
		const t = e.options.listItemIndent || "one"
		if (t !== "tab" && t !== "one" && t !== "mixed")
			throw new Error(
				"Cannot serialize items with `" +
					t +
					"` for `options.listItemIndent`, expected `tab`, `one`, or `mixed`",
			)
		return t
	}
	function bvt(e, t, n, r) {
		const i = yvt(n)
		let a = n.bulletCurrent || IA(n)
		t &&
			t.type === "list" &&
			t.ordered &&
			(a =
				(typeof t.start == "number" && t.start > -1 ? t.start : 1) +
				(n.options.incrementListMarker === !1 ? 0 : t.children.indexOf(e)) +
				a)
		let o = a.length + 1
		;(i === "tab" || (i === "mixed" && ((t && t.type === "list" && t.spread) || e.spread))) &&
			(o = Math.ceil(o / 4) * 4)
		const s = n.createTracker(r)
		s.move(a + " ".repeat(o - a.length)), s.shift(o)
		const l = n.enter("listItem"),
			u = n.indentLines(n.containerFlow(e, s.current()), d)
		return l(), u
		function d(p, m, v) {
			return m ? (v ? "" : " ".repeat(o)) + p : (v ? a : a + " ".repeat(o - a.length)) + p
		}
	}
	function xvt(e, t, n, r) {
		const i = n.enter("paragraph"),
			a = n.enter("phrasing"),
			o = n.containerPhrasing(e, r)
		return a(), i(), o
	}
	const wvt = Tw([
		"break",
		"delete",
		"emphasis",
		"footnote",
		"footnoteReference",
		"image",
		"imageReference",
		"inlineCode",
		"inlineMath",
		"link",
		"linkReference",
		"mdxJsxTextElement",
		"mdxTextExpression",
		"strong",
		"text",
		"textDirective",
	])
	function Evt(e, t, n, r) {
		return (
			e.children.some(function (o) {
				return wvt(o)
			})
				? n.containerPhrasing
				: n.containerFlow
		).call(n, e, r)
	}
	function Cvt(e) {
		const t = e.options.strong || "*"
		if (t !== "*" && t !== "_")
			throw new Error(
				"Cannot serialize strong with `" + t + "` for `options.strong`, expected `*`, or `_`",
			)
		return t
	}
	CW.peek = Tvt
	function CW(e, t, n, r) {
		const i = Cvt(n),
			a = n.enter("strong"),
			o = n.createTracker(r),
			s = o.move(i + i)
		let l = o.move(n.containerPhrasing(e, { after: i, before: s, ...o.current() }))
		const u = l.charCodeAt(0),
			d = Fb(r.before.charCodeAt(r.before.length - 1), u, i)
		d.inside && (l = Rv(u) + l.slice(1))
		const p = l.charCodeAt(l.length - 1),
			m = Fb(r.after.charCodeAt(0), p, i)
		m.inside && (l = l.slice(0, -1) + Rv(p))
		const v = o.move(i + i)
		return (
			a(), (n.attentionEncodeSurroundingInfo = { after: m.outside, before: d.outside }), s + l + v
		)
	}
	function Tvt(e, t, n) {
		return n.options.strong || "*"
	}
	function kvt(e, t, n, r) {
		return n.safe(e.value, r)
	}
	function Svt(e) {
		const t = e.options.ruleRepetition || 3
		if (t < 3)
			throw new Error(
				"Cannot serialize rules with repetition `" +
					t +
					"` for `options.ruleRepetition`, expected `3` or more",
			)
		return t
	}
	function Dvt(e, t, n) {
		const r = (EW(n) + (n.options.ruleSpaces ? " " : "")).repeat(Svt(n))
		return n.options.ruleSpaces ? r.slice(0, -1) : r
	}
	const TW = {
		blockquote: Qmt,
		break: vF,
		code: nvt,
		definition: ivt,
		emphasis: hW,
		hardBreak: vF,
		heading: lvt,
		html: mW,
		image: vW,
		imageReference: gW,
		inlineCode: yW,
		link: xW,
		linkReference: wW,
		list: gvt,
		listItem: bvt,
		paragraph: xvt,
		root: Evt,
		strong: CW,
		text: kvt,
		thematicBreak: Dvt,
	}
	function _vt() {
		return {
			enter: { table: Ovt, tableData: gF, tableHeader: gF, tableRow: Nvt },
			exit: { codeText: Mvt, table: Avt, tableData: rS, tableHeader: rS, tableRow: rS },
		}
	}
	function Ovt(e) {
		const t = e._align
		this.enter(
			{
				type: "table",
				align: t.map(function (n) {
					return n === "none" ? null : n
				}),
				children: [],
			},
			e,
		),
			(this.data.inTable = !0)
	}
	function Avt(e) {
		this.exit(e), (this.data.inTable = void 0)
	}
	function Nvt(e) {
		this.enter({ type: "tableRow", children: [] }, e)
	}
	function rS(e) {
		this.exit(e)
	}
	function gF(e) {
		this.enter({ type: "tableCell", children: [] }, e)
	}
	function Mvt(e) {
		let t = this.resume()
		this.data.inTable && (t = t.replace(/\\([\\|])/g, Ivt))
		const n = this.stack[this.stack.length - 1]
		n.type, (n.value = t), this.exit(e)
	}
	function Ivt(e, t) {
		return t === "|" ? t : e
	}
	function Rvt(e) {
		const t = e || {},
			n = t.tableCellPadding,
			r = t.tablePipeAlign,
			i = t.stringLength,
			a = n ? " " : "|"
		return {
			unsafe: [
				{ character: "\r", inConstruct: "tableCell" },
				{
					character: `
`,
					inConstruct: "tableCell",
				},
				{ atBreak: !0, character: "|", after: "[	 :-]" },
				{ character: "|", inConstruct: "tableCell" },
				{ atBreak: !0, character: ":", after: "-" },
				{ atBreak: !0, character: "-", after: "[:|-]" },
			],
			handlers: { inlineCode: m, table: o, tableCell: l, tableRow: s },
		}
		function o(v, y, b, x) {
			return u(d(v, b, x), v.align)
		}
		function s(v, y, b, x) {
			const E = p(v, b, x),
				T = u([E])
			return T.slice(
				0,
				T.indexOf(`
`),
			)
		}
		function l(v, y, b, x) {
			const E = b.enter("tableCell"),
				T = b.enter("phrasing"),
				C = b.containerPhrasing(v, { ...x, before: a, after: a })
			return T(), E(), C
		}
		function u(v, y) {
			return Gmt(v, { align: y, alignDelimiters: r, padding: n, stringLength: i })
		}
		function d(v, y, b) {
			const x = v.children
			let E = -1
			const T = [],
				C = y.enter("table")
			for (; ++E < x.length; ) T[E] = p(x[E], y, b)
			return C(), T
		}
		function p(v, y, b) {
			const x = v.children
			let E = -1
			const T = [],
				C = y.enter("tableRow")
			for (; ++E < x.length; ) T[E] = l(x[E], v, y, b)
			return C(), T
		}
		function m(v, y, b) {
			let x = TW.inlineCode(v, y, b)
			return b.stack.includes("tableCell") && (x = x.replace(/\|/g, "\\$&")), x
		}
	}
	function Lvt() {
		return {
			exit: { taskListCheckValueChecked: yF, taskListCheckValueUnchecked: yF, paragraph: jvt },
		}
	}
	function Pvt() {
		return {
			unsafe: [{ atBreak: !0, character: "-", after: "[:|-]" }],
			handlers: { listItem: Fvt },
		}
	}
	function yF(e) {
		const t = this.stack[this.stack.length - 2]
		t.type, (t.checked = e.type === "taskListCheckValueChecked")
	}
	function jvt(e) {
		const t = this.stack[this.stack.length - 2]
		if (t && t.type === "listItem" && typeof t.checked == "boolean") {
			const n = this.stack[this.stack.length - 1]
			n.type
			const r = n.children[0]
			if (r && r.type === "text") {
				const i = t.children
				let a = -1,
					o
				for (; ++a < i.length; ) {
					const s = i[a]
					if (s.type === "paragraph") {
						o = s
						break
					}
				}
				o === n &&
					((r.value = r.value.slice(1)),
					r.value.length === 0
						? n.children.shift()
						: n.position &&
						  r.position &&
						  typeof r.position.start.offset == "number" &&
						  (r.position.start.column++,
						  r.position.start.offset++,
						  (n.position.start = Object.assign({}, r.position.start))))
			}
		}
		this.exit(e)
	}
	function Fvt(e, t, n, r) {
		const i = e.children[0],
			a = typeof e.checked == "boolean" && i && i.type === "paragraph",
			o = "[" + (e.checked ? "x" : " ") + "] ",
			s = n.createTracker(r)
		a && s.move(o)
		let l = TW.listItem(e, t, n, { ...r, ...s.current() })
		return a && (l = l.replace(/^(?:[*+-]|\d+\.)([\r\n]| {1,3})/, u)), l
		function u(d) {
			return d + o
		}
	}
	function Bvt() {
		return [vmt(), _mt(), Umt(), _vt(), Lvt()]
	}
	function Hvt(e) {
		return { extensions: [gmt(), Omt(), zmt(), Rvt(e), Pvt()] }
	}
	const $vt = { tokenize: Yvt, partial: !0 },
		kW = { tokenize: Gvt, partial: !0 },
		SW = { tokenize: Kvt, partial: !0 },
		DW = { tokenize: Qvt, partial: !0 },
		Uvt = { tokenize: Xvt, partial: !0 },
		_W = { name: "wwwAutolink", tokenize: Vvt, previous: AW },
		OW = { name: "protocolAutolink", tokenize: Wvt, previous: NW },
		Il = { name: "emailAutolink", tokenize: qvt, previous: MW },
		As = {}
	function zvt() {
		return { text: As }
	}
	let Sc = 48
	for (; Sc < 123; ) (As[Sc] = Il), Sc++, Sc === 58 ? (Sc = 65) : Sc === 91 && (Sc = 97)
	As[43] = Il
	As[45] = Il
	As[46] = Il
	As[95] = Il
	As[72] = [Il, OW]
	As[104] = [Il, OW]
	As[87] = [Il, _W]
	As[119] = [Il, _W]
	function qvt(e, t, n) {
		const r = this
		let i, a
		return o
		function o(p) {
			return !wD(p) || !MW.call(r, r.previous) || RA(r.events)
				? n(p)
				: (e.enter("literalAutolink"), e.enter("literalAutolinkEmail"), s(p))
		}
		function s(p) {
			return wD(p) ? (e.consume(p), s) : p === 64 ? (e.consume(p), l) : n(p)
		}
		function l(p) {
			return p === 46
				? e.check(Uvt, d, u)(p)
				: p === 45 || p === 95 || Zr(p)
				? ((a = !0), e.consume(p), l)
				: d(p)
		}
		function u(p) {
			return e.consume(p), (i = !0), l
		}
		function d(p) {
			return a && i && vi(r.previous)
				? (e.exit("literalAutolinkEmail"), e.exit("literalAutolink"), t(p))
				: n(p)
		}
	}
	function Vvt(e, t, n) {
		const r = this
		return i
		function i(o) {
			return (o !== 87 && o !== 119) || !AW.call(r, r.previous) || RA(r.events)
				? n(o)
				: (e.enter("literalAutolink"),
				  e.enter("literalAutolinkWww"),
				  e.check($vt, e.attempt(kW, e.attempt(SW, a), n), n)(o))
		}
		function a(o) {
			return e.exit("literalAutolinkWww"), e.exit("literalAutolink"), t(o)
		}
	}
	function Wvt(e, t, n) {
		const r = this
		let i = "",
			a = !1
		return o
		function o(p) {
			return (p === 72 || p === 104) && NW.call(r, r.previous) && !RA(r.events)
				? (e.enter("literalAutolink"),
				  e.enter("literalAutolinkHttp"),
				  (i += String.fromCodePoint(p)),
				  e.consume(p),
				  s)
				: n(p)
		}
		function s(p) {
			if (vi(p) && i.length < 5) return (i += String.fromCodePoint(p)), e.consume(p), s
			if (p === 58) {
				const m = i.toLowerCase()
				if (m === "http" || m === "https") return e.consume(p), l
			}
			return n(p)
		}
		function l(p) {
			return p === 47 ? (e.consume(p), a ? u : ((a = !0), l)) : n(p)
		}
		function u(p) {
			return p === null || Mb(p) || un(p) || Td(p) || ww(p)
				? n(p)
				: e.attempt(kW, e.attempt(SW, d), n)(p)
		}
		function d(p) {
			return e.exit("literalAutolinkHttp"), e.exit("literalAutolink"), t(p)
		}
	}
	function Yvt(e, t, n) {
		let r = 0
		return i
		function i(o) {
			return (o === 87 || o === 119) && r < 3
				? (r++, e.consume(o), i)
				: o === 46 && r === 3
				? (e.consume(o), a)
				: n(o)
		}
		function a(o) {
			return o === null ? n(o) : t(o)
		}
	}
	function Gvt(e, t, n) {
		let r, i, a
		return o
		function o(u) {
			return u === 46 || u === 95
				? e.check(DW, l, s)(u)
				: u === null || un(u) || Td(u) || (u !== 45 && ww(u))
				? l(u)
				: ((a = !0), e.consume(u), o)
		}
		function s(u) {
			return u === 95 ? (r = !0) : ((i = r), (r = void 0)), e.consume(u), o
		}
		function l(u) {
			return i || r || !a ? n(u) : t(u)
		}
	}
	function Kvt(e, t) {
		let n = 0,
			r = 0
		return i
		function i(o) {
			return o === 40
				? (n++, e.consume(o), i)
				: o === 41 && r < n
				? a(o)
				: o === 33 ||
				  o === 34 ||
				  o === 38 ||
				  o === 39 ||
				  o === 41 ||
				  o === 42 ||
				  o === 44 ||
				  o === 46 ||
				  o === 58 ||
				  o === 59 ||
				  o === 60 ||
				  o === 63 ||
				  o === 93 ||
				  o === 95 ||
				  o === 126
				? e.check(DW, t, a)(o)
				: o === null || un(o) || Td(o)
				? t(o)
				: (e.consume(o), i)
		}
		function a(o) {
			return o === 41 && r++, e.consume(o), i
		}
	}
	function Qvt(e, t, n) {
		return r
		function r(s) {
			return s === 33 ||
				s === 34 ||
				s === 39 ||
				s === 41 ||
				s === 42 ||
				s === 44 ||
				s === 46 ||
				s === 58 ||
				s === 59 ||
				s === 63 ||
				s === 95 ||
				s === 126
				? (e.consume(s), r)
				: s === 38
				? (e.consume(s), a)
				: s === 93
				? (e.consume(s), i)
				: s === 60 || s === null || un(s) || Td(s)
				? t(s)
				: n(s)
		}
		function i(s) {
			return s === null || s === 40 || s === 91 || un(s) || Td(s) ? t(s) : r(s)
		}
		function a(s) {
			return vi(s) ? o(s) : n(s)
		}
		function o(s) {
			return s === 59 ? (e.consume(s), r) : vi(s) ? (e.consume(s), o) : n(s)
		}
	}
	function Xvt(e, t, n) {
		return r
		function r(a) {
			return e.consume(a), i
		}
		function i(a) {
			return Zr(a) ? n(a) : t(a)
		}
	}
	function AW(e) {
		return (
			e === null || e === 40 || e === 42 || e === 95 || e === 91 || e === 93 || e === 126 || un(e)
		)
	}
	function NW(e) {
		return !vi(e)
	}
	function MW(e) {
		return !(e === 47 || wD(e))
	}
	function wD(e) {
		return e === 43 || e === 45 || e === 46 || e === 95 || Zr(e)
	}
	function RA(e) {
		let t = e.length,
			n = !1
		for (; t--; ) {
			const r = e[t][1]
			if ((r.type === "labelLink" || r.type === "labelImage") && !r._balanced) {
				n = !0
				break
			}
			if (r._gfmAutolinkLiteralWalkedInto) {
				n = !1
				break
			}
		}
		return e.length > 0 && !n && (e[e.length - 1][1]._gfmAutolinkLiteralWalkedInto = !0), n
	}
	const Jvt = { tokenize: ogt, partial: !0 }
	function Zvt() {
		return {
			document: {
				91: {
					name: "gfmFootnoteDefinition",
					tokenize: rgt,
					continuation: { tokenize: igt },
					exit: agt,
				},
			},
			text: {
				91: { name: "gfmFootnoteCall", tokenize: ngt },
				93: { name: "gfmPotentialFootnoteCall", add: "after", tokenize: egt, resolveTo: tgt },
			},
		}
	}
	function egt(e, t, n) {
		const r = this
		let i = r.events.length
		const a = r.parser.gfmFootnotes || (r.parser.gfmFootnotes = [])
		let o
		for (; i--; ) {
			const l = r.events[i][1]
			if (l.type === "labelImage") {
				o = l
				break
			}
			if (
				l.type === "gfmFootnoteCall" ||
				l.type === "labelLink" ||
				l.type === "label" ||
				l.type === "image" ||
				l.type === "link"
			)
				break
		}
		return s
		function s(l) {
			if (!o || !o._balanced) return n(l)
			const u = To(r.sliceSerialize({ start: o.end, end: r.now() }))
			return u.codePointAt(0) !== 94 || !a.includes(u.slice(1))
				? n(l)
				: (e.enter("gfmFootnoteCallLabelMarker"),
				  e.consume(l),
				  e.exit("gfmFootnoteCallLabelMarker"),
				  t(l))
		}
	}
	function tgt(e, t) {
		let n = e.length
		for (; n--; )
			if (e[n][1].type === "labelImage" && e[n][0] === "enter") {
				e[n][1]
				break
			}
		;(e[n + 1][1].type = "data"), (e[n + 3][1].type = "gfmFootnoteCallLabelMarker")
		const r = {
				type: "gfmFootnoteCall",
				start: Object.assign({}, e[n + 3][1].start),
				end: Object.assign({}, e[e.length - 1][1].end),
			},
			i = {
				type: "gfmFootnoteCallMarker",
				start: Object.assign({}, e[n + 3][1].end),
				end: Object.assign({}, e[n + 3][1].end),
			}
		i.end.column++, i.end.offset++, i.end._bufferIndex++
		const a = {
				type: "gfmFootnoteCallString",
				start: Object.assign({}, i.end),
				end: Object.assign({}, e[e.length - 1][1].start),
			},
			o = {
				type: "chunkString",
				contentType: "string",
				start: Object.assign({}, a.start),
				end: Object.assign({}, a.end),
			},
			s = [
				e[n + 1],
				e[n + 2],
				["enter", r, t],
				e[n + 3],
				e[n + 4],
				["enter", i, t],
				["exit", i, t],
				["enter", a, t],
				["enter", o, t],
				["exit", o, t],
				["exit", a, t],
				e[e.length - 2],
				e[e.length - 1],
				["exit", r, t],
			]
		return e.splice(n, e.length - n + 1, ...s), e
	}
	function ngt(e, t, n) {
		const r = this,
			i = r.parser.gfmFootnotes || (r.parser.gfmFootnotes = [])
		let a = 0,
			o
		return s
		function s(p) {
			return (
				e.enter("gfmFootnoteCall"),
				e.enter("gfmFootnoteCallLabelMarker"),
				e.consume(p),
				e.exit("gfmFootnoteCallLabelMarker"),
				l
			)
		}
		function l(p) {
			return p !== 94
				? n(p)
				: (e.enter("gfmFootnoteCallMarker"),
				  e.consume(p),
				  e.exit("gfmFootnoteCallMarker"),
				  e.enter("gfmFootnoteCallString"),
				  (e.enter("chunkString").contentType = "string"),
				  u)
		}
		function u(p) {
			if (a > 999 || (p === 93 && !o) || p === null || p === 91 || un(p)) return n(p)
			if (p === 93) {
				e.exit("chunkString")
				const m = e.exit("gfmFootnoteCallString")
				return i.includes(To(r.sliceSerialize(m)))
					? (e.enter("gfmFootnoteCallLabelMarker"),
					  e.consume(p),
					  e.exit("gfmFootnoteCallLabelMarker"),
					  e.exit("gfmFootnoteCall"),
					  t)
					: n(p)
			}
			return un(p) || (o = !0), a++, e.consume(p), p === 92 ? d : u
		}
		function d(p) {
			return p === 91 || p === 92 || p === 93 ? (e.consume(p), a++, u) : u(p)
		}
	}
	function rgt(e, t, n) {
		const r = this,
			i = r.parser.gfmFootnotes || (r.parser.gfmFootnotes = [])
		let a,
			o = 0,
			s
		return l
		function l(y) {
			return (
				(e.enter("gfmFootnoteDefinition")._container = !0),
				e.enter("gfmFootnoteDefinitionLabel"),
				e.enter("gfmFootnoteDefinitionLabelMarker"),
				e.consume(y),
				e.exit("gfmFootnoteDefinitionLabelMarker"),
				u
			)
		}
		function u(y) {
			return y === 94
				? (e.enter("gfmFootnoteDefinitionMarker"),
				  e.consume(y),
				  e.exit("gfmFootnoteDefinitionMarker"),
				  e.enter("gfmFootnoteDefinitionLabelString"),
				  (e.enter("chunkString").contentType = "string"),
				  d)
				: n(y)
		}
		function d(y) {
			if (o > 999 || (y === 93 && !s) || y === null || y === 91 || un(y)) return n(y)
			if (y === 93) {
				e.exit("chunkString")
				const b = e.exit("gfmFootnoteDefinitionLabelString")
				return (
					(a = To(r.sliceSerialize(b))),
					e.enter("gfmFootnoteDefinitionLabelMarker"),
					e.consume(y),
					e.exit("gfmFootnoteDefinitionLabelMarker"),
					e.exit("gfmFootnoteDefinitionLabel"),
					m
				)
			}
			return un(y) || (s = !0), o++, e.consume(y), y === 92 ? p : d
		}
		function p(y) {
			return y === 91 || y === 92 || y === 93 ? (e.consume(y), o++, d) : d(y)
		}
		function m(y) {
			return y === 58
				? (e.enter("definitionMarker"),
				  e.consume(y),
				  e.exit("definitionMarker"),
				  i.includes(a) || i.push(a),
				  Nt(e, v, "gfmFootnoteDefinitionWhitespace"))
				: n(y)
		}
		function v(y) {
			return t(y)
		}
	}
	function igt(e, t, n) {
		return e.check(yg, t, e.attempt(Jvt, t, n))
	}
	function agt(e) {
		e.exit("gfmFootnoteDefinition")
	}
	function ogt(e, t, n) {
		const r = this
		return Nt(e, i, "gfmFootnoteDefinitionIndent", 5)
		function i(a) {
			const o = r.events[r.events.length - 1]
			return o &&
				o[1].type === "gfmFootnoteDefinitionIndent" &&
				o[2].sliceSerialize(o[1], !0).length === 4
				? t(a)
				: n(a)
		}
	}
	function sgt(e) {
		let n = (e || {}).singleTilde
		const r = { name: "strikethrough", tokenize: a, resolveAll: i }
		return (
			n == null && (n = !0),
			{ text: { 126: r }, insideSpan: { null: [r] }, attentionMarkers: { null: [126] } }
		)
		function i(o, s) {
			let l = -1
			for (; ++l < o.length; )
				if (
					o[l][0] === "enter" &&
					o[l][1].type === "strikethroughSequenceTemporary" &&
					o[l][1]._close
				) {
					let u = l
					for (; u--; )
						if (
							o[u][0] === "exit" &&
							o[u][1].type === "strikethroughSequenceTemporary" &&
							o[u][1]._open &&
							o[l][1].end.offset - o[l][1].start.offset ===
								o[u][1].end.offset - o[u][1].start.offset
						) {
							;(o[l][1].type = "strikethroughSequence"), (o[u][1].type = "strikethroughSequence")
							const d = {
									type: "strikethrough",
									start: Object.assign({}, o[u][1].start),
									end: Object.assign({}, o[l][1].end),
								},
								p = {
									type: "strikethroughText",
									start: Object.assign({}, o[u][1].end),
									end: Object.assign({}, o[l][1].start),
								},
								m = [
									["enter", d, s],
									["enter", o[u][1], s],
									["exit", o[u][1], s],
									["enter", p, s],
								],
								v = s.parser.constructs.insideSpan.null
							v && va(m, m.length, 0, Ew(v, o.slice(u + 1, l), s)),
								va(m, m.length, 0, [
									["exit", p, s],
									["enter", o[l][1], s],
									["exit", o[l][1], s],
									["exit", d, s],
								]),
								va(o, u - 1, l - u + 3, m),
								(l = u + m.length - 2)
							break
						}
				}
			for (l = -1; ++l < o.length; )
				o[l][1].type === "strikethroughSequenceTemporary" && (o[l][1].type = "data")
			return o
		}
		function a(o, s, l) {
			const u = this.previous,
				d = this.events
			let p = 0
			return m
			function m(y) {
				return u === 126 && d[d.length - 1][1].type !== "characterEscape"
					? l(y)
					: (o.enter("strikethroughSequenceTemporary"), v(y))
			}
			function v(y) {
				const b = Sp(u)
				if (y === 126) return p > 1 ? l(y) : (o.consume(y), p++, v)
				if (p < 2 && !n) return l(y)
				const x = o.exit("strikethroughSequenceTemporary"),
					E = Sp(y)
				return (x._open = !E || (E === 2 && !!b)), (x._close = !b || (b === 2 && !!E)), s(y)
			}
		}
	}
	class lgt {
		constructor() {
			this.map = []
		}
		add(t, n, r) {
			ugt(this, t, n, r)
		}
		consume(t) {
			if (
				(this.map.sort(function (a, o) {
					return a[0] - o[0]
				}),
				this.map.length === 0)
			)
				return
			let n = this.map.length
			const r = []
			for (; n > 0; )
				(n -= 1),
					r.push(t.slice(this.map[n][0] + this.map[n][1]), this.map[n][2]),
					(t.length = this.map[n][0])
			r.push([...t]), (t.length = 0)
			let i = r.pop()
			for (; i; ) t.push(...i), (i = r.pop())
			this.map.length = 0
		}
	}
	function ugt(e, t, n, r) {
		let i = 0
		if (!(n === 0 && r.length === 0)) {
			for (; i < e.map.length; ) {
				if (e.map[i][0] === t) {
					;(e.map[i][1] += n), e.map[i][2].push(...r)
					return
				}
				i += 1
			}
			e.map.push([t, n, r])
		}
	}
	function cgt(e, t) {
		let n = !1
		const r = []
		for (; t < e.length; ) {
			const i = e[t]
			if (n) {
				if (i[0] === "enter")
					i[1].type === "tableContent" &&
						r.push(e[t + 1][1].type === "tableDelimiterMarker" ? "left" : "none")
				else if (i[1].type === "tableContent") {
					if (e[t - 1][1].type === "tableDelimiterMarker") {
						const a = r.length - 1
						r[a] = r[a] === "left" ? "center" : "right"
					}
				} else if (i[1].type === "tableDelimiterRow") break
			} else i[0] === "enter" && i[1].type === "tableDelimiterRow" && (n = !0)
			t += 1
		}
		return r
	}
	function dgt() {
		return { flow: { null: { name: "table", tokenize: fgt, resolveAll: pgt } } }
	}
	function fgt(e, t, n) {
		const r = this
		let i = 0,
			a = 0,
			o
		return s
		function s(L) {
			let B = r.events.length - 1
			for (; B > -1; ) {
				const K = r.events[B][1].type
				if (K === "lineEnding" || K === "linePrefix") B--
				else break
			}
			const z = B > -1 ? r.events[B][1].type : null,
				V = z === "tableHead" || z === "tableRow" ? A : l
			return V === A && r.parser.lazy[r.now().line] ? n(L) : V(L)
		}
		function l(L) {
			return e.enter("tableHead"), e.enter("tableRow"), u(L)
		}
		function u(L) {
			return L === 124 || ((o = !0), (a += 1)), d(L)
		}
		function d(L) {
			return L === null
				? n(L)
				: ut(L)
				? a > 1
					? ((a = 0),
					  (r.interrupt = !0),
					  e.exit("tableRow"),
					  e.enter("lineEnding"),
					  e.consume(L),
					  e.exit("lineEnding"),
					  v)
					: n(L)
				: kt(L)
				? Nt(e, d, "whitespace")(L)
				: ((a += 1),
				  o && ((o = !1), (i += 1)),
				  L === 124
						? (e.enter("tableCellDivider"), e.consume(L), e.exit("tableCellDivider"), (o = !0), d)
						: (e.enter("data"), p(L)))
		}
		function p(L) {
			return L === null || L === 124 || un(L)
				? (e.exit("data"), d(L))
				: (e.consume(L), L === 92 ? m : p)
		}
		function m(L) {
			return L === 92 || L === 124 ? (e.consume(L), p) : p(L)
		}
		function v(L) {
			return (
				(r.interrupt = !1),
				r.parser.lazy[r.now().line]
					? n(L)
					: (e.enter("tableDelimiterRow"),
					  (o = !1),
					  kt(L)
							? Nt(
									e,
									y,
									"linePrefix",
									r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4,
							  )(L)
							: y(L))
			)
		}
		function y(L) {
			return L === 45 || L === 58
				? x(L)
				: L === 124
				? ((o = !0), e.enter("tableCellDivider"), e.consume(L), e.exit("tableCellDivider"), b)
				: O(L)
		}
		function b(L) {
			return kt(L) ? Nt(e, x, "whitespace")(L) : x(L)
		}
		function x(L) {
			return L === 58
				? ((a += 1),
				  (o = !0),
				  e.enter("tableDelimiterMarker"),
				  e.consume(L),
				  e.exit("tableDelimiterMarker"),
				  E)
				: L === 45
				? ((a += 1), E(L))
				: L === null || ut(L)
				? D(L)
				: O(L)
		}
		function E(L) {
			return L === 45 ? (e.enter("tableDelimiterFiller"), T(L)) : O(L)
		}
		function T(L) {
			return L === 45
				? (e.consume(L), T)
				: L === 58
				? ((o = !0),
				  e.exit("tableDelimiterFiller"),
				  e.enter("tableDelimiterMarker"),
				  e.consume(L),
				  e.exit("tableDelimiterMarker"),
				  C)
				: (e.exit("tableDelimiterFiller"), C(L))
		}
		function C(L) {
			return kt(L) ? Nt(e, D, "whitespace")(L) : D(L)
		}
		function D(L) {
			return L === 124
				? y(L)
				: L === null || ut(L)
				? !o || i !== a
					? O(L)
					: (e.exit("tableDelimiterRow"), e.exit("tableHead"), t(L))
				: O(L)
		}
		function O(L) {
			return n(L)
		}
		function A(L) {
			return e.enter("tableRow"), N(L)
		}
		function N(L) {
			return L === 124
				? (e.enter("tableCellDivider"), e.consume(L), e.exit("tableCellDivider"), N)
				: L === null || ut(L)
				? (e.exit("tableRow"), t(L))
				: kt(L)
				? Nt(e, N, "whitespace")(L)
				: (e.enter("data"), I(L))
		}
		function I(L) {
			return L === null || L === 124 || un(L)
				? (e.exit("data"), N(L))
				: (e.consume(L), L === 92 ? P : I)
		}
		function P(L) {
			return L === 92 || L === 124 ? (e.consume(L), I) : I(L)
		}
	}
	function pgt(e, t) {
		let n = -1,
			r = !0,
			i = 0,
			a = [0, 0, 0, 0],
			o = [0, 0, 0, 0],
			s = !1,
			l = 0,
			u,
			d,
			p
		const m = new lgt()
		for (; ++n < e.length; ) {
			const v = e[n],
				y = v[1]
			v[0] === "enter"
				? y.type === "tableHead"
					? ((s = !1),
					  l !== 0 && (bF(m, t, l, u, d), (d = void 0), (l = 0)),
					  (u = {
							type: "table",
							start: Object.assign({}, y.start),
							end: Object.assign({}, y.end),
					  }),
					  m.add(n, 0, [["enter", u, t]]))
					: y.type === "tableRow" || y.type === "tableDelimiterRow"
					? ((r = !0),
					  (p = void 0),
					  (a = [0, 0, 0, 0]),
					  (o = [0, n + 1, 0, 0]),
					  s &&
							((s = !1),
							(d = {
								type: "tableBody",
								start: Object.assign({}, y.start),
								end: Object.assign({}, y.end),
							}),
							m.add(n, 0, [["enter", d, t]])),
					  (i = y.type === "tableDelimiterRow" ? 2 : d ? 3 : 1))
					: i &&
					  (y.type === "data" ||
							y.type === "tableDelimiterMarker" ||
							y.type === "tableDelimiterFiller")
					? ((r = !1),
					  o[2] === 0 &&
							(a[1] !== 0 && ((o[0] = o[1]), (p = by(m, t, a, i, void 0, p)), (a = [0, 0, 0, 0])),
							(o[2] = n)))
					: y.type === "tableCellDivider" &&
					  (r
							? (r = !1)
							: (a[1] !== 0 && ((o[0] = o[1]), (p = by(m, t, a, i, void 0, p))),
							  (a = o),
							  (o = [a[1], n, 0, 0])))
				: y.type === "tableHead"
				? ((s = !0), (l = n))
				: y.type === "tableRow" || y.type === "tableDelimiterRow"
				? ((l = n),
				  a[1] !== 0
						? ((o[0] = o[1]), (p = by(m, t, a, i, n, p)))
						: o[1] !== 0 && (p = by(m, t, o, i, n, p)),
				  (i = 0))
				: i &&
				  (y.type === "data" ||
						y.type === "tableDelimiterMarker" ||
						y.type === "tableDelimiterFiller") &&
				  (o[3] = n)
		}
		for (l !== 0 && bF(m, t, l, u, d), m.consume(t.events), n = -1; ++n < t.events.length; ) {
			const v = t.events[n]
			v[0] === "enter" && v[1].type === "table" && (v[1]._align = cgt(t.events, n))
		}
		return e
	}
	function by(e, t, n, r, i, a) {
		const o = r === 1 ? "tableHeader" : r === 2 ? "tableDelimiter" : "tableData",
			s = "tableContent"
		n[0] !== 0 &&
			((a.end = Object.assign({}, Nf(t.events, n[0]))), e.add(n[0], 0, [["exit", a, t]]))
		const l = Nf(t.events, n[1])
		if (
			((a = { type: o, start: Object.assign({}, l), end: Object.assign({}, l) }),
			e.add(n[1], 0, [["enter", a, t]]),
			n[2] !== 0)
		) {
			const u = Nf(t.events, n[2]),
				d = Nf(t.events, n[3]),
				p = { type: s, start: Object.assign({}, u), end: Object.assign({}, d) }
			if ((e.add(n[2], 0, [["enter", p, t]]), r !== 2)) {
				const m = t.events[n[2]],
					v = t.events[n[3]]
				if (
					((m[1].end = Object.assign({}, v[1].end)),
					(m[1].type = "chunkText"),
					(m[1].contentType = "text"),
					n[3] > n[2] + 1)
				) {
					const y = n[2] + 1,
						b = n[3] - n[2] - 1
					e.add(y, b, [])
				}
			}
			e.add(n[3] + 1, 0, [["exit", p, t]])
		}
		return (
			i !== void 0 &&
				((a.end = Object.assign({}, Nf(t.events, i))), e.add(i, 0, [["exit", a, t]]), (a = void 0)),
			a
		)
	}
	function bF(e, t, n, r, i) {
		const a = [],
			o = Nf(t.events, n)
		i && ((i.end = Object.assign({}, o)), a.push(["exit", i, t])),
			(r.end = Object.assign({}, o)),
			a.push(["exit", r, t]),
			e.add(n + 1, 0, a)
	}
	function Nf(e, t) {
		const n = e[t],
			r = n[0] === "enter" ? "start" : "end"
		return n[1][r]
	}
	const hgt = { name: "tasklistCheck", tokenize: vgt }
	function mgt() {
		return { text: { 91: hgt } }
	}
	function vgt(e, t, n) {
		const r = this
		return i
		function i(l) {
			return r.previous !== null || !r._gfmTasklistFirstContentOfListItem
				? n(l)
				: (e.enter("taskListCheck"),
				  e.enter("taskListCheckMarker"),
				  e.consume(l),
				  e.exit("taskListCheckMarker"),
				  a)
		}
		function a(l) {
			return un(l)
				? (e.enter("taskListCheckValueUnchecked"),
				  e.consume(l),
				  e.exit("taskListCheckValueUnchecked"),
				  o)
				: l === 88 || l === 120
				? (e.enter("taskListCheckValueChecked"),
				  e.consume(l),
				  e.exit("taskListCheckValueChecked"),
				  o)
				: n(l)
		}
		function o(l) {
			return l === 93
				? (e.enter("taskListCheckMarker"),
				  e.consume(l),
				  e.exit("taskListCheckMarker"),
				  e.exit("taskListCheck"),
				  s)
				: n(l)
		}
		function s(l) {
			return ut(l) ? t(l) : kt(l) ? e.check({ tokenize: ggt }, t, n)(l) : n(l)
		}
	}
	function ggt(e, t, n) {
		return Nt(e, r, "whitespace")
		function r(i) {
			return i === null ? n(i) : t(i)
		}
	}
	function ygt(e) {
		return iV([zvt(), Zvt(), sgt(e), dgt(), mgt()])
	}
	const bgt = {}
	function xgt(e) {
		const t = this,
			n = e || bgt,
			r = t.data(),
			i = r.micromarkExtensions || (r.micromarkExtensions = []),
			a = r.fromMarkdownExtensions || (r.fromMarkdownExtensions = []),
			o = r.toMarkdownExtensions || (r.toMarkdownExtensions = [])
		i.push(ygt(n)), a.push(Bvt()), o.push(Hvt(n))
	}
	const tc = (e) => {
			const { text: t } = e
			return h.jsx(kV, { remarkPlugins: [xgt], rehypePlugins: [cmt], children: t })
		},
		wgt = (e) => {
			const { pageContent: t } = e
			return h.jsxs("div", {
				children: [
					h.jsx("h3", { className: "text-primary mb-3", children: t.title }),
					h.jsx(tc, { text: t.content }),
				],
			})
		},
		Rl = (e) => {
			const { pageCode: t } = e,
				{ pageContent: n, isLoading: r } = sve(void 0, {
					selectFromResult: ({ data: s }) => ({
						pageContent: new rve(s == null ? void 0 : s.find((l) => l.page_type === t)),
						isLoading: r,
					}),
				}),
				i = Wt(),
				a = _.useRef(),
				o = () => {
					var s
					;(s = a.current) == null || s.close()
				}
			return h.jsx(ht, {
				loading: r,
				children: h.jsx(Wr, {
					ref: a,
					initEdit: !1,
					canEdit: i.canEditPageContent(),
					viewComponent: h.jsx(wgt, { pageContent: n }),
					editComponent: h.jsx(qst, { pageContent: n, onClose: o }),
				}),
			})
		},
		xF = (e) => {
			const { document: t, file: n } = e,
				r = new FormData()
			if (
				(t.id && r.append("id", t.id.toString()),
				t.tournament && r.append("tournament", t.tournament.toString()),
				t.tags)
			) {
				const i = t.tags.map((a) => a.name).join("|")
				r.append("tags", i)
			}
			return (
				r.append("document_type", t.document_type),
				r.append("year", t.year.toString()),
				r.append("title", t.title),
				n && r.append("file", n, n.name),
				r
			)
		},
		Egt = (e) => {
			const t = e.year || 0,
				n = e.tournamentId || 0
			let r = "?d=1"
			return (
				t > 0 && (r = r + `&year=${t}`),
				n > 0 && (r = r + `&tournament=${n}`),
				e.documentType
					? (r = r + `&type=${e.documentType}`)
					: e.documentTypes && (r = r + e.documentTypes.map((i) => `&type=${i}`)),
				e.tags && (r = r + `&tags=${e.tags}`),
				r
			)
		},
		Cgt = Ui.injectEndpoints({
			endpoints: (e) => ({
				getDocuments: e.query({
					query: (t) => ({ url: "/documents/" + Egt(t), method: "GET" }),
					providesTags: [{ type: "Documents", id: "LIST" }],
				}),
				updateDocument: e.mutation({
					query(t) {
						const { id: n } = t.document
						return { url: `/documents/${n}/`, method: "PUT", data: xF(t) }
					},
					invalidatesTags: [{ type: "Documents", id: "LIST" }],
				}),
				addDocument: e.mutation({
					query(t) {
						return { url: "/documents/", method: "POST", data: xF(t) }
					},
					invalidatesTags: [{ type: "Documents", id: "LIST" }],
				}),
				deleteDocument: e.mutation({
					query(t) {
						return { url: `/documents/${t}/`, method: "DELETE" }
					},
					invalidatesTags: [{ type: "Documents", id: "LIST" }],
				}),
			}),
		}),
		{
			useGetDocumentsQuery: sh,
			useAddDocumentMutation: Tgt,
			useUpdateDocumentMutation: kgt,
			useDeleteDocumentMutation: Sgt,
		} = Cgt
	class zu extends _n {
		constructor(n) {
			super()
			q(this, "year", Te().year())
			q(this, "title", "")
			q(this, "documentType", "Other")
			q(this, "file")
			q(this, "lastUpdate")
			q(this, "createdBy")
			q(this, "tournament")
			q(this, "tags")
			const r = this.fromJson(n)
			n && n.tags && (r.tags = n.tags.map((i) => ({ id: i.id, name: i.tag }))),
				Object.assign(this, r)
		}
		get extension() {
			if (this.file) {
				const n = this.file.split(".")
				return n[n.length - 1]
			}
			return ""
		}
	}
	class LA extends _n {
		constructor(n) {
			super()
			q(this, "year", Te().year())
			q(this, "caption")
			q(this, "photoType", "Other")
			q(this, "thumbnailUrl")
			q(this, "imageUrl")
			q(this, "rawImage")
			q(this, "lastUpdate")
			q(this, "createdBy")
			q(this, "tournament")
			q(this, "tags")
			const r = this.fromJson(n)
			n && n.tags && (r.tags = n.tags.map((i) => ({ id: i.id, name: i.tag }))),
				Object.assign(this, r)
		}
	}
	const br = (e) =>
		h.jsx(H.Fragment, {
			children: e.canCancel
				? h.jsx(Ge, {
						variant: "light",
						size: "sm",
						className: "ml-2",
						onClick: () => e.OnCancel(),
						children: e.title || "Cancel",
				  })
				: null,
		})
	var xy
	function wF(e) {
		if (((!xy && xy !== 0) || e) && Zp) {
			var t = document.createElement("div")
			;(t.style.position = "absolute"),
				(t.style.top = "-9999px"),
				(t.style.width = "50px"),
				(t.style.height = "50px"),
				(t.style.overflow = "scroll"),
				document.body.appendChild(t),
				(xy = t.offsetWidth - t.clientWidth),
				document.body.removeChild(t)
		}
		return xy
	}
	function Dgt() {
		return _.useState(null)
	}
	function _gt(e) {
		const t = _.useRef(e)
		return (t.current = e), t
	}
	function Ogt(e) {
		const t = _gt(e)
		_.useEffect(() => () => t.current(), [])
	}
	const IW = _.forwardRef(
		({ className: e, bsPrefix: t, as: n = "div", ...r }, i) => (
			(t = nt(t, "modal-body")), h.jsx(n, { ref: i, className: Fe(e, t), ...r })
		),
	)
	IW.displayName = "ModalBody"
	const PA = _.forwardRef(
		(
			{
				bsPrefix: e,
				className: t,
				contentClassName: n,
				centered: r,
				size: i,
				fullscreen: a,
				children: o,
				scrollable: s,
				...l
			},
			u,
		) => {
			e = nt(e, "modal")
			const d = `${e}-dialog`,
				p = typeof a == "string" ? `${e}-fullscreen-${a}` : `${e}-fullscreen`
			return h.jsx("div", {
				...l,
				ref: u,
				className: Fe(d, t, i && `${e}-${i}`, r && `${d}-centered`, s && `${d}-scrollable`, a && p),
				children: h.jsx("div", { className: Fe(`${e}-content`, n), children: o }),
			})
		},
	)
	PA.displayName = "ModalDialog"
	const RW = _.forwardRef(
		({ className: e, bsPrefix: t, as: n = "div", ...r }, i) => (
			(t = nt(t, "modal-footer")), h.jsx(n, { ref: i, className: Fe(e, t), ...r })
		),
	)
	RW.displayName = "ModalFooter"
	const LW = _.forwardRef(
		({ bsPrefix: e, className: t, closeLabel: n = "Close", closeButton: r = !1, ...i }, a) => (
			(e = nt(e, "modal-header")),
			h.jsx(u$, { ref: a, ...i, className: Fe(t, e), closeLabel: n, closeButton: r })
		),
	)
	LW.displayName = "ModalHeader"
	const Agt = Ux("h4"),
		PW = _.forwardRef(
			({ className: e, bsPrefix: t, as: n = Agt, ...r }, i) => (
				(t = nt(t, "modal-title")), h.jsx(n, { ref: i, className: Fe(e, t), ...r })
			),
		)
	PW.displayName = "ModalTitle"
	function Ngt(e) {
		return h.jsx(Yx, { ...e, timeout: null })
	}
	function Mgt(e) {
		return h.jsx(Yx, { ...e, timeout: null })
	}
	const jW = _.forwardRef(
		(
			{
				bsPrefix: e,
				className: t,
				style: n,
				dialogClassName: r,
				contentClassName: i,
				children: a,
				dialogAs: o = PA,
				"data-bs-theme": s,
				"aria-labelledby": l,
				"aria-describedby": u,
				"aria-label": d,
				show: p = !1,
				animation: m = !0,
				backdrop: v = !0,
				keyboard: y = !0,
				onEscapeKeyDown: b,
				onShow: x,
				onHide: E,
				container: T,
				autoFocus: C = !0,
				enforceFocus: D = !0,
				restoreFocus: O = !0,
				restoreFocusOptions: A,
				onEntered: N,
				onExit: I,
				onExiting: P,
				onEnter: L,
				onEntering: B,
				onExited: z,
				backdropClassName: V,
				manager: K,
				...ne
			},
			re,
		) => {
			const [ie, J] = _.useState({}),
				[le, F] = _.useState(!1),
				Y = _.useRef(!1),
				ee = _.useRef(!1),
				$ = _.useRef(null),
				[ge, Se] = Dgt(),
				Ee = qx(re, Se),
				be = wl(E),
				Le = xB()
			e = nt(e, "modal")
			const Be = _.useMemo(() => ({ onHide: be }), [be])
			function et() {
				return K || p$({ isRTL: Le })
			}
			function pt(X) {
				if (!Zp) return
				const de = et().getScrollbarWidth() > 0,
					Me = X.scrollHeight > Jp(X).documentElement.clientHeight
				J({ paddingRight: de && !Me ? wF() : void 0, paddingLeft: !de && Me ? wF() : void 0 })
			}
			const mt = wl(() => {
				ge && pt(ge.dialog)
			})
			Ogt(() => {
				d2(window, "resize", mt), $.current == null || $.current()
			})
			const Xt = () => {
					Y.current = !0
				},
				on = (X) => {
					Y.current && ge && X.target === ge.dialog && (ee.current = !0), (Y.current = !1)
				},
				dt = () => {
					F(!0),
						($.current = XH(ge.dialog, () => {
							F(!1)
						}))
				},
				cn = (X) => {
					X.target === X.currentTarget && dt()
				},
				sn = (X) => {
					if (v === "static") {
						cn(X)
						return
					}
					if (ee.current || X.target !== X.currentTarget) {
						ee.current = !1
						return
					}
					E == null || E()
				},
				ur = (X) => {
					y ? b == null || b(X) : (X.preventDefault(), v === "static" && dt())
				},
				Hn = (X, de) => {
					X && pt(X), L == null || L(X, de)
				},
				Jt = (X) => {
					$.current == null || $.current(), I == null || I(X)
				},
				mn = (X, de) => {
					B == null || B(X, de), J_(window, "resize", mt)
				},
				ue = (X) => {
					X && (X.style.display = ""), z == null || z(X), d2(window, "resize", mt)
				},
				Re = _.useCallback(
					(X) => h.jsx("div", { ...X, className: Fe(`${e}-backdrop`, V, !m && "show") }),
					[m, V, e],
				),
				pe = { ...n, ...ie }
			pe.display = "block"
			const ye = (X) =>
				h.jsx("div", {
					role: "dialog",
					...X,
					style: pe,
					className: Fe(t, e, le && `${e}-static`, !m && "show"),
					onClick: v ? sn : void 0,
					onMouseUp: on,
					"data-bs-theme": s,
					"aria-label": d,
					"aria-labelledby": l,
					"aria-describedby": u,
					children: h.jsx(o, {
						...ne,
						onMouseDown: Xt,
						className: r,
						contentClassName: i,
						children: a,
					}),
				})
			return h.jsx(nO.Provider, {
				value: Be,
				children: h.jsx(o$, {
					show: p,
					ref: Ee,
					backdrop: v,
					container: T,
					keyboard: !0,
					autoFocus: C,
					enforceFocus: D,
					restoreFocus: O,
					restoreFocusOptions: A,
					onEscapeKeyDown: ur,
					onShow: x,
					onHide: E,
					onEnter: Hn,
					onEntering: mn,
					onEntered: N,
					onExit: Jt,
					onExiting: P,
					onExited: ue,
					manager: et(),
					transition: m ? Ngt : void 0,
					backdropTransition: m ? Mgt : void 0,
					renderBackdrop: Re,
					renderDialog: ye,
				}),
			})
		},
	)
	jW.displayName = "Modal"
	const Or = Object.assign(jW, {
			Body: IW,
			Header: LW,
			Title: PW,
			Footer: RW,
			Dialog: PA,
			TRANSITION_DURATION: 300,
			BACKDROP_TRANSITION_DURATION: 150,
		}),
		Pd = (e) => {
			const { messageText: t, titleText: n, DoConfirm: r, DoCancel: i } = e,
				a = e.cancelText || "Cancel",
				o = e.confirmText || "Continue"
			return h.jsxs(Or, {
				show: e.show,
				onHide: () => i(),
				children: [
					h.jsx(Or.Header, { closeButton: !0, children: h.jsx(Or.Title, { children: n }) }),
					h.jsx(Or.Body, { children: t }),
					h.jsxs(Or.Footer, {
						children: [
							h.jsx(Ge, { variant: "light", onClick: () => i(), children: a }),
							h.jsx(Ge, { variant: "danger", onClick: () => r(), children: o }),
						],
					}),
				],
			})
		},
		jd = (e) => {
			const t = Up((n) => n.app)
			return h.jsx(H.Fragment, {
				children: e.canDelete
					? h.jsx(Ge, {
							variant: "outline-danger",
							size: "sm",
							className: "ml-2",
							disabled: t.isBusy,
							onClick: () => e.OnDelete(),
							children: e.title || "Delete",
					  })
					: null,
			})
		}
	function Fd(e, t, n, r) {
		function i(a) {
			return a instanceof n
				? a
				: new n(function (o) {
						o(a)
				  })
		}
		return new (n || (n = Promise))(function (a, o) {
			function s(d) {
				try {
					u(r.next(d))
				} catch (p) {
					o(p)
				}
			}
			function l(d) {
				try {
					u(r.throw(d))
				} catch (p) {
					o(p)
				}
			}
			function u(d) {
				d.done ? a(d.value) : i(d.value).then(s, l)
			}
			u((r = r.apply(e, t || [])).next())
		})
	}
	const Igt = new Map([
		["1km", "application/vnd.1000minds.decision-model+xml"],
		["3dml", "text/vnd.in3d.3dml"],
		["3ds", "image/x-3ds"],
		["3g2", "video/3gpp2"],
		["3gp", "video/3gp"],
		["3gpp", "video/3gpp"],
		["3mf", "model/3mf"],
		["7z", "application/x-7z-compressed"],
		["7zip", "application/x-7z-compressed"],
		["123", "application/vnd.lotus-1-2-3"],
		["aab", "application/x-authorware-bin"],
		["aac", "audio/x-acc"],
		["aam", "application/x-authorware-map"],
		["aas", "application/x-authorware-seg"],
		["abw", "application/x-abiword"],
		["ac", "application/vnd.nokia.n-gage.ac+xml"],
		["ac3", "audio/ac3"],
		["acc", "application/vnd.americandynamics.acc"],
		["ace", "application/x-ace-compressed"],
		["acu", "application/vnd.acucobol"],
		["acutc", "application/vnd.acucorp"],
		["adp", "audio/adpcm"],
		["aep", "application/vnd.audiograph"],
		["afm", "application/x-font-type1"],
		["afp", "application/vnd.ibm.modcap"],
		["ahead", "application/vnd.ahead.space"],
		["ai", "application/pdf"],
		["aif", "audio/x-aiff"],
		["aifc", "audio/x-aiff"],
		["aiff", "audio/x-aiff"],
		["air", "application/vnd.adobe.air-application-installer-package+zip"],
		["ait", "application/vnd.dvb.ait"],
		["ami", "application/vnd.amiga.ami"],
		["amr", "audio/amr"],
		["apk", "application/vnd.android.package-archive"],
		["apng", "image/apng"],
		["appcache", "text/cache-manifest"],
		["application", "application/x-ms-application"],
		["apr", "application/vnd.lotus-approach"],
		["arc", "application/x-freearc"],
		["arj", "application/x-arj"],
		["asc", "application/pgp-signature"],
		["asf", "video/x-ms-asf"],
		["asm", "text/x-asm"],
		["aso", "application/vnd.accpac.simply.aso"],
		["asx", "video/x-ms-asf"],
		["atc", "application/vnd.acucorp"],
		["atom", "application/atom+xml"],
		["atomcat", "application/atomcat+xml"],
		["atomdeleted", "application/atomdeleted+xml"],
		["atomsvc", "application/atomsvc+xml"],
		["atx", "application/vnd.antix.game-component"],
		["au", "audio/x-au"],
		["avi", "video/x-msvideo"],
		["avif", "image/avif"],
		["aw", "application/applixware"],
		["azf", "application/vnd.airzip.filesecure.azf"],
		["azs", "application/vnd.airzip.filesecure.azs"],
		["azv", "image/vnd.airzip.accelerator.azv"],
		["azw", "application/vnd.amazon.ebook"],
		["b16", "image/vnd.pco.b16"],
		["bat", "application/x-msdownload"],
		["bcpio", "application/x-bcpio"],
		["bdf", "application/x-font-bdf"],
		["bdm", "application/vnd.syncml.dm+wbxml"],
		["bdoc", "application/x-bdoc"],
		["bed", "application/vnd.realvnc.bed"],
		["bh2", "application/vnd.fujitsu.oasysprs"],
		["bin", "application/octet-stream"],
		["blb", "application/x-blorb"],
		["blorb", "application/x-blorb"],
		["bmi", "application/vnd.bmi"],
		["bmml", "application/vnd.balsamiq.bmml+xml"],
		["bmp", "image/bmp"],
		["book", "application/vnd.framemaker"],
		["box", "application/vnd.previewsystems.box"],
		["boz", "application/x-bzip2"],
		["bpk", "application/octet-stream"],
		["bpmn", "application/octet-stream"],
		["bsp", "model/vnd.valve.source.compiled-map"],
		["btif", "image/prs.btif"],
		["buffer", "application/octet-stream"],
		["bz", "application/x-bzip"],
		["bz2", "application/x-bzip2"],
		["c", "text/x-c"],
		["c4d", "application/vnd.clonk.c4group"],
		["c4f", "application/vnd.clonk.c4group"],
		["c4g", "application/vnd.clonk.c4group"],
		["c4p", "application/vnd.clonk.c4group"],
		["c4u", "application/vnd.clonk.c4group"],
		["c11amc", "application/vnd.cluetrust.cartomobile-config"],
		["c11amz", "application/vnd.cluetrust.cartomobile-config-pkg"],
		["cab", "application/vnd.ms-cab-compressed"],
		["caf", "audio/x-caf"],
		["cap", "application/vnd.tcpdump.pcap"],
		["car", "application/vnd.curl.car"],
		["cat", "application/vnd.ms-pki.seccat"],
		["cb7", "application/x-cbr"],
		["cba", "application/x-cbr"],
		["cbr", "application/x-cbr"],
		["cbt", "application/x-cbr"],
		["cbz", "application/x-cbr"],
		["cc", "text/x-c"],
		["cco", "application/x-cocoa"],
		["cct", "application/x-director"],
		["ccxml", "application/ccxml+xml"],
		["cdbcmsg", "application/vnd.contact.cmsg"],
		["cda", "application/x-cdf"],
		["cdf", "application/x-netcdf"],
		["cdfx", "application/cdfx+xml"],
		["cdkey", "application/vnd.mediastation.cdkey"],
		["cdmia", "application/cdmi-capability"],
		["cdmic", "application/cdmi-container"],
		["cdmid", "application/cdmi-domain"],
		["cdmio", "application/cdmi-object"],
		["cdmiq", "application/cdmi-queue"],
		["cdr", "application/cdr"],
		["cdx", "chemical/x-cdx"],
		["cdxml", "application/vnd.chemdraw+xml"],
		["cdy", "application/vnd.cinderella"],
		["cer", "application/pkix-cert"],
		["cfs", "application/x-cfs-compressed"],
		["cgm", "image/cgm"],
		["chat", "application/x-chat"],
		["chm", "application/vnd.ms-htmlhelp"],
		["chrt", "application/vnd.kde.kchart"],
		["cif", "chemical/x-cif"],
		["cii", "application/vnd.anser-web-certificate-issue-initiation"],
		["cil", "application/vnd.ms-artgalry"],
		["cjs", "application/node"],
		["cla", "application/vnd.claymore"],
		["class", "application/octet-stream"],
		["clkk", "application/vnd.crick.clicker.keyboard"],
		["clkp", "application/vnd.crick.clicker.palette"],
		["clkt", "application/vnd.crick.clicker.template"],
		["clkw", "application/vnd.crick.clicker.wordbank"],
		["clkx", "application/vnd.crick.clicker"],
		["clp", "application/x-msclip"],
		["cmc", "application/vnd.cosmocaller"],
		["cmdf", "chemical/x-cmdf"],
		["cml", "chemical/x-cml"],
		["cmp", "application/vnd.yellowriver-custom-menu"],
		["cmx", "image/x-cmx"],
		["cod", "application/vnd.rim.cod"],
		["coffee", "text/coffeescript"],
		["com", "application/x-msdownload"],
		["conf", "text/plain"],
		["cpio", "application/x-cpio"],
		["cpp", "text/x-c"],
		["cpt", "application/mac-compactpro"],
		["crd", "application/x-mscardfile"],
		["crl", "application/pkix-crl"],
		["crt", "application/x-x509-ca-cert"],
		["crx", "application/x-chrome-extension"],
		["cryptonote", "application/vnd.rig.cryptonote"],
		["csh", "application/x-csh"],
		["csl", "application/vnd.citationstyles.style+xml"],
		["csml", "chemical/x-csml"],
		["csp", "application/vnd.commonspace"],
		["csr", "application/octet-stream"],
		["css", "text/css"],
		["cst", "application/x-director"],
		["csv", "text/csv"],
		["cu", "application/cu-seeme"],
		["curl", "text/vnd.curl"],
		["cww", "application/prs.cww"],
		["cxt", "application/x-director"],
		["cxx", "text/x-c"],
		["dae", "model/vnd.collada+xml"],
		["daf", "application/vnd.mobius.daf"],
		["dart", "application/vnd.dart"],
		["dataless", "application/vnd.fdsn.seed"],
		["davmount", "application/davmount+xml"],
		["dbf", "application/vnd.dbf"],
		["dbk", "application/docbook+xml"],
		["dcr", "application/x-director"],
		["dcurl", "text/vnd.curl.dcurl"],
		["dd2", "application/vnd.oma.dd2+xml"],
		["ddd", "application/vnd.fujixerox.ddd"],
		["ddf", "application/vnd.syncml.dmddf+xml"],
		["dds", "image/vnd.ms-dds"],
		["deb", "application/x-debian-package"],
		["def", "text/plain"],
		["deploy", "application/octet-stream"],
		["der", "application/x-x509-ca-cert"],
		["dfac", "application/vnd.dreamfactory"],
		["dgc", "application/x-dgc-compressed"],
		["dic", "text/x-c"],
		["dir", "application/x-director"],
		["dis", "application/vnd.mobius.dis"],
		["disposition-notification", "message/disposition-notification"],
		["dist", "application/octet-stream"],
		["distz", "application/octet-stream"],
		["djv", "image/vnd.djvu"],
		["djvu", "image/vnd.djvu"],
		["dll", "application/octet-stream"],
		["dmg", "application/x-apple-diskimage"],
		["dmn", "application/octet-stream"],
		["dmp", "application/vnd.tcpdump.pcap"],
		["dms", "application/octet-stream"],
		["dna", "application/vnd.dna"],
		["doc", "application/msword"],
		["docm", "application/vnd.ms-word.template.macroEnabled.12"],
		["docx", "application/vnd.openxmlformats-officedocument.wordprocessingml.document"],
		["dot", "application/msword"],
		["dotm", "application/vnd.ms-word.template.macroEnabled.12"],
		["dotx", "application/vnd.openxmlformats-officedocument.wordprocessingml.template"],
		["dp", "application/vnd.osgi.dp"],
		["dpg", "application/vnd.dpgraph"],
		["dra", "audio/vnd.dra"],
		["drle", "image/dicom-rle"],
		["dsc", "text/prs.lines.tag"],
		["dssc", "application/dssc+der"],
		["dtb", "application/x-dtbook+xml"],
		["dtd", "application/xml-dtd"],
		["dts", "audio/vnd.dts"],
		["dtshd", "audio/vnd.dts.hd"],
		["dump", "application/octet-stream"],
		["dvb", "video/vnd.dvb.file"],
		["dvi", "application/x-dvi"],
		["dwd", "application/atsc-dwd+xml"],
		["dwf", "model/vnd.dwf"],
		["dwg", "image/vnd.dwg"],
		["dxf", "image/vnd.dxf"],
		["dxp", "application/vnd.spotfire.dxp"],
		["dxr", "application/x-director"],
		["ear", "application/java-archive"],
		["ecelp4800", "audio/vnd.nuera.ecelp4800"],
		["ecelp7470", "audio/vnd.nuera.ecelp7470"],
		["ecelp9600", "audio/vnd.nuera.ecelp9600"],
		["ecma", "application/ecmascript"],
		["edm", "application/vnd.novadigm.edm"],
		["edx", "application/vnd.novadigm.edx"],
		["efif", "application/vnd.picsel"],
		["ei6", "application/vnd.pg.osasli"],
		["elc", "application/octet-stream"],
		["emf", "image/emf"],
		["eml", "message/rfc822"],
		["emma", "application/emma+xml"],
		["emotionml", "application/emotionml+xml"],
		["emz", "application/x-msmetafile"],
		["eol", "audio/vnd.digital-winds"],
		["eot", "application/vnd.ms-fontobject"],
		["eps", "application/postscript"],
		["epub", "application/epub+zip"],
		["es", "application/ecmascript"],
		["es3", "application/vnd.eszigno3+xml"],
		["esa", "application/vnd.osgi.subsystem"],
		["esf", "application/vnd.epson.esf"],
		["et3", "application/vnd.eszigno3+xml"],
		["etx", "text/x-setext"],
		["eva", "application/x-eva"],
		["evy", "application/x-envoy"],
		["exe", "application/octet-stream"],
		["exi", "application/exi"],
		["exp", "application/express"],
		["exr", "image/aces"],
		["ext", "application/vnd.novadigm.ext"],
		["ez", "application/andrew-inset"],
		["ez2", "application/vnd.ezpix-album"],
		["ez3", "application/vnd.ezpix-package"],
		["f", "text/x-fortran"],
		["f4v", "video/mp4"],
		["f77", "text/x-fortran"],
		["f90", "text/x-fortran"],
		["fbs", "image/vnd.fastbidsheet"],
		["fcdt", "application/vnd.adobe.formscentral.fcdt"],
		["fcs", "application/vnd.isac.fcs"],
		["fdf", "application/vnd.fdf"],
		["fdt", "application/fdt+xml"],
		["fe_launch", "application/vnd.denovo.fcselayout-link"],
		["fg5", "application/vnd.fujitsu.oasysgp"],
		["fgd", "application/x-director"],
		["fh", "image/x-freehand"],
		["fh4", "image/x-freehand"],
		["fh5", "image/x-freehand"],
		["fh7", "image/x-freehand"],
		["fhc", "image/x-freehand"],
		["fig", "application/x-xfig"],
		["fits", "image/fits"],
		["flac", "audio/x-flac"],
		["fli", "video/x-fli"],
		["flo", "application/vnd.micrografx.flo"],
		["flv", "video/x-flv"],
		["flw", "application/vnd.kde.kivio"],
		["flx", "text/vnd.fmi.flexstor"],
		["fly", "text/vnd.fly"],
		["fm", "application/vnd.framemaker"],
		["fnc", "application/vnd.frogans.fnc"],
		["fo", "application/vnd.software602.filler.form+xml"],
		["for", "text/x-fortran"],
		["fpx", "image/vnd.fpx"],
		["frame", "application/vnd.framemaker"],
		["fsc", "application/vnd.fsc.weblaunch"],
		["fst", "image/vnd.fst"],
		["ftc", "application/vnd.fluxtime.clip"],
		["fti", "application/vnd.anser-web-funds-transfer-initiation"],
		["fvt", "video/vnd.fvt"],
		["fxp", "application/vnd.adobe.fxp"],
		["fxpl", "application/vnd.adobe.fxp"],
		["fzs", "application/vnd.fuzzysheet"],
		["g2w", "application/vnd.geoplan"],
		["g3", "image/g3fax"],
		["g3w", "application/vnd.geospace"],
		["gac", "application/vnd.groove-account"],
		["gam", "application/x-tads"],
		["gbr", "application/rpki-ghostbusters"],
		["gca", "application/x-gca-compressed"],
		["gdl", "model/vnd.gdl"],
		["gdoc", "application/vnd.google-apps.document"],
		["geo", "application/vnd.dynageo"],
		["geojson", "application/geo+json"],
		["gex", "application/vnd.geometry-explorer"],
		["ggb", "application/vnd.geogebra.file"],
		["ggt", "application/vnd.geogebra.tool"],
		["ghf", "application/vnd.groove-help"],
		["gif", "image/gif"],
		["gim", "application/vnd.groove-identity-message"],
		["glb", "model/gltf-binary"],
		["gltf", "model/gltf+json"],
		["gml", "application/gml+xml"],
		["gmx", "application/vnd.gmx"],
		["gnumeric", "application/x-gnumeric"],
		["gpg", "application/gpg-keys"],
		["gph", "application/vnd.flographit"],
		["gpx", "application/gpx+xml"],
		["gqf", "application/vnd.grafeq"],
		["gqs", "application/vnd.grafeq"],
		["gram", "application/srgs"],
		["gramps", "application/x-gramps-xml"],
		["gre", "application/vnd.geometry-explorer"],
		["grv", "application/vnd.groove-injector"],
		["grxml", "application/srgs+xml"],
		["gsf", "application/x-font-ghostscript"],
		["gsheet", "application/vnd.google-apps.spreadsheet"],
		["gslides", "application/vnd.google-apps.presentation"],
		["gtar", "application/x-gtar"],
		["gtm", "application/vnd.groove-tool-message"],
		["gtw", "model/vnd.gtw"],
		["gv", "text/vnd.graphviz"],
		["gxf", "application/gxf"],
		["gxt", "application/vnd.geonext"],
		["gz", "application/gzip"],
		["gzip", "application/gzip"],
		["h", "text/x-c"],
		["h261", "video/h261"],
		["h263", "video/h263"],
		["h264", "video/h264"],
		["hal", "application/vnd.hal+xml"],
		["hbci", "application/vnd.hbci"],
		["hbs", "text/x-handlebars-template"],
		["hdd", "application/x-virtualbox-hdd"],
		["hdf", "application/x-hdf"],
		["heic", "image/heic"],
		["heics", "image/heic-sequence"],
		["heif", "image/heif"],
		["heifs", "image/heif-sequence"],
		["hej2", "image/hej2k"],
		["held", "application/atsc-held+xml"],
		["hh", "text/x-c"],
		["hjson", "application/hjson"],
		["hlp", "application/winhlp"],
		["hpgl", "application/vnd.hp-hpgl"],
		["hpid", "application/vnd.hp-hpid"],
		["hps", "application/vnd.hp-hps"],
		["hqx", "application/mac-binhex40"],
		["hsj2", "image/hsj2"],
		["htc", "text/x-component"],
		["htke", "application/vnd.kenameaapp"],
		["htm", "text/html"],
		["html", "text/html"],
		["hvd", "application/vnd.yamaha.hv-dic"],
		["hvp", "application/vnd.yamaha.hv-voice"],
		["hvs", "application/vnd.yamaha.hv-script"],
		["i2g", "application/vnd.intergeo"],
		["icc", "application/vnd.iccprofile"],
		["ice", "x-conference/x-cooltalk"],
		["icm", "application/vnd.iccprofile"],
		["ico", "image/x-icon"],
		["ics", "text/calendar"],
		["ief", "image/ief"],
		["ifb", "text/calendar"],
		["ifm", "application/vnd.shana.informed.formdata"],
		["iges", "model/iges"],
		["igl", "application/vnd.igloader"],
		["igm", "application/vnd.insors.igm"],
		["igs", "model/iges"],
		["igx", "application/vnd.micrografx.igx"],
		["iif", "application/vnd.shana.informed.interchange"],
		["img", "application/octet-stream"],
		["imp", "application/vnd.accpac.simply.imp"],
		["ims", "application/vnd.ms-ims"],
		["in", "text/plain"],
		["ini", "text/plain"],
		["ink", "application/inkml+xml"],
		["inkml", "application/inkml+xml"],
		["install", "application/x-install-instructions"],
		["iota", "application/vnd.astraea-software.iota"],
		["ipfix", "application/ipfix"],
		["ipk", "application/vnd.shana.informed.package"],
		["irm", "application/vnd.ibm.rights-management"],
		["irp", "application/vnd.irepository.package+xml"],
		["iso", "application/x-iso9660-image"],
		["itp", "application/vnd.shana.informed.formtemplate"],
		["its", "application/its+xml"],
		["ivp", "application/vnd.immervision-ivp"],
		["ivu", "application/vnd.immervision-ivu"],
		["jad", "text/vnd.sun.j2me.app-descriptor"],
		["jade", "text/jade"],
		["jam", "application/vnd.jam"],
		["jar", "application/java-archive"],
		["jardiff", "application/x-java-archive-diff"],
		["java", "text/x-java-source"],
		["jhc", "image/jphc"],
		["jisp", "application/vnd.jisp"],
		["jls", "image/jls"],
		["jlt", "application/vnd.hp-jlyt"],
		["jng", "image/x-jng"],
		["jnlp", "application/x-java-jnlp-file"],
		["joda", "application/vnd.joost.joda-archive"],
		["jp2", "image/jp2"],
		["jpe", "image/jpeg"],
		["jpeg", "image/jpeg"],
		["jpf", "image/jpx"],
		["jpg", "image/jpeg"],
		["jpg2", "image/jp2"],
		["jpgm", "video/jpm"],
		["jpgv", "video/jpeg"],
		["jph", "image/jph"],
		["jpm", "video/jpm"],
		["jpx", "image/jpx"],
		["js", "application/javascript"],
		["json", "application/json"],
		["json5", "application/json5"],
		["jsonld", "application/ld+json"],
		["jsonl", "application/jsonl"],
		["jsonml", "application/jsonml+json"],
		["jsx", "text/jsx"],
		["jxr", "image/jxr"],
		["jxra", "image/jxra"],
		["jxrs", "image/jxrs"],
		["jxs", "image/jxs"],
		["jxsc", "image/jxsc"],
		["jxsi", "image/jxsi"],
		["jxss", "image/jxss"],
		["kar", "audio/midi"],
		["karbon", "application/vnd.kde.karbon"],
		["kdb", "application/octet-stream"],
		["kdbx", "application/x-keepass2"],
		["key", "application/x-iwork-keynote-sffkey"],
		["kfo", "application/vnd.kde.kformula"],
		["kia", "application/vnd.kidspiration"],
		["kml", "application/vnd.google-earth.kml+xml"],
		["kmz", "application/vnd.google-earth.kmz"],
		["kne", "application/vnd.kinar"],
		["knp", "application/vnd.kinar"],
		["kon", "application/vnd.kde.kontour"],
		["kpr", "application/vnd.kde.kpresenter"],
		["kpt", "application/vnd.kde.kpresenter"],
		["kpxx", "application/vnd.ds-keypoint"],
		["ksp", "application/vnd.kde.kspread"],
		["ktr", "application/vnd.kahootz"],
		["ktx", "image/ktx"],
		["ktx2", "image/ktx2"],
		["ktz", "application/vnd.kahootz"],
		["kwd", "application/vnd.kde.kword"],
		["kwt", "application/vnd.kde.kword"],
		["lasxml", "application/vnd.las.las+xml"],
		["latex", "application/x-latex"],
		["lbd", "application/vnd.llamagraphics.life-balance.desktop"],
		["lbe", "application/vnd.llamagraphics.life-balance.exchange+xml"],
		["les", "application/vnd.hhe.lesson-player"],
		["less", "text/less"],
		["lgr", "application/lgr+xml"],
		["lha", "application/octet-stream"],
		["link66", "application/vnd.route66.link66+xml"],
		["list", "text/plain"],
		["list3820", "application/vnd.ibm.modcap"],
		["listafp", "application/vnd.ibm.modcap"],
		["litcoffee", "text/coffeescript"],
		["lnk", "application/x-ms-shortcut"],
		["log", "text/plain"],
		["lostxml", "application/lost+xml"],
		["lrf", "application/octet-stream"],
		["lrm", "application/vnd.ms-lrm"],
		["ltf", "application/vnd.frogans.ltf"],
		["lua", "text/x-lua"],
		["luac", "application/x-lua-bytecode"],
		["lvp", "audio/vnd.lucent.voice"],
		["lwp", "application/vnd.lotus-wordpro"],
		["lzh", "application/octet-stream"],
		["m1v", "video/mpeg"],
		["m2a", "audio/mpeg"],
		["m2v", "video/mpeg"],
		["m3a", "audio/mpeg"],
		["m3u", "text/plain"],
		["m3u8", "application/vnd.apple.mpegurl"],
		["m4a", "audio/x-m4a"],
		["m4p", "application/mp4"],
		["m4s", "video/iso.segment"],
		["m4u", "application/vnd.mpegurl"],
		["m4v", "video/x-m4v"],
		["m13", "application/x-msmediaview"],
		["m14", "application/x-msmediaview"],
		["m21", "application/mp21"],
		["ma", "application/mathematica"],
		["mads", "application/mads+xml"],
		["maei", "application/mmt-aei+xml"],
		["mag", "application/vnd.ecowin.chart"],
		["maker", "application/vnd.framemaker"],
		["man", "text/troff"],
		["manifest", "text/cache-manifest"],
		["map", "application/json"],
		["mar", "application/octet-stream"],
		["markdown", "text/markdown"],
		["mathml", "application/mathml+xml"],
		["mb", "application/mathematica"],
		["mbk", "application/vnd.mobius.mbk"],
		["mbox", "application/mbox"],
		["mc1", "application/vnd.medcalcdata"],
		["mcd", "application/vnd.mcd"],
		["mcurl", "text/vnd.curl.mcurl"],
		["md", "text/markdown"],
		["mdb", "application/x-msaccess"],
		["mdi", "image/vnd.ms-modi"],
		["mdx", "text/mdx"],
		["me", "text/troff"],
		["mesh", "model/mesh"],
		["meta4", "application/metalink4+xml"],
		["metalink", "application/metalink+xml"],
		["mets", "application/mets+xml"],
		["mfm", "application/vnd.mfmp"],
		["mft", "application/rpki-manifest"],
		["mgp", "application/vnd.osgeo.mapguide.package"],
		["mgz", "application/vnd.proteus.magazine"],
		["mid", "audio/midi"],
		["midi", "audio/midi"],
		["mie", "application/x-mie"],
		["mif", "application/vnd.mif"],
		["mime", "message/rfc822"],
		["mj2", "video/mj2"],
		["mjp2", "video/mj2"],
		["mjs", "application/javascript"],
		["mk3d", "video/x-matroska"],
		["mka", "audio/x-matroska"],
		["mkd", "text/x-markdown"],
		["mks", "video/x-matroska"],
		["mkv", "video/x-matroska"],
		["mlp", "application/vnd.dolby.mlp"],
		["mmd", "application/vnd.chipnuts.karaoke-mmd"],
		["mmf", "application/vnd.smaf"],
		["mml", "text/mathml"],
		["mmr", "image/vnd.fujixerox.edmics-mmr"],
		["mng", "video/x-mng"],
		["mny", "application/x-msmoney"],
		["mobi", "application/x-mobipocket-ebook"],
		["mods", "application/mods+xml"],
		["mov", "video/quicktime"],
		["movie", "video/x-sgi-movie"],
		["mp2", "audio/mpeg"],
		["mp2a", "audio/mpeg"],
		["mp3", "audio/mpeg"],
		["mp4", "video/mp4"],
		["mp4a", "audio/mp4"],
		["mp4s", "application/mp4"],
		["mp4v", "video/mp4"],
		["mp21", "application/mp21"],
		["mpc", "application/vnd.mophun.certificate"],
		["mpd", "application/dash+xml"],
		["mpe", "video/mpeg"],
		["mpeg", "video/mpeg"],
		["mpg", "video/mpeg"],
		["mpg4", "video/mp4"],
		["mpga", "audio/mpeg"],
		["mpkg", "application/vnd.apple.installer+xml"],
		["mpm", "application/vnd.blueice.multipass"],
		["mpn", "application/vnd.mophun.application"],
		["mpp", "application/vnd.ms-project"],
		["mpt", "application/vnd.ms-project"],
		["mpy", "application/vnd.ibm.minipay"],
		["mqy", "application/vnd.mobius.mqy"],
		["mrc", "application/marc"],
		["mrcx", "application/marcxml+xml"],
		["ms", "text/troff"],
		["mscml", "application/mediaservercontrol+xml"],
		["mseed", "application/vnd.fdsn.mseed"],
		["mseq", "application/vnd.mseq"],
		["msf", "application/vnd.epson.msf"],
		["msg", "application/vnd.ms-outlook"],
		["msh", "model/mesh"],
		["msi", "application/x-msdownload"],
		["msl", "application/vnd.mobius.msl"],
		["msm", "application/octet-stream"],
		["msp", "application/octet-stream"],
		["msty", "application/vnd.muvee.style"],
		["mtl", "model/mtl"],
		["mts", "model/vnd.mts"],
		["mus", "application/vnd.musician"],
		["musd", "application/mmt-usd+xml"],
		["musicxml", "application/vnd.recordare.musicxml+xml"],
		["mvb", "application/x-msmediaview"],
		["mvt", "application/vnd.mapbox-vector-tile"],
		["mwf", "application/vnd.mfer"],
		["mxf", "application/mxf"],
		["mxl", "application/vnd.recordare.musicxml"],
		["mxmf", "audio/mobile-xmf"],
		["mxml", "application/xv+xml"],
		["mxs", "application/vnd.triscape.mxs"],
		["mxu", "video/vnd.mpegurl"],
		["n-gage", "application/vnd.nokia.n-gage.symbian.install"],
		["n3", "text/n3"],
		["nb", "application/mathematica"],
		["nbp", "application/vnd.wolfram.player"],
		["nc", "application/x-netcdf"],
		["ncx", "application/x-dtbncx+xml"],
		["nfo", "text/x-nfo"],
		["ngdat", "application/vnd.nokia.n-gage.data"],
		["nitf", "application/vnd.nitf"],
		["nlu", "application/vnd.neurolanguage.nlu"],
		["nml", "application/vnd.enliven"],
		["nnd", "application/vnd.noblenet-directory"],
		["nns", "application/vnd.noblenet-sealer"],
		["nnw", "application/vnd.noblenet-web"],
		["npx", "image/vnd.net-fpx"],
		["nq", "application/n-quads"],
		["nsc", "application/x-conference"],
		["nsf", "application/vnd.lotus-notes"],
		["nt", "application/n-triples"],
		["ntf", "application/vnd.nitf"],
		["numbers", "application/x-iwork-numbers-sffnumbers"],
		["nzb", "application/x-nzb"],
		["oa2", "application/vnd.fujitsu.oasys2"],
		["oa3", "application/vnd.fujitsu.oasys3"],
		["oas", "application/vnd.fujitsu.oasys"],
		["obd", "application/x-msbinder"],
		["obgx", "application/vnd.openblox.game+xml"],
		["obj", "model/obj"],
		["oda", "application/oda"],
		["odb", "application/vnd.oasis.opendocument.database"],
		["odc", "application/vnd.oasis.opendocument.chart"],
		["odf", "application/vnd.oasis.opendocument.formula"],
		["odft", "application/vnd.oasis.opendocument.formula-template"],
		["odg", "application/vnd.oasis.opendocument.graphics"],
		["odi", "application/vnd.oasis.opendocument.image"],
		["odm", "application/vnd.oasis.opendocument.text-master"],
		["odp", "application/vnd.oasis.opendocument.presentation"],
		["ods", "application/vnd.oasis.opendocument.spreadsheet"],
		["odt", "application/vnd.oasis.opendocument.text"],
		["oga", "audio/ogg"],
		["ogex", "model/vnd.opengex"],
		["ogg", "audio/ogg"],
		["ogv", "video/ogg"],
		["ogx", "application/ogg"],
		["omdoc", "application/omdoc+xml"],
		["onepkg", "application/onenote"],
		["onetmp", "application/onenote"],
		["onetoc", "application/onenote"],
		["onetoc2", "application/onenote"],
		["opf", "application/oebps-package+xml"],
		["opml", "text/x-opml"],
		["oprc", "application/vnd.palm"],
		["opus", "audio/ogg"],
		["org", "text/x-org"],
		["osf", "application/vnd.yamaha.openscoreformat"],
		["osfpvg", "application/vnd.yamaha.openscoreformat.osfpvg+xml"],
		["osm", "application/vnd.openstreetmap.data+xml"],
		["otc", "application/vnd.oasis.opendocument.chart-template"],
		["otf", "font/otf"],
		["otg", "application/vnd.oasis.opendocument.graphics-template"],
		["oth", "application/vnd.oasis.opendocument.text-web"],
		["oti", "application/vnd.oasis.opendocument.image-template"],
		["otp", "application/vnd.oasis.opendocument.presentation-template"],
		["ots", "application/vnd.oasis.opendocument.spreadsheet-template"],
		["ott", "application/vnd.oasis.opendocument.text-template"],
		["ova", "application/x-virtualbox-ova"],
		["ovf", "application/x-virtualbox-ovf"],
		["owl", "application/rdf+xml"],
		["oxps", "application/oxps"],
		["oxt", "application/vnd.openofficeorg.extension"],
		["p", "text/x-pascal"],
		["p7a", "application/x-pkcs7-signature"],
		["p7b", "application/x-pkcs7-certificates"],
		["p7c", "application/pkcs7-mime"],
		["p7m", "application/pkcs7-mime"],
		["p7r", "application/x-pkcs7-certreqresp"],
		["p7s", "application/pkcs7-signature"],
		["p8", "application/pkcs8"],
		["p10", "application/x-pkcs10"],
		["p12", "application/x-pkcs12"],
		["pac", "application/x-ns-proxy-autoconfig"],
		["pages", "application/x-iwork-pages-sffpages"],
		["pas", "text/x-pascal"],
		["paw", "application/vnd.pawaafile"],
		["pbd", "application/vnd.powerbuilder6"],
		["pbm", "image/x-portable-bitmap"],
		["pcap", "application/vnd.tcpdump.pcap"],
		["pcf", "application/x-font-pcf"],
		["pcl", "application/vnd.hp-pcl"],
		["pclxl", "application/vnd.hp-pclxl"],
		["pct", "image/x-pict"],
		["pcurl", "application/vnd.curl.pcurl"],
		["pcx", "image/x-pcx"],
		["pdb", "application/x-pilot"],
		["pde", "text/x-processing"],
		["pdf", "application/pdf"],
		["pem", "application/x-x509-user-cert"],
		["pfa", "application/x-font-type1"],
		["pfb", "application/x-font-type1"],
		["pfm", "application/x-font-type1"],
		["pfr", "application/font-tdpfr"],
		["pfx", "application/x-pkcs12"],
		["pgm", "image/x-portable-graymap"],
		["pgn", "application/x-chess-pgn"],
		["pgp", "application/pgp"],
		["php", "application/x-httpd-php"],
		["php3", "application/x-httpd-php"],
		["php4", "application/x-httpd-php"],
		["phps", "application/x-httpd-php-source"],
		["phtml", "application/x-httpd-php"],
		["pic", "image/x-pict"],
		["pkg", "application/octet-stream"],
		["pki", "application/pkixcmp"],
		["pkipath", "application/pkix-pkipath"],
		["pkpass", "application/vnd.apple.pkpass"],
		["pl", "application/x-perl"],
		["plb", "application/vnd.3gpp.pic-bw-large"],
		["plc", "application/vnd.mobius.plc"],
		["plf", "application/vnd.pocketlearn"],
		["pls", "application/pls+xml"],
		["pm", "application/x-perl"],
		["pml", "application/vnd.ctc-posml"],
		["png", "image/png"],
		["pnm", "image/x-portable-anymap"],
		["portpkg", "application/vnd.macports.portpkg"],
		["pot", "application/vnd.ms-powerpoint"],
		["potm", "application/vnd.ms-powerpoint.presentation.macroEnabled.12"],
		["potx", "application/vnd.openxmlformats-officedocument.presentationml.template"],
		["ppa", "application/vnd.ms-powerpoint"],
		["ppam", "application/vnd.ms-powerpoint.addin.macroEnabled.12"],
		["ppd", "application/vnd.cups-ppd"],
		["ppm", "image/x-portable-pixmap"],
		["pps", "application/vnd.ms-powerpoint"],
		["ppsm", "application/vnd.ms-powerpoint.slideshow.macroEnabled.12"],
		["ppsx", "application/vnd.openxmlformats-officedocument.presentationml.slideshow"],
		["ppt", "application/powerpoint"],
		["pptm", "application/vnd.ms-powerpoint.presentation.macroEnabled.12"],
		["pptx", "application/vnd.openxmlformats-officedocument.presentationml.presentation"],
		["pqa", "application/vnd.palm"],
		["prc", "application/x-pilot"],
		["pre", "application/vnd.lotus-freelance"],
		["prf", "application/pics-rules"],
		["provx", "application/provenance+xml"],
		["ps", "application/postscript"],
		["psb", "application/vnd.3gpp.pic-bw-small"],
		["psd", "application/x-photoshop"],
		["psf", "application/x-font-linux-psf"],
		["pskcxml", "application/pskc+xml"],
		["pti", "image/prs.pti"],
		["ptid", "application/vnd.pvi.ptid1"],
		["pub", "application/x-mspublisher"],
		["pvb", "application/vnd.3gpp.pic-bw-var"],
		["pwn", "application/vnd.3m.post-it-notes"],
		["pya", "audio/vnd.ms-playready.media.pya"],
		["pyv", "video/vnd.ms-playready.media.pyv"],
		["qam", "application/vnd.epson.quickanime"],
		["qbo", "application/vnd.intu.qbo"],
		["qfx", "application/vnd.intu.qfx"],
		["qps", "application/vnd.publishare-delta-tree"],
		["qt", "video/quicktime"],
		["qwd", "application/vnd.quark.quarkxpress"],
		["qwt", "application/vnd.quark.quarkxpress"],
		["qxb", "application/vnd.quark.quarkxpress"],
		["qxd", "application/vnd.quark.quarkxpress"],
		["qxl", "application/vnd.quark.quarkxpress"],
		["qxt", "application/vnd.quark.quarkxpress"],
		["ra", "audio/x-realaudio"],
		["ram", "audio/x-pn-realaudio"],
		["raml", "application/raml+yaml"],
		["rapd", "application/route-apd+xml"],
		["rar", "application/x-rar"],
		["ras", "image/x-cmu-raster"],
		["rcprofile", "application/vnd.ipunplugged.rcprofile"],
		["rdf", "application/rdf+xml"],
		["rdz", "application/vnd.data-vision.rdz"],
		["relo", "application/p2p-overlay+xml"],
		["rep", "application/vnd.businessobjects"],
		["res", "application/x-dtbresource+xml"],
		["rgb", "image/x-rgb"],
		["rif", "application/reginfo+xml"],
		["rip", "audio/vnd.rip"],
		["ris", "application/x-research-info-systems"],
		["rl", "application/resource-lists+xml"],
		["rlc", "image/vnd.fujixerox.edmics-rlc"],
		["rld", "application/resource-lists-diff+xml"],
		["rm", "audio/x-pn-realaudio"],
		["rmi", "audio/midi"],
		["rmp", "audio/x-pn-realaudio-plugin"],
		["rms", "application/vnd.jcp.javame.midlet-rms"],
		["rmvb", "application/vnd.rn-realmedia-vbr"],
		["rnc", "application/relax-ng-compact-syntax"],
		["rng", "application/xml"],
		["roa", "application/rpki-roa"],
		["roff", "text/troff"],
		["rp9", "application/vnd.cloanto.rp9"],
		["rpm", "audio/x-pn-realaudio-plugin"],
		["rpss", "application/vnd.nokia.radio-presets"],
		["rpst", "application/vnd.nokia.radio-preset"],
		["rq", "application/sparql-query"],
		["rs", "application/rls-services+xml"],
		["rsa", "application/x-pkcs7"],
		["rsat", "application/atsc-rsat+xml"],
		["rsd", "application/rsd+xml"],
		["rsheet", "application/urc-ressheet+xml"],
		["rss", "application/rss+xml"],
		["rtf", "text/rtf"],
		["rtx", "text/richtext"],
		["run", "application/x-makeself"],
		["rusd", "application/route-usd+xml"],
		["rv", "video/vnd.rn-realvideo"],
		["s", "text/x-asm"],
		["s3m", "audio/s3m"],
		["saf", "application/vnd.yamaha.smaf-audio"],
		["sass", "text/x-sass"],
		["sbml", "application/sbml+xml"],
		["sc", "application/vnd.ibm.secure-container"],
		["scd", "application/x-msschedule"],
		["scm", "application/vnd.lotus-screencam"],
		["scq", "application/scvp-cv-request"],
		["scs", "application/scvp-cv-response"],
		["scss", "text/x-scss"],
		["scurl", "text/vnd.curl.scurl"],
		["sda", "application/vnd.stardivision.draw"],
		["sdc", "application/vnd.stardivision.calc"],
		["sdd", "application/vnd.stardivision.impress"],
		["sdkd", "application/vnd.solent.sdkm+xml"],
		["sdkm", "application/vnd.solent.sdkm+xml"],
		["sdp", "application/sdp"],
		["sdw", "application/vnd.stardivision.writer"],
		["sea", "application/octet-stream"],
		["see", "application/vnd.seemail"],
		["seed", "application/vnd.fdsn.seed"],
		["sema", "application/vnd.sema"],
		["semd", "application/vnd.semd"],
		["semf", "application/vnd.semf"],
		["senmlx", "application/senml+xml"],
		["sensmlx", "application/sensml+xml"],
		["ser", "application/java-serialized-object"],
		["setpay", "application/set-payment-initiation"],
		["setreg", "application/set-registration-initiation"],
		["sfd-hdstx", "application/vnd.hydrostatix.sof-data"],
		["sfs", "application/vnd.spotfire.sfs"],
		["sfv", "text/x-sfv"],
		["sgi", "image/sgi"],
		["sgl", "application/vnd.stardivision.writer-global"],
		["sgm", "text/sgml"],
		["sgml", "text/sgml"],
		["sh", "application/x-sh"],
		["shar", "application/x-shar"],
		["shex", "text/shex"],
		["shf", "application/shf+xml"],
		["shtml", "text/html"],
		["sid", "image/x-mrsid-image"],
		["sieve", "application/sieve"],
		["sig", "application/pgp-signature"],
		["sil", "audio/silk"],
		["silo", "model/mesh"],
		["sis", "application/vnd.symbian.install"],
		["sisx", "application/vnd.symbian.install"],
		["sit", "application/x-stuffit"],
		["sitx", "application/x-stuffitx"],
		["siv", "application/sieve"],
		["skd", "application/vnd.koan"],
		["skm", "application/vnd.koan"],
		["skp", "application/vnd.koan"],
		["skt", "application/vnd.koan"],
		["sldm", "application/vnd.ms-powerpoint.slide.macroenabled.12"],
		["sldx", "application/vnd.openxmlformats-officedocument.presentationml.slide"],
		["slim", "text/slim"],
		["slm", "text/slim"],
		["sls", "application/route-s-tsid+xml"],
		["slt", "application/vnd.epson.salt"],
		["sm", "application/vnd.stepmania.stepchart"],
		["smf", "application/vnd.stardivision.math"],
		["smi", "application/smil"],
		["smil", "application/smil"],
		["smv", "video/x-smv"],
		["smzip", "application/vnd.stepmania.package"],
		["snd", "audio/basic"],
		["snf", "application/x-font-snf"],
		["so", "application/octet-stream"],
		["spc", "application/x-pkcs7-certificates"],
		["spdx", "text/spdx"],
		["spf", "application/vnd.yamaha.smaf-phrase"],
		["spl", "application/x-futuresplash"],
		["spot", "text/vnd.in3d.spot"],
		["spp", "application/scvp-vp-response"],
		["spq", "application/scvp-vp-request"],
		["spx", "audio/ogg"],
		["sql", "application/x-sql"],
		["src", "application/x-wais-source"],
		["srt", "application/x-subrip"],
		["sru", "application/sru+xml"],
		["srx", "application/sparql-results+xml"],
		["ssdl", "application/ssdl+xml"],
		["sse", "application/vnd.kodak-descriptor"],
		["ssf", "application/vnd.epson.ssf"],
		["ssml", "application/ssml+xml"],
		["sst", "application/octet-stream"],
		["st", "application/vnd.sailingtracker.track"],
		["stc", "application/vnd.sun.xml.calc.template"],
		["std", "application/vnd.sun.xml.draw.template"],
		["stf", "application/vnd.wt.stf"],
		["sti", "application/vnd.sun.xml.impress.template"],
		["stk", "application/hyperstudio"],
		["stl", "model/stl"],
		["stpx", "model/step+xml"],
		["stpxz", "model/step-xml+zip"],
		["stpz", "model/step+zip"],
		["str", "application/vnd.pg.format"],
		["stw", "application/vnd.sun.xml.writer.template"],
		["styl", "text/stylus"],
		["stylus", "text/stylus"],
		["sub", "text/vnd.dvb.subtitle"],
		["sus", "application/vnd.sus-calendar"],
		["susp", "application/vnd.sus-calendar"],
		["sv4cpio", "application/x-sv4cpio"],
		["sv4crc", "application/x-sv4crc"],
		["svc", "application/vnd.dvb.service"],
		["svd", "application/vnd.svd"],
		["svg", "image/svg+xml"],
		["svgz", "image/svg+xml"],
		["swa", "application/x-director"],
		["swf", "application/x-shockwave-flash"],
		["swi", "application/vnd.aristanetworks.swi"],
		["swidtag", "application/swid+xml"],
		["sxc", "application/vnd.sun.xml.calc"],
		["sxd", "application/vnd.sun.xml.draw"],
		["sxg", "application/vnd.sun.xml.writer.global"],
		["sxi", "application/vnd.sun.xml.impress"],
		["sxm", "application/vnd.sun.xml.math"],
		["sxw", "application/vnd.sun.xml.writer"],
		["t", "text/troff"],
		["t3", "application/x-t3vm-image"],
		["t38", "image/t38"],
		["taglet", "application/vnd.mynfc"],
		["tao", "application/vnd.tao.intent-module-archive"],
		["tap", "image/vnd.tencent.tap"],
		["tar", "application/x-tar"],
		["tcap", "application/vnd.3gpp2.tcap"],
		["tcl", "application/x-tcl"],
		["td", "application/urc-targetdesc+xml"],
		["teacher", "application/vnd.smart.teacher"],
		["tei", "application/tei+xml"],
		["teicorpus", "application/tei+xml"],
		["tex", "application/x-tex"],
		["texi", "application/x-texinfo"],
		["texinfo", "application/x-texinfo"],
		["text", "text/plain"],
		["tfi", "application/thraud+xml"],
		["tfm", "application/x-tex-tfm"],
		["tfx", "image/tiff-fx"],
		["tga", "image/x-tga"],
		["tgz", "application/x-tar"],
		["thmx", "application/vnd.ms-officetheme"],
		["tif", "image/tiff"],
		["tiff", "image/tiff"],
		["tk", "application/x-tcl"],
		["tmo", "application/vnd.tmobile-livetv"],
		["toml", "application/toml"],
		["torrent", "application/x-bittorrent"],
		["tpl", "application/vnd.groove-tool-template"],
		["tpt", "application/vnd.trid.tpt"],
		["tr", "text/troff"],
		["tra", "application/vnd.trueapp"],
		["trig", "application/trig"],
		["trm", "application/x-msterminal"],
		["ts", "video/mp2t"],
		["tsd", "application/timestamped-data"],
		["tsv", "text/tab-separated-values"],
		["ttc", "font/collection"],
		["ttf", "font/ttf"],
		["ttl", "text/turtle"],
		["ttml", "application/ttml+xml"],
		["twd", "application/vnd.simtech-mindmapper"],
		["twds", "application/vnd.simtech-mindmapper"],
		["txd", "application/vnd.genomatix.tuxedo"],
		["txf", "application/vnd.mobius.txf"],
		["txt", "text/plain"],
		["u8dsn", "message/global-delivery-status"],
		["u8hdr", "message/global-headers"],
		["u8mdn", "message/global-disposition-notification"],
		["u8msg", "message/global"],
		["u32", "application/x-authorware-bin"],
		["ubj", "application/ubjson"],
		["udeb", "application/x-debian-package"],
		["ufd", "application/vnd.ufdl"],
		["ufdl", "application/vnd.ufdl"],
		["ulx", "application/x-glulx"],
		["umj", "application/vnd.umajin"],
		["unityweb", "application/vnd.unity"],
		["uoml", "application/vnd.uoml+xml"],
		["uri", "text/uri-list"],
		["uris", "text/uri-list"],
		["urls", "text/uri-list"],
		["usdz", "model/vnd.usdz+zip"],
		["ustar", "application/x-ustar"],
		["utz", "application/vnd.uiq.theme"],
		["uu", "text/x-uuencode"],
		["uva", "audio/vnd.dece.audio"],
		["uvd", "application/vnd.dece.data"],
		["uvf", "application/vnd.dece.data"],
		["uvg", "image/vnd.dece.graphic"],
		["uvh", "video/vnd.dece.hd"],
		["uvi", "image/vnd.dece.graphic"],
		["uvm", "video/vnd.dece.mobile"],
		["uvp", "video/vnd.dece.pd"],
		["uvs", "video/vnd.dece.sd"],
		["uvt", "application/vnd.dece.ttml+xml"],
		["uvu", "video/vnd.uvvu.mp4"],
		["uvv", "video/vnd.dece.video"],
		["uvva", "audio/vnd.dece.audio"],
		["uvvd", "application/vnd.dece.data"],
		["uvvf", "application/vnd.dece.data"],
		["uvvg", "image/vnd.dece.graphic"],
		["uvvh", "video/vnd.dece.hd"],
		["uvvi", "image/vnd.dece.graphic"],
		["uvvm", "video/vnd.dece.mobile"],
		["uvvp", "video/vnd.dece.pd"],
		["uvvs", "video/vnd.dece.sd"],
		["uvvt", "application/vnd.dece.ttml+xml"],
		["uvvu", "video/vnd.uvvu.mp4"],
		["uvvv", "video/vnd.dece.video"],
		["uvvx", "application/vnd.dece.unspecified"],
		["uvvz", "application/vnd.dece.zip"],
		["uvx", "application/vnd.dece.unspecified"],
		["uvz", "application/vnd.dece.zip"],
		["vbox", "application/x-virtualbox-vbox"],
		["vbox-extpack", "application/x-virtualbox-vbox-extpack"],
		["vcard", "text/vcard"],
		["vcd", "application/x-cdlink"],
		["vcf", "text/x-vcard"],
		["vcg", "application/vnd.groove-vcard"],
		["vcs", "text/x-vcalendar"],
		["vcx", "application/vnd.vcx"],
		["vdi", "application/x-virtualbox-vdi"],
		["vds", "model/vnd.sap.vds"],
		["vhd", "application/x-virtualbox-vhd"],
		["vis", "application/vnd.visionary"],
		["viv", "video/vnd.vivo"],
		["vlc", "application/videolan"],
		["vmdk", "application/x-virtualbox-vmdk"],
		["vob", "video/x-ms-vob"],
		["vor", "application/vnd.stardivision.writer"],
		["vox", "application/x-authorware-bin"],
		["vrml", "model/vrml"],
		["vsd", "application/vnd.visio"],
		["vsf", "application/vnd.vsf"],
		["vss", "application/vnd.visio"],
		["vst", "application/vnd.visio"],
		["vsw", "application/vnd.visio"],
		["vtf", "image/vnd.valve.source.texture"],
		["vtt", "text/vtt"],
		["vtu", "model/vnd.vtu"],
		["vxml", "application/voicexml+xml"],
		["w3d", "application/x-director"],
		["wad", "application/x-doom"],
		["wadl", "application/vnd.sun.wadl+xml"],
		["war", "application/java-archive"],
		["wasm", "application/wasm"],
		["wav", "audio/x-wav"],
		["wax", "audio/x-ms-wax"],
		["wbmp", "image/vnd.wap.wbmp"],
		["wbs", "application/vnd.criticaltools.wbs+xml"],
		["wbxml", "application/wbxml"],
		["wcm", "application/vnd.ms-works"],
		["wdb", "application/vnd.ms-works"],
		["wdp", "image/vnd.ms-photo"],
		["weba", "audio/webm"],
		["webapp", "application/x-web-app-manifest+json"],
		["webm", "video/webm"],
		["webmanifest", "application/manifest+json"],
		["webp", "image/webp"],
		["wg", "application/vnd.pmi.widget"],
		["wgt", "application/widget"],
		["wks", "application/vnd.ms-works"],
		["wm", "video/x-ms-wm"],
		["wma", "audio/x-ms-wma"],
		["wmd", "application/x-ms-wmd"],
		["wmf", "image/wmf"],
		["wml", "text/vnd.wap.wml"],
		["wmlc", "application/wmlc"],
		["wmls", "text/vnd.wap.wmlscript"],
		["wmlsc", "application/vnd.wap.wmlscriptc"],
		["wmv", "video/x-ms-wmv"],
		["wmx", "video/x-ms-wmx"],
		["wmz", "application/x-msmetafile"],
		["woff", "font/woff"],
		["woff2", "font/woff2"],
		["word", "application/msword"],
		["wpd", "application/vnd.wordperfect"],
		["wpl", "application/vnd.ms-wpl"],
		["wps", "application/vnd.ms-works"],
		["wqd", "application/vnd.wqd"],
		["wri", "application/x-mswrite"],
		["wrl", "model/vrml"],
		["wsc", "message/vnd.wfa.wsc"],
		["wsdl", "application/wsdl+xml"],
		["wspolicy", "application/wspolicy+xml"],
		["wtb", "application/vnd.webturbo"],
		["wvx", "video/x-ms-wvx"],
		["x3d", "model/x3d+xml"],
		["x3db", "model/x3d+fastinfoset"],
		["x3dbz", "model/x3d+binary"],
		["x3dv", "model/x3d-vrml"],
		["x3dvz", "model/x3d+vrml"],
		["x3dz", "model/x3d+xml"],
		["x32", "application/x-authorware-bin"],
		["x_b", "model/vnd.parasolid.transmit.binary"],
		["x_t", "model/vnd.parasolid.transmit.text"],
		["xaml", "application/xaml+xml"],
		["xap", "application/x-silverlight-app"],
		["xar", "application/vnd.xara"],
		["xav", "application/xcap-att+xml"],
		["xbap", "application/x-ms-xbap"],
		["xbd", "application/vnd.fujixerox.docuworks.binder"],
		["xbm", "image/x-xbitmap"],
		["xca", "application/xcap-caps+xml"],
		["xcs", "application/calendar+xml"],
		["xdf", "application/xcap-diff+xml"],
		["xdm", "application/vnd.syncml.dm+xml"],
		["xdp", "application/vnd.adobe.xdp+xml"],
		["xdssc", "application/dssc+xml"],
		["xdw", "application/vnd.fujixerox.docuworks"],
		["xel", "application/xcap-el+xml"],
		["xenc", "application/xenc+xml"],
		["xer", "application/patch-ops-error+xml"],
		["xfdf", "application/vnd.adobe.xfdf"],
		["xfdl", "application/vnd.xfdl"],
		["xht", "application/xhtml+xml"],
		["xhtml", "application/xhtml+xml"],
		["xhvml", "application/xv+xml"],
		["xif", "image/vnd.xiff"],
		["xl", "application/excel"],
		["xla", "application/vnd.ms-excel"],
		["xlam", "application/vnd.ms-excel.addin.macroEnabled.12"],
		["xlc", "application/vnd.ms-excel"],
		["xlf", "application/xliff+xml"],
		["xlm", "application/vnd.ms-excel"],
		["xls", "application/vnd.ms-excel"],
		["xlsb", "application/vnd.ms-excel.sheet.binary.macroEnabled.12"],
		["xlsm", "application/vnd.ms-excel.sheet.macroEnabled.12"],
		["xlsx", "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"],
		["xlt", "application/vnd.ms-excel"],
		["xltm", "application/vnd.ms-excel.template.macroEnabled.12"],
		["xltx", "application/vnd.openxmlformats-officedocument.spreadsheetml.template"],
		["xlw", "application/vnd.ms-excel"],
		["xm", "audio/xm"],
		["xml", "application/xml"],
		["xns", "application/xcap-ns+xml"],
		["xo", "application/vnd.olpc-sugar"],
		["xop", "application/xop+xml"],
		["xpi", "application/x-xpinstall"],
		["xpl", "application/xproc+xml"],
		["xpm", "image/x-xpixmap"],
		["xpr", "application/vnd.is-xpr"],
		["xps", "application/vnd.ms-xpsdocument"],
		["xpw", "application/vnd.intercon.formnet"],
		["xpx", "application/vnd.intercon.formnet"],
		["xsd", "application/xml"],
		["xsl", "application/xml"],
		["xslt", "application/xslt+xml"],
		["xsm", "application/vnd.syncml+xml"],
		["xspf", "application/xspf+xml"],
		["xul", "application/vnd.mozilla.xul+xml"],
		["xvm", "application/xv+xml"],
		["xvml", "application/xv+xml"],
		["xwd", "image/x-xwindowdump"],
		["xyz", "chemical/x-xyz"],
		["xz", "application/x-xz"],
		["yaml", "text/yaml"],
		["yang", "application/yang"],
		["yin", "application/yin+xml"],
		["yml", "text/yaml"],
		["ymp", "text/x-suse-ymp"],
		["z", "application/x-compress"],
		["z1", "application/x-zmachine"],
		["z2", "application/x-zmachine"],
		["z3", "application/x-zmachine"],
		["z4", "application/x-zmachine"],
		["z5", "application/x-zmachine"],
		["z6", "application/x-zmachine"],
		["z7", "application/x-zmachine"],
		["z8", "application/x-zmachine"],
		["zaz", "application/vnd.zzazz.deck+xml"],
		["zip", "application/zip"],
		["zir", "application/vnd.zul"],
		["zirz", "application/vnd.zul"],
		["zmm", "application/vnd.handheld-entertainment+xml"],
		["zsh", "text/x-scriptzsh"],
	])
	function Op(e, t, n) {
		const r = Rgt(e),
			{ webkitRelativePath: i } = e,
			a = typeof t == "string" ? t : typeof i == "string" && i.length > 0 ? i : `./${e.name}`
		return typeof r.path != "string" && EF(r, "path", a), EF(r, "relativePath", a), r
	}
	function Rgt(e) {
		const { name: t } = e
		if (t && t.lastIndexOf(".") !== -1 && !e.type) {
			const r = t.split(".").pop().toLowerCase(),
				i = Igt.get(r)
			i &&
				Object.defineProperty(e, "type", {
					value: i,
					writable: !1,
					configurable: !1,
					enumerable: !0,
				})
		}
		return e
	}
	function EF(e, t, n) {
		Object.defineProperty(e, t, { value: n, writable: !1, configurable: !1, enumerable: !0 })
	}
	const Lgt = [".DS_Store", "Thumbs.db"]
	function Pgt(e) {
		return Fd(this, void 0, void 0, function* () {
			return Bb(e) && jgt(e.dataTransfer)
				? $gt(e.dataTransfer, e.type)
				: Fgt(e)
				? Bgt(e)
				: Array.isArray(e) && e.every((t) => "getFile" in t && typeof t.getFile == "function")
				? Hgt(e)
				: []
		})
	}
	function jgt(e) {
		return Bb(e)
	}
	function Fgt(e) {
		return Bb(e) && Bb(e.target)
	}
	function Bb(e) {
		return typeof e == "object" && e !== null
	}
	function Bgt(e) {
		return ED(e.target.files).map((t) => Op(t))
	}
	function Hgt(e) {
		return Fd(this, void 0, void 0, function* () {
			return (yield Promise.all(e.map((n) => n.getFile()))).map((n) => Op(n))
		})
	}
	function $gt(e, t) {
		return Fd(this, void 0, void 0, function* () {
			if (e.items) {
				const n = ED(e.items).filter((i) => i.kind === "file")
				if (t !== "drop") return n
				const r = yield Promise.all(n.map(Ugt))
				return CF(FW(r))
			}
			return CF(ED(e.files).map((n) => Op(n)))
		})
	}
	function CF(e) {
		return e.filter((t) => Lgt.indexOf(t.name) === -1)
	}
	function ED(e) {
		if (e === null) return []
		const t = []
		for (let n = 0; n < e.length; n++) {
			const r = e[n]
			t.push(r)
		}
		return t
	}
	function Ugt(e) {
		if (typeof e.webkitGetAsEntry != "function") return TF(e)
		const t = e.webkitGetAsEntry()
		return t && t.isDirectory ? BW(t) : TF(e, t)
	}
	function FW(e) {
		return e.reduce((t, n) => [...t, ...(Array.isArray(n) ? FW(n) : [n])], [])
	}
	function TF(e, t) {
		return Fd(this, void 0, void 0, function* () {
			var n
			if (globalThis.isSecureContext && typeof e.getAsFileSystemHandle == "function") {
				const a = yield e.getAsFileSystemHandle()
				if (a === null) throw new Error(`${e} is not a File`)
				if (a !== void 0) {
					const o = yield a.getFile()
					return (o.handle = a), Op(o)
				}
			}
			const r = e.getAsFile()
			if (!r) throw new Error(`${e} is not a File`)
			return Op(r, (n = t == null ? void 0 : t.fullPath) !== null && n !== void 0 ? n : void 0)
		})
	}
	function zgt(e) {
		return Fd(this, void 0, void 0, function* () {
			return e.isDirectory ? BW(e) : qgt(e)
		})
	}
	function BW(e) {
		const t = e.createReader()
		return new Promise((n, r) => {
			const i = []
			function a() {
				t.readEntries(
					(o) =>
						Fd(this, void 0, void 0, function* () {
							if (o.length) {
								const s = Promise.all(o.map(zgt))
								i.push(s), a()
							} else
								try {
									const s = yield Promise.all(i)
									n(s)
								} catch (s) {
									r(s)
								}
						}),
					(o) => {
						r(o)
					},
				)
			}
			a()
		})
	}
	function qgt(e) {
		return Fd(this, void 0, void 0, function* () {
			return new Promise((t, n) => {
				e.file(
					(r) => {
						const i = Op(r, e.fullPath)
						t(i)
					},
					(r) => {
						n(r)
					},
				)
			})
		})
	}
	var wy = {},
		kF
	function Vgt() {
		return (
			kF ||
				((kF = 1),
				(wy.__esModule = !0),
				(wy.default = function (e, t) {
					if (e && t) {
						var n = Array.isArray(t) ? t : t.split(",")
						if (n.length === 0) return !0
						var r = e.name || "",
							i = (e.type || "").toLowerCase(),
							a = i.replace(/\/.*$/, "")
						return n.some(function (o) {
							var s = o.trim().toLowerCase()
							return s.charAt(0) === "."
								? r.toLowerCase().endsWith(s)
								: s.endsWith("/*")
								? a === s.replace(/\/.*$/, "")
								: i === s
						})
					}
					return !0
				})),
			wy
		)
	}
	var Wgt = Vgt()
	const iS = Ti(Wgt)
	function SF(e) {
		return Kgt(e) || Ggt(e) || $W(e) || Ygt()
	}
	function Ygt() {
		throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
	}
	function Ggt(e) {
		if ((typeof Symbol < "u" && e[Symbol.iterator] != null) || e["@@iterator"] != null)
			return Array.from(e)
	}
	function Kgt(e) {
		if (Array.isArray(e)) return CD(e)
	}
	function DF(e, t) {
		var n = Object.keys(e)
		if (Object.getOwnPropertySymbols) {
			var r = Object.getOwnPropertySymbols(e)
			t &&
				(r = r.filter(function (i) {
					return Object.getOwnPropertyDescriptor(e, i).enumerable
				})),
				n.push.apply(n, r)
		}
		return n
	}
	function _F(e) {
		for (var t = 1; t < arguments.length; t++) {
			var n = arguments[t] != null ? arguments[t] : {}
			t % 2
				? DF(Object(n), !0).forEach(function (r) {
						HW(e, r, n[r])
				  })
				: Object.getOwnPropertyDescriptors
				? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n))
				: DF(Object(n)).forEach(function (r) {
						Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r))
				  })
		}
		return e
	}
	function HW(e, t, n) {
		return (
			t in e
				? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 })
				: (e[t] = n),
			e
		)
	}
	function Lv(e, t) {
		return Jgt(e) || Xgt(e, t) || $W(e, t) || Qgt()
	}
	function Qgt() {
		throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
	}
	function $W(e, t) {
		if (e) {
			if (typeof e == "string") return CD(e, t)
			var n = Object.prototype.toString.call(e).slice(8, -1)
			if ((n === "Object" && e.constructor && (n = e.constructor.name), n === "Map" || n === "Set"))
				return Array.from(e)
			if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return CD(e, t)
		}
	}
	function CD(e, t) {
		;(t == null || t > e.length) && (t = e.length)
		for (var n = 0, r = new Array(t); n < t; n++) r[n] = e[n]
		return r
	}
	function Xgt(e, t) {
		var n = e == null ? null : (typeof Symbol < "u" && e[Symbol.iterator]) || e["@@iterator"]
		if (n != null) {
			var r = [],
				i = !0,
				a = !1,
				o,
				s
			try {
				for (
					n = n.call(e);
					!(i = (o = n.next()).done) && (r.push(o.value), !(t && r.length === t));
					i = !0
				);
			} catch (l) {
				;(a = !0), (s = l)
			} finally {
				try {
					!i && n.return != null && n.return()
				} finally {
					if (a) throw s
				}
			}
			return r
		}
	}
	function Jgt(e) {
		if (Array.isArray(e)) return e
	}
	var Zgt = typeof iS == "function" ? iS : iS.default,
		e0t = "file-invalid-type",
		t0t = "file-too-large",
		n0t = "file-too-small",
		r0t = "too-many-files",
		i0t = function () {
			var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "",
				n = t.split(","),
				r = n.length > 1 ? "one of ".concat(n.join(", ")) : n[0]
			return { code: e0t, message: "File type must be ".concat(r) }
		},
		OF = function (t) {
			return {
				code: t0t,
				message: "File is larger than ".concat(t, " ").concat(t === 1 ? "byte" : "bytes"),
			}
		},
		AF = function (t) {
			return {
				code: n0t,
				message: "File is smaller than ".concat(t, " ").concat(t === 1 ? "byte" : "bytes"),
			}
		},
		a0t = { code: r0t, message: "Too many files" }
	function UW(e, t) {
		var n = e.type === "application/x-moz-file" || Zgt(e, t)
		return [n, n ? null : i0t(t)]
	}
	function zW(e, t, n) {
		if (Ic(e.size))
			if (Ic(t) && Ic(n)) {
				if (e.size > n) return [!1, OF(n)]
				if (e.size < t) return [!1, AF(t)]
			} else {
				if (Ic(t) && e.size < t) return [!1, AF(t)]
				if (Ic(n) && e.size > n) return [!1, OF(n)]
			}
		return [!0, null]
	}
	function Ic(e) {
		return e != null
	}
	function o0t(e) {
		var t = e.files,
			n = e.accept,
			r = e.minSize,
			i = e.maxSize,
			a = e.multiple,
			o = e.maxFiles,
			s = e.validator
		return (!a && t.length > 1) || (a && o >= 1 && t.length > o)
			? !1
			: t.every(function (l) {
					var u = UW(l, n),
						d = Lv(u, 1),
						p = d[0],
						m = zW(l, r, i),
						v = Lv(m, 1),
						y = v[0],
						b = s ? s(l) : null
					return p && y && !b
			  })
	}
	function Hb(e) {
		return typeof e.isPropagationStopped == "function"
			? e.isPropagationStopped()
			: typeof e.cancelBubble < "u"
			? e.cancelBubble
			: !1
	}
	function Ey(e) {
		return e.dataTransfer
			? Array.prototype.some.call(e.dataTransfer.types, function (t) {
					return t === "Files" || t === "application/x-moz-file"
			  })
			: !!e.target && !!e.target.files
	}
	function NF(e) {
		e.preventDefault()
	}
	function s0t(e) {
		return e.indexOf("MSIE") !== -1 || e.indexOf("Trident/") !== -1
	}
	function l0t(e) {
		return e.indexOf("Edge/") !== -1
	}
	function u0t() {
		var e =
			arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : window.navigator.userAgent
		return s0t(e) || l0t(e)
	}
	function $o() {
		for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++) t[n] = arguments[n]
		return function (r) {
			for (var i = arguments.length, a = new Array(i > 1 ? i - 1 : 0), o = 1; o < i; o++)
				a[o - 1] = arguments[o]
			return t.some(function (s) {
				return !Hb(r) && s && s.apply(void 0, [r].concat(a)), Hb(r)
			})
		}
	}
	function c0t() {
		return "showOpenFilePicker" in window
	}
	function d0t(e) {
		if (Ic(e)) {
			var t = Object.entries(e)
				.filter(function (n) {
					var r = Lv(n, 2),
						i = r[0],
						a = r[1],
						o = !0
					return (
						qW(i) ||
							(console.warn(
								'Skipped "'.concat(
									i,
									'" because it is not a valid MIME type. Check https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types/Common_types for a list of valid MIME types.',
								),
							),
							(o = !1)),
						(!Array.isArray(a) || !a.every(VW)) &&
							(console.warn(
								'Skipped "'.concat(i, '" because an invalid file extension was provided.'),
							),
							(o = !1)),
						o
					)
				})
				.reduce(function (n, r) {
					var i = Lv(r, 2),
						a = i[0],
						o = i[1]
					return _F(_F({}, n), {}, HW({}, a, o))
				}, {})
			return [{ description: "Files", accept: t }]
		}
		return e
	}
	function f0t(e) {
		if (Ic(e))
			return Object.entries(e)
				.reduce(function (t, n) {
					var r = Lv(n, 2),
						i = r[0],
						a = r[1]
					return [].concat(SF(t), [i], SF(a))
				}, [])
				.filter(function (t) {
					return qW(t) || VW(t)
				})
				.join(",")
	}
	function p0t(e) {
		return e instanceof DOMException && (e.name === "AbortError" || e.code === e.ABORT_ERR)
	}
	function h0t(e) {
		return e instanceof DOMException && (e.name === "SecurityError" || e.code === e.SECURITY_ERR)
	}
	function qW(e) {
		return (
			e === "audio/*" ||
			e === "video/*" ||
			e === "image/*" ||
			e === "text/*" ||
			e === "application/*" ||
			/\w+\/[-+.\w]+/g.test(e)
		)
	}
	function VW(e) {
		return /^.*\.[\w]+$/.test(e)
	}
	var m0t = ["children"],
		v0t = ["open"],
		g0t = [
			"refKey",
			"role",
			"onKeyDown",
			"onFocus",
			"onBlur",
			"onClick",
			"onDragEnter",
			"onDragOver",
			"onDragLeave",
			"onDrop",
		],
		y0t = ["refKey", "onChange", "onClick"]
	function b0t(e) {
		return E0t(e) || w0t(e) || WW(e) || x0t()
	}
	function x0t() {
		throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
	}
	function w0t(e) {
		if ((typeof Symbol < "u" && e[Symbol.iterator] != null) || e["@@iterator"] != null)
			return Array.from(e)
	}
	function E0t(e) {
		if (Array.isArray(e)) return TD(e)
	}
	function aS(e, t) {
		return k0t(e) || T0t(e, t) || WW(e, t) || C0t()
	}
	function C0t() {
		throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
	}
	function WW(e, t) {
		if (e) {
			if (typeof e == "string") return TD(e, t)
			var n = Object.prototype.toString.call(e).slice(8, -1)
			if ((n === "Object" && e.constructor && (n = e.constructor.name), n === "Map" || n === "Set"))
				return Array.from(e)
			if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return TD(e, t)
		}
	}
	function TD(e, t) {
		;(t == null || t > e.length) && (t = e.length)
		for (var n = 0, r = new Array(t); n < t; n++) r[n] = e[n]
		return r
	}
	function T0t(e, t) {
		var n = e == null ? null : (typeof Symbol < "u" && e[Symbol.iterator]) || e["@@iterator"]
		if (n != null) {
			var r = [],
				i = !0,
				a = !1,
				o,
				s
			try {
				for (
					n = n.call(e);
					!(i = (o = n.next()).done) && (r.push(o.value), !(t && r.length === t));
					i = !0
				);
			} catch (l) {
				;(a = !0), (s = l)
			} finally {
				try {
					!i && n.return != null && n.return()
				} finally {
					if (a) throw s
				}
			}
			return r
		}
	}
	function k0t(e) {
		if (Array.isArray(e)) return e
	}
	function MF(e, t) {
		var n = Object.keys(e)
		if (Object.getOwnPropertySymbols) {
			var r = Object.getOwnPropertySymbols(e)
			t &&
				(r = r.filter(function (i) {
					return Object.getOwnPropertyDescriptor(e, i).enumerable
				})),
				n.push.apply(n, r)
		}
		return n
	}
	function Ln(e) {
		for (var t = 1; t < arguments.length; t++) {
			var n = arguments[t] != null ? arguments[t] : {}
			t % 2
				? MF(Object(n), !0).forEach(function (r) {
						kD(e, r, n[r])
				  })
				: Object.getOwnPropertyDescriptors
				? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n))
				: MF(Object(n)).forEach(function (r) {
						Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r))
				  })
		}
		return e
	}
	function kD(e, t, n) {
		return (
			t in e
				? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 })
				: (e[t] = n),
			e
		)
	}
	function $b(e, t) {
		if (e == null) return {}
		var n = S0t(e, t),
			r,
			i
		if (Object.getOwnPropertySymbols) {
			var a = Object.getOwnPropertySymbols(e)
			for (i = 0; i < a.length; i++)
				(r = a[i]),
					!(t.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(e, r) && (n[r] = e[r])
		}
		return n
	}
	function S0t(e, t) {
		if (e == null) return {}
		var n = {},
			r = Object.keys(e),
			i,
			a
		for (a = 0; a < r.length; a++) (i = r[a]), !(t.indexOf(i) >= 0) && (n[i] = e[i])
		return n
	}
	var jA = _.forwardRef(function (e, t) {
		var n = e.children,
			r = $b(e, m0t),
			i = GW(r),
			a = i.open,
			o = $b(i, v0t)
		return (
			_.useImperativeHandle(
				t,
				function () {
					return { open: a }
				},
				[a],
			),
			H.createElement(_.Fragment, null, n(Ln(Ln({}, o), {}, { open: a })))
		)
	})
	jA.displayName = "Dropzone"
	var YW = {
		disabled: !1,
		getFilesFromEvent: Pgt,
		maxSize: 1 / 0,
		minSize: 0,
		multiple: !0,
		maxFiles: 0,
		preventDropOnDocument: !0,
		noClick: !1,
		noKeyboard: !1,
		noDrag: !1,
		noDragEventsBubbling: !1,
		validator: null,
		useFsAccessApi: !1,
		autoFocus: !1,
	}
	jA.defaultProps = YW
	jA.propTypes = {
		children: he.func,
		accept: he.objectOf(he.arrayOf(he.string)),
		multiple: he.bool,
		preventDropOnDocument: he.bool,
		noClick: he.bool,
		noKeyboard: he.bool,
		noDrag: he.bool,
		noDragEventsBubbling: he.bool,
		minSize: he.number,
		maxSize: he.number,
		maxFiles: he.number,
		disabled: he.bool,
		getFilesFromEvent: he.func,
		onFileDialogCancel: he.func,
		onFileDialogOpen: he.func,
		useFsAccessApi: he.bool,
		autoFocus: he.bool,
		onDragEnter: he.func,
		onDragLeave: he.func,
		onDragOver: he.func,
		onDrop: he.func,
		onDropAccepted: he.func,
		onDropRejected: he.func,
		onError: he.func,
		validator: he.func,
	}
	var SD = {
		isFocused: !1,
		isFileDialogActive: !1,
		isDragActive: !1,
		isDragAccept: !1,
		isDragReject: !1,
		acceptedFiles: [],
		fileRejections: [],
	}
	function GW() {
		var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {},
			t = Ln(Ln({}, YW), e),
			n = t.accept,
			r = t.disabled,
			i = t.getFilesFromEvent,
			a = t.maxSize,
			o = t.minSize,
			s = t.multiple,
			l = t.maxFiles,
			u = t.onDragEnter,
			d = t.onDragLeave,
			p = t.onDragOver,
			m = t.onDrop,
			v = t.onDropAccepted,
			y = t.onDropRejected,
			b = t.onFileDialogCancel,
			x = t.onFileDialogOpen,
			E = t.useFsAccessApi,
			T = t.autoFocus,
			C = t.preventDropOnDocument,
			D = t.noClick,
			O = t.noKeyboard,
			A = t.noDrag,
			N = t.noDragEventsBubbling,
			I = t.onError,
			P = t.validator,
			L = _.useMemo(
				function () {
					return f0t(n)
				},
				[n],
			),
			B = _.useMemo(
				function () {
					return d0t(n)
				},
				[n],
			),
			z = _.useMemo(
				function () {
					return typeof x == "function" ? x : IF
				},
				[x],
			),
			V = _.useMemo(
				function () {
					return typeof b == "function" ? b : IF
				},
				[b],
			),
			K = _.useRef(null),
			ne = _.useRef(null),
			re = _.useReducer(D0t, SD),
			ie = aS(re, 2),
			J = ie[0],
			le = ie[1],
			F = J.isFocused,
			Y = J.isFileDialogActive,
			ee = _.useRef(typeof window < "u" && window.isSecureContext && E && c0t()),
			$ = function () {
				!ee.current &&
					Y &&
					setTimeout(function () {
						if (ne.current) {
							var ye = ne.current.files
							ye.length || (le({ type: "closeDialog" }), V())
						}
					}, 300)
			}
		_.useEffect(
			function () {
				return (
					window.addEventListener("focus", $, !1),
					function () {
						window.removeEventListener("focus", $, !1)
					}
				)
			},
			[ne, Y, V, ee],
		)
		var ge = _.useRef([]),
			Se = function (ye) {
				;(K.current && K.current.contains(ye.target)) || (ye.preventDefault(), (ge.current = []))
			}
		_.useEffect(
			function () {
				return (
					C &&
						(document.addEventListener("dragover", NF, !1),
						document.addEventListener("drop", Se, !1)),
					function () {
						C &&
							(document.removeEventListener("dragover", NF),
							document.removeEventListener("drop", Se))
					}
				)
			},
			[K, C],
		),
			_.useEffect(
				function () {
					return !r && T && K.current && K.current.focus(), function () {}
				},
				[K, T, r],
			)
		var Ee = _.useCallback(
				function (pe) {
					I ? I(pe) : console.error(pe)
				},
				[I],
			),
			be = _.useCallback(
				function (pe) {
					pe.preventDefault(),
						pe.persist(),
						Jt(pe),
						(ge.current = [].concat(b0t(ge.current), [pe.target])),
						Ey(pe) &&
							Promise.resolve(i(pe))
								.then(function (ye) {
									if (!(Hb(pe) && !N)) {
										var X = ye.length,
											de =
												X > 0 &&
												o0t({
													files: ye,
													accept: L,
													minSize: o,
													maxSize: a,
													multiple: s,
													maxFiles: l,
													validator: P,
												}),
											Me = X > 0 && !de
										le({
											isDragAccept: de,
											isDragReject: Me,
											isDragActive: !0,
											type: "setDraggedFiles",
										}),
											u && u(pe)
									}
								})
								.catch(function (ye) {
									return Ee(ye)
								})
				},
				[i, u, Ee, N, L, o, a, s, l, P],
			),
			Le = _.useCallback(
				function (pe) {
					pe.preventDefault(), pe.persist(), Jt(pe)
					var ye = Ey(pe)
					if (ye && pe.dataTransfer)
						try {
							pe.dataTransfer.dropEffect = "copy"
						} catch {}
					return ye && p && p(pe), !1
				},
				[p, N],
			),
			Be = _.useCallback(
				function (pe) {
					pe.preventDefault(), pe.persist(), Jt(pe)
					var ye = ge.current.filter(function (de) {
							return K.current && K.current.contains(de)
						}),
						X = ye.indexOf(pe.target)
					X !== -1 && ye.splice(X, 1),
						(ge.current = ye),
						!(ye.length > 0) &&
							(le({
								type: "setDraggedFiles",
								isDragActive: !1,
								isDragAccept: !1,
								isDragReject: !1,
							}),
							Ey(pe) && d && d(pe))
				},
				[K, d, N],
			),
			et = _.useCallback(
				function (pe, ye) {
					var X = [],
						de = []
					pe.forEach(function (Me) {
						var Ze = UW(Me, L),
							ct = aS(Ze, 2),
							Ot = ct[0],
							tr = ct[1],
							Wn = zW(Me, o, a),
							An = aS(Wn, 2),
							li = An[0],
							Nn = An[1],
							Yn = P ? P(Me) : null
						if (Ot && li && !Yn) X.push(Me)
						else {
							var Tn = [tr, Nn]
							Yn && (Tn = Tn.concat(Yn)),
								de.push({
									file: Me,
									errors: Tn.filter(function (rc) {
										return rc
									}),
								})
						}
					}),
						((!s && X.length > 1) || (s && l >= 1 && X.length > l)) &&
							(X.forEach(function (Me) {
								de.push({ file: Me, errors: [a0t] })
							}),
							X.splice(0)),
						le({
							acceptedFiles: X,
							fileRejections: de,
							isDragReject: de.length > 0,
							type: "setFiles",
						}),
						m && m(X, de, ye),
						de.length > 0 && y && y(de, ye),
						X.length > 0 && v && v(X, ye)
				},
				[le, s, L, o, a, l, m, v, y, P],
			),
			pt = _.useCallback(
				function (pe) {
					pe.preventDefault(),
						pe.persist(),
						Jt(pe),
						(ge.current = []),
						Ey(pe) &&
							Promise.resolve(i(pe))
								.then(function (ye) {
									;(Hb(pe) && !N) || et(ye, pe)
								})
								.catch(function (ye) {
									return Ee(ye)
								}),
						le({ type: "reset" })
				},
				[i, et, Ee, N],
			),
			mt = _.useCallback(
				function () {
					if (ee.current) {
						le({ type: "openDialog" }), z()
						var pe = { multiple: s, types: B }
						window
							.showOpenFilePicker(pe)
							.then(function (ye) {
								return i(ye)
							})
							.then(function (ye) {
								et(ye, null), le({ type: "closeDialog" })
							})
							.catch(function (ye) {
								p0t(ye)
									? (V(ye), le({ type: "closeDialog" }))
									: h0t(ye)
									? ((ee.current = !1),
									  ne.current
											? ((ne.current.value = null), ne.current.click())
											: Ee(
													new Error(
														"Cannot open the file picker because the https://developer.mozilla.org/en-US/docs/Web/API/File_System_Access_API is not supported and no <input> was provided.",
													),
											  ))
									: Ee(ye)
							})
						return
					}
					ne.current &&
						(le({ type: "openDialog" }), z(), (ne.current.value = null), ne.current.click())
				},
				[le, z, V, E, et, Ee, B, s],
			),
			Xt = _.useCallback(
				function (pe) {
					!K.current ||
						!K.current.isEqualNode(pe.target) ||
						((pe.key === " " || pe.key === "Enter" || pe.keyCode === 32 || pe.keyCode === 13) &&
							(pe.preventDefault(), mt()))
				},
				[K, mt],
			),
			on = _.useCallback(function () {
				le({ type: "focus" })
			}, []),
			dt = _.useCallback(function () {
				le({ type: "blur" })
			}, []),
			cn = _.useCallback(
				function () {
					D || (u0t() ? setTimeout(mt, 0) : mt())
				},
				[D, mt],
			),
			sn = function (ye) {
				return r ? null : ye
			},
			ur = function (ye) {
				return O ? null : sn(ye)
			},
			Hn = function (ye) {
				return A ? null : sn(ye)
			},
			Jt = function (ye) {
				N && ye.stopPropagation()
			},
			mn = _.useMemo(
				function () {
					return function () {
						var pe = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {},
							ye = pe.refKey,
							X = ye === void 0 ? "ref" : ye,
							de = pe.role,
							Me = pe.onKeyDown,
							Ze = pe.onFocus,
							ct = pe.onBlur,
							Ot = pe.onClick,
							tr = pe.onDragEnter,
							Wn = pe.onDragOver,
							An = pe.onDragLeave,
							li = pe.onDrop,
							Nn = $b(pe, g0t)
						return Ln(
							Ln(
								kD(
									{
										onKeyDown: ur($o(Me, Xt)),
										onFocus: ur($o(Ze, on)),
										onBlur: ur($o(ct, dt)),
										onClick: sn($o(Ot, cn)),
										onDragEnter: Hn($o(tr, be)),
										onDragOver: Hn($o(Wn, Le)),
										onDragLeave: Hn($o(An, Be)),
										onDrop: Hn($o(li, pt)),
										role: typeof de == "string" && de !== "" ? de : "presentation",
									},
									X,
									K,
								),
								!r && !O ? { tabIndex: 0 } : {},
							),
							Nn,
						)
					}
				},
				[K, Xt, on, dt, cn, be, Le, Be, pt, O, A, r],
			),
			ue = _.useCallback(function (pe) {
				pe.stopPropagation()
			}, []),
			Re = _.useMemo(
				function () {
					return function () {
						var pe = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {},
							ye = pe.refKey,
							X = ye === void 0 ? "ref" : ye,
							de = pe.onChange,
							Me = pe.onClick,
							Ze = $b(pe, y0t),
							ct = kD(
								{
									accept: L,
									multiple: s,
									type: "file",
									style: {
										border: 0,
										clip: "rect(0, 0, 0, 0)",
										clipPath: "inset(50%)",
										height: "1px",
										margin: "0 -1px -1px 0",
										overflow: "hidden",
										padding: 0,
										position: "absolute",
										width: "1px",
										whiteSpace: "nowrap",
									},
									onChange: sn($o(de, pt)),
									onClick: sn($o(Me, ue)),
									tabIndex: -1,
								},
								X,
								ne,
							)
						return Ln(Ln({}, ct), Ze)
					}
				},
				[ne, n, s, pt, r],
			)
		return Ln(
			Ln({}, J),
			{},
			{
				isFocused: F && !r,
				getRootProps: mn,
				getInputProps: Re,
				rootRef: K,
				inputRef: ne,
				open: sn(mt),
			},
		)
	}
	function D0t(e, t) {
		switch (t.type) {
			case "focus":
				return Ln(Ln({}, e), {}, { isFocused: !0 })
			case "blur":
				return Ln(Ln({}, e), {}, { isFocused: !1 })
			case "openDialog":
				return Ln(Ln({}, SD), {}, { isFileDialogActive: !0 })
			case "closeDialog":
				return Ln(Ln({}, e), {}, { isFileDialogActive: !1 })
			case "setDraggedFiles":
				return Ln(
					Ln({}, e),
					{},
					{
						isDragActive: t.isDragActive,
						isDragAccept: t.isDragAccept,
						isDragReject: t.isDragReject,
					},
				)
			case "setFiles":
				return Ln(
					Ln({}, e),
					{},
					{
						acceptedFiles: t.acceptedFiles,
						fileRejections: t.fileRejections,
						isDragReject: t.isDragReject,
					},
				)
			case "reset":
				return Ln({}, SD)
			default:
				return e
		}
	}
	function IF() {}
	const _0t = {
			flex: 1,
			display: "flex",
			alignItems: "center",
			justifyContent: "center",
			height: "150px",
			padding: "2rem",
			borderWidth: "4px",
			borderRadius: "4px",
			borderColor: "#6c757d",
			color: "#6c757d",
			borderStyle: "dashed",
			backgroundColor: "transparent",
			outline: "none",
			marginBottom: "1rem",
		},
		O0t = { borderColor: "#2196f3", color: "#2196f3" },
		A0t = { borderColor: "#00e676", color: "#00e676" },
		N0t = { borderColor: "#ff1744", color: "#ff1744" }
	function KW({ accept: e, onSelected: t }) {
		const {
				acceptedFiles: n,
				getRootProps: r,
				getInputProps: i,
				isDragActive: a,
				isDragAccept: o,
				isDragReject: s,
				isFocused: l,
			} = GW({
				accept: e,
				maxFiles: 1,
				multiple: !1,
				onDrop: (p) => {
					t(p)
				},
			}),
			u = _.useMemo(
				() => ({ ..._0t, ...(l ? O0t : {}), ...(o ? A0t : {}), ...(s ? N0t : {}) }),
				[l, o, s],
			),
			d = n.map((p) => h.jsxs("p", { children: [p.name, " - ", p.size, " bytes"] }, p.name))
		return h.jsxs("section", {
			className: "container",
			children: [
				h.jsxs("div", {
					...r({ style: u }),
					children: [
						h.jsx("input", { ...i() }),
						a
							? h.jsx("div", { className: "text-center", children: "Drop the file here ..." })
							: h.jsxs("div", {
									className: "text-center",
									children: [
										"Drag and drop a file here, ",
										h.jsx("br", {}),
										"or click to select a file",
									],
							  }),
					],
				}),
				h.jsx("aside", {
					className: "text-info text-center",
					children: h.jsx("div", { children: d }),
				}),
			],
		})
	}
	const M0t = Ui.injectEndpoints({
			endpoints: (e) => ({
				getTournaments: e.query({
					query: () => ({ url: "/tournaments/", method: "GET" }),
					providesTags: (t) =>
						t
							? [
									...t.map(({ id: n }) => ({ type: "Tournaments", id: n })),
									{ type: "Tournaments", id: "LIST" },
							  ]
							: [{ type: "Tournaments", id: "LIST" }],
				}),
				getTournament: e.query({
					query: (t) => ({ url: `/tournaments/?name=${t}`, method: "GET" }),
					transformResponse: (t) => ((t == null ? void 0 : t.length) === 1 ? t[0] : void 0),
					providesTags: (t, n, r) => [{ type: "Tournaments", id: r }],
				}),
				updateTournament: e.mutation({
					query(t) {
						const { id: n } = t
						return { url: `/tournaments/${n}/`, method: "PUT", data: t }
					},
					invalidatesTags: (t, n, { id: r }) => [{ type: "Tournaments", id: r }],
				}),
				getTournamentWinners: e.query({
					query: (t) => ({ url: "/tournament-winners/?name=" + t, method: "GET" }),
					providesTags: (t) =>
						t
							? [
									...t.map(({ id: n }) => ({ type: "Tournament-Winners", id: n })),
									{ type: "Tournament-Winners", id: "LIST" },
							  ]
							: [{ type: "Tournament-Winners", id: "LIST" }],
				}),
				addTournamentWinner: e.mutation({
					query(t) {
						return { url: "/tournament-winners/", method: "POST", data: t }
					},
					invalidatesTags: (t, n, { id: r }) => [
						{ type: "Tournament-Winners", id: r },
						{ type: "Tournament-Winners", id: "LIST" },
					],
				}),
				updateTournamentWinner: e.mutation({
					query(t) {
						const { id: n } = t
						return { url: `/tournament-winners/${n}/`, method: "PUT", data: t }
					},
					invalidatesTags: (t, n, { id: r }) => [{ type: "Tournament-Winners", id: r }],
				}),
			}),
		}),
		{
			useGetTournamentQuery: FA,
			useAddTournamentWinnerMutation: I0t,
			useGetTournamentWinnersQuery: QW,
			useGetTournamentsQuery: BA,
			useUpdateTournamentMutation: R0t,
			useUpdateTournamentWinnerMutation: L0t,
		} = M0t
	function Ap(e) {
		"@babel/helpers - typeof"
		return (
			(Ap =
				typeof Symbol == "function" && typeof Symbol.iterator == "symbol"
					? function (t) {
							return typeof t
					  }
					: function (t) {
							return t &&
								typeof Symbol == "function" &&
								t.constructor === Symbol &&
								t !== Symbol.prototype
								? "symbol"
								: typeof t
					  }),
			Ap(e)
		)
	}
	function P0t(e, t) {
		if (Ap(e) != "object" || !e) return e
		var n = e[Symbol.toPrimitive]
		if (n !== void 0) {
			var r = n.call(e, t || "default")
			if (Ap(r) != "object") return r
			throw new TypeError("@@toPrimitive must return a primitive value.")
		}
		return (t === "string" ? String : Number)(e)
	}
	function XW(e) {
		var t = P0t(e, "string")
		return Ap(t) == "symbol" ? t : t + ""
	}
	function st(e, t, n) {
		return (
			(t = XW(t)) in e
				? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 })
				: (e[t] = n),
			e
		)
	}
	function ri(e, t) {
		if (e == null) return {}
		var n,
			r,
			i = Q_(e, t)
		if (Object.getOwnPropertySymbols) {
			var a = Object.getOwnPropertySymbols(e)
			for (r = 0; r < a.length; r++)
				(n = a[r]), t.includes(n) || ({}.propertyIsEnumerable.call(e, n) && (i[n] = e[n]))
		}
		return i
	}
	var j0t = ["justify", "left", "right"],
		JW = "label",
		F0t = ["lg", "sm"]
	function DD(e) {
		return typeof e == "string" ? e : JW
	}
	function Ub(e, t) {
		return Object.prototype.hasOwnProperty.call(e, t)
	}
	var RF = 0
	function xa(e) {
		return typeof e == "function"
	}
	function ko(e) {
		return typeof e == "string"
	}
	function Ha() {}
	function w1(e, t) {
		var n = {}
		return (
			t.forEach(function (r) {
				n[r] = e[r]
			}),
			n
		)
	}
	function B0t(e) {
		return (RF += 1), String(e) + RF
	}
	function ys(e, t) {
		if (!ko(e) && (Ub(e, "paginationOption") || Ub(e, "customOption"))) return e[DD(t)]
		var n
		return xa(t) ? (n = t(e)) : ko(e) ? (n = e) : (n = e[t]), ko(n) || GH(!1), n
	}
	function H0t(e, t) {
		var n = t.allowNew,
			r = t.labelKey,
			i = t.text
		return !n || !i.trim()
			? !1
			: xa(n)
			? n(e, t)
			: !e.some(function (a) {
					return ys(a, r) === i
			  })
	}
	var oS, LF
	function $0t() {
		return (
			LF ||
				((LF = 1),
				(oS = function e(t, n) {
					if (t === n) return !0
					if (t && n && typeof t == "object" && typeof n == "object") {
						if (t.constructor !== n.constructor) return !1
						var r, i, a
						if (Array.isArray(t)) {
							if (((r = t.length), r != n.length)) return !1
							for (i = r; i-- !== 0; ) if (!e(t[i], n[i])) return !1
							return !0
						}
						if (t.constructor === RegExp) return t.source === n.source && t.flags === n.flags
						if (t.valueOf !== Object.prototype.valueOf) return t.valueOf() === n.valueOf()
						if (t.toString !== Object.prototype.toString) return t.toString() === n.toString()
						if (((a = Object.keys(t)), (r = a.length), r !== Object.keys(n).length)) return !1
						for (i = r; i-- !== 0; ) if (!Object.prototype.hasOwnProperty.call(n, a[i])) return !1
						for (i = r; i-- !== 0; ) {
							var o = a[i]
							if (!e(t[o], n[o])) return !1
						}
						return !0
					}
					return t !== t && n !== n
				})),
			oS
		)
	}
	var U0t = $0t()
	const Sm = Ti(U0t)
	function rd(e, t) {
		if (!ko(e)) return e[t]
	}
	var z0t = [
			{ base: "A", letters: "A" },
			{ base: "AA", letters: "" },
			{ base: "AE", letters: "" },
			{ base: "AO", letters: "" },
			{ base: "AU", letters: "" },
			{ base: "AV", letters: "" },
			{ base: "AY", letters: "" },
			{ base: "B", letters: "B" },
			{ base: "C", letters: "C" },
			{ base: "D", letters: "D" },
			{ base: "DZ", letters: "" },
			{ base: "Dz", letters: "" },
			{ base: "E", letters: "E" },
			{ base: "F", letters: "F" },
			{ base: "G", letters: "G" },
			{ base: "H", letters: "H" },
			{ base: "I", letters: "I" },
			{ base: "J", letters: "J" },
			{ base: "K", letters: "K" },
			{ base: "L", letters: "L" },
			{ base: "LJ", letters: "" },
			{ base: "Lj", letters: "" },
			{ base: "M", letters: "M" },
			{ base: "N", letters: "N" },
			{ base: "NJ", letters: "" },
			{ base: "Nj", letters: "" },
			{ base: "O", letters: "O" },
			{ base: "OI", letters: "" },
			{ base: "OO", letters: "" },
			{ base: "OU", letters: "" },
			{ base: "OE", letters: "" },
			{ base: "oe", letters: "" },
			{ base: "P", letters: "P" },
			{ base: "Q", letters: "Q" },
			{ base: "R", letters: "R" },
			{ base: "S", letters: "S" },
			{ base: "T", letters: "T" },
			{ base: "TZ", letters: "" },
			{ base: "U", letters: "U" },
			{ base: "V", letters: "V" },
			{ base: "VY", letters: "" },
			{ base: "W", letters: "W" },
			{ base: "X", letters: "X" },
			{ base: "Y", letters: "Y" },
			{ base: "Z", letters: "Z" },
			{ base: "a", letters: "a" },
			{ base: "aa", letters: "" },
			{ base: "ae", letters: "" },
			{ base: "ao", letters: "" },
			{ base: "au", letters: "" },
			{ base: "av", letters: "" },
			{ base: "ay", letters: "" },
			{ base: "b", letters: "b" },
			{ base: "c", letters: "c" },
			{ base: "d", letters: "d" },
			{ base: "dz", letters: "" },
			{ base: "e", letters: "e" },
			{ base: "f", letters: "f" },
			{ base: "g", letters: "g" },
			{ base: "h", letters: "h" },
			{ base: "hv", letters: "" },
			{ base: "i", letters: "i" },
			{ base: "j", letters: "j" },
			{ base: "k", letters: "k" },
			{ base: "l", letters: "l" },
			{ base: "lj", letters: "" },
			{ base: "m", letters: "m" },
			{ base: "n", letters: "n" },
			{ base: "nj", letters: "" },
			{ base: "o", letters: "o" },
			{ base: "oi", letters: "" },
			{ base: "ou", letters: "" },
			{ base: "oo", letters: "" },
			{ base: "p", letters: "p" },
			{ base: "q", letters: "q" },
			{ base: "r", letters: "r" },
			{ base: "s", letters: "s" },
			{ base: "t", letters: "t" },
			{ base: "tz", letters: "" },
			{ base: "u", letters: "u" },
			{ base: "v", letters: "v" },
			{ base: "vy", letters: "" },
			{ base: "w", letters: "w" },
			{ base: "x", letters: "x" },
			{ base: "y", letters: "y" },
			{ base: "z", letters: "z" },
		].reduce(function (e, t) {
			var n = t.base,
				r = t.letters
			return (
				r.split("").forEach(function (i) {
					e[i] = n
				}),
				e
			)
		}, {}),
		q0t = "-",
		V0t = ""
	function zb(e) {
		return e
			.normalize("NFD")
			.replace(new RegExp("[".concat(q0t).concat(V0t, "]"), "g"), "")
			.replace(/[^\u0000-\u007E]/g, function (t) {
				return z0t[t] || t
			})
	}
	var PF = {}
	function wa(e, t) {
		if (!e && t.indexOf("deprecated") !== -1) {
			if (PF[t]) return
			PF[t] = !0
		}
		for (var n = arguments.length, r = new Array(n > 2 ? n - 2 : 0), i = 2; i < n; i++)
			r[i - 2] = arguments[i]
		z_.apply(void 0, [e, "[react-bootstrap-typeahead] ".concat(t)].concat(r))
	}
	function sS(e, t, n) {
		var r = e,
			i = t
		return (
			n.caseSensitive || ((r = r.toLowerCase()), (i = i.toLowerCase())),
			n.ignoreDiacritics && ((r = zb(r)), (i = zb(i))),
			i.indexOf(r) !== -1
		)
	}
	function W0t(e, t) {
		var n = t.filterBy,
			r = t.labelKey,
			i = t.multiple,
			a = t.selected,
			o = t.text
		if (
			i &&
			a.some(function (l) {
				return Sm(l, e)
			})
		)
			return !1
		if (xa(r)) return sS(o, r(e), t)
		var s = n.slice()
		return (
			ko(r) && s.indexOf(r) === -1 && s.unshift(r),
			ko(e)
				? (wa(s.length <= 1, "You cannot filter by properties when `option` is a string."),
				  sS(o, e, t))
				: s.some(function (l) {
						var u = rd(e, l)
						return (
							ko(u) ||
								(wa(
									!1,
									"Fields passed to `filterBy` should have string values. Value will be converted to a string; results may be unexpected.",
								),
								(u = String(u))),
							sS(o, u, t)
						)
				  })
		)
	}
	function ZW(e) {
		return e.selectionStart != null
	}
	function Y0t(e, t) {
		var n = !1
		return (
			e.key === "ArrowRight" &&
				(n = ZW(e.currentTarget)
					? e.currentTarget.selectionStart === e.currentTarget.value.length
					: !0),
			e.key === "Tab" && (e.preventDefault(), (n = !0)),
			t ? t(n, e) : n
		)
	}
	var G0t = "i",
		lS = /[\u0300-\u036F]/
	function K0t(e) {
		return (
			typeof e != "string" && GH(!1),
			e.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d")
		)
	}
	function eY(e, t) {
		var n = new RegExp(K0t(zb(t)), G0t),
			r = n.exec(zb(e))
		if (!r) return null
		var i = r.index,
			a = r[0].length
		if (lS.test(e)) {
			for (var o = 0; o <= i; o++) lS.test(e[o]) && (i += 1)
			for (var s = i; s <= i + a; s++) lS.test(e[s]) && (a += 1)
		}
		return { end: i + a, start: i }
	}
	function Q0t(e) {
		var t = e.activeIndex,
			n = e.initialItem,
			r = e.isFocused,
			i = e.isMenuShown,
			a = e.labelKey,
			o = e.multiple,
			s = e.selected,
			l = e.text
		if (
			!l ||
			!r ||
			!i ||
			!n ||
			(!ko(n) && Ub(n, "customOption")) ||
			(!ko(n) && n.disabled) ||
			t > -1 ||
			(s.length && !o)
		)
			return ""
		var u = ys(n, a),
			d = eY(u.toLowerCase(), l.toLowerCase())
		return d && d.start === 0 ? l + u.slice(d.end, u.length) : ""
	}
	function tY() {
		var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "",
			t = arguments.length > 1 ? arguments[1] : void 0
		return "".concat(e, "-item-").concat(t)
	}
	var X0t = [
		"activeIndex",
		"id",
		"isFocused",
		"isMenuShown",
		"multiple",
		"onClick",
		"onFocus",
		"placeholder",
	]
	function jF(e, t) {
		var n = Object.keys(e)
		if (Object.getOwnPropertySymbols) {
			var r = Object.getOwnPropertySymbols(e)
			t &&
				(r = r.filter(function (i) {
					return Object.getOwnPropertyDescriptor(e, i).enumerable
				})),
				n.push.apply(n, r)
		}
		return n
	}
	function Cy(e) {
		for (var t = 1; t < arguments.length; t++) {
			var n = arguments[t] != null ? arguments[t] : {}
			t % 2
				? jF(Object(n), !0).forEach(function (r) {
						st(e, r, n[r])
				  })
				: Object.getOwnPropertyDescriptors
				? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n))
				: jF(Object(n)).forEach(function (r) {
						Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r))
				  })
		}
		return e
	}
	var J0t = function (t) {
		var n = t.activeIndex,
			r = t.id,
			i = t.isFocused,
			a = t.isMenuShown,
			o = t.multiple,
			s = t.onClick,
			l = t.onFocus,
			u = t.placeholder,
			d = ri(t, X0t)
		return function () {
			var p,
				m = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {},
				v = Ub(m, "className") ? String(m.className) : void 0
			return Cy(
				Cy(
					Cy(Cy({ autoComplete: "off", placeholder: u, type: "text" }, m), d),
					{},
					{
						"aria-activedescendant": n >= 0 ? tY(r, n) : void 0,
						"aria-autocomplete": "both",
						"aria-expanded": a,
						"aria-haspopup": "listbox",
						"aria-multiselectable": o || void 0,
						"aria-owns": a ? r : void 0,
						className: Fe(((p = {}), st(p, v || "", !o), st(p, "focus", i), p)),
					},
					o && { inputClassName: v },
				),
				{},
				{ onClick: s, onFocus: l, role: "combobox" },
			)
		}
	}
	function Z0t(e) {
		var t = e.activeItem,
			n = e.labelKey,
			r = e.multiple,
			i = e.selected,
			a = e.text
		return t ? ys(t, n) : !r && i.length && i[0] ? ys(i[0], n) : a
	}
	function FF(e) {
		var t = e.allowNew,
			n = e.highlightOnlyResult,
			r = e.results
		return !n || t ? !1 : r.length === 1 && !rd(r[0], "disabled")
	}
	function eyt(e, t) {
		return !t || t >= e.length ? e : e.slice(0, t)
	}
	function tyt(e, t) {
		var n = t[e]
		return !!n && !!rd(n, "disabled")
	}
	function BF(e, t, n) {
		for (var r = e; tyt(r, n); ) r += t === "ArrowUp" ? -1 : 1
		return r
	}
	function nyt(e, t, n) {
		var r = e
		return (
			(r += t === "ArrowUp" ? -1 : 1),
			(r = BF(r, t, n)),
			r === n.length ? (r = -1) : r === -2 && ((r = n.length - 1), (r = BF(r, t, n))),
			r
		)
	}
	function ryt(e) {
		var t = e.open,
			n = e.minLength,
			r = e.showMenu,
			i = e.text
		return t || t === !1 ? t : i.length < n ? !1 : r
	}
	function HA(e) {
		e.preventDefault()
	}
	function $A(e) {
		return e === "lg"
	}
	function nY(e) {
		return e === "sm"
	}
	var iyt = ["className", "isInvalid", "isValid", "size"]
	function HF(e, t) {
		var n = Object.keys(e)
		if (Object.getOwnPropertySymbols) {
			var r = Object.getOwnPropertySymbols(e)
			t &&
				(r = r.filter(function (i) {
					return Object.getOwnPropertyDescriptor(e, i).enumerable
				})),
				n.push.apply(n, r)
		}
		return n
	}
	function $F(e) {
		for (var t = 1; t < arguments.length; t++) {
			var n = arguments[t] != null ? arguments[t] : {}
			t % 2
				? HF(Object(n), !0).forEach(function (r) {
						st(e, r, n[r])
				  })
				: Object.getOwnPropertyDescriptors
				? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n))
				: HF(Object(n)).forEach(function (r) {
						Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r))
				  })
		}
		return e
	}
	function rY(e) {
		var t = e.className,
			n = e.isInvalid,
			r = e.isValid,
			i = e.size,
			a = ri(e, iyt)
		return $F(
			$F({}, a),
			{},
			{
				className: Fe(
					"form-control",
					"rbt-input",
					{ "form-control-lg": $A(i), "form-control-sm": nY(i), "is-invalid": n, "is-valid": r },
					t,
				),
			},
		)
	}
	function ayt(e, t) {
		var n = !e && t,
			r = e && !t,
			i,
			a,
			o
		n
			? ((i = "uncontrolled"), (a = "controlled"), (o = "an"))
			: ((i = "controlled"), (a = "uncontrolled"), (o = "a"))
		var s =
			"You are changing ".concat(o, " ").concat(i, " typeahead to be ").concat(a, ". ") +
			"Input elements should not switch from ".concat(i, " to ").concat(a, " (or vice versa). ") +
			"Decide between using a controlled or uncontrolled element for the lifetime of the component."
		wa(!(n || r), s)
	}
	var oyt = [
			{ alt: "onBlur", prop: "onBlur" },
			{ alt: "onInputChange", prop: "onChange" },
			{ alt: "onFocus", prop: "onFocus" },
			{ alt: "onKeyDown", prop: "onKeyDown" },
		],
		iY = he.oneOf(F0t)
	function Wo(e, t) {
		return function (n, r, i) {
			he.checkPropTypes(st({}, r, e), n, "prop", i), xa(t) && t(n, r, i)
		}
	}
	function syt(e) {
		var t = e.caseSensitive,
			n = e.filterBy
		wa(
			!t || typeof n != "function",
			"Your `filterBy` function will override the `caseSensitive` prop.",
		)
	}
	function lyt(e) {
		var t = e.defaultInputValue,
			n = e.defaultSelected,
			r = e.multiple,
			i = e.selected,
			a = n.length ? "defaultSelected" : "selected"
		wa(
			!(!r && t && (n.length || (i && i.length))),
			"`defaultInputValue` will be overridden by the value from `".concat(a, "`."),
		)
	}
	function uyt(e) {
		var t = e.defaultSelected,
			n = e.multiple
		wa(
			n || t.length <= 1,
			"You are passing multiple options to the `defaultSelected` prop of a Typeahead in single-select mode. The selections will be truncated to a single selection.",
		)
	}
	function cyt(e) {
		var t = e.allowNew,
			n = e.highlightOnlyResult
		wa(!(n && t), "`highlightOnlyResult` will not work with `allowNew`.")
	}
	function dyt(e) {
		var t = e.filterBy,
			n = e.ignoreDiacritics
		wa(
			n || typeof t != "function",
			"Your `filterBy` function will override the `ignoreDiacritics` prop.",
		)
	}
	function fyt(e) {
		var t = e.inputProps
		t &&
			Object.prototype.toString.call(t) === "[object Object]" &&
			oyt.forEach(function (n) {
				var r = n.alt,
					i = n.prop,
					a = r ? " Use the top-level `".concat(r, "` prop instead.") : null
				wa(!t[i], "The `".concat(i, "` property of `inputProps` will be ignored.").concat(a))
			})
	}
	function aY(e, t, n) {
		wa(
			e[t] != null,
			"The prop `".concat(t, "` is required to make `").concat(n, "` ") +
				"accessible for users of assistive technologies such as screen readers.",
		)
	}
	function pyt(e) {
		var t = e.allowNew,
			n = e.labelKey
		wa(!(xa(n) && t), "`labelKey` must be a string when `allowNew={true}`.")
	}
	var Qf = he.oneOfType([he.object, he.string])
	function hyt(e) {
		var t = e.multiple,
			n = e.onChange,
			r = e.selected
		wa(
			t || !r || r.length <= 1,
			"You are passing multiple options to the `selected` prop of a Typeahead in single-select mode. This may lead to unexpected behaviors or errors.",
		),
			wa(
				!r || (r && xa(n)),
				"You provided a `selected` prop without an `onChange` handler. If you want the typeahead to be uncontrolled, use `defaultSelected`. Otherwise, set `onChange`.",
			)
	}
	he.number,
		he.bool.isRequired,
		he.number,
		he.func.isRequired,
		he.arrayOf(Qf),
		he.node,
		he.node,
		he.bool
	function oY(e, t) {
		if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
	}
	function myt(e, t) {
		for (var n = 0; n < t.length; n++) {
			var r = t[n]
			;(r.enumerable = r.enumerable || !1),
				(r.configurable = !0),
				"value" in r && (r.writable = !0),
				Object.defineProperty(e, XW(r.key), r)
		}
	}
	function sY(e, t, n) {
		return t && myt(e.prototype, t), Object.defineProperty(e, "prototype", { writable: !1 }), e
	}
	function Ut(e) {
		if (e === void 0)
			throw new ReferenceError("this hasn't been initialised - super() hasn't been called")
		return e
	}
	function lY(e, t) {
		if (typeof t != "function" && t !== null)
			throw new TypeError("Super expression must either be null or a function")
		;(e.prototype = Object.create(t && t.prototype, {
			constructor: { value: e, writable: !0, configurable: !0 },
		})),
			Object.defineProperty(e, "prototype", { writable: !1 }),
			t && Q1(e, t)
	}
	function uY(e, t) {
		if (t && (Ap(t) == "object" || typeof t == "function")) return t
		if (t !== void 0)
			throw new TypeError("Derived constructors may only return object or undefined")
		return Ut(e)
	}
	function Np(e) {
		return (
			(Np = Object.setPrototypeOf
				? Object.getPrototypeOf.bind()
				: function (t) {
						return t.__proto__ || Object.getPrototypeOf(t)
				  }),
			Np(e)
		)
	}
	var vyt = {
			activeIndex: -1,
			hintText: "",
			id: "",
			initialItem: null,
			inputNode: null,
			isOnlyResult: !1,
			onActiveItemChange: Ha,
			onAdd: Ha,
			onInitialItemChange: Ha,
			onMenuItemClick: Ha,
			setItem: Ha,
		},
		cY = _.createContext(vyt),
		dY = function () {
			return _.useContext(cY)
		}
	function UF(e, t) {
		var n = Object.keys(e)
		if (Object.getOwnPropertySymbols) {
			var r = Object.getOwnPropertySymbols(e)
			t &&
				(r = r.filter(function (i) {
					return Object.getOwnPropertyDescriptor(e, i).enumerable
				})),
				n.push.apply(n, r)
		}
		return n
	}
	function kf(e) {
		for (var t = 1; t < arguments.length; t++) {
			var n = arguments[t] != null ? arguments[t] : {}
			t % 2
				? UF(Object(n), !0).forEach(function (r) {
						st(e, r, n[r])
				  })
				: Object.getOwnPropertyDescriptors
				? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n))
				: UF(Object(n)).forEach(function (r) {
						Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r))
				  })
		}
		return e
	}
	var gyt = [
			"activeIndex",
			"disabled",
			"id",
			"inputRef",
			"isFocused",
			"isMenuShown",
			"multiple",
			"onBlur",
			"onChange",
			"onClick",
			"onFocus",
			"onKeyDown",
			"placeholder",
		],
		yyt = [
			"activeIndex",
			"hideMenu",
			"isMenuShown",
			"labelKey",
			"onClear",
			"onHide",
			"onRemove",
			"results",
			"selected",
			"text",
			"toggleMenu",
		],
		byt = [
			"activeIndex",
			"id",
			"initialItem",
			"inputNode",
			"onActiveItemChange",
			"onAdd",
			"onInitialItemChange",
			"onMenuItemClick",
			"setItem",
		],
		xyt = function (t) {
			var n = t.allowNew,
				r = t.children,
				i = t.initialItem,
				a = t.isMenuShown,
				o = t.onAdd,
				s = t.onInitialItemChange,
				l = t.onKeyDown,
				u = t.onMenuToggle,
				d = t.results,
				p = t.selectHint,
				m = Q0t(t)
			_.useEffect(function () {
				n || d.length || s()
			})
			var v = _.useRef(!0)
			_.useEffect(
				function () {
					if (v.current) {
						v.current = !1
						return
					}
					u(a)
				},
				[a, u],
			)
			var y = function (T) {
					if ((l(T), !!i)) {
						var C = T.key === "Enter" && FF(t),
							D = m && Y0t(T, p)
						;(C || D) && o(i)
					}
				},
				b = kf(
					kf({}, w1(t, yyt)),
					{},
					{ getInputProps: J0t(kf(kf({}, w1(t, gyt)), {}, { onKeyDown: y, value: Z0t(t) })) },
				),
				x = kf(kf({}, w1(t, byt)), {}, { hintText: m, isOnlyResult: FF(t) })
			return H.createElement(cY.Provider, { value: x }, xa(r) ? r(b) : r)
		}
	function zF(e, t) {
		var n = Object.keys(e)
		if (Object.getOwnPropertySymbols) {
			var r = Object.getOwnPropertySymbols(e)
			t &&
				(r = r.filter(function (i) {
					return Object.getOwnPropertyDescriptor(e, i).enumerable
				})),
				n.push.apply(n, r)
		}
		return n
	}
	function qu(e) {
		for (var t = 1; t < arguments.length; t++) {
			var n = arguments[t] != null ? arguments[t] : {}
			t % 2
				? zF(Object(n), !0).forEach(function (r) {
						st(e, r, n[r])
				  })
				: Object.getOwnPropertyDescriptors
				? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n))
				: zF(Object(n)).forEach(function (r) {
						Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r))
				  })
		}
		return e
	}
	function qb(e) {
		var t = e.defaultInputValue,
			n = e.defaultOpen,
			r = e.defaultSelected,
			i = e.maxResults,
			a = e.multiple,
			o = e.selected ? e.selected.slice() : r.slice(),
			s = t
		return (
			!a && o.length && ((s = ys(o[0], e.labelKey)), o.length > 1 && (o = o.slice(0, 1))),
			{
				activeIndex: -1,
				activeItem: void 0,
				initialItem: void 0,
				isFocused: !1,
				selected: o,
				showMenu: n,
				shownResults: i,
				text: s,
			}
		)
	}
	function qF(e, t) {
		return qu(qu({}, qb(t)), {}, { isFocused: e.isFocused, selected: [], text: "" })
	}
	function VF(e) {
		return qu(qu({}, e), {}, { isFocused: !0, showMenu: !0 })
	}
	function E1(e, t) {
		var n = qb(t),
			r = n.activeIndex,
			i = n.activeItem,
			a = n.initialItem,
			o = n.shownResults
		return qu(
			qu({}, e),
			{},
			{ activeIndex: r, activeItem: i, initialItem: a, showMenu: !1, shownResults: o },
		)
	}
	function wyt(e, t) {
		return e.showMenu ? E1(e, t) : qu(qu({}, e), {}, { showMenu: !0 })
	}
	var Eyt = ["onChange"]
	function WF(e, t) {
		var n = Object.keys(e)
		if (Object.getOwnPropertySymbols) {
			var r = Object.getOwnPropertySymbols(e)
			t &&
				(r = r.filter(function (i) {
					return Object.getOwnPropertyDescriptor(e, i).enumerable
				})),
				n.push.apply(n, r)
		}
		return n
	}
	function ou(e) {
		for (var t = 1; t < arguments.length; t++) {
			var n = arguments[t] != null ? arguments[t] : {}
			t % 2
				? WF(Object(n), !0).forEach(function (r) {
						st(e, r, n[r])
				  })
				: Object.getOwnPropertyDescriptors
				? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n))
				: WF(Object(n)).forEach(function (r) {
						Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r))
				  })
		}
		return e
	}
	function Cyt(e) {
		var t = Tyt()
		return function () {
			var r = Np(e),
				i
			if (t) {
				var a = Np(this).constructor
				i = Reflect.construct(r, arguments, a)
			} else i = r.apply(this, arguments)
			return uY(this, i)
		}
	}
	function Tyt() {
		if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham) return !1
		if (typeof Proxy == "function") return !0
		try {
			return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})), !0
		} catch {
			return !1
		}
	}
	var kyt = {
			allowNew: he.oneOfType([he.bool, he.func]),
			autoFocus: he.bool,
			caseSensitive: Wo(he.bool, syt),
			defaultInputValue: Wo(he.string, lyt),
			defaultOpen: he.bool,
			defaultSelected: Wo(he.arrayOf(Qf), uyt),
			filterBy: he.oneOfType([he.arrayOf(he.string.isRequired), he.func]),
			highlightOnlyResult: Wo(he.bool, cyt),
			id: Wo(he.oneOfType([he.number, he.string]), aY),
			ignoreDiacritics: Wo(he.bool, dyt),
			labelKey: Wo(he.oneOfType([he.string, he.func]), pyt),
			maxResults: he.number,
			minLength: he.number,
			multiple: he.bool,
			onBlur: he.func,
			onChange: he.func,
			onFocus: he.func,
			onInputChange: he.func,
			onKeyDown: he.func,
			onMenuToggle: he.func,
			onPaginate: he.func,
			open: he.bool,
			options: he.arrayOf(Qf).isRequired,
			paginate: he.bool,
			selected: Wo(he.arrayOf(Qf), hyt),
		},
		Syt = {
			allowNew: !1,
			autoFocus: !1,
			caseSensitive: !1,
			defaultInputValue: "",
			defaultOpen: !1,
			defaultSelected: [],
			filterBy: [],
			highlightOnlyResult: !1,
			ignoreDiacritics: !0,
			labelKey: JW,
			maxResults: 100,
			minLength: 0,
			multiple: !1,
			onBlur: Ha,
			onFocus: Ha,
			onInputChange: Ha,
			onKeyDown: Ha,
			onMenuToggle: Ha,
			onPaginate: Ha,
			paginate: !0,
		}
	function Dyt(e, t) {
		var n = Object.getOwnPropertyDescriptor(window.HTMLInputElement.prototype, "value")
		n && n.set && n.set.call(e, t)
		var r = new Event("input", { bubbles: !0 })
		e.dispatchEvent(r)
	}
	var UA = (function (e) {
		lY(n, e)
		var t = Cyt(n)
		function n() {
			var r
			oY(this, n)
			for (var i = arguments.length, a = new Array(i), o = 0; o < i; o++) a[o] = arguments[o]
			return (
				(r = t.call.apply(t, [this].concat(a))),
				st(Ut(r), "state", qb(r.props)),
				st(Ut(r), "inputNode", null),
				st(Ut(r), "isMenuShown", !1),
				st(Ut(r), "items", []),
				st(Ut(r), "blur", function () {
					r.inputNode && r.inputNode.blur(), r.hideMenu()
				}),
				st(Ut(r), "clear", function () {
					r.setState(qF)
				}),
				st(Ut(r), "focus", function () {
					r.inputNode && r.inputNode.focus()
				}),
				st(Ut(r), "getInput", function () {
					return r.inputNode
				}),
				st(Ut(r), "inputRef", function (s) {
					r.inputNode = s
				}),
				st(Ut(r), "setItem", function (s, l) {
					r.items[l] = s
				}),
				st(Ut(r), "hideMenu", function () {
					r.setState(E1)
				}),
				st(Ut(r), "toggleMenu", function () {
					r.setState(wyt)
				}),
				st(Ut(r), "_handleActiveIndexChange", function (s) {
					r.setState(function (l) {
						return { activeIndex: s, activeItem: s >= 0 ? l.activeItem : void 0 }
					})
				}),
				st(Ut(r), "_handleActiveItemChange", function (s) {
					Sm(s, r.state.activeItem) || r.setState({ activeItem: s })
				}),
				st(Ut(r), "_handleBlur", function (s) {
					s.persist(),
						r.setState({ isFocused: !1 }, function () {
							return r.props.onBlur(s)
						})
				}),
				st(Ut(r), "_handleChange", function (s) {
					r.props.onChange && r.props.onChange(s)
				}),
				st(Ut(r), "_handleClear", function () {
					r.inputNode && Dyt(r.inputNode, ""),
						r.setState(qF, function () {
							r.props.multiple && r._handleChange([])
						})
				}),
				st(Ut(r), "_handleClick", function (s) {
					var l
					s.persist()
					var u = (l = r.props.inputProps) === null || l === void 0 ? void 0 : l.onClick
					r.setState(VF, function () {
						return xa(u) && u(s)
					})
				}),
				st(Ut(r), "_handleFocus", function (s) {
					s.persist(),
						r.setState(VF, function () {
							return r.props.onFocus(s)
						})
				}),
				st(Ut(r), "_handleInitialItemChange", function (s) {
					Sm(s, r.state.initialItem) || r.setState({ initialItem: s })
				}),
				st(Ut(r), "_handleInputChange", function (s) {
					s.persist()
					var l = s.currentTarget.value,
						u = r.props,
						d = u.multiple,
						p = u.onInputChange,
						m = r.state.selected.length && !d
					r.setState(
						function (v, y) {
							var b = qb(y),
								x = b.activeIndex,
								E = b.activeItem,
								T = b.shownResults
							return {
								activeIndex: x,
								activeItem: E,
								selected: m ? [] : v.selected,
								showMenu: !0,
								shownResults: T,
								text: l,
							}
						},
						function () {
							p(l, s), m && r._handleChange([])
						},
					)
				}),
				st(Ut(r), "_handleKeyDown", function (s) {
					var l = r.state.activeItem
					if (!r.isMenuShown) {
						;(s.key === "ArrowUp" || s.key === "ArrowDown") && r.setState({ showMenu: !0 }),
							r.props.onKeyDown(s)
						return
					}
					switch (s.key) {
						case "ArrowUp":
						case "ArrowDown":
							s.preventDefault(),
								r._handleActiveIndexChange(nyt(r.state.activeIndex, s.key, r.items))
							break
						case "Enter":
							s.preventDefault(), l && r._handleMenuItemSelect(l, s)
							break
						case "Escape":
						case "Tab":
							r.hideMenu()
							break
					}
					r.props.onKeyDown(s)
				}),
				st(Ut(r), "_handleMenuItemSelect", function (s, l) {
					rd(s, "paginationOption") ? r._handlePaginate(l) : r._handleSelectionAdd(s)
				}),
				st(Ut(r), "_handlePaginate", function (s) {
					s.persist(),
						r.setState(
							function (l, u) {
								return { shownResults: l.shownResults + u.maxResults }
							},
							function () {
								return r.props.onPaginate(s, r.state.shownResults)
							},
						)
				}),
				st(Ut(r), "_handleSelectionAdd", function (s) {
					var l = r.props,
						u = l.multiple,
						d = l.labelKey,
						p,
						m = s,
						v
					!ko(m) && m.customOption && (m = ou(ou({}, m), {}, { id: B0t("new-id-") })),
						u ? ((p = r.state.selected.concat(m)), (v = "")) : ((p = [m]), (v = ys(m, d))),
						r.setState(
							function (y, b) {
								return ou(ou({}, E1(y, b)), {}, { initialItem: m, selected: p, text: v })
							},
							function () {
								return r._handleChange(p)
							},
						)
				}),
				st(Ut(r), "_handleSelectionRemove", function (s) {
					var l = r.state.selected.filter(function (u) {
						return !Sm(u, s)
					})
					r.focus(),
						r.setState(
							function (u, d) {
								return ou(ou({}, E1(u, d)), {}, { selected: l })
							},
							function () {
								return r._handleChange(l)
							},
						)
				}),
				r
			)
		}
		return (
			sY(n, [
				{
					key: "componentDidMount",
					value: function () {
						this.props.autoFocus && this.focus()
					},
				},
				{
					key: "componentDidUpdate",
					value: function (i, a) {
						var o = this.props,
							s = o.labelKey,
							l = o.multiple,
							u = o.selected
						ayt(u, i.selected),
							u &&
								!Sm(u, a.selected) &&
								(this.setState({ selected: u }),
								l || this.setState({ text: u.length ? ys(u[0], s) : "" }))
					},
				},
				{
					key: "render",
					value: function () {
						var i = this.props
						i.onChange
						var a = ri(i, Eyt),
							o = ou(ou({}, a), this.state),
							s = o.filterBy,
							l = o.labelKey,
							u = o.options,
							d = o.paginate,
							p = o.shownResults,
							m = o.text
						;(this.isMenuShown = ryt(o)), (this.items = [])
						var v = []
						if (this.isMenuShown) {
							var y = xa(s) ? s : W0t
							v = u.filter(function (E) {
								return y(E, o)
							})
							var b = d && v.length > p
							if (((v = eyt(v, p)), H0t(v, o) && v.push(st({ customOption: !0 }, DD(l), m)), b)) {
								var x
								v.push(((x = {}), st(x, DD(l), ""), st(x, "paginationOption", !0), x))
							}
						}
						return H.createElement(
							xyt,
							zn({}, o, {
								hideMenu: this.hideMenu,
								inputNode: this.inputNode,
								inputRef: this.inputRef,
								isMenuShown: this.isMenuShown,
								onActiveItemChange: this._handleActiveItemChange,
								onAdd: this._handleSelectionAdd,
								onBlur: this._handleBlur,
								onChange: this._handleInputChange,
								onClear: this._handleClear,
								onClick: this._handleClick,
								onFocus: this._handleFocus,
								onHide: this.hideMenu,
								onInitialItemChange: this._handleInitialItemChange,
								onKeyDown: this._handleKeyDown,
								onMenuItemClick: this._handleMenuItemSelect,
								onRemove: this._handleSelectionRemove,
								results: v,
								setItem: this.setItem,
								toggleMenu: this.toggleMenu,
							}),
						)
					},
				},
			]),
			n
		)
	})(H.Component)
	st(UA, "propTypes", kyt)
	st(UA, "defaultProps", Syt)
	var _yt = ["className", "label", "onClick", "onKeyDown", "size"],
		Oyt = { label: he.string, onClick: he.func, onKeyDown: he.func, size: iY },
		zA = function (t) {
			var n = t.className,
				r = t.label,
				i = r === void 0 ? "Clear" : r,
				a = t.onClick,
				o = t.onKeyDown,
				s = t.size,
				l = ri(t, _yt)
			return H.createElement(
				"button",
				zn({}, l, {
					"aria-label": i,
					className: Fe(
						"close",
						"btn-close",
						"rbt-close",
						{ "rbt-close-lg": $A(s), "rbt-close-sm": nY(s) },
						n,
					),
					onClick: function (d) {
						d.stopPropagation(), a && a(d)
					},
					onKeyDown: function (d) {
						d.key === "Backspace" && d.preventDefault(), o && o(d)
					},
					type: "button",
				}),
				H.createElement("span", { "aria-hidden": "true", className: "rbt-close-content" }, ""),
				H.createElement("span", { className: "visually-hidden visually-hidden" }, i),
			)
		}
	zA.propTypes = Oyt
	var Ayt = { label: he.string },
		fY = function (t) {
			var n = t.label,
				r = n === void 0 ? "Loading..." : n
			return H.createElement(
				"div",
				{ className: "rbt-loader spinner-border spinner-border-sm", role: "status" },
				H.createElement("span", { className: "visually-hidden visually-hidden" }, r),
			)
		}
	fY.propTypes = Ayt
	function Nyt(e) {
		if (Array.isArray(e)) return e
	}
	function Myt(e, t) {
		var n = e == null ? null : (typeof Symbol < "u" && e[Symbol.iterator]) || e["@@iterator"]
		if (n != null) {
			var r,
				i,
				a,
				o,
				s = [],
				l = !0,
				u = !1
			try {
				if (((a = (n = n.call(e)).next), t !== 0))
					for (; !(l = (r = a.call(n)).done) && (s.push(r.value), s.length !== t); l = !0);
			} catch (d) {
				;(u = !0), (i = d)
			} finally {
				try {
					if (!l && n.return != null && ((o = n.return()), Object(o) !== o)) return
				} finally {
					if (u) throw i
				}
			}
			return s
		}
	}
	function YF(e, t) {
		;(t == null || t > e.length) && (t = e.length)
		for (var n = 0, r = Array(t); n < t; n++) r[n] = e[n]
		return r
	}
	function Iyt(e, t) {
		if (e) {
			if (typeof e == "string") return YF(e, t)
			var n = {}.toString.call(e).slice(8, -1)
			return (
				n === "Object" && e.constructor && (n = e.constructor.name),
				n === "Map" || n === "Set"
					? Array.from(e)
					: n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)
					? YF(e, t)
					: void 0
			)
		}
	}
	function Ryt() {
		throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
	}
	function _D(e, t) {
		return Nyt(e) || Myt(e, t) || Iyt(e, t) || Ryt()
	}
	var GF = function (t) {
			return t.reduce(function (n, r) {
				var i = r[0],
					a = r[1]
				return (n[i] = a), n
			}, {})
		},
		KF =
			typeof window < "u" && window.document && window.document.createElement
				? _.useLayoutEffect
				: _.useEffect
	function Lyt(e) {
		var t = e.state
		Object.keys(t.elements).forEach(function (n) {
			var r = t.styles[n] || {},
				i = t.attributes[n] || {},
				a = t.elements[n]
			!qa(a) ||
				!hs(a) ||
				(Object.assign(a.style, r),
				Object.keys(i).forEach(function (o) {
					var s = i[o]
					s === !1 ? a.removeAttribute(o) : a.setAttribute(o, s === !0 ? "" : s)
				}))
		})
	}
	function Pyt(e) {
		var t = e.state,
			n = {
				popper: { position: t.options.strategy, left: "0", top: "0", margin: "0" },
				arrow: { position: "absolute" },
				reference: {},
			}
		return (
			Object.assign(t.elements.popper.style, n.popper),
			(t.styles = n),
			t.elements.arrow && Object.assign(t.elements.arrow.style, n.arrow),
			function () {
				Object.keys(t.elements).forEach(function (r) {
					var i = t.elements[r],
						a = t.attributes[r] || {},
						o = Object.keys(t.styles.hasOwnProperty(r) ? t.styles[r] : n[r]),
						s = o.reduce(function (l, u) {
							return (l[u] = ""), l
						}, {})
					!qa(i) ||
						!hs(i) ||
						(Object.assign(i.style, s),
						Object.keys(a).forEach(function (l) {
							i.removeAttribute(l)
						}))
				})
			}
		)
	}
	const jyt = {
		name: "applyStyles",
		enabled: !0,
		phase: "write",
		fn: Lyt,
		effect: Pyt,
		requires: ["computeStyles"],
	}
	var Fyt = [F$, q$, j$, jyt, z$, $$, V$, P$, U$],
		Byt = W$({ defaultModifiers: Fyt }),
		uS,
		QF
	function Hyt() {
		if (QF) return uS
		QF = 1
		var e = typeof Element < "u",
			t = typeof Map == "function",
			n = typeof Set == "function",
			r = typeof ArrayBuffer == "function" && !!ArrayBuffer.isView
		function i(a, o) {
			if (a === o) return !0
			if (a && o && typeof a == "object" && typeof o == "object") {
				if (a.constructor !== o.constructor) return !1
				var s, l, u
				if (Array.isArray(a)) {
					if (((s = a.length), s != o.length)) return !1
					for (l = s; l-- !== 0; ) if (!i(a[l], o[l])) return !1
					return !0
				}
				var d
				if (t && a instanceof Map && o instanceof Map) {
					if (a.size !== o.size) return !1
					for (d = a.entries(); !(l = d.next()).done; ) if (!o.has(l.value[0])) return !1
					for (d = a.entries(); !(l = d.next()).done; )
						if (!i(l.value[1], o.get(l.value[0]))) return !1
					return !0
				}
				if (n && a instanceof Set && o instanceof Set) {
					if (a.size !== o.size) return !1
					for (d = a.entries(); !(l = d.next()).done; ) if (!o.has(l.value[0])) return !1
					return !0
				}
				if (r && ArrayBuffer.isView(a) && ArrayBuffer.isView(o)) {
					if (((s = a.length), s != o.length)) return !1
					for (l = s; l-- !== 0; ) if (a[l] !== o[l]) return !1
					return !0
				}
				if (a.constructor === RegExp) return a.source === o.source && a.flags === o.flags
				if (
					a.valueOf !== Object.prototype.valueOf &&
					typeof a.valueOf == "function" &&
					typeof o.valueOf == "function"
				)
					return a.valueOf() === o.valueOf()
				if (
					a.toString !== Object.prototype.toString &&
					typeof a.toString == "function" &&
					typeof o.toString == "function"
				)
					return a.toString() === o.toString()
				if (((u = Object.keys(a)), (s = u.length), s !== Object.keys(o).length)) return !1
				for (l = s; l-- !== 0; ) if (!Object.prototype.hasOwnProperty.call(o, u[l])) return !1
				if (e && a instanceof Element) return !1
				for (l = s; l-- !== 0; )
					if (
						!((u[l] === "_owner" || u[l] === "__v" || u[l] === "__o") && a.$$typeof) &&
						!i(a[u[l]], o[u[l]])
					)
						return !1
				return !0
			}
			return a !== a && o !== o
		}
		return (
			(uS = function (o, s) {
				try {
					return i(o, s)
				} catch (l) {
					if ((l.message || "").match(/stack|recursion/i))
						return console.warn("react-fast-compare cannot handle circular refs"), !1
					throw l
				}
			}),
			uS
		)
	}
	var $yt = Hyt()
	const Uyt = Ti($yt)
	var zyt = [],
		qyt = function (t, n, r) {
			r === void 0 && (r = {})
			var i = _.useRef(null),
				a = {
					onFirstUpdate: r.onFirstUpdate,
					placement: r.placement || "bottom",
					strategy: r.strategy || "absolute",
					modifiers: r.modifiers || zyt,
				},
				o = _.useState({
					styles: {
						popper: { position: a.strategy, left: "0", top: "0" },
						arrow: { position: "absolute" },
					},
					attributes: {},
				}),
				s = o[0],
				l = o[1],
				u = _.useMemo(function () {
					return {
						name: "updateState",
						enabled: !0,
						phase: "write",
						fn: function (v) {
							var y = v.state,
								b = Object.keys(y.elements)
							$D.flushSync(function () {
								l({
									styles: GF(
										b.map(function (x) {
											return [x, y.styles[x] || {}]
										}),
									),
									attributes: GF(
										b.map(function (x) {
											return [x, y.attributes[x]]
										}),
									),
								})
							})
						},
						requires: ["computeStyles"],
					}
				}, []),
				d = _.useMemo(
					function () {
						var m = {
							onFirstUpdate: a.onFirstUpdate,
							placement: a.placement,
							strategy: a.strategy,
							modifiers: [].concat(a.modifiers, [u, { name: "applyStyles", enabled: !1 }]),
						}
						return Uyt(i.current, m) ? i.current || m : ((i.current = m), m)
					},
					[a.onFirstUpdate, a.placement, a.strategy, a.modifiers, u],
				),
				p = _.useRef()
			return (
				KF(
					function () {
						p.current && p.current.setOptions(d)
					},
					[d],
				),
				KF(
					function () {
						if (!(t == null || n == null)) {
							var m = r.createPopper || Byt,
								v = m(t, n, d)
							return (
								(p.current = v),
								function () {
									v.destroy(), (p.current = null)
								}
							)
						}
					},
					[t, n, r.createPopper],
				),
				{
					state: p.current ? p.current.state : null,
					styles: s.styles,
					attributes: s.attributes,
					update: p.current ? p.current.update : null,
					forceUpdate: p.current ? p.current.forceUpdate : null,
				}
			)
		}
	function XF(e, t) {
		var n = Object.keys(e)
		if (Object.getOwnPropertySymbols) {
			var r = Object.getOwnPropertySymbols(e)
			t &&
				(r = r.filter(function (i) {
					return Object.getOwnPropertyDescriptor(e, i).enumerable
				})),
				n.push.apply(n, r)
		}
		return n
	}
	function JF(e) {
		for (var t = 1; t < arguments.length; t++) {
			var n = arguments[t] != null ? arguments[t] : {}
			t % 2
				? XF(Object(n), !0).forEach(function (r) {
						st(e, r, n[r])
				  })
				: Object.getOwnPropertyDescriptors
				? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n))
				: XF(Object(n)).forEach(function (r) {
						Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r))
				  })
		}
		return e
	}
	var Vyt = {
		enabled: !0,
		fn: function (t) {
			t.state.styles.popper.width = "".concat(t.state.rects.reference.width, "px")
		},
		name: "setPopperWidth",
		phase: "write",
	}
	function Wyt(e) {
		var t = [
			{ enabled: !!e.flip, name: "flip" },
			{ name: "preventOverflow", options: { mainAxis: !1 } },
		]
		return e.align !== "right" && e.align !== "left" && t.push(Vyt), t
	}
	function Yyt(e) {
		var t = e.align === "right" ? "end" : "start",
			n = e.dropup ? "top" : "bottom"
		return "".concat(n, "-").concat(t)
	}
	function Gyt(e, t) {
		var n = _.useState(null),
			r = _D(n, 2),
			i = r[0],
			a = r[1],
			o = qyt(e, i, {
				modifiers: Wyt(t),
				placement: Yyt(t),
				strategy: t.positionFixed ? "fixed" : "absolute",
			}),
			s = o.attributes,
			l = o.styles,
			u = o.forceUpdate,
			d = e == null ? void 0 : e.offsetHeight
		return (
			_.useEffect(
				function () {
					u && u()
				},
				[d],
			),
			JF(JF({}, s.popper), {}, { innerRef: a, style: l.popper })
		)
	}
	var Kyt = ["referenceElement", "isMenuShown"],
		Qyt = typeof Element > "u" ? Ha : Element,
		Xyt = {
			align: he.oneOf(j0t),
			children: he.func.isRequired,
			dropup: he.bool,
			flip: he.bool,
			isMenuShown: he.bool,
			positionFixed: he.bool,
			referenceElement: he.instanceOf(Qyt),
		},
		pY = function (t) {
			var n = t.referenceElement,
				r = t.isMenuShown,
				i = ri(t, Kyt),
				a = Gyt(n, i)
			return r ? i.children(a) : null
		}
	pY.propTypes = Xyt
	function Jyt(e) {
		return e && "setState" in e ? nl.findDOMNode(e) : e ?? null
	}
	const Zyt = function (e) {
		return Jp(Jyt(e))
	}
	var e1t = 27,
		ZF = function () {}
	function t1t(e) {
		return e.button === 0
	}
	function n1t(e) {
		return !!(e.metaKey || e.altKey || e.ctrlKey || e.shiftKey)
	}
	var e5 = function (t) {
		return t && ("current" in t ? t.current : t)
	}
	function hY(e, t, n) {
		var r = n === void 0 ? {} : n,
			i = r.disabled,
			a = r.clickTrigger,
			o = a === void 0 ? "click" : a,
			s = _.useRef(!1),
			l = t || ZF,
			u = _.useCallback(
				function (m) {
					var v,
						y = e5(e)
					z_(
						!!y,
						"RootClose captured a close event but does not have a ref to compare it to. useRootClose(), should be passed a ref that resolves to a DOM node",
					),
						(s.current =
							!y ||
							n1t(m) ||
							!t1t(m) ||
							!!bv(
								y,
								(v = m.composedPath == null ? void 0 : m.composedPath()[0]) != null ? v : m.target,
							))
				},
				[e],
			),
			d = wl(function (m) {
				s.current || l(m)
			}),
			p = wl(function (m) {
				m.keyCode === e1t && l(m)
			})
		_.useEffect(
			function () {
				if (!(i || e == null)) {
					var m = window.event,
						v = Zyt(e5(e)),
						y = za(v, o, u, !0),
						b = za(v, o, function (T) {
							if (T === m) {
								m = void 0
								return
							}
							d(T)
						}),
						x = za(v, "keyup", function (T) {
							if (T === m) {
								m = void 0
								return
							}
							p(T)
						}),
						E = []
					return (
						"ontouchstart" in v.documentElement &&
							(E = [].slice.call(v.body.children).map(function (T) {
								return za(T, "mousemove", ZF)
							})),
						function () {
							y(),
								b(),
								x(),
								E.forEach(function (T) {
									return T()
								})
						}
					)
				}
			},
			[e, i, o, u, d, p],
		)
	}
	function r1t(e, t) {
		var n = _.useRef(null)
		return hY(n.current, e, t), n
	}
	var i1t = ["children", "onRootClose"]
	function a1t(e) {
		var t = e.children,
			n = e.onRootClose,
			r = ri(e, i1t),
			i = r1t(n, r)
		return t(i)
	}
	var o1t = ["onBlur", "onClick", "onFocus", "onRemove", "option"]
	function t5(e, t) {
		var n = Object.keys(e)
		if (Object.getOwnPropertySymbols) {
			var r = Object.getOwnPropertySymbols(e)
			t &&
				(r = r.filter(function (i) {
					return Object.getOwnPropertyDescriptor(e, i).enumerable
				})),
				n.push.apply(n, r)
		}
		return n
	}
	function n5(e) {
		for (var t = 1; t < arguments.length; t++) {
			var n = arguments[t] != null ? arguments[t] : {}
			t % 2
				? t5(Object(n), !0).forEach(function (r) {
						st(e, r, n[r])
				  })
				: Object.getOwnPropertyDescriptors
				? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n))
				: t5(Object(n)).forEach(function (r) {
						Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r))
				  })
		}
		return e
	}
	he.func, he.func, he.func, he.func, Qf.isRequired
	function s1t(e) {
		var t = e.onBlur,
			n = e.onClick,
			r = e.onFocus,
			i = e.onRemove,
			a = e.option,
			o = ri(e, o1t),
			s = _.useState(!1),
			l = _D(s, 2),
			u = l[0],
			d = l[1],
			p = _.useState(null),
			m = _D(p, 2),
			v = m[0],
			y = m[1],
			b = function (O) {
				d(!1), t && t(O)
			},
			x = function (O) {
				d(!0), n && n(O)
			},
			E = function (O) {
				d(!0), r && r(O)
			},
			T = function () {
				i && i(a)
			},
			C = function (O) {
				O.key === "Backspace" && u && (O.preventDefault(), T())
			}
		return (
			hY(v, b, n5(n5({}, o), {}, { disabled: !u })),
			{
				active: u,
				onBlur: b,
				onClick: x,
				onFocus: E,
				onKeyDown: C,
				onRemove: xa(i) ? T : void 0,
				ref: y,
			}
		)
	}
	var l1t = ["active", "children", "className", "onRemove", "tabIndex"],
		u1t = ["children", "option", "readOnly"],
		c1t = ["ref"]
	function r5(e, t) {
		var n = Object.keys(e)
		if (Object.getOwnPropertySymbols) {
			var r = Object.getOwnPropertySymbols(e)
			t &&
				(r = r.filter(function (i) {
					return Object.getOwnPropertyDescriptor(e, i).enumerable
				})),
				n.push.apply(n, r)
		}
		return n
	}
	function i5(e) {
		for (var t = 1; t < arguments.length; t++) {
			var n = arguments[t] != null ? arguments[t] : {}
			t % 2
				? r5(Object(n), !0).forEach(function (r) {
						st(e, r, n[r])
				  })
				: Object.getOwnPropertyDescriptors
				? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n))
				: r5(Object(n)).forEach(function (r) {
						Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r))
				  })
		}
		return e
	}
	var d1t = _.forwardRef(function (e, t) {
			var n = e.active,
				r = e.children,
				i = e.className,
				a = e.onRemove,
				o = e.tabIndex,
				s = ri(e, l1t)
			return H.createElement(
				"div",
				zn({}, s, {
					className: Fe("rbt-token", "rbt-token-removeable", { "rbt-token-active": !!n }, i),
					ref: t,
					tabIndex: o || 0,
				}),
				r,
				H.createElement(zA, {
					className: "rbt-token-remove-button",
					label: "Remove",
					onClick: a,
					tabIndex: -1,
				}),
			)
		}),
		f1t = function (t) {
			var n = t.children,
				r = t.className,
				i = t.disabled,
				a = t.href,
				o = Fe("rbt-token", { "rbt-token-disabled": i }, r)
			return a && !i
				? H.createElement("a", { className: o, href: a }, n)
				: H.createElement("div", { className: o }, n)
		},
		p1t = function (t) {
			var n = t.children,
				r = t.option,
				i = t.readOnly,
				a = ri(t, u1t),
				o = s1t(i5(i5({}, a), {}, { option: r })),
				s = o.ref,
				l = ri(o, c1t),
				u = H.createElement("div", { className: "rbt-token-label" }, n)
			return !a.disabled && !i && xa(l.onRemove)
				? H.createElement(d1t, zn({}, a, l, { ref: s }), u)
				: H.createElement(f1t, a, u)
		}
	function Ty(e, t) {
		var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : ""
		return (
			n && (n = n.replace(n[0], n[0].toUpperCase())),
			["Top", "Right", "Bottom", "Left"]
				.map(function (r) {
					return e["".concat(t).concat(r).concat(n)]
				})
				.join(" ")
		)
	}
	function h1t(e, t) {
		var n = window.getComputedStyle(e)
		;(t.style.borderStyle = Ty(n, "border", "style")),
			(t.style.borderWidth = Ty(n, "border", "width")),
			(t.style.fontSize = n.fontSize),
			(t.style.fontWeight = n.fontWeight),
			(t.style.height = n.height),
			(t.style.lineHeight = n.lineHeight),
			(t.style.margin = Ty(n, "margin")),
			(t.style.padding = Ty(n, "padding"))
	}
	var m1t = function () {
			var t = dY(),
				n = t.hintText,
				r = t.inputNode,
				i = _.useRef(null)
			return (
				_.useEffect(
					function () {
						var a = function () {
							i.current && r && (i.current.scrollLeft = r.scrollLeft)
						}
						return (
							r == null || r.addEventListener("scroll", a),
							function () {
								r == null || r.removeEventListener("scroll", a)
							}
						)
					},
					[r],
				),
				_.useEffect(function () {
					r && i.current && h1t(r, i.current)
				}),
				{ hintRef: i, hintText: n }
			)
		},
		mY = function (t) {
			var n = t.children,
				r = t.className,
				i = m1t(),
				a = i.hintRef,
				o = i.hintText
			return H.createElement(
				"div",
				{ className: r, style: { display: "flex", flex: 1, height: "100%", position: "relative" } },
				n,
				H.createElement("input", {
					"aria-hidden": !0,
					className: "rbt-input-hint",
					ref: a,
					readOnly: !0,
					style: {
						backgroundColor: "transparent",
						borderColor: "transparent",
						boxShadow: "none",
						color: "rgba(0, 0, 0, 0.54)",
						left: 0,
						pointerEvents: "none",
						position: "absolute",
						top: 0,
						width: "100%",
					},
					tabIndex: -1,
					value: o,
				}),
			)
		},
		vY = _.forwardRef(function (e, t) {
			return H.createElement(
				"input",
				zn({}, e, { className: Fe("rbt-input-main", e.className), ref: t }),
			)
		}),
		v1t = ["children", "className", "inputClassName", "inputRef", "referenceElementRef", "selected"]
	function g1t(e) {
		var t = H.useRef(null),
			n = H.useRef(null),
			r = rY(e),
			i = r.children,
			a = r.className,
			o = r.inputClassName
		r.inputRef
		var s = r.referenceElementRef,
			l = r.selected,
			u = ri(r, v1t)
		function d(v) {
			;(n.current = v), e.inputRef(v)
		}
		function p(v) {
			if (e.disabled) {
				v.currentTarget.blur()
				return
			}
			var y = n.current
			!y ||
				(v.currentTarget.contains(v.target) && v.currentTarget !== v.target) ||
				(ZW(y) && (y.selectionStart = y.value.length), y.focus())
		}
		function m(v) {
			if (v.key === "Backspace" && l.length && !e.value) {
				var y
				v.preventDefault()
				var b = (y = t.current) === null || y === void 0 ? void 0 : y.children
				if (b != null && b.length) {
					var x = b[b.length - 2]
					x == null || x.focus()
				}
			}
			e.onKeyDown && e.onKeyDown(v)
		}
		return H.createElement(
			"div",
			{
				className: Fe("rbt-input-multi", { disabled: e.disabled }, a),
				onClick: p,
				onFocus: p,
				ref: s,
				tabIndex: -1,
			},
			H.createElement(
				"div",
				{ className: "rbt-input-wrapper", ref: t },
				i,
				H.createElement(
					mY,
					null,
					H.createElement(
						vY,
						zn({}, u, {
							className: o,
							onKeyDown: m,
							ref: d,
							style: {
								backgroundColor: "transparent",
								border: 0,
								boxShadow: "none",
								cursor: "inherit",
								outline: "none",
								padding: 0,
								width: "100%",
								zIndex: 1,
							},
						}),
					),
				),
			),
		)
	}
	var y1t = ["inputRef", "referenceElementRef"],
		b1t = function (t) {
			var n = t.inputRef,
				r = t.referenceElementRef,
				i = ri(t, y1t)
			return H.createElement(
				mY,
				null,
				H.createElement(
					vY,
					zn({}, rY(i), {
						ref: function (o) {
							n(o), r(o)
						},
					}),
				),
			)
		},
		x1t = {
			children: he.string.isRequired,
			highlightClassName: he.string,
			search: he.string.isRequired,
		},
		Nw = function (t) {
			var n = t.children,
				r = t.highlightClassName,
				i = r === void 0 ? "rbt-highlight-text" : r,
				a = t.search
			if (!a || !n) return H.createElement(H.Fragment, null, n)
			for (var o = 0, s = n, l = []; s; ) {
				var u = eY(s, a)
				if (!u) {
					l.push(s)
					break
				}
				var d = s.slice(0, u.start)
				d && l.push(d)
				var p = s.slice(u.start, u.end)
				l.push(H.createElement("mark", { className: i, key: o }, p)), (o += 1), (s = s.slice(u.end))
			}
			return H.createElement(H.Fragment, null, l)
		}
	Nw.propTypes = x1t
	const a5 = (e) => typeof e == "object" && e != null && e.nodeType === 1,
		o5 = (e, t) => (!t || e !== "hidden") && e !== "visible" && e !== "clip",
		cS = (e, t) => {
			if (e.clientHeight < e.scrollHeight || e.clientWidth < e.scrollWidth) {
				const n = getComputedStyle(e, null)
				return (
					o5(n.overflowY, t) ||
					o5(n.overflowX, t) ||
					((r) => {
						const i = ((a) => {
							if (!a.ownerDocument || !a.ownerDocument.defaultView) return null
							try {
								return a.ownerDocument.defaultView.frameElement
							} catch {
								return null
							}
						})(r)
						return !!i && (i.clientHeight < r.scrollHeight || i.clientWidth < r.scrollWidth)
					})(e)
				)
			}
			return !1
		},
		ky = (e, t, n, r, i, a, o, s) =>
			(a < e && o > t) || (a > e && o < t)
				? 0
				: (a <= e && s <= n) || (o >= t && s >= n)
				? a - e - r
				: (o > t && s < n) || (a < e && s > n)
				? o - t + i
				: 0,
		w1t = (e) => {
			const t = e.parentElement
			return t ?? (e.getRootNode().host || null)
		},
		s5 = (e, t) => {
			var n, r, i, a
			if (typeof document > "u") return []
			const { scrollMode: o, block: s, inline: l, boundary: u, skipOverflowHiddenElements: d } = t,
				p = typeof u == "function" ? u : (re) => re !== u
			if (!a5(e)) throw new TypeError("Invalid target")
			const m = document.scrollingElement || document.documentElement,
				v = []
			let y = e
			for (; a5(y) && p(y); ) {
				if (((y = w1t(y)), y === m)) {
					v.push(y)
					break
				}
				;(y != null && y === document.body && cS(y) && !cS(document.documentElement)) ||
					(y != null && cS(y, d) && v.push(y))
			}
			const b =
					(r = (n = window.visualViewport) == null ? void 0 : n.width) != null ? r : innerWidth,
				x = (a = (i = window.visualViewport) == null ? void 0 : i.height) != null ? a : innerHeight,
				{ scrollX: E, scrollY: T } = window,
				{ height: C, width: D, top: O, right: A, bottom: N, left: I } = e.getBoundingClientRect(),
				{
					top: P,
					right: L,
					bottom: B,
					left: z,
				} = ((re) => {
					const ie = window.getComputedStyle(re)
					return {
						top: parseFloat(ie.scrollMarginTop) || 0,
						right: parseFloat(ie.scrollMarginRight) || 0,
						bottom: parseFloat(ie.scrollMarginBottom) || 0,
						left: parseFloat(ie.scrollMarginLeft) || 0,
					}
				})(e)
			let V = s === "start" || s === "nearest" ? O - P : s === "end" ? N + B : O + C / 2 - P + B,
				K = l === "center" ? I + D / 2 - z + L : l === "end" ? A + L : I - z
			const ne = []
			for (let re = 0; re < v.length; re++) {
				const ie = v[re],
					{
						height: J,
						width: le,
						top: F,
						right: Y,
						bottom: ee,
						left: $,
					} = ie.getBoundingClientRect()
				if (
					o === "if-needed" &&
					O >= 0 &&
					I >= 0 &&
					N <= x &&
					A <= b &&
					O >= F &&
					N <= ee &&
					I >= $ &&
					A <= Y
				)
					return ne
				const ge = getComputedStyle(ie),
					Se = parseInt(ge.borderLeftWidth, 10),
					Ee = parseInt(ge.borderTopWidth, 10),
					be = parseInt(ge.borderRightWidth, 10),
					Le = parseInt(ge.borderBottomWidth, 10)
				let Be = 0,
					et = 0
				const pt = "offsetWidth" in ie ? ie.offsetWidth - ie.clientWidth - Se - be : 0,
					mt = "offsetHeight" in ie ? ie.offsetHeight - ie.clientHeight - Ee - Le : 0,
					Xt = "offsetWidth" in ie ? (ie.offsetWidth === 0 ? 0 : le / ie.offsetWidth) : 0,
					on = "offsetHeight" in ie ? (ie.offsetHeight === 0 ? 0 : J / ie.offsetHeight) : 0
				if (m === ie)
					(Be =
						s === "start"
							? V
							: s === "end"
							? V - x
							: s === "nearest"
							? ky(T, T + x, x, Ee, Le, T + V, T + V + C, C)
							: V - x / 2),
						(et =
							l === "start"
								? K
								: l === "center"
								? K - b / 2
								: l === "end"
								? K - b
								: ky(E, E + b, b, Se, be, E + K, E + K + D, D)),
						(Be = Math.max(0, Be + T)),
						(et = Math.max(0, et + E))
				else {
					;(Be =
						s === "start"
							? V - F - Ee
							: s === "end"
							? V - ee + Le + mt
							: s === "nearest"
							? ky(F, ee, J, Ee, Le + mt, V, V + C, C)
							: V - (F + J / 2) + mt / 2),
						(et =
							l === "start"
								? K - $ - Se
								: l === "center"
								? K - ($ + le / 2) + pt / 2
								: l === "end"
								? K - Y + be + pt
								: ky($, Y, le, Se, be + pt, K, K + D, D))
					const { scrollLeft: dt, scrollTop: cn } = ie
					;(Be = on === 0 ? 0 : Math.max(0, Math.min(cn + Be / on, ie.scrollHeight - J / on + mt))),
						(et =
							Xt === 0 ? 0 : Math.max(0, Math.min(dt + et / Xt, ie.scrollWidth - le / Xt + pt))),
						(V += cn - Be),
						(K += dt - et)
				}
				ne.push({ el: ie, top: Be, left: et })
			}
			return ne
		},
		E1t = (e) =>
			e === !1
				? { block: "end", inline: "nearest" }
				: ((t) => t === Object(t) && Object.keys(t).length !== 0)(e)
				? e
				: { block: "start", inline: "nearest" }
	function C1t(e, t) {
		if (
			!e.isConnected ||
			!((i) => {
				let a = i
				for (; a && a.parentNode; ) {
					if (a.parentNode === document) return !0
					a = a.parentNode instanceof ShadowRoot ? a.parentNode.host : a.parentNode
				}
				return !1
			})(e)
		)
			return
		const n = ((i) => {
			const a = window.getComputedStyle(i)
			return {
				top: parseFloat(a.scrollMarginTop) || 0,
				right: parseFloat(a.scrollMarginRight) || 0,
				bottom: parseFloat(a.scrollMarginBottom) || 0,
				left: parseFloat(a.scrollMarginLeft) || 0,
			}
		})(e)
		if (((i) => typeof i == "object" && typeof i.behavior == "function")(t))
			return t.behavior(s5(e, t))
		const r = typeof t == "boolean" || t == null ? void 0 : t.behavior
		for (const { el: i, top: a, left: o } of s5(e, E1t(t))) {
			const s = a - n.top + n.bottom,
				l = o - n.left + n.right
			i.scroll({ top: s, left: l, behavior: r })
		}
	}
	var T1t = ["label", "onClick", "option", "position"]
	function l5(e, t) {
		var n = Object.keys(e)
		if (Object.getOwnPropertySymbols) {
			var r = Object.getOwnPropertySymbols(e)
			t &&
				(r = r.filter(function (i) {
					return Object.getOwnPropertyDescriptor(e, i).enumerable
				})),
				n.push.apply(n, r)
		}
		return n
	}
	function u5(e) {
		for (var t = 1; t < arguments.length; t++) {
			var n = arguments[t] != null ? arguments[t] : {}
			t % 2
				? l5(Object(n), !0).forEach(function (r) {
						st(e, r, n[r])
				  })
				: Object.getOwnPropertyDescriptors
				? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n))
				: l5(Object(n)).forEach(function (r) {
						Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r))
				  })
		}
		return e
	}
	Qf.isRequired, he.number
	function k1t(e) {
		var t = e.label,
			n = e.onClick,
			r = e.option,
			i = e.position,
			a = ri(e, T1t),
			o = dY(),
			s = o.activeIndex,
			l = o.id,
			u = o.isOnlyResult,
			d = o.onActiveItemChange,
			p = o.onInitialItemChange,
			m = o.onMenuItemClick,
			v = o.setItem,
			y = _.useRef(null)
		_.useEffect(function () {
			i === 0 && p(r)
		}),
			_.useEffect(
				function () {
					if (i === s) {
						d(r)
						var E = y.current
						E && C1t(E, { boundary: E.parentNode, scrollMode: "if-needed" })
					}
				},
				[s, d, r, i],
			)
		var b = _.useCallback(
				function (E) {
					m(r, E), n && n(E)
				},
				[n, m, r],
			),
			x = u || s === i
		return (
			v(r, i),
			u5(
				u5({}, a),
				{},
				{
					active: x,
					"aria-label": t,
					"aria-selected": x,
					id: tY(l, i),
					onClick: b,
					onMouseDown: HA,
					ref: y,
					role: "option",
				},
			)
		)
	}
	var S1t = ["active", "children", "className", "disabled", "onClick"],
		gY = _.forwardRef(function (e, t) {
			var n = e.active,
				r = e.children,
				i = e.className,
				a = e.disabled,
				o = e.onClick,
				s = ri(e, S1t)
			return H.createElement(
				"a",
				zn({}, s, {
					className: Fe("dropdown-item", { active: n, disabled: a }, i),
					href: s.href || "#",
					onClick: function (u) {
						u.preventDefault(), !a && o && o(u)
					},
					ref: t,
				}),
				r,
			)
		})
	function dS(e) {
		return H.createElement(gY, k1t(e))
	}
	var D1t = ["emptyLabel", "innerRef", "maxHeight", "style"]
	function c5(e, t) {
		var n = Object.keys(e)
		if (Object.getOwnPropertySymbols) {
			var r = Object.getOwnPropertySymbols(e)
			t &&
				(r = r.filter(function (i) {
					return Object.getOwnPropertyDescriptor(e, i).enumerable
				})),
				n.push.apply(n, r)
		}
		return n
	}
	function d5(e) {
		for (var t = 1; t < arguments.length; t++) {
			var n = arguments[t] != null ? arguments[t] : {}
			t % 2
				? c5(Object(n), !0).forEach(function (r) {
						st(e, r, n[r])
				  })
				: Object.getOwnPropertyDescriptors
				? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n))
				: c5(Object(n)).forEach(function (r) {
						Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r))
				  })
		}
		return e
	}
	var _1t = function () {
			return H.createElement("div", { className: "dropdown-divider", role: "separator" })
		},
		O1t = function (t) {
			return H.createElement("div", zn({}, t, { className: "dropdown-header", role: "heading" }))
		},
		A1t = {
			"aria-label": he.string,
			emptyLabel: he.node,
			id: Wo(he.oneOfType([he.number, he.string]), aY),
			maxHeight: he.string,
		},
		Pv = function (t) {
			var n = t.emptyLabel,
				r = n === void 0 ? "No matches found." : n,
				i = t.innerRef,
				a = t.maxHeight,
				o = a === void 0 ? "300px" : a,
				s = t.style,
				l = ri(t, D1t),
				u =
					_.Children.count(l.children) === 0
						? H.createElement(gY, { disabled: !0, role: "option" }, r)
						: l.children
			return H.createElement(
				"div",
				zn({}, l, {
					"aria-label": l["aria-label"] || "menu-options",
					className: Fe("rbt-menu", "dropdown-menu", "show", l.className),
					onMouseDown: HA,
					ref: i,
					role: "listbox",
					style: d5(d5({}, s), {}, { display: "block", maxHeight: o, overflow: "auto" }),
				}),
				u,
			)
		}
	Pv.propTypes = A1t
	Pv.Divider = _1t
	Pv.Header = O1t
	var N1t = [
			"labelKey",
			"newSelectionPrefix",
			"options",
			"paginationText",
			"renderMenuItemChildren",
			"text",
		],
		M1t = { newSelectionPrefix: he.node, paginationText: he.node, renderMenuItemChildren: he.func }
	function I1t(e, t) {
		return H.createElement(Nw, { search: t.text }, ys(e, t.labelKey))
	}
	var yY = function (t) {
		var n = t.labelKey,
			r = t.newSelectionPrefix,
			i = r === void 0 ? "New selection: " : r,
			a = t.options,
			o = t.paginationText,
			s = o === void 0 ? "Display additional results..." : o,
			l = t.renderMenuItemChildren,
			u = l === void 0 ? I1t : l,
			d = t.text,
			p = ri(t, N1t),
			m = function (y, b) {
				var x = ys(y, n),
					E = { disabled: !!rd(y, "disabled"), label: x, option: y, position: b }
				return rd(y, "customOption")
					? H.createElement(
							dS,
							zn({}, E, { className: "rbt-menu-custom-option", key: b, label: x }),
							i,
							H.createElement(Nw, { search: d }, x),
					  )
					: rd(y, "paginationOption")
					? H.createElement(
							H.Fragment,
							{ key: "pagination-option-divider" },
							H.createElement(Pv.Divider, null),
							H.createElement(
								dS,
								zn({}, E, { className: "rbt-menu-pagination-option", label: ko(s) ? s : "" }),
								s,
							),
					  )
					: H.createElement(dS, zn({}, E, { key: b }), u(y, t, b))
			}
		return H.createElement(Pv, zn({}, p, { key: d }), a.map(m))
	}
	yY.propTypes = M1t
	function f5(e, t) {
		var n = Object.keys(e)
		if (Object.getOwnPropertySymbols) {
			var r = Object.getOwnPropertySymbols(e)
			t &&
				(r = r.filter(function (i) {
					return Object.getOwnPropertyDescriptor(e, i).enumerable
				})),
				n.push.apply(n, r)
		}
		return n
	}
	function Uo(e) {
		for (var t = 1; t < arguments.length; t++) {
			var n = arguments[t] != null ? arguments[t] : {}
			t % 2
				? f5(Object(n), !0).forEach(function (r) {
						st(e, r, n[r])
				  })
				: Object.getOwnPropertyDescriptors
				? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n))
				: f5(Object(n)).forEach(function (r) {
						Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r))
				  })
		}
		return e
	}
	function R1t(e) {
		var t = L1t()
		return function () {
			var r = Np(e),
				i
			if (t) {
				var a = Np(this).constructor
				i = Reflect.construct(r, arguments, a)
			} else i = r.apply(this, arguments)
			return uY(this, i)
		}
	}
	function L1t() {
		if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham) return !1
		if (typeof Proxy == "function") return !0
		try {
			return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})), !0
		} catch {
			return !1
		}
	}
	var P1t = {
			clearButton: he.bool,
			inputProps: Wo(he.object, fyt),
			isInvalid: he.bool,
			isLoading: he.bool,
			isValid: he.bool,
			renderInput: he.func,
			renderMenu: he.func,
			renderToken: he.func,
			size: iY,
		},
		j1t = { isLoading: !1 },
		F1t = function (t, n, r) {
			return H.createElement(yY, zn({}, n, { labelKey: r.labelKey, options: t, text: r.text }))
		},
		B1t = function (t, n, r) {
			return H.createElement(
				p1t,
				{ disabled: n.disabled, key: r, onRemove: n.onRemove, option: t, tabIndex: n.tabIndex },
				ys(t, n.labelKey),
			)
		},
		H1t = ["align", "dropup", "flip", "positionFixed"]
	function $1t(e) {
		return w1(e, H1t)
	}
	var qA = (function (e) {
		lY(n, e)
		var t = R1t(n)
		function n() {
			var r
			oY(this, n)
			for (var i = arguments.length, a = new Array(i), o = 0; o < i; o++) a[o] = arguments[o]
			return (
				(r = t.call.apply(t, [this].concat(a))),
				st(Ut(r), "_referenceElement", null),
				st(Ut(r), "referenceElementRef", function (s) {
					r._referenceElement = s
				}),
				st(Ut(r), "_renderInput", function (s, l) {
					var u = r.props,
						d = u.isInvalid,
						p = u.isValid,
						m = u.multiple,
						v = u.renderInput,
						y = u.renderToken,
						b = u.size
					if (xa(v)) return v(s, l)
					var x = Uo(Uo({}, s), {}, { isInvalid: d, isValid: p, size: b })
					if (!m) return H.createElement(b1t, x)
					var E = l.labelKey,
						T = l.onRemove,
						C = l.selected
					return H.createElement(
						g1t,
						zn({}, x, { placeholder: C.length ? "" : s.placeholder, selected: C }),
						C.map(function (D, O) {
							return (y || B1t)(D, Uo(Uo({}, x), {}, { labelKey: E, onRemove: T }), O)
						}),
					)
				}),
				st(Ut(r), "_renderMenu", function (s, l, u) {
					var d = r.props,
						p = d.emptyLabel,
						m = d.id,
						v = d.maxHeight,
						y = d.newSelectionPrefix,
						b = d.paginationText,
						x = d.renderMenu,
						E = d.renderMenuItemChildren
					return (
						x || F1t
					)(s, Uo(Uo({}, l), {}, { emptyLabel: p, id: m, maxHeight: v, newSelectionPrefix: y, paginationText: b, renderMenuItemChildren: E }), u)
				}),
				st(Ut(r), "_renderAux", function (s) {
					var l = s.onClear,
						u = s.selected,
						d = r.props,
						p = d.clearButton,
						m = d.disabled,
						v = d.isLoading,
						y = d.size,
						b
					return (
						v
							? (b = H.createElement(fY, null))
							: p &&
							  !m &&
							  u.length &&
							  (b = H.createElement(zA, { onClick: l, onMouseDown: HA, size: y })),
						b
							? H.createElement("div", { className: Fe("rbt-aux", { "rbt-aux-lg": $A(y) }) }, b)
							: null
					)
				}),
				r
			)
		}
		return (
			sY(n, [
				{
					key: "render",
					value: function () {
						var i = this,
							a = this.props,
							o = a.children,
							s = a.className,
							l = a.instanceRef,
							u = a.open,
							d = a.options,
							p = a.style
						return H.createElement(UA, zn({}, this.props, { options: d, ref: l }), function (m) {
							var v = m.hideMenu,
								y = m.isMenuShown,
								b = m.results,
								x = i._renderAux(m)
							return H.createElement(a1t, { disabled: u || !y, onRootClose: v }, function (E) {
								return H.createElement(
									"div",
									{
										className: Fe(
											"rbt",
											{
												"has-aux": !!x,
												"is-invalid": i.props.isInvalid,
												"is-valid": i.props.isValid,
											},
											s,
										),
										ref: E,
										style: Uo(Uo({}, p), {}, { outline: "none", position: "relative" }),
										tabIndex: -1,
									},
									i._renderInput(
										Uo(
											Uo({}, m.getInputProps(i.props.inputProps)),
											{},
											{ referenceElementRef: i.referenceElementRef },
										),
										m,
									),
									H.createElement(
										pY,
										zn({}, $1t(i.props), { isMenuShown: y, referenceElement: i._referenceElement }),
										function (T) {
											return i._renderMenu(b, T, m)
										},
									),
									x,
									xa(o) ? o(m) : o,
								)
							})
						})
					},
				},
			]),
			n
		)
	})(H.Component)
	st(qA, "propTypes", P1t)
	st(qA, "defaultProps", j1t)
	const VA = _.forwardRef(function (e, t) {
			return H.createElement(qA, zn({}, e, { instanceRef: t }))
		}),
		U1t = (e, t) => {
			switch (t.type) {
				case "GET_TAGS_INIT":
					return { ...e, isLoading: !0, isError: !1 }
				case "GET_TAGS_SUCCESS":
					return { ...e, isLoading: !1, isError: !1, data: t.payload }
				case "GET_TAGS_FAILURE":
					return { ...e, isLoading: !1, isError: !0 }
				default:
					throw new Error()
			}
		},
		z1t = (e, t) => {
			const n = lt.ApiUrl + "/tags/",
				[r, i] = _.useState(e),
				[a, o] = _.useReducer(U1t, { isLoading: !1, isError: !1, data: t })
			return (
				_.useEffect(() => {
					let s = !1
					return (
						(async () => {
							if (r) {
								o({ type: "GET_TAGS_INIT" })
								try {
									console.log("searching for " + r)
									const u = await vx(n + "?pattern=" + r)
									s || o({ type: "GET_TAGS_SUCCESS", payload: u.data })
								} catch {
									s || o({ type: "GET_TAGS_FAILURE" })
								}
							}
						})(),
						() => {
							s = !0
						}
					)
				}, [n, r]),
				[a, i]
			)
		},
		Eg = _.forwardRef(
			(
				{
					bsPrefix: e,
					bg: t = "primary",
					pill: n = !1,
					text: r,
					className: i,
					as: a = "span",
					...o
				},
				s,
			) => {
				const l = nt(e, "badge")
				return h.jsx(a, {
					ref: s,
					...o,
					className: Fe(i, l, n && "rounded-pill", r && `text-${r}`, t && `bg-${t}`),
				})
			},
		)
	Eg.displayName = "Badge"
	const bY = Ft.a`
    color: white;
    cursor: pointer;
`
	bY.displayName = "TagRemover"
	const q1t = (e) => {
			const { tag: t } = e
			return h.jsxs(Eg, {
				text: "info",
				children: [
					t.name,
					" ",
					h.jsx(bY, { onClick: () => e.RemoveTag(t), children: h.jsx(m7, { size: 16 }) }),
				],
			})
		},
		xY = Ft.ul`
    margin: 0;
    padding: 0;
    list-style-type: none;
    li {
        display: inline;
        padding-right: 5px;
    }
`
	xY.displayName = "TagContainer"
	const V1t = (e) => {
			const { tags: t } = e
			return h.jsx(xY, {
				className: "mb-2 mt-1",
				children:
					t &&
					t.map((n) =>
						h.jsx(
							"li",
							{ children: h.jsx(q1t, { tag: n, RemoveTag: () => e.RemoveTag(n) }) },
							n.id,
						),
					),
			})
		},
		WA = (e) => {
			const [{ isLoading: t, isError: n, data: r }] = z1t("", []),
				[i, a] = _.useState(e.selectedTags),
				o = _.useRef(),
				s = (l) => {
					const u = i.findIndex((d) => d.id === l.id)
					if (u >= 0) {
						const d = i.slice(0)
						d.splice(u, 1), a(d), e.OnChange(d)
					}
				}
			return h.jsxs("div", {
				children: [
					h.jsx(VA, {
						id: "tag-picker",
						ref: o,
						labelKey: "name",
						placeholder: "Tags...",
						isLoading: t,
						filterBy: ["name"],
						minLength: 3,
						allowNew: !0,
						onChange: (l) => {
							var d
							i.push(l[0])
							const u = i.slice(0)
							a(u), e.OnChange(u), (d = o.current) == null || d.clear()
						},
						options: r,
					}),
					h.jsx(V1t, { tags: i, RemoveTag: s }),
					n && h.jsx("span", { className: "text-danger", children: "Doh!" }),
				],
			})
		},
		W1t = Bt({ year: gi().required(), title: Oe().required(), documentType: Oe().required() }),
		YA = (e) => {
			const { document: t, file: n, onClose: r } = e,
				[i, a] = _.useState(!1),
				{ data: o } = BA(),
				[s, { isLoading: l }] = Tgt(),
				[u, { isLoading: d }] = kgt(),
				[p, { isLoading: m }] = Sgt(),
				v = l || d || m,
				y = {
					id: (t == null ? void 0 : t.id) || 0,
					year: t == null ? void 0 : t.year,
					title: t == null ? void 0 : t.title,
					documentType: t == null ? void 0 : t.documentType,
					tournamentId: t == null ? void 0 : t.tournament,
					tags: t == null ? void 0 : t.tags,
					file: n,
				},
				b = () => {
					a(!1)
				},
				x = async () => {
					a(!1),
						await p(t.id)
							.unwrap()
							.then(() => {
								je.success(`${t.title} has been deleted.`), r()
							})
							.catch((T) => {
								je.error(" " + T)
							})
				},
				E = async (T) => {
					const C = new zu(T)
					;(C.id = y.id),
						(C.tournament = T.tournamentId || (t == null ? void 0 : t.tournament)),
						(C.documentType = T.documentType),
						(C.tags = T.tags)
					const D = { document: C.prepJson(), file: T.file }
					await (t.id ? u(D) : s(D))
						.unwrap()
						.then(() => {
							je.success(`${C.title} has been saved.`), r()
						})
						.catch((A) => {
							je.error(" " + A)
						})
				}
			return h.jsxs(ht, {
				loading: v,
				children: [
					h.jsx(Vt, {
						validationSchema: W1t,
						onSubmit: E,
						initialValues: y,
						children: ({
							handleSubmit: T,
							handleChange: C,
							handleBlur: D,
							values: O,
							touched: A,
							errors: N,
						}) => {
							var I, P
							return h.jsxs(R, {
								noValidate: !0,
								onSubmit: T,
								children: [
									h.jsxs(R.Group, {
										controlId: "doc.Year",
										children: [
											h.jsx(R.Label, { children: "Year" }),
											h.jsx(R.Control, {
												placeholder: "Year",
												name: "year",
												value: (I = O.year) == null ? void 0 : I.toString(),
												isValid: A.year && !N.year,
												isInvalid: !!N.year,
												onChange: C,
												onBlur: D,
											}),
											h.jsx(R.Control.Feedback, { type: "invalid", children: N.year }),
										],
									}),
									h.jsxs(R.Group, {
										controlId: "doc.Title",
										children: [
											h.jsx(R.Label, { children: "Title" }),
											h.jsx(R.Control, {
												placeholder: "Document title",
												name: "title",
												value: O.title,
												isValid: A.title && !N.title,
												isInvalid: !!N.title,
												onChange: C,
												onBlur: D,
											}),
											h.jsx(R.Control.Feedback, { type: "invalid", children: N.title }),
										],
									}),
									h.jsxs(R.Group, {
										controlId: "doc.DocumentType",
										children: [
											h.jsx(R.Label, { children: "Document type" }),
											h.jsxs(R.Control, {
												as: "select",
												name: "documentType",
												value: O.documentType,
												isValid: A.documentType && !N.documentType,
												isInvalid: !!N.documentType,
												onChange: C,
												onBlur: D,
												children: [
													h.jsx("option", { value: "" }),
													h.jsx("option", { value: "Agenda", children: "Agenda" }),
													h.jsx("option", { value: "ByLaws", children: "ByLaws" }),
													h.jsx("option", {
														value: "Club Registration",
														children: "Club Registration",
													}),
													h.jsx("option", { value: "Financial", children: "Financial" }),
													h.jsx("option", { value: "Hard Card", children: "Hard Card" }),
													h.jsx("option", { value: "Match Play", children: "Match Play" }),
													h.jsx("option", {
														value: "Match Play Brackets",
														children: "Match Play Brackets",
													}),
													h.jsx("option", { value: "Minutes", children: "Minutes" }),
													h.jsx("option", { value: "Other", children: "Other" }),
													h.jsx("option", { value: "Registration", children: "Registration" }),
													h.jsx("option", { value: "Results", children: "Results" }),
													h.jsx("option", {
														value: "Standing Orders",
														children: "Standing Orders",
													}),
													h.jsx("option", { value: "Tee Times", children: "Tee Times" }),
												],
											}),
										],
									}),
									h.jsxs(R.Group, {
										children: [
											h.jsx(R.Label, { children: "Tournament" }),
											h.jsxs(R.Control, {
												as: "select",
												name: "tournamentId",
												value: (P = O.tournamentId) == null ? void 0 : P.toString(),
												isValid: A.tournamentId && !N.tournamentId,
												isInvalid: !!N.tournamentId,
												onChange: C,
												onBlur: D,
												children: [
													h.jsx("option", { value: void 0 }, 0),
													o == null
														? void 0
														: o.map((L) =>
																h.jsx("option", { value: L.id, children: L.name }, L.id),
														  ),
												],
											}),
										],
									}),
									h.jsx(KW, { onDrop: (L) => (O.file = L[0]), onSelected: (L) => (O.file = L[0]) }),
									h.jsx(WA, { selectedTags: O.tags || [], OnChange: (L) => (O.tags = L) }),
									h.jsx(lr, {}),
									h.jsx(jd, { canDelete: y.id !== 0, OnDelete: () => a(!0) }),
									h.jsx(br, { canCancel: !0, OnCancel: r }),
								],
							})
						},
					}),
					h.jsx(Pd, {
						show: i,
						titleText: "Delete Document?",
						messageText: "Please confirm that we should delete this document.",
						confirmText: "Delete",
						DoCancel: b,
						DoConfirm: x,
					}),
				],
			})
		}
	var Ou = ((e) => (
		(e[(e.Link = 0)] = "Link"),
		(e[(e.Button = 1)] = "Button"),
		(e[(e.Detail = 2)] = "Detail"),
		(e[(e.Icon = 3)] = "Icon"),
		e
	))(Ou || {})
	const Y1t = (e) => {
			const { document: t, render: n } = e
			return (() => {
				var i
				switch (n.viewType) {
					case Ou.Link:
						return h.jsx("a", {
							href: t.file,
							className: n.className || "",
							target: n.external ? "_blank" : "_self",
							rel: "noreferrer",
							children: t.title,
						})
					case Ou.Button:
						return h.jsx(Ge, {
							as: "a",
							href: t.file,
							target: n.external ? "_blank" : "_self",
							size: "sm",
							variant: n.variant || "light",
							children: t.title,
						})
					case Ou.Detail:
						return h.jsxs("p", {
							children: [
								h.jsx("a", {
									href: t.file,
									className: n.className || "",
									target: n.external ? "_blank" : "_self",
									rel: "noreferrer",
									children: t.title,
								}),
								h.jsx("span", { children: t.year }),
								h.jsx("span", { children: (i = t.lastUpdate) == null ? void 0 : i.toDateString() }),
								h.jsx("span", { children: "TODO: derive type" }),
							],
						})
					default:
						return h.jsx(h.Fragment, {})
				}
			})()
		},
		p5 = (e) => {
			const t = Wt(),
				{ document: n, edit: r, render: i } = e,
				a = _.useRef(),
				o = () => {
					a.current.close()
				}
			return h.jsx(Wr, {
				ref: a,
				initEdit: r,
				canEdit: t.canEditDocuments(),
				viewComponent: h.jsx(Y1t, { document: n, render: i }),
				editComponent: h.jsx(YA, { document: n, onClose: o }),
			})
		},
		Mw = (e) => {
			const { documents: t, render: n } = e,
				[r, i] = _.useState(!1),
				a = Wt(),
				o = (t == null ? void 0 : t.findIndex((s) => s.id === 0)) || !0
			return h.jsxs("div", {
				children: [
					a.canEditDocuments() &&
						h.jsx(Ge, {
							variant: "link",
							className: "text-warning",
							disabled: !o,
							onClick: () => i(!0),
							children: "Add New",
						}),
					r &&
						h.jsx(
							p5,
							{
								document: new zu({ id: 0, year: lt.EventCalendarYear }),
								render: n,
								edit: !0,
								onClose: () => i(!1),
							},
							0,
						),
					t == null
						? void 0
						: t.map((s) =>
								h.jsx(p5, { document: new zu(s), render: n, edit: !1, onClose: () => i(!1) }, s.id),
						  ),
				],
			})
		},
		Iw = (e) => {
			const { query: t } = e,
				{ data: n, isLoading: r } = sh(t),
				i = { viewType: Ou.Button, variant: "secondary", external: !0 }
			return h.jsx(ht, {
				loading: r,
				children: h.jsx(Mw, { documents: (n == null ? void 0 : n.slice(0, 1)) || [], render: i }),
			})
		},
		G1t = () => {
			const e = { key: "bylaws", documentTypes: ["ByLaws"] }
			return h.jsx(ii, {
				fluid: !0,
				children: h.jsxs(ug, {
					children: [
						h.jsx("h1", { className: "text-secondary", children: "About Us" }),
						h.jsx(Rl, { pageCode: Rn.OurMission }),
						h.jsx("h3", { className: "text-primary", children: "By Laws" }),
						h.jsx(Iw, { query: e }),
					],
				}),
			})
		},
		GA = (e) =>
			h.jsxs(ln, {
				children: [
					h.jsx(it, { lg: !0, children: e.Column1 }),
					h.jsx(it, { lg: !0, children: e.Column2 }),
					h.jsx(it, { lg: !0, children: e.Column3 }),
				],
			})
	class wY extends _n {
		constructor(n) {
			super()
			q(this, "year", 0)
			q(this, "winner", "")
			q(this, "notes", "")
			if (n) {
				const r = super.fromJson(n)
				Object.assign(this, r)
			}
		}
	}
	class K1t extends _n {
		constructor(n) {
			super()
			q(this, "name", "")
			q(this, "description", "")
			q(this, "winners", [])
			q(this, "winnerList")
			if (n) {
				const r = super.fromJson(n)
				n.winners && (r.winners = n.winners.map((i) => new wY(i))), Object.assign(this, r)
			}
		}
	}
	class Au extends _n {
		constructor(n) {
			super()
			q(this, "tournament", 0)
			q(this, "year", 0)
			q(this, "location", "")
			q(this, "winner", "")
			q(this, "winnerClub", "")
			q(this, "coWinner")
			q(this, "coWinnerClub")
			q(this, "flightOrDivision", "")
			q(this, "score", "")
			q(this, "isNet", !1)
			q(this, "isMatch", !1)
			q(this, "notes")
			const r = this.fromJson(n)
			Object.assign(this, r)
		}
		get scoreFormatted() {
			return this.isNet ? this.score + "*" : this.score
		}
		get winnersFormatted() {
			return this.isMatch
				? `${this.winner} defeated ${this.coWinner}`
				: this.coWinner
				? `${this.winner} (${this.winnerClub}) / ${this.coWinner} (${this.coWinnerClub})`
				: `${this.winner} (${this.winnerClub})`
		}
	}
	class Mp extends _n {
		constructor(n) {
			super()
			q(this, "name", "")
			q(this, "systemName", "")
			q(this, "description", "")
			q(this, "winners", [])
			if (n) {
				const r = this.fromJson(n)
				n && n.winners && (r.winners = n.winners.map((i) => new Au(i))), Object.assign(this, r)
			}
		}
	}
	class Q1t extends _n {
		constructor() {
			super(...arguments)
			q(this, "chair")
		}
		fromJson(n) {
			const r = super.fromJson(n)
			return (r.chair = new ha(n.chair)), r
		}
	}
	class EY extends _n {
		constructor(n) {
			super()
			q(this, "event", 0)
			q(this, "place", 0)
			q(this, "points", 0)
			q(this, "ordinalPlace")
			if (n !== void 0) {
				const r = super.fromJson(n)
				Object.assign(this, r)
			}
		}
	}
	class X1t extends _n {
		constructor(n) {
			super()
			q(this, "event", 0)
			q(this, "policy")
			q(this, "order")
			if (n !== void 0) {
				const r = super.fromJson(n)
				;(r.policy = new g2(n.policy)), Object.assign(this, r)
			}
		}
	}
	class CY extends _n {
		constructor(n) {
			super()
			q(this, "event", 0)
			q(this, "linkType", "")
			q(this, "title", "")
			q(this, "url", "")
			const r = super.fromJson(n)
			Object.assign(this, r)
		}
	}
	class Ip extends _n {
		constructor(n) {
			super()
			q(this, "location")
			q(this, "tournament")
			q(this, "name", "")
			q(this, "description", "")
			q(this, "rounds", 0)
			q(this, "notes")
			q(this, "eventType", "")
			q(this, "startDate", new Date())
			q(this, "registrationStart", new Date())
			q(this, "registrationEnd", new Date())
			q(this, "earlyRegistrationEnd", new Date())
			q(this, "policies")
			q(this, "chairs")
			q(this, "playerPoints")
			q(this, "links")
			q(this, "eventDates", "")
			if (n) {
				const r = super.fromJson(n)
				r.startDate &&
					((r.location = new f9(n.location)),
					(r.tournament = new Mp(n.tournament)),
					n.policies && (r.policies = n.policies.map((i) => new X1t(i))),
					n.chairs && (r.chairs = n.chairs.map((i) => new Q1t().fromJson(i))),
					n.player_points && (r.playerPoints = n.player_points.map((i) => new EY(i))),
					n.links && (r.links = n.links.map((i) => new CY(i))),
					r.rounds === 1
						? (r.eventDates = Te(r.startDate).format("dddd, MMM D"))
						: (r.eventDates = `${Te(r.startDate).format("dddd, MMM D")} - ${Te(r.startDate)
								.add(1, "d")
								.format("dddd, MMM D")}`)),
					Object.assign(this, r)
			}
		}
		static CreateDefault() {
			const n = new Ip({ id: 0, name: "loading...", description: "loading..." })
			return (n.tournament = new Mp({ id: 0, system_name: "loading...", winners: [] })), n
		}
		get eventYear() {
			return Te(this.startDate).year()
		}
		get mostRecentYear() {
			const n = this.eventYear,
				r = Te().year(),
				i = Te(this.startDate)
			return n === r
				? i.isAfter(Te())
					? this.eventYear - 1
					: this.eventYear
				: n < r
				? this.eventYear
				: this.eventYear - 1
		}
		get canRegister() {
			return Te(this.registrationStart).isBefore(Te()) && Te(this.registrationEnd).isAfter(Te())
		}
		get registrationIsPending() {
			return Te(this.registrationStart).isAfter(Te())
		}
		get registrationIsClosed() {
			return Te(this.registrationEnd).clone().add(1, "d").isBefore(Te())
		}
	}
	const J1t = Ui.injectEndpoints({
			endpoints: (e) => ({
				getAwards: e.query({
					query: () => ({ url: "/awards/", method: "GET" }),
					providesTags: ["Awards"],
				}),
				getAward: e.query({
					query: (t) => ({ url: `/awards/${t}/`, method: "GET" }),
					providesTags: (t, n, r) => [{ type: "Awards", id: r }],
				}),
				updateAward: e.mutation({
					query(t) {
						const { id: n } = t
						return { url: `/awards/${n}/`, method: "PUT", data: t }
					},
					invalidatesTags: (t, n, { id: r }) => [{ type: "Awards", id: r }],
				}),
				addWinner: e.mutation({
					query(t) {
						return { url: "/award-winners/", method: "POST", data: t }
					},
					invalidatesTags: (t, n, { award: r }) => [{ type: "Awards", id: r }],
				}),
				updateWinner: e.mutation({
					query(t) {
						const { id: n } = t
						return { url: `/award-winners/${n}/`, method: "PUT", data: t }
					},
					invalidatesTags: (t, n, { award: r }) => [{ type: "Awards", id: r }],
				}),
			}),
		}),
		{
			useGetAwardQuery: Z1t,
			useGetAwardsQuery: ebt,
			useAddWinnerMutation: tbt,
			useUpdateAwardMutation: nbt,
			useUpdateWinnerMutation: rbt,
		} = J1t,
		ibt = Bt({ description: Oe().required() }),
		abt = (e) => {
			const { award: t, onClose: n } = e,
				[r, { isLoading: i }] = nbt(),
				a = async (o) => {
					await r(o.prepJson())
						.unwrap()
						.then(() => {
							je.success(`Changes to ${o.name} have been saved.`), n()
						})
						.catch((s) => {
							je.error(" " + s)
						})
				}
			return h.jsx(ht, {
				loading: i,
				children: h.jsx(Vt, {
					validationSchema: ibt,
					onSubmit: a,
					initialValues: t,
					children: ({ handleSubmit: o, values: s }) =>
						h.jsxs(R, {
							noValidate: !0,
							onSubmit: o,
							children: [
								h.jsxs(R.Group, {
									controlId: "awardDescription",
									children: [
										h.jsx(R.Label, { children: "Description" }),
										h.jsx(_s, { name: "description", value: s.description, height: "300px" }),
									],
								}),
								h.jsx(lr, {}),
								h.jsx(br, { canCancel: !0, OnCancel: n }),
							],
						}),
				}),
			})
		},
		obt = Bt({ year: gi().required(), winner: Oe().max(100).required(), notes: Oe() }),
		sbt = (e) => {
			const { winner: t, onClose: n } = e,
				[r, { isLoading: i }] = rbt(),
				[a, { isLoading: o }] = tbt(),
				s = async (l) => {
					const u = l.prepJson()
					await (l.id > 0 ? r(u) : a(u))
						.unwrap()
						.then(() => {
							je.success(`${l.winner} has been saved.`), n()
						})
						.catch((p) => {
							je.error(" " + p)
						})
				}
			return h.jsx(ht, {
				loading: o || i,
				children: h.jsx(Vt, {
					validationSchema: obt,
					onSubmit: s,
					initialValues: t,
					children: ({
						handleSubmit: l,
						handleChange: u,
						handleBlur: d,
						values: p,
						touched: m,
						errors: v,
					}) =>
						h.jsxs(R, {
							noValidate: !0,
							onSubmit: l,
							children: [
								h.jsxs(R.Group, {
									controlId: "winner.year",
									children: [
										h.jsx(R.Label, { children: "Year" }),
										h.jsx(R.Control, {
											name: "year",
											placeholder: "Year",
											value: p.year.toString(),
											isValid: m.year && !v.year,
											isInvalid: !!v.year,
											onChange: u,
											onBlur: d,
										}),
										h.jsx(R.Control.Feedback, { type: "invalid", children: v.year }),
									],
								}),
								h.jsxs(R.Group, {
									controlId: "winner.winner",
									children: [
										h.jsx(R.Label, { children: "Winner" }),
										h.jsx(R.Control, {
											name: "winner",
											placeholder: "Winner",
											value: p.winner,
											isValid: m.winner && !v.winner,
											isInvalid: !!v.winner,
											onChange: u,
											onBlur: d,
										}),
										h.jsx(R.Control.Feedback, { type: "invalid", children: v.winner }),
									],
								}),
								h.jsxs(R.Group, {
									controlId: "winner.notes",
									children: [
										h.jsx(R.Label, { children: "Notes" }),
										h.jsx(_s, { name: "notes", value: p.notes, height: "200px" }),
									],
								}),
								h.jsx(lr, {}),
								h.jsx(br, { canCancel: !0, OnCancel: n }),
							],
						}),
				}),
			})
		},
		lbt = Ft.div`
  background-color: #fff;
`,
		Rw = (e) => h.jsx(lbt, { children: h.jsx(tc, { text: e.children }) }),
		ubt = (e) => {
			const { winner: t } = e,
				[n, r] = _.useState(!1)
			return h.jsxs(H.Fragment, {
				children: [
					h.jsxs(ln, {
						children: [
							h.jsx(it, { xs: "3", children: t.year }),
							h.jsx(it, { xs: "8", children: t.winner }),
							h.jsx(it, {
								xs: "1",
								className: "clickable text-secondary",
								onClick: () => r(!n),
								children: t.notes && h.jsx(mO, { size: 18, color: "primary" }),
							}),
						],
					}),
					t.notes &&
						n &&
						h.jsx(ln, { children: h.jsx(it, { children: h.jsx(Rw, { children: t.notes }) }) }),
				],
			})
		},
		h5 = (e) => {
			const { edit: t, winner: n, onClose: r } = e,
				i = Wt(),
				a = _.useRef(),
				o = () => {
					a.current.close(), r()
				}
			return h.jsx(Wr, {
				ref: a,
				onClose: r,
				initEdit: t,
				canEdit: i.canEditAwards(),
				viewComponent: h.jsx(ubt, { winner: n }),
				editComponent: h.jsx(sbt, { winner: n, onClose: o }),
			})
		},
		cbt = (e) => {
			const { award: t } = e,
				[n, r] = H.useState(!1),
				i = Wt()
			return h.jsxs("div", {
				children: [
					i.canEditAwards() &&
						h.jsx(Ge, {
							variant: "link",
							className: "text-warning",
							onClick: () => r(!0),
							children: "Add New",
						}),
					n &&
						h.jsx(
							h5,
							{ edit: !0, winner: new wY({ id: 0, award: t.id }), award: t, onClose: () => r(!1) },
							0,
						),
					t.winners.map((a) =>
						h.jsx(h5, { edit: !1, winner: a, award: t, onClose: () => r(!1) }, a.id),
					),
				],
			})
		},
		dbt = (e) => {
			const { award: t } = e
			return h.jsxs("div", {
				children: [
					h.jsx("h3", { className: "text-primary", children: t.name }),
					h.jsx(tc, { text: t.description }),
					h.jsx(cbt, { award: t }),
				],
			})
		},
		fS = (e) => {
			const { awardId: t } = e,
				{ data: n, isLoading: r } = Z1t(t || ho),
				i = Wt(),
				a = _.useRef(),
				o = new K1t(n),
				s = () => {
					a.current.close()
				}
			return h.jsx(ht, {
				loading: r,
				children: h.jsx(Wr, {
					ref: a,
					initEdit: !1,
					canEdit: i.canEditPageContent(),
					viewComponent: h.jsx(dbt, { award: o }),
					editComponent: h.jsx(abt, { award: o, onClose: s }),
				}),
			})
		},
		fbt = () => {
			var n
			const e = ebt(),
				t = {}
			return (
				(n = e.data) == null ||
					n.forEach((r) => {
						t[r.name] = r.id
					}),
				{ awards: e, awardMap: t }
			)
		},
		pbt = () => {
			const { awardMap: e, awards: t } = fbt(),
				{ isSuccess: n } = t
			return h.jsx(ii, {
				fluid: !0,
				children:
					n &&
					h.jsx(GA, {
						Column1: h.jsx(fS, { awardId: e["Ron Self Award"] }),
						Column2: h.jsx(fS, { awardId: e["Clasen Cup"] }),
						Column3: h.jsx(fS, { awardId: e["Al Wareham Memorial"] }),
					}),
			})
		},
		hbt = () =>
			h.jsx(ii, {
				fluid: !0,
				children: h.jsx(ug, {
					children: h.jsx(h.Fragment, { children: h.jsx(Rl, { pageCode: Rn.CodeOfConduct }) }),
				}),
			}),
		mbt = () => {
			const e = { key: "past-presidents", documentTypes: ["Past Presidents"] }
			return h.jsxs("div", {
				children: [h.jsx(Rl, { pageCode: Rn.PastPresidents }), h.jsx(Iw, { query: e })],
			})
		},
		vbt = (e, t) => {
			switch (t.type) {
				case "GET_CONTACTS_INIT":
					return { ...e, isLoading: !0, isError: !1 }
				case "GET_CONTACTS_SUCCESS":
					const n = t.payload.map((r) => new ha(r))
					return { ...e, isLoading: !1, isError: !1, data: n }
				case "GET_CONTACTS_FAILURE":
					return { ...e, isLoading: !1, isError: !0 }
				default:
					throw new Error("That's not right!")
			}
		},
		gbt = (e, t) => {
			const n = lt.ApiUrl + "/contacts/",
				[r, i] = _.useState(e),
				[a, o] = _.useReducer(vbt, { isLoading: !1, isError: !1, data: t })
			return (
				_.useEffect(() => {
					let s = !1
					return (
						(async () => {
							if (r) {
								o({ type: "GET_CONTACTS_INIT" })
								try {
									console.log("searching for " + r)
									const u = await ws.get(n + "?pattern=" + r)
									s || o({ type: "GET_CONTACTS_SUCCESS", payload: u.data })
								} catch {
									s || o({ type: "GET_CONTACTS_FAILURE" })
								}
							}
						})(),
						() => {
							s = !0
						}
					)
				}, [n, r]),
				[a, i]
			)
		},
		TY = (e) => {
			const [{ isLoading: t, isError: n, data: r }, i] = gbt("", []),
				a = _.useRef(),
				o =
					(r == null
						? void 0
						: r.map((l) => ({ id: l.id, label: l.name, name: l.name, email: l.email }))) ?? [],
				s = (l) => {
					var u
					if (r && l) {
						const d = r.find((p) => p.id === l.id)
						d && ((u = a.current) == null || u.clear(), e.OnSelect(d))
					}
				}
			return h.jsxs("div", {
				className: "mb-3",
				children: [
					h.jsx("p", {
						children: `First search for a contact already in our database. If you don't find one, select "Create new contact".`,
					}),
					h.jsx(VA, {
						id: "contact-search",
						ref: a,
						filterBy: ["name", "email"],
						placeholder: "Search for contact...",
						isLoading: t,
						minLength: 3,
						renderMenuItemChildren: (l, u) =>
							h.jsxs(h.Fragment, {
								children: [
									h.jsx(Nw, { search: u.text, children: l.name }, "name"),
									h.jsx(
										"div",
										{ children: h.jsxs("small", { children: ["Email: ", l.email] }) },
										"email",
									),
								],
							}),
						highlightOnlyResult: !e.allowNew,
						newSelectionPrefix: "Create new contact: ",
						allowNew: e.allowNew,
						onChange: (l) => s(l[0]),
						options: o,
					}),
					n && h.jsx("span", { className: "text-danger", children: "Doh!" }),
				],
			})
		},
		ybt = Ui.injectEndpoints({
			endpoints: (e) => ({
				getCommittee: e.query({
					query: () => ({ url: "/committee/", method: "GET" }),
					providesTags: (t) =>
						t
							? [
									...t.map(({ id: n }) => ({ type: "Committee", id: n })),
									{ type: "Committee", id: "LIST" },
							  ]
							: [{ type: "Committee", id: "LIST" }],
				}),
				updateCommittee: e.mutation({
					query(t) {
						const { id: n } = t
						return { url: `/committee/${n}/`, method: "PUT", data: t }
					},
					invalidatesTags: (t, n, { id: r }) => [{ type: "Committee", id: r }],
				}),
				addCommittee: e.mutation({
					query(t) {
						return { url: "/committee/", method: "POST", data: t }
					},
					invalidatesTags: (t, n, { id: r }) => [{ type: "Committee", id: r }],
				}),
				deleteCommittee: e.mutation({
					query(t) {
						const { id: n } = t
						return { url: `/committee/${n}/`, method: "DELETE" }
					},
				}),
			}),
		}),
		{
			useAddCommitteeMutation: bbt,
			useDeleteCommitteeMutation: xbt,
			useGetCommitteeQuery: wbt,
			useUpdateCommitteeMutation: Ebt,
		} = ybt,
		Cbt = Bt({
			firstName: Oe().required(),
			lastName: Oe().required(),
			email: Oe().email().required(),
			primaryPhone: Oe().required(),
			addressTxt: Oe().nullable(),
			city: Oe().nullable(),
			state: Oe().nullable(),
			zip: Oe().nullable(),
			role: Oe().required(),
			homeClub: gi().required(),
		}),
		Tbt = (e) => {
			const t = e.contact || new ha({})
			return {
				firstName: t.firstName,
				lastName: t.lastName,
				primaryPhone: t.primaryPhone,
				alternatePhone: t.alternatePhone,
				email: t.email,
				addressTxt: t.addressTxt,
				city: t.city,
				state: t.state,
				zip: t.zip,
				notes: t.notes,
				role: e.role,
				homeClub: e.homeClub,
			}
		},
		kbt = (e) => {
			const { committeeMember: t, onClose: n } = e,
				{ data: r, isLoading: i } = Kp(),
				[a, { isLoading: o }] = bbt(),
				[s, { isLoading: l }] = Ebt(),
				[u, { isLoading: d }] = xbt(),
				p = Tbt(t),
				[m, v] = _.useState(!1),
				y = i || o || l || d,
				b = () => {
					v(!1)
				},
				x = async () => {
					v(!1)
					const T = t.prepJson()
					await u(T)
						.unwrap()
						.then(() => {
							je.success(`${t.contact.name} has been removed.`), n()
						})
						.catch((C) => {
							je.error(" " + C)
						})
				},
				E = async (T, C) => {
					const D = dv.Create(C)
					D.id = T
					const O = D.toJson()
					await (O.id > 0 ? s(O) : a(O))
						.unwrap()
						.then(() => {
							je.success(`${C.firstName} ${C.lastName} has been saved.`), n()
						})
						.catch((N) => {
							je.error(" " + N)
						})
				}
			return h.jsxs(ht, {
				loading: y,
				children: [
					h.jsx(Vt, {
						validationSchema: Cbt,
						onSubmit: (T, C) => {
							C.setSubmitting(!1), E(t.id || 0, T)
						},
						initialValues: p,
						children: ({
							handleSubmit: T,
							handleChange: C,
							handleBlur: D,
							values: O,
							touched: A,
							errors: N,
							isSubmitting: I,
						}) => {
							var P
							return h.jsxs(R, {
								noValidate: !0,
								onSubmit: T,
								children: [
									h.jsxs(R.Group, {
										controlId: "ec.firstName",
										children: [
											h.jsx(R.Label, { children: "First name" }),
											h.jsx(R.Control, {
												placeholder: "First name",
												name: "firstName",
												value: O.firstName,
												isValid: A.firstName && !N.firstName,
												isInvalid: !!N.firstName,
												onChange: C,
												onBlur: D,
											}),
											h.jsx(R.Control.Feedback, { type: "invalid", children: N.firstName }),
										],
									}),
									h.jsxs(R.Group, {
										controlId: "ec.lastName",
										children: [
											h.jsx(R.Label, { children: "Last name" }),
											h.jsx(R.Control, {
												placeholder: "Last name",
												name: "lastName",
												value: O.lastName,
												isValid: A.lastName && !N.lastName,
												isInvalid: !!N.lastName,
												onChange: C,
												onBlur: D,
											}),
											h.jsx(R.Control.Feedback, { type: "invalid", children: N.lastName }),
										],
									}),
									h.jsxs(R.Group, {
										controlId: "ec.email",
										children: [
											h.jsx(R.Label, { children: "Email" }),
											h.jsx(R.Control, {
												placeholder: "Email",
												name: "email",
												value: O.email,
												isValid: A.email && !N.email,
												isInvalid: !!N.email,
												onChange: C,
												onBlur: D,
											}),
											h.jsx(R.Control.Feedback, { type: "invalid", children: N.email }),
										],
									}),
									h.jsxs(R.Group, {
										controlId: "ec.primaryPhone",
										children: [
											h.jsx(R.Label, { children: "Primary phone" }),
											h.jsx(R.Control, {
												placeholder: "xxx-xxx-xxxx",
												name: "primaryPhone",
												value: O.primaryPhone,
												isValid: A.primaryPhone && !N.primaryPhone,
												isInvalid: !!N.primaryPhone,
												onChange: C,
												onBlur: D,
											}),
											h.jsx(R.Control.Feedback, { type: "invalid", children: N.primaryPhone }),
											h.jsx(R.Text, { className: "text-muted", children: "Format: xxx-xxx-xxxx" }),
										],
									}),
									h.jsxs(R.Group, {
										controlId: "ec.role",
										children: [
											h.jsx(R.Label, { children: "Role" }),
											h.jsxs(R.Control, {
												as: "select",
												name: "role",
												value: O.role,
												isValid: A.role && !N.role,
												isInvalid: !!N.role,
												onChange: C,
												onBlur: D,
												children: [
													h.jsx("option", { value: void 0, children: "--Select a Role--" }),
													h.jsx("option", { value: "At Large", children: "At Large" }),
													h.jsx("option", { value: "President", children: "President" }),
													h.jsx("option", { value: "Vice President", children: "Vice President" }),
													h.jsx("option", { value: "Secretary", children: "Secretary" }),
													h.jsx("option", { value: "Treasurer", children: "Treasurer" }),
													h.jsx("option", {
														value: "MGA Public Golf Manager",
														children: "MGA Public Golf Manager",
													}),
													h.jsx("option", {
														value: "Immediate Past President",
														children: "Immediate Past President",
													}),
												],
											}),
											h.jsx(R.Control.Feedback, { type: "invalid", children: N.role }),
										],
									}),
									h.jsxs(R.Group, {
										controlId: "ec.homeClub",
										children: [
											h.jsx(R.Label, { children: "Home club" }),
											h.jsxs(R.Control, {
												as: "select",
												name: "homeClub",
												value: (P = O.homeClub) == null ? void 0 : P.toString(),
												isValid: A.homeClub && !N.homeClub,
												isInvalid: !!N.homeClub,
												onChange: C,
												onBlur: D,
												children: [
													h.jsx("option", { value: void 0, children: "--Select a Home Club--" }),
													r == null
														? void 0
														: r.map((L) =>
																h.jsx("option", { value: L.id, children: L.name }, L.id),
														  ),
												],
											}),
											h.jsx(R.Control.Feedback, { type: "invalid", children: N.homeClub }),
										],
									}),
									h.jsxs(R.Group, {
										controlId: "ec.addressTxt",
										children: [
											h.jsx(R.Label, { children: "Address" }),
											h.jsx(R.Control, {
												placeholder: "Street address",
												name: "addressTxt",
												value: O.addressTxt,
												isValid: A.addressTxt && !N.addressTxt,
												isInvalid: !!N.addressTxt,
												onChange: C,
												onBlur: D,
											}),
											h.jsx(R.Control.Feedback, { type: "invalid", children: N.addressTxt }),
										],
									}),
									h.jsxs(R.Group, {
										controlId: "ec.city",
										children: [
											h.jsx(R.Label, { children: "City" }),
											h.jsx(R.Control, {
												placeholder: "City",
												name: "city",
												value: O.city,
												isValid: A.city && !N.city,
												isInvalid: !!N.city,
												onChange: C,
												onBlur: D,
											}),
											h.jsx(R.Control.Feedback, { type: "invalid", children: N.city }),
										],
									}),
									h.jsxs(R.Group, {
										controlId: "ec.state",
										children: [
											h.jsx(R.Label, { children: "State" }),
											h.jsx(R.Control, {
												placeholder: "State",
												name: "state",
												value: O.state,
												isValid: A.state && !N.state,
												isInvalid: !!N.state,
												onChange: C,
												onBlur: D,
											}),
											h.jsx(R.Control.Feedback, { type: "invalid", children: N.state }),
											h.jsx(R.Text, {
												className: "text-muted",
												children: "Two-letter state code (MN, WI, etc.)",
											}),
										],
									}),
									h.jsxs(R.Group, {
										controlId: "ec.zip",
										children: [
											h.jsx(R.Label, { children: "Zip code" }),
											h.jsx(R.Control, {
												placeholder: "Zip code",
												name: "zip",
												value: O.zip,
												isValid: A.zip && !N.zip,
												isInvalid: !!N.zip,
												onChange: C,
												onBlur: D,
											}),
											h.jsx(R.Control.Feedback, { type: "invalid", children: N.zip }),
										],
									}),
									h.jsx(lr, {}),
									h.jsx(jd, { canDelete: t.id > 0, title: "Remove", OnDelete: () => v(!0) }),
									h.jsx(br, { canCancel: !0, OnCancel: n }),
								],
							})
						},
					}),
					h.jsx(Pd, {
						show: m,
						titleText: "Remove Committee Member?",
						messageText:
							"Please confirm that we should remove this contact from the executive committee.",
						confirmText: "Remove",
						DoCancel: b,
						DoConfirm: x,
					}),
				],
			})
		},
		kY = Ft.span`
    font-weight: 900;
    padding: 8px 12px 8px 0;
`
	kY.displayName = "InlineLabel"
	const SY = Ft.p`
    font-weight: 600;
    margin: 4px 0 4px 0;
`
	SY.displayName = "StackedLabel"
	var Fi = ((e) => ((e[(e.Inline = 0)] = "Inline"), (e[(e.Stacked = 1)] = "Stacked"), e))(Fi || {}),
		Bi = ((e) => (
			(e[(e.Text = 0)] = "Text"),
			(e[(e.ExternalLink = 1)] = "ExternalLink"),
			(e[(e.Markdown = 2)] = "Markdown"),
			(e[(e.Date = 3)] = "Date"),
			(e[(e.Address = 4)] = "Address"),
			e
		))(Bi || {})
	const la = (e) => {
			const { label: t, value: n, defaultValue: r, labelStyle: i, valueType: a } = e,
				o = () => {
					switch (a) {
						case 0:
							return h.jsx("span", { children: n || r || "n/a" })
						case 1:
							return h.jsx("a", {
								href: n,
								target: "_blank",
								rel: "noopener noreferrer",
								children: n,
							})
						case 2:
							return h.jsx(kV, { children: n })
						case 3:
							return n && Te.isDate(n)
								? h.jsx("span", { children: Te(n).format("YYYY-MM-DD") })
								: h.jsx("span", { children: r || "n/a" })
						case 4:
							return h.jsxs("div", {
								children: [
									h.jsx("p", { className: "mb-1", children: n.addressTxt }),
									h.jsxs("p", { children: [n.city, ", ", n.state, " ", n.zip] }),
								],
							})
						default:
							return h.jsx(h.Fragment, {})
					}
				}
			return h.jsxs("div", {
				children: [
					i === 0 && h.jsxs(kY, { children: [t, ":"] }),
					i === 1 && h.jsx(SY, { className: "text-primary", children: t }),
					o(),
				],
			})
		},
		Sbt = (e) => {
			var n, r
			const { committeeMember: t } = e
			return h.jsxs("div", {
				children: [
					h.jsx("h4", {
						className: "text-secondary",
						children:
							((n = t.contact) == null ? void 0 : n.firstName) +
							" " +
							((r = t.contact) == null ? void 0 : r.lastName),
					}),
					h.jsx("h5", { className: "text-muted", children: t.role }),
					h.jsx(la, {
						label: "Home Club",
						value: t.homeClubName,
						labelStyle: Fi.Inline,
						valueType: Bi.Text,
					}),
				],
			})
		},
		m5 = (e) => {
			const { committeeMember: t, edit: n } = e,
				r = Wt(),
				i = _.useRef(),
				a = () => {
					var o
					;(o = i.current) == null || o.close()
				}
			return h.jsx(Wr, {
				ref: i,
				initEdit: n,
				canEdit: r.canEditCommittee(),
				viewComponent: h.jsx(Sbt, { committeeMember: t }),
				editComponent: h.jsx(kbt, { committeeMember: t, onClose: a }),
			})
		},
		Dbt = () => {
			const [e, t] = _.useState(!1),
				[n, r] = _.useState(!1),
				[i, a] = _.useState(new ha({ id: 0 })),
				{ data: o, isLoading: s, isFetching: l } = wbt(),
				u = Wt(),
				d = (p) => {
					a(p || new ha({ id: 0 })), r(!1), t(!0)
				}
			return h.jsxs("div", {
				children: [
					h.jsx(cg, { loading: s || l }),
					h.jsxs("div", {
						children: [
							h.jsx("h3", { className: "text-primary", children: "Executive Committee Members" }),
							u.canAddCommittee() &&
								!e &&
								h.jsx(Ge, {
									variant: "link",
									className: "text-warning",
									onClick: () => r(!0),
									children: "Add New",
								}),
						],
					}),
					n && h.jsx(TY, { allowNew: !0, OnSelect: d }),
					e &&
						h.jsx(
							m5,
							{
								committeeMember: new dv({ id: 0, contact: i.prepJson() }),
								edit: !0,
								onClose: () => t(!1),
							},
							0,
						),
					o == null
						? void 0
						: o.map((p) =>
								h.jsx(m5, { committeeMember: new dv(p), edit: !1, onClose: () => t(!1) }, p.id),
						  ),
				],
			})
		},
		_bt = () =>
			h.jsx(ii, {
				fluid: !0,
				children: h.jsx(GA, {
					Column1: h.jsx(Rl, { pageCode: Rn.ExecutiveCommittee }),
					Column2: h.jsx(Dbt, {}),
					Column3: h.jsx(mbt, {}),
				}),
			})
	function KA(e) {
		return h.jsx(ln, {
			children: h.jsx(it, {
				sm: 12,
				md: { span: 10, offset: 1 },
				lg: { span: 6, offset: 3 },
				children: e.children,
			}),
		})
	}
	class jv extends _n {
		constructor(n, r) {
			super()
			q(this, "messageType", "General")
			q(this, "course", "")
			q(this, "contactName", "")
			q(this, "contactEmail", "")
			q(this, "contactPhone")
			q(this, "event")
			q(this, "message", "")
			n && ((this.messageType = n), (this.event = r))
		}
	}
	const DY = Ft.div`
	border: 1px solid silver;
	background-color: #eeeeee;
	border-radius: 4px;
	padding: 10px;
	margin: 20px 0;
`
	DY.displayName = "ContactFormContainer"
	const Obt = Bt({
			course: Oe().required(),
			contactName: Oe().required(),
			contactEmail: Oe().email().required(),
			contactPhone: Oe().nullable(),
			message: Oe().required(),
		}),
		QA = (e) => {
			const t = ki(),
				n = Up((i) => i.messaging)
			let r = e.message
			return h.jsxs(H.Fragment, {
				children: [
					h.jsx(DY, {
						children: h.jsx(Vt, {
							validationSchema: Obt,
							onSubmit: (i, a) => {
								const o = Object.assign(new jv(), e.message, i)
								t($y(o))
							},
							onReset: (i, a) => {
								a.resetForm({ values: new jv() })
							},
							initialValues: r,
							children: ({
								handleSubmit: i,
								handleReset: a,
								handleChange: o,
								handleBlur: s,
								values: l,
								touched: u,
								errors: d,
							}) =>
								h.jsxs(R, {
									noValidate: !0,
									onSubmit: i,
									onReset: a,
									children: [
										h.jsxs(R.Group, {
											controlId: "contactName",
											children: [
												h.jsx(R.Control, {
													placeholder: "Name",
													name: "contactName",
													value: l.contactName,
													isValid: u.contactName && !d.contactName,
													isInvalid: !!d.contactName,
													onChange: o,
													onBlur: s,
												}),
												h.jsx(R.Control.Feedback, { type: "invalid", children: d.contactName }),
											],
										}),
										h.jsxs(R.Group, {
											controlId: "contactEmail",
											children: [
												h.jsx(R.Control, {
													placeholder: "Email",
													name: "contactEmail",
													value: l.contactEmail,
													isValid: u.contactEmail && !d.contactEmail,
													isInvalid: !!d.contactEmail,
													onChange: o,
													onBlur: s,
												}),
												h.jsx(R.Control.Feedback, { type: "invalid", children: d.contactEmail }),
											],
										}),
										h.jsxs(R.Group, {
											controlId: "contactPhone",
											children: [
												h.jsx(R.Control, {
													placeholder: "Phone number",
													name: "contactPhone",
													value: l.contactPhone,
													isValid: u.contactPhone && !d.contactPhone,
													isInvalid: !!d.contactPhone,
													onChange: o,
													onBlur: s,
												}),
												h.jsx(R.Control.Feedback, { type: "invalid", children: d.contactPhone }),
											],
										}),
										h.jsxs(R.Group, {
											controlId: "course",
											children: [
												h.jsx(R.Control, {
													placeholder: "Home course",
													name: "course",
													value: l.course,
													isValid: u.course && !d.course,
													isInvalid: !!d.course,
													onChange: o,
													onBlur: s,
												}),
												h.jsx(R.Control.Feedback, { type: "invalid", children: d.course }),
											],
										}),
										h.jsxs(R.Group, {
											controlId: "announcement.Text",
											children: [
												h.jsx(R.Control, {
													as: "textarea",
													placeholder: "Enter your message here",
													rows: 6,
													name: "message",
													value: l.message,
													isValid: u.message && !d.message,
													isInvalid: !!d.message,
													onChange: o,
													onBlur: s,
												}),
												h.jsx(R.Control.Feedback, { type: "invalid", children: d.message }),
											],
										}),
										h.jsxs(Ge, {
											variant: "secondary",
											type: "submit",
											size: "sm",
											disabled: n.sending || n.sent !== void 0,
											children: [
												n.sending &&
													h.jsx(Qv, {
														as: "span",
														animation: "border",
														variant: "secondary",
														role: "status",
														children: h.jsx("span", {
															className: "visually-hidden",
															children: "Sending...",
														}),
													}),
												"Send",
											],
										}),
										h.jsx(Ge, {
											className: "ml-2",
											variant: "light",
											type: "reset",
											size: "sm",
											children: "Reset",
										}),
									],
								}),
						}),
					}),
					n.failed &&
						h.jsx("p", {
							className: "text-danger mt-2",
							children:
								"Something went wrong and your message was not sent. You can try again, or contact the MPGA directly at info@mpga.net.",
						}),
					n.sent !== void 0 &&
						h.jsx("p", { className: "text-success mt-2", children: "Thank you for your message." }),
				],
			})
		},
		Abt = () =>
			h.jsxs(KA, {
				children: [
					h.jsx("h3", { className: "text-primary", children: "Contact the MPGA" }),
					h.jsx("p", {
						children:
							"Have a question about the Minnesota Public Golf Association (MPGA), your MPGA membership, an MPGA Event, or the contents of this website? Please let us help.",
					}),
					h.jsx(QA, { message: new jv("General") }),
				],
			}),
		nc = _.forwardRef(
			(
				{
					bsPrefix: e,
					className: t,
					striped: n,
					bordered: r,
					borderless: i,
					hover: a,
					size: o,
					variant: s,
					responsive: l,
					...u
				},
				d,
			) => {
				const p = nt(e, "table"),
					m = Fe(
						t,
						p,
						s && `${p}-${s}`,
						o && `${p}-${o}`,
						n && `${p}-${typeof n == "string" ? `striped-${n}` : "striped"}`,
						r && `${p}-bordered`,
						i && `${p}-borderless`,
						a && `${p}-hover`,
					),
					v = h.jsx("table", { ...u, className: m, ref: d })
				if (l) {
					let y = `${p}-responsive`
					return (
						typeof l == "string" && (y = `${y}-${l}`), h.jsx("div", { className: y, children: v })
					)
				}
				return v
			},
		),
		Nbt = (e) => {
			const { document: t, onClose: n, show: r } = e
			return h.jsx(H.Fragment, {
				children:
					t &&
					h.jsxs(Or, {
						show: r,
						onHide: n,
						children: [
							h.jsx(Or.Header, {
								closeButton: !0,
								children: h.jsx(Or.Title, {
									className: "text-primary",
									children: "Document Upload / Edit / Replace",
								}),
							}),
							h.jsx(Or.Body, { children: h.jsx(YA, { document: t, onClose: n }) }),
							h.jsx(Or.Footer, {
								children: h.jsx(Ge, { variant: "light", onClick: n, children: "Cancel" }),
							}),
						],
					}),
			})
		},
		Mbt = (e) => {
			var o
			const { document: t, onEdit: n } = e,
				{ data: r } = BA(),
				i = t.tournament && r.find((s) => s.id === t.tournament),
				a = (s) => {
					switch (s) {
						case "doc":
						case "docx":
							return h.jsx("a", {
								href: t.file,
								target: "_blank",
								className: "text-info",
								rel: "noopener noreferrer",
								children: h.jsx(h7, { size: 24 }),
							})
						case "xls":
						case "xlsx":
							return h.jsx("a", {
								href: t.file,
								target: "_blank",
								className: "text-success",
								rel: "noopener noreferrer",
								children: h.jsx(p7, { size: 24 }),
							})
						case "pdf":
							return h.jsx("a", {
								href: t.file,
								target: "_blank",
								className: "text-danger",
								rel: "noopener noreferrer",
								children: h.jsx(jme, { size: 24 }),
							})
						default:
							return h.jsx("a", {
								href: t.file,
								target: "_blank",
								rel: "noopener noreferrer",
								children: h.jsx(Fme, { size: 24 }),
							})
					}
				}
			return h.jsx(H.Fragment, {
				children: h.jsxs("tr", {
					children: [
						h.jsx("td", { children: a(t.extension) }),
						h.jsx("td", { children: t.year }),
						h.jsx("td", { children: t.title }),
						h.jsx("td", { children: t.documentType }),
						h.jsx("td", { children: i == null ? void 0 : i.name }),
						h.jsx("td", { children: Te(t.lastUpdate).format("MMM Do YYYY h:mm a") }),
						h.jsx("td", {
							children:
								(o = t.tags) == null
									? void 0
									: o.map((s) =>
											h.jsx(Eg, { className: "mr-1", text: "dark", children: s.name }, s.id),
									  ),
						}),
						h.jsx("td", {
							className: "clickable text-warning",
							onClick: () => n(t),
							children: h.jsx(Ime, { size: 18, color: "warning" }),
						}),
					],
				}),
			})
		},
		_Y = _.forwardRef(
			(
				{
					bsPrefix: e,
					size: t,
					vertical: n = !1,
					className: r,
					role: i = "group",
					as: a = "div",
					...o
				},
				s,
			) => {
				const l = nt(e, "btn-group")
				let u = l
				return (
					n && (u = `${l}-vertical`),
					h.jsx(a, { ...o, ref: s, role: i, className: Fe(r, u, t && `${l}-${t}`) })
				)
			},
		)
	_Y.displayName = "ButtonGroup"
	const Ibt = Bt({
			year: gi().nullable(),
			tournamentId: gi().nullable(),
			documentTypes: Oe().nullable(),
			tags: Oe().nullable(),
		}),
		Rbt = (e) => {
			var o
			const { query: t, onSearch: n } = e,
				{ data: r } = BA(),
				i = {
					tournamentId: t.tournamentId,
					year: t.year,
					documentType: t.documentType,
					tags: (o = t.tags) == null ? void 0 : o.join(","),
				},
				a = [
					{ value: "Agenda", label: "Agenda" },
					{ value: "ByLaws", label: "ByLaws" },
					{ value: "Club Registration", label: "Club Registration" },
					{ value: "Financial", label: "Financial" },
					{ value: "Match Play", label: "Match Play" },
					{ value: "Match Play Brackets", label: "Match Play Brackets" },
					{ value: "Minutes", label: "Minutes" },
					{ value: "Other", label: "Other" },
					{ value: "Registration", label: "Registration" },
					{ value: "Results", label: "Results" },
					{ value: "Standing Orders", label: "Standing Orders" },
					{ value: "Tee Times", label: "Tee Times" },
				]
			return h.jsx(Vt, {
				validationSchema: Ibt,
				onSubmit: (s) => {
					var u
					const l = Object.assign({}, t)
					;(l.year = s.year),
						(l.tournamentId = s.tournamentId),
						(l.documentType = s.documentType),
						(l.tags = ((u = s.tags) == null ? void 0 : u.split(",")) || []),
						n(l)
				},
				initialValues: i,
				children: ({
					handleSubmit: s,
					handleChange: l,
					handleBlur: u,
					values: d,
					touched: p,
					errors: m,
				}) => {
					var v, y, b
					return h.jsx(R, {
						noValidate: !0,
						onSubmit: s,
						children: h.jsxs(ln, {
							children: [
								h.jsxs(it, {
									xs: 12,
									sm: 3,
									md: 2,
									lg: 1,
									children: [
										h.jsx(R.Control, {
											name: "year",
											placeholder: "Year",
											width: "80px",
											type: "number",
											value: ((v = d.year) == null ? void 0 : v.toString()) || "",
											isValid: p.year && !m.year,
											isInvalid: !!m.year,
											onChange: l,
											onBlur: u,
										}),
										h.jsx(R.Control.Feedback, { type: "invalid", children: m.year }),
									],
								}),
								h.jsx(it, {
									xs: 12,
									sm: 5,
									md: 2,
									lg: 3,
									children: h.jsxs(R.Control, {
										as: "select",
										name: "documentType",
										value: ((y = d.documentType) == null ? void 0 : y.toString()) || "",
										isValid: p.documentType && !m.documentType,
										isInvalid: !!m.documentType,
										onChange: l,
										onBlur: u,
										children: [
											h.jsx("option", { value: void 0 }),
											a.map((x) => h.jsx("option", { value: x.value, children: x.label }, x.value)),
										],
									}),
								}),
								h.jsx(it, {
									xs: 12,
									sm: 4,
									md: 3,
									lg: 3,
									children: h.jsxs(R.Control, {
										as: "select",
										name: "tournamentId",
										value: ((b = d.tournamentId) == null ? void 0 : b.toString()) || "",
										isValid: p.tournamentId && !m.tournamentId,
										isInvalid: !!m.tournamentId,
										onChange: l,
										onBlur: u,
										children: [
											h.jsx("option", { value: void 0 }),
											r && r.map((x) => h.jsx("option", { value: x.id, children: x.name }, x.id)),
										],
									}),
								}),
								h.jsx(it, {
									xs: 12,
									sm: 6,
									md: 3,
									lg: 3,
									children: h.jsx(R.Control, {
										name: "tags",
										placeholder: "Tags (comma separated)",
										value: d.tags || "",
										isValid: p.tags && !m.tags,
										isInvalid: !!m.tags,
										onChange: l,
										onBlur: u,
									}),
								}),
								h.jsx(it, {
									xs: 12,
									sm: 6,
									md: 2,
									lg: 2,
									children: h.jsx(Ge, {
										variant: "secondary",
										type: "submit",
										size: "sm",
										children: "Search",
									}),
								}),
							],
						}),
					})
				},
			})
		},
		Lbt = () => {
			const [e, t] = _.useState(!1),
				[n, r] = _.useState(),
				[i, a] = _.useState({ key: "library" }),
				{ data: o, isLoading: s } = sh(i),
				l = () => {
					r(new zu({ id: 0, year: lt.EventCalendarYear })), t(!0)
				},
				u = (d) => {
					r(d), t(!0)
				}
			return h.jsxs(H.Fragment, {
				children: [
					h.jsx("h3", { className: "text-primary mb-2", children: "MPGA Document Library" }),
					h.jsxs(H.Fragment, {
						children: [
							h.jsx("h5", { className: "text-secondary", children: "Search" }),
							h.jsx(Rbt, { query: i, onSearch: (d) => a(d) }),
						],
					}),
					h.jsxs(ht, {
						loading: s,
						children: [
							h.jsx(Ge, {
								variant: "link",
								className: "text-warning",
								onClick: () => l(),
								children: "Add New Document",
							}),
							h.jsxs(nc, {
								children: [
									h.jsx("thead", {
										children: h.jsxs("tr", {
											children: [
												h.jsx("th", {}),
												h.jsx("th", { children: "Year" }),
												h.jsx("th", { children: "Title" }),
												h.jsx("th", { children: "Document Type" }),
												h.jsx("th", { children: "Tournament" }),
												h.jsx("th", { children: "Last Updated" }),
												h.jsx("th", { children: "Tags" }),
												h.jsx("th", {}),
											],
										}),
									}),
									h.jsx("tbody", {
										children:
											o == null
												? void 0
												: o.map((d) =>
														h.jsx(Mbt, { document: new zu(d), onEdit: (p) => u(p) }, d.id),
												  ),
									}),
								],
							}),
							h.jsx(Nbt, { show: e, document: n, onClose: () => t(!1) }),
						],
					}),
				],
			})
		},
		Pbt = () => h.jsx(ii, { fluid: !0, children: h.jsx(ug, { children: h.jsx(Lbt, {}) }) }),
		OY = (e) => {
			var t, n
			return {
				id: e.id,
				location: (t = e.location) == null ? void 0 : t.id,
				tournament: (n = e.tournament) == null ? void 0 : n.id,
				name: e.name,
				description: e.description,
				rounds: e.rounds,
				notes: e.notes,
				event_type: e.eventType,
				start_date: Te(e.startDate).format("YYYY-MM-DD"),
				registration_start: e.registrationStart.toISOString(),
				registration_end: e.registrationEnd.toISOString(),
				early_registration_end: e.earlyRegistrationEnd.toISOString(),
			}
		},
		jbt = Ui.injectEndpoints({
			endpoints: (e) => ({
				getEvents: e.query({
					query: (t) => ({ url: "/events/?year=" + t, method: "GET" }),
					providesTags: (t) => [
						...t.map(({ id: n }) => ({ type: "Events", id: n })),
						{ type: "Events", id: "LIST" },
					],
				}),
				getEvent: e.query({
					query: ({ name: t, year: n }) => ({ url: `/events/?name=${t}&year=${n}`, method: "GET" }),
					transformResponse: (t) => ((t == null ? void 0 : t.length) === 1 ? t[0] : void 0),
					providesTags: (t) => [
						{ type: "Events", id: t == null ? void 0 : t.id },
						{ type: "Events", id: "LIST" },
					],
				}),
				updateEvent: e.mutation({
					query(t) {
						const { id: n } = t
						return { url: `/events/${n}/`, method: "PUT", data: t }
					},
					invalidatesTags: (t, n, { id: r }) => [{ type: "Events", id: r }],
				}),
				addEventLink: e.mutation({
					query(t) {
						return { url: "/event-links/", method: "POST", data: t }
					},
					invalidatesTags: (t, n, { event: r }) => [{ type: "Events", id: r }],
				}),
				updateEventLink: e.mutation({
					query(t) {
						const { id: n } = t
						return { url: `/event-links/${n}/`, method: "PUT", data: t }
					},
					invalidatesTags: (t, n, { event: r }) => [{ type: "Events", id: r }],
				}),
				removeEventLink: e.mutation({
					query(t) {
						const { id: n } = t
						return { url: `/event-links/${n}/`, method: "DELETE" }
					},
					invalidatesTags: (t, n, { event: r }) => [{ type: "Events", id: r }],
				}),
				addEventPoints: e.mutation({
					query(t) {
						return { url: "/event-points/", method: "POST", data: t }
					},
					invalidatesTags: (t, n, { event: r }) => [{ type: "Events", id: r }],
				}),
				updateEventPoints: e.mutation({
					query(t) {
						const { id: n } = t
						return { url: `/event-points/${n}/`, method: "PUT", data: t }
					},
					invalidatesTags: (t, n, { event: r }) => [{ type: "Events", id: r }],
				}),
				removeEventPoints: e.mutation({
					query(t) {
						const { id: n } = t
						return { url: `/event-points/${n}/`, method: "DELETE" }
					},
					invalidatesTags: (t, n, { event: r }) => [{ type: "Events", id: r }],
				}),
				updateEventPolicy: e.mutation({
					query(t) {
						const { id: n } = t
						return { url: `/event-policies/${n}/`, method: "PUT", data: t }
					},
					invalidatesTags: (t, n, { event: r }) => [{ type: "Events", id: r }],
				}),
				removeEventPolicy: e.mutation({
					query(t) {
						const { id: n } = t
						return { url: `/event-policies/${n}/`, method: "DELETE" }
					},
					invalidatesTags: (t, n, { event: r }) => [{ type: "Events", id: r }],
				}),
			}),
		}),
		{
			useAddEventLinkMutation: Fbt,
			useAddEventPointsMutation: Bbt,
			useGetEventQuery: AY,
			useGetEventsQuery: NY,
			useRemoveEventLinkMutation: Hbt,
			useRemoveEventPointsMutation: $bt,
			useRemoveEventPolicyMutation: Ubt,
			useUpdateEventLinkMutation: zbt,
			useUpdateEventMutation: MY,
			useUpdateEventPointsMutation: qbt,
			useUpdateEventPolicyMutation: Vbt,
		} = jbt,
		Wbt = () => {
			const { name: e } = Sl(),
				{ data: t, isLoading: n } = AY({ name: e, year: lt.EventCalendarYear })
			return h.jsx(KA, {
				children: h.jsxs(ht, {
					loading: n,
					children: [
						h.jsxs("h3", {
							className: "text-primary",
							children: ["Contact the ", t.name, " Chairs"],
						}),
						h.jsx("p", {
							children:
								"Messages sent here are routed to the tournament chairs. They will respond as soon possible.",
						}),
						h.jsx(QA, { message: new jv("Tournament", t.name) }),
					],
				}),
			})
		},
		Ybt = (e) =>
			h.jsxs(ln, {
				children: [
					h.jsx(it, { sm: 6, lg: 9, children: e.LeftColumn }),
					h.jsx(it, { sm: 6, lg: 3, children: e.RightColumn }),
				],
			}),
		Gbt = (e) => {
			var n
			const { eventDetail: t } = e
			return h.jsxs(_.Fragment, {
				children: [
					h.jsx("h5", { className: "text-primary", children: "Tournament Chairs" }),
					(n = t.chairs) == null
						? void 0
						: n.map((r) => {
								var i
								return h.jsx(
									"p",
									{ className: "mb-1", children: (i = r.chair) == null ? void 0 : i.name },
									r.id,
								)
						  }),
				],
			})
		},
		IY = Ft.img`
  width: 80px;
  height: 80px;
  background-size: contain;
  object-fit: scale-down;
  float: right;
`
	IY.displayName = "CourseLogo"
	const Kbt = (e) => {
			var n, r, i
			const { eventDetail: t } = e
			return h.jsxs("div", {
				children: [
					h.jsx("a", {
						target: "_blank",
						rel: "noopener noreferrer",
						href: (n = t.location) == null ? void 0 : n.website,
						children: h.jsx(IY, { src: (r = t.location) == null ? void 0 : r.logoUrl }),
					}),
					h.jsx("h4", {
						className: "text-secondary",
						children: (i = t.location) == null ? void 0 : i.name,
					}),
					t.eventType === "P" && h.jsx("h5", { className: "text-danger", children: "POSTPONED" }),
					t.eventType === "C" && h.jsx("h5", { className: "text-danger", children: "CANCELED" }),
					t.eventType !== "P" && t.eventType !== "C" && h.jsx("h5", { children: t.eventDates }),
				],
			})
		},
		Qbt = Bt({ description: Oe().required() }),
		Xbt = (e) => {
			const { eventDetail: t, onClose: n } = e,
				[r, { isLoading: i }] = MY(),
				a = async (o) => {
					const s = OY(o)
					await r(s)
						.unwrap()
						.then(() => {
							je.success(`Format information for ${t.name} has been saved.`), n()
						})
						.catch((l) => {
							je.error(" " + l)
						})
				}
			return h.jsx(ht, {
				loading: i,
				children: h.jsx(Vt, {
					validationSchema: Qbt,
					onSubmit: a,
					initialValues: t,
					children: ({ handleSubmit: o, values: s }) =>
						h.jsxs(R, {
							noValidate: !0,
							onSubmit: o,
							children: [
								h.jsxs(R.Group, {
									controlId: "description",
									children: [
										h.jsx(R.Label, { children: "Event format" }),
										h.jsx(_s, { name: "description", value: s.description, height: "480px" }),
									],
								}),
								h.jsx(lr, {}),
								h.jsx(br, { canCancel: !0, OnCancel: n }),
							],
						}),
				}),
			})
		},
		Jbt = (e) => {
			const { eventDetail: t } = e
			return h.jsxs(_.Fragment, {
				children: [
					h.jsx("h5", { className: "text-primary", children: "Format" }),
					h.jsx(tc, { text: t.description }),
				],
			})
		},
		Zbt = (e) => {
			const { eventDetail: t } = e,
				n = Wt(),
				r = H.useRef(),
				i = () => {
					r.current.close()
				}
			return h.jsx(Wr, {
				ref: r,
				initEdit: !1,
				canEdit: n.canManageEvent(),
				viewComponent: h.jsx(Jbt, { eventDetail: t }),
				editComponent: h.jsx(Xbt, { eventDetail: t, onClose: i }),
			})
		},
		ext = Bt({ place: gi().required(), points: gi().required() }),
		txt = (e) => {
			const { points: t, onClose: n } = e,
				[r, i] = _.useState(!1),
				[a, { isLoading: o }] = Bbt(),
				[s, { isLoading: l }] = qbt(),
				[u, { isLoading: d }] = $bt(),
				p = o || l || d,
				m = () => {
					i(!1)
				},
				v = async () => {
					i(!1)
					const b = t.prepJson()
					await u(b)
						.unwrap()
						.then(() => {
							je.success(`${t.ordinalPlace} place has been removed.`), n()
						})
						.catch((x) => {
							je.error(" " + x)
						})
				},
				y = async (b) => {
					const x = b.prepJson()
					await (b.id > 0 ? s(x) : a(x))
						.unwrap()
						.then(() => {
							je.success(`${b.place} place has been saved.`), n()
						})
						.catch((T) => {
							je.error(" " + T)
						})
				}
			return h.jsxs(ht, {
				loading: p,
				children: [
					h.jsx(Vt, {
						validationSchema: ext,
						onSubmit: y,
						initialValues: t,
						children: ({
							handleSubmit: b,
							handleChange: x,
							handleBlur: E,
							values: T,
							touched: C,
							errors: D,
						}) => {
							var O, A
							return h.jsxs(R, {
								noValidate: !0,
								onSubmit: b,
								children: [
									h.jsxs(R.Group, {
										controlId: "points.place",
										children: [
											h.jsx(R.Label, { children: "Place" }),
											h.jsx(R.Control, {
												name: "place",
												value: (O = T.place) == null ? void 0 : O.toString(),
												isValid: C.place && !D.place,
												isInvalid: !!D.place,
												onChange: x,
												onBlur: E,
											}),
											h.jsx(R.Control.Feedback, { type: "invalid", children: D.place }),
										],
									}),
									h.jsxs(R.Group, {
										controlId: "points.points",
										children: [
											h.jsx(R.Label, { children: "Points" }),
											h.jsx(R.Control, {
												name: "points",
												value: (A = T.points) == null ? void 0 : A.toString(),
												isValid: C.points && !D.points,
												isInvalid: !!D.points,
												onChange: x,
												onBlur: E,
											}),
											h.jsx(R.Control.Feedback, { type: "invalid", children: D.points }),
										],
									}),
									h.jsx(lr, {}),
									h.jsx(jd, { canDelete: t.id !== 0, OnDelete: () => i(!0) }),
									h.jsx(br, { canCancel: !0, OnCancel: n }),
								],
							})
						},
					}),
					h.jsx(Pd, {
						show: r,
						titleText: "Delete Place/Points?",
						messageText: "Please confirm that we should delete this place from the tournament.",
						confirmText: "Delete",
						DoCancel: m,
						DoConfirm: v,
					}),
				],
			})
		},
		nxt = (e) => {
			const { points: t } = e
			return h.jsxs("p", {
				className: "mb-1",
				children: [t.ordinalPlace, " - ", h.jsxs("strong", { children: [t.points, " pts"] })],
			})
		},
		v5 = (e) => {
			const { points: t, edit: n, onClose: r } = e,
				i = Wt(),
				a = _.useRef(),
				o = () => {
					a.current.close(), r()
				}
			return h.jsx(Wr, {
				ref: a,
				initEdit: n,
				canEdit: i.canManageEvent(),
				viewComponent: h.jsx(nxt, { points: t }),
				editComponent: h.jsx(txt, { points: t, onClose: o }),
			})
		},
		rxt = (e) => {
			var o, s, l
			const { eventDetail: t } = e,
				n = Wt(),
				[r, i] = H.useState(!1),
				a = ((o = t.playerPoints) == null ? void 0 : o.findIndex((u) => u.id === 0)) || !0
			return ((s = t.playerPoints) == null ? void 0 : s.length) > 0
				? h.jsxs(H.Fragment, {
						children: [
							h.jsx("h5", { className: "text-primary", children: "Player Points" }),
							(l = t.playerPoints) == null
								? void 0
								: l.map((u) => h.jsx(v5, { edit: !1, points: u, onClose: () => i(!1) }, u.id)),
							r &&
								h.jsx(
									v5,
									{ edit: !0, points: new EY({ id: 0, event: t.id }), onClose: () => i(!1) },
									0,
								),
							n.canManageEvent() &&
								h.jsx(Ge, {
									variant: "link",
									className: "text-warning",
									disabled: !a,
									onClick: () => i(!0),
									children: "New Player Points",
								}),
						],
				  })
				: null
		},
		ixt = Bt({
			name: Oe().max(30).required(),
			title: Oe().max(120).required(),
			description: Oe().required(),
		}),
		axt = (e) => {
			const { policy: t, onClose: n } = e,
				[r, i] = _.useState(!1),
				a = t.policy,
				[o, { isLoading: s }] = Vbt(),
				[l, { isLoading: u }] = Ubt(),
				d = s || u,
				p = () => {
					i(!1)
				},
				m = async () => {
					i(!1)
					const y = t.prepJson()
					await l(y)
						.unwrap()
						.then(() => {
							je.success(`${t.policy.name} has been removed from this event.`), n()
						})
						.catch((b) => {
							je.error(" " + b)
						})
				},
				v = async (y) => {
					const b = t.prepJson()
					;(b.policy = y.prepJson()),
						await o(b)
							.unwrap()
							.then(() => {
								je.success(`Policy ${y.name} has been saved.`), n()
							})
							.catch((x) => {
								je.error(" " + x)
							})
				}
			return h.jsxs(ht, {
				loading: d,
				children: [
					t.id > 0 &&
						h.jsx("p", {
							className: "text-muted",
							children:
								"Policies are typically shared between tournaments, so changes to this policy will be reflected in elsewhere. If you need a policy unique to this event, contact the website administrator (Stuart).",
						}),
					h.jsx(Vt, {
						validationSchema: ixt,
						onSubmit: v,
						initialValues: a,
						children: ({
							handleSubmit: y,
							handleChange: b,
							handleBlur: x,
							values: E,
							touched: T,
							errors: C,
						}) =>
							h.jsxs(R, {
								noValidate: !0,
								onSubmit: y,
								children: [
									h.jsxs(R.Group, {
										controlId: "policy.Name",
										children: [
											h.jsx(R.Label, { children: "Name" }),
											h.jsx(R.Control, {
												name: "name",
												placeholder: "Unique policy name",
												value: E.name,
												isValid: T.name && !C.name,
												isInvalid: !!C.name,
												onChange: b,
												onBlur: x,
											}),
											h.jsx(R.Control.Feedback, { type: "invalid", children: C.name }),
											h.jsx(R.Text, {
												className: "text-muted",
												children: "This name is not displayed on the website",
											}),
										],
									}),
									h.jsxs(R.Group, {
										controlId: "policy.Title",
										children: [
											h.jsx(R.Label, { children: "Title" }),
											h.jsx(R.Control, {
												name: "title",
												placeholder: "Title",
												value: E.title,
												isValid: T.title && !C.title,
												isInvalid: !!C.title,
												onChange: b,
												onBlur: x,
											}),
											h.jsx(R.Control.Feedback, { type: "invalid", children: C.title }),
										],
									}),
									h.jsxs(R.Group, {
										controlId: "policy.Description",
										children: [
											h.jsx(R.Label, { children: "Policy text" }),
											h.jsx(_s, { name: "description", value: E.description, height: "240px" }),
										],
									}),
									h.jsx(lr, {}),
									h.jsx(jd, { canDelete: t.id !== 0, OnDelete: () => i(!0) }),
									h.jsx(br, { canCancel: !0, OnCancel: n }),
								],
							}),
					}),
					h.jsx(Pd, {
						show: r,
						titleText: "Remove Policy?",
						messageText: "Please confirm that we should remove this policy from the tournament.",
						confirmText: "Remove Policy",
						DoCancel: p,
						DoConfirm: m,
					}),
				],
			})
		},
		oxt = (e) => {
			const { policy: t } = e
			return t && t.policy
				? h.jsxs("div", {
						children: [
							h.jsx("h5", { className: "text-primary", children: t.policy.title }),
							h.jsx(tc, { text: t.policy.description }),
						],
				  })
				: null
		},
		sxt = (e) => {
			const { policy: t, edit: n, onClose: r } = e,
				i = Wt(),
				a = _.useRef(),
				o = () => {
					a.current.close(), r()
				}
			return h.jsx(Wr, {
				ref: a,
				initEdit: n,
				canEdit: i.canManageEvent(),
				viewComponent: h.jsx(oxt, { policy: t }),
				editComponent: h.jsx(axt, { policy: t, onClose: o }),
			})
		},
		lxt = (e) => {
			var n
			const { eventDetail: t } = e
			return h.jsx(H.Fragment, {
				children:
					(n = t.policies) == null
						? void 0
						: n.map((r) => h.jsx(sxt, { edit: !1, policy: r, onClose: () => {} }, r.id)),
			})
		},
		uxt = (e) => {
			const { eventDetail: t } = e
			return h.jsxs("div", {
				children: [
					h.jsx("h1", { className: "text-secondary", children: t.name }),
					h.jsx(Kbt, { eventDetail: t }),
					h.jsx(Zbt, { eventDetail: t }),
					h.jsx(lxt, { eventDetail: t }),
					h.jsx(rxt, { eventDetail: t }),
					h.jsx(Gbt, { eventDetail: t }),
				],
			})
		},
		cxt = { viewType: Ou.Link, external: !0, variant: "secondary" },
		Sy = (e) => {
			const { documents: t, title: n, documentType: r } = e,
				i = t == null ? void 0 : t.filter((a) => a.document_type === r)
			return h.jsx("div", {
				children:
					i &&
					i.length > 0 &&
					h.jsxs(H.Fragment, {
						children: [
							h.jsx("h5", { className: "mt-1 text-primary", children: n }),
							h.jsx(Mw, { documents: i, render: cxt }),
						],
					}),
			})
		},
		dxt = Bt({
			title: Oe().max(60).required(),
			linkType: Oe().required(),
			url: Oe().max(240).url().required(),
		}),
		RY = (e) => {
			const { eventLink: t, onClose: n } = e,
				[r, i] = _.useState(!1),
				[a, { isLoading: o }] = Fbt(),
				[s, { isLoading: l }] = zbt(),
				[u, { isLoading: d }] = Hbt(),
				p = o || l || d,
				m = () => {
					i(!1)
				},
				v = async () => {
					i(!1)
					const b = t.prepJson()
					await u(b)
						.unwrap()
						.then(() => {
							je.success(`${t.title} has been removed.`), n()
						})
						.catch((x) => {
							je.error(" " + x)
						})
				},
				y = async (b) => {
					const x = b.prepJson()
					await (b.id > 0 ? s(x) : a(x))
						.unwrap()
						.then(() => {
							je.success(`${b.title} has been saved.`), n()
						})
						.catch((T) => {
							je.error(" " + T)
						})
				}
			return h.jsxs(ht, {
				loading: p,
				children: [
					h.jsx(Vt, {
						validationSchema: dxt,
						onSubmit: y,
						initialValues: t,
						children: ({
							handleSubmit: b,
							handleChange: x,
							handleBlur: E,
							values: T,
							touched: C,
							errors: D,
						}) =>
							h.jsxs(R, {
								noValidate: !0,
								onSubmit: b,
								children: [
									h.jsxs(R.Group, {
										controlId: "eventLink.title",
										children: [
											h.jsx(R.Label, { className: "full-width", children: "Title" }),
											h.jsx(R.Control, {
												placeholder: "Title",
												name: "title",
												value: T.title,
												isValid: C.title && !D.title,
												isInvalid: !!D.title,
												onChange: x,
												onBlur: E,
											}),
											h.jsx(R.Control.Feedback, { type: "invalid", children: D.title }),
											h.jsx(R.Text, {
												className: "text-muted",
												children: "Display name for this link.",
											}),
										],
									}),
									h.jsxs(R.Group, {
										controlId: "doc.LinkType",
										children: [
											h.jsx(R.Label, { children: "Link type" }),
											h.jsxs(R.Control, {
												as: "select",
												name: "linkType",
												value: T.linkType,
												isValid: C.linkType && !D.linkType,
												isInvalid: !!D.linkType,
												onChange: x,
												onBlur: E,
												children: [
													h.jsx("option", { value: "" }),
													h.jsx("option", { value: "Media", children: "Media" }),
													h.jsx("option", { value: "Registration", children: "Registration" }),
													h.jsx("option", { value: "Results", children: "Results" }),
													h.jsx("option", { value: "Tee Times", children: "Tee Times" }),
												],
											}),
										],
									}),
									h.jsxs(R.Group, {
										controlId: "eventLink.url",
										children: [
											h.jsx(R.Label, { className: "full-width", children: "Url" }),
											h.jsx(R.Control, {
												placeholder: "https://link-to-somewhere",
												name: "url",
												value: T.url,
												isValid: C.url && !D.url,
												isInvalid: !!D.url,
												onChange: x,
												onBlur: E,
											}),
											h.jsx(R.Control.Feedback, { type: "invalid", children: D.url }),
											h.jsx(R.Text, { className: "text-muted", children: "Url for the link" }),
										],
									}),
									h.jsx(lr, {}),
									h.jsx(jd, { canDelete: t.id !== 0, OnDelete: () => i(!0) }),
									h.jsx(br, { canCancel: !0, OnCancel: n }),
								],
							}),
					}),
					h.jsx(Pd, {
						show: r,
						titleText: "Delete Link?",
						messageText: "Please confirm that we should delete this link.",
						confirmText: "Delete Link",
						DoCancel: m,
						DoConfirm: v,
					}),
				],
			})
		}
	var Vb = ((e) => ((e[(e.Link = 0)] = "Link"), (e[(e.Button = 1)] = "Button"), e))(Vb || {})
	const fxt = (e) => {
			const { eventLink: t, render: n } = e
			return (() => {
				switch (n.viewType) {
					case Vb.Link:
						return h.jsx("a", {
							href: t.url,
							className: n.className || "",
							target: n.external ? "_blank" : "_self",
							rel: "noopener noreferrer",
							children: t.title,
						})
					case Vb.Button:
						return h.jsx(Ge, {
							as: "a",
							href: t.url,
							target: n.external ? "_blank" : "_self",
							rel: "noopener noreferrer",
							size: "sm",
							variant: n.variant || "light",
							children: t.title,
						})
					default:
						return h.jsx(h.Fragment, {})
				}
			})()
		},
		pxt = (e) => {
			const t = Wt(),
				{ eventLink: n, edit: r, render: i } = e,
				a = _.useRef(),
				o = () => {
					a.current.close()
				}
			return h.jsx(Wr, {
				ref: a,
				initEdit: r,
				canEdit: t.canManageEvent(),
				viewComponent: h.jsx(fxt, { eventLink: n, render: i }),
				editComponent: h.jsx(RY, { eventLink: n, onClose: o }),
			})
		},
		hxt = { viewType: Vb.Link, external: !0, variant: "secondary" },
		Dy = (e) => {
			var o
			const { eventDetail: t, linkType: n, title: r } = e,
				i = (o = t.links) == null ? void 0 : o.filter((s) => s.linkType === n),
				a = (s) => h.jsx(pxt, { eventLink: s, render: hxt, edit: s.id === 0 }, s.id)
			return h.jsx("div", {
				children:
					i &&
					i.length > 0 &&
					h.jsxs(H.Fragment, {
						children: [
							h.jsx("h5", { className: "text-primary mt-1", children: r }),
							i == null ? void 0 : i.map((s) => a(s)),
						],
					}),
			})
		}
	function ze(e) {
		const t = Object.prototype.toString.call(e)
		return e instanceof Date || (typeof e == "object" && t === "[object Date]")
			? new e.constructor(+e)
			: typeof e == "number" ||
			  t === "[object Number]" ||
			  typeof e == "string" ||
			  t === "[object String]"
			? new Date(e)
			: new Date(NaN)
	}
	function nn(e, t) {
		return e instanceof Date ? new e.constructor(t) : new Date(t)
	}
	function Tl(e, t) {
		const n = ze(e)
		return isNaN(t) ? nn(e, NaN) : (t && n.setDate(n.getDate() + t), n)
	}
	function No(e, t) {
		const n = ze(e)
		if (isNaN(t)) return nn(e, NaN)
		if (!t) return n
		const r = n.getDate(),
			i = nn(e, n.getTime())
		i.setMonth(n.getMonth() + t + 1, 0)
		const a = i.getDate()
		return r >= a ? i : (n.setFullYear(i.getFullYear(), i.getMonth(), r), n)
	}
	function XA(e, t) {
		const n = +ze(e)
		return nn(e, n + t)
	}
	const LY = 6048e5,
		mxt = 864e5,
		Lw = 6e4,
		Pw = 36e5,
		vxt = 1e3
	function gxt(e, t) {
		return XA(e, t * Pw)
	}
	let yxt = {}
	function Bd() {
		return yxt
	}
	function kl(e, t) {
		var s, l, u, d
		const n = Bd(),
			r =
				(t == null ? void 0 : t.weekStartsOn) ??
				((l = (s = t == null ? void 0 : t.locale) == null ? void 0 : s.options) == null
					? void 0
					: l.weekStartsOn) ??
				n.weekStartsOn ??
				((d = (u = n.locale) == null ? void 0 : u.options) == null ? void 0 : d.weekStartsOn) ??
				0,
			i = ze(e),
			a = i.getDay(),
			o = (a < r ? 7 : 0) + a - r
		return i.setDate(i.getDate() - o), i.setHours(0, 0, 0, 0), i
	}
	function Rp(e) {
		return kl(e, { weekStartsOn: 1 })
	}
	function PY(e) {
		const t = ze(e),
			n = t.getFullYear(),
			r = nn(e, 0)
		r.setFullYear(n + 1, 0, 4), r.setHours(0, 0, 0, 0)
		const i = Rp(r),
			a = nn(e, 0)
		a.setFullYear(n, 0, 4), a.setHours(0, 0, 0, 0)
		const o = Rp(a)
		return t.getTime() >= i.getTime() ? n + 1 : t.getTime() >= o.getTime() ? n : n - 1
	}
	function kd(e) {
		const t = ze(e)
		return t.setHours(0, 0, 0, 0), t
	}
	function Wb(e) {
		const t = ze(e),
			n = new Date(
				Date.UTC(
					t.getFullYear(),
					t.getMonth(),
					t.getDate(),
					t.getHours(),
					t.getMinutes(),
					t.getSeconds(),
					t.getMilliseconds(),
				),
			)
		return n.setUTCFullYear(t.getFullYear()), +e - +n
	}
	function Lp(e, t) {
		const n = kd(e),
			r = kd(t),
			i = +n - Wb(n),
			a = +r - Wb(r)
		return Math.round((i - a) / mxt)
	}
	function bxt(e) {
		const t = PY(e),
			n = nn(e, 0)
		return n.setFullYear(t, 0, 4), n.setHours(0, 0, 0, 0), Rp(n)
	}
	function OD(e, t) {
		return XA(e, t * Lw)
	}
	function JA(e, t) {
		const n = t * 3
		return No(e, n)
	}
	function xxt(e, t) {
		return XA(e, t * 1e3)
	}
	function Yb(e, t) {
		const n = t * 7
		return Tl(e, n)
	}
	function hl(e, t) {
		return No(e, t * 12)
	}
	function g5(e) {
		let t
		return (
			e.forEach(function (n) {
				const r = ze(n)
				;(t === void 0 || t < r || isNaN(Number(r))) && (t = r)
			}),
			t || new Date(NaN)
		)
	}
	function y5(e) {
		let t
		return (
			e.forEach((n) => {
				const r = ze(n)
				;(!t || t > r || isNaN(+r)) && (t = r)
			}),
			t || new Date(NaN)
		)
	}
	function wxt(e, t) {
		const n = kd(e),
			r = kd(t)
		return +n == +r
	}
	function ml(e) {
		return (
			e instanceof Date ||
			(typeof e == "object" && Object.prototype.toString.call(e) === "[object Date]")
		)
	}
	function Gb(e) {
		if (!ml(e) && typeof e != "number") return !1
		const t = ze(e)
		return !isNaN(Number(t))
	}
	function Kb(e, t) {
		const n = ze(e),
			r = ze(t),
			i = n.getFullYear() - r.getFullYear(),
			a = n.getMonth() - r.getMonth()
		return i * 12 + a
	}
	function id(e) {
		const t = ze(e)
		return Math.trunc(t.getMonth() / 3) + 1
	}
	function Qb(e, t) {
		const n = ze(e),
			r = ze(t),
			i = n.getFullYear() - r.getFullYear(),
			a = id(n) - id(r)
		return i * 4 + a
	}
	function Xb(e, t) {
		const n = ze(e),
			r = ze(t)
		return n.getFullYear() - r.getFullYear()
	}
	function Ext(e, t) {
		const n = ze(e),
			r = ze(t),
			i = b5(n, r),
			a = Math.abs(Lp(n, r))
		n.setDate(n.getDate() - i * a)
		const o = +(b5(n, r) === -i),
			s = i * (a - o)
		return s === 0 ? 0 : s
	}
	function b5(e, t) {
		const n =
			e.getFullYear() - t.getFullYear() ||
			e.getMonth() - t.getMonth() ||
			e.getDate() - t.getDate() ||
			e.getHours() - t.getHours() ||
			e.getMinutes() - t.getMinutes() ||
			e.getSeconds() - t.getSeconds() ||
			e.getMilliseconds() - t.getMilliseconds()
		return n < 0 ? -1 : n > 0 ? 1 : n
	}
	function jY(e) {
		const t = ze(e)
		return t.setHours(23, 59, 59, 999), t
	}
	function FY(e) {
		const t = ze(e),
			n = t.getMonth()
		return t.setFullYear(t.getFullYear(), n + 1, 0), t.setHours(23, 59, 59, 999), t
	}
	function AD(e) {
		const t = ze(e),
			n = t.getMonth(),
			r = n - (n % 3)
		return t.setMonth(r, 1), t.setHours(0, 0, 0, 0), t
	}
	function BY(e) {
		const t = ze(e)
		return t.setDate(1), t.setHours(0, 0, 0, 0), t
	}
	function HY(e) {
		const t = ze(e),
			n = t.getFullYear()
		return t.setFullYear(n + 1, 0, 0), t.setHours(23, 59, 59, 999), t
	}
	function jw(e) {
		const t = ze(e),
			n = nn(e, 0)
		return n.setFullYear(t.getFullYear(), 0, 1), n.setHours(0, 0, 0, 0), n
	}
	function Cxt(e, t) {
		var s, l
		const n = Bd(),
			r =
				n.weekStartsOn ??
				((l = (s = n.locale) == null ? void 0 : s.options) == null ? void 0 : l.weekStartsOn) ??
				0,
			i = ze(e),
			a = i.getDay(),
			o = (a < r ? -7 : 0) + 6 - (a - r)
		return i.setDate(i.getDate() + o), i.setHours(23, 59, 59, 999), i
	}
	const Txt = {
			lessThanXSeconds: { one: "less than a second", other: "less than {{count}} seconds" },
			xSeconds: { one: "1 second", other: "{{count}} seconds" },
			halfAMinute: "half a minute",
			lessThanXMinutes: { one: "less than a minute", other: "less than {{count}} minutes" },
			xMinutes: { one: "1 minute", other: "{{count}} minutes" },
			aboutXHours: { one: "about 1 hour", other: "about {{count}} hours" },
			xHours: { one: "1 hour", other: "{{count}} hours" },
			xDays: { one: "1 day", other: "{{count}} days" },
			aboutXWeeks: { one: "about 1 week", other: "about {{count}} weeks" },
			xWeeks: { one: "1 week", other: "{{count}} weeks" },
			aboutXMonths: { one: "about 1 month", other: "about {{count}} months" },
			xMonths: { one: "1 month", other: "{{count}} months" },
			aboutXYears: { one: "about 1 year", other: "about {{count}} years" },
			xYears: { one: "1 year", other: "{{count}} years" },
			overXYears: { one: "over 1 year", other: "over {{count}} years" },
			almostXYears: { one: "almost 1 year", other: "almost {{count}} years" },
		},
		kxt = (e, t, n) => {
			let r
			const i = Txt[e]
			return (
				typeof i == "string"
					? (r = i)
					: t === 1
					? (r = i.one)
					: (r = i.other.replace("{{count}}", t.toString())),
				n != null && n.addSuffix ? (n.comparison && n.comparison > 0 ? "in " + r : r + " ago") : r
			)
		}
	function pS(e) {
		return (t = {}) => {
			const n = t.width ? String(t.width) : e.defaultWidth
			return e.formats[n] || e.formats[e.defaultWidth]
		}
	}
	const Sxt = {
			full: "EEEE, MMMM do, y",
			long: "MMMM do, y",
			medium: "MMM d, y",
			short: "MM/dd/yyyy",
		},
		Dxt = { full: "h:mm:ss a zzzz", long: "h:mm:ss a z", medium: "h:mm:ss a", short: "h:mm a" },
		_xt = {
			full: "{{date}} 'at' {{time}}",
			long: "{{date}} 'at' {{time}}",
			medium: "{{date}}, {{time}}",
			short: "{{date}}, {{time}}",
		},
		Oxt = {
			date: pS({ formats: Sxt, defaultWidth: "full" }),
			time: pS({ formats: Dxt, defaultWidth: "full" }),
			dateTime: pS({ formats: _xt, defaultWidth: "full" }),
		},
		Axt = {
			lastWeek: "'last' eeee 'at' p",
			yesterday: "'yesterday at' p",
			today: "'today at' p",
			tomorrow: "'tomorrow at' p",
			nextWeek: "eeee 'at' p",
			other: "P",
		},
		Nxt = (e, t, n, r) => Axt[e]
	function pm(e) {
		return (t, n) => {
			const r = n != null && n.context ? String(n.context) : "standalone"
			let i
			if (r === "formatting" && e.formattingValues) {
				const o = e.defaultFormattingWidth || e.defaultWidth,
					s = n != null && n.width ? String(n.width) : o
				i = e.formattingValues[s] || e.formattingValues[o]
			} else {
				const o = e.defaultWidth,
					s = n != null && n.width ? String(n.width) : e.defaultWidth
				i = e.values[s] || e.values[o]
			}
			const a = e.argumentCallback ? e.argumentCallback(t) : t
			return i[a]
		}
	}
	const Mxt = {
			narrow: ["B", "A"],
			abbreviated: ["BC", "AD"],
			wide: ["Before Christ", "Anno Domini"],
		},
		Ixt = {
			narrow: ["1", "2", "3", "4"],
			abbreviated: ["Q1", "Q2", "Q3", "Q4"],
			wide: ["1st quarter", "2nd quarter", "3rd quarter", "4th quarter"],
		},
		Rxt = {
			narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
			abbreviated: [
				"Jan",
				"Feb",
				"Mar",
				"Apr",
				"May",
				"Jun",
				"Jul",
				"Aug",
				"Sep",
				"Oct",
				"Nov",
				"Dec",
			],
			wide: [
				"January",
				"February",
				"March",
				"April",
				"May",
				"June",
				"July",
				"August",
				"September",
				"October",
				"November",
				"December",
			],
		},
		Lxt = {
			narrow: ["S", "M", "T", "W", "T", "F", "S"],
			short: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
			abbreviated: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
			wide: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
		},
		Pxt = {
			narrow: {
				am: "a",
				pm: "p",
				midnight: "mi",
				noon: "n",
				morning: "morning",
				afternoon: "afternoon",
				evening: "evening",
				night: "night",
			},
			abbreviated: {
				am: "AM",
				pm: "PM",
				midnight: "midnight",
				noon: "noon",
				morning: "morning",
				afternoon: "afternoon",
				evening: "evening",
				night: "night",
			},
			wide: {
				am: "a.m.",
				pm: "p.m.",
				midnight: "midnight",
				noon: "noon",
				morning: "morning",
				afternoon: "afternoon",
				evening: "evening",
				night: "night",
			},
		},
		jxt = {
			narrow: {
				am: "a",
				pm: "p",
				midnight: "mi",
				noon: "n",
				morning: "in the morning",
				afternoon: "in the afternoon",
				evening: "in the evening",
				night: "at night",
			},
			abbreviated: {
				am: "AM",
				pm: "PM",
				midnight: "midnight",
				noon: "noon",
				morning: "in the morning",
				afternoon: "in the afternoon",
				evening: "in the evening",
				night: "at night",
			},
			wide: {
				am: "a.m.",
				pm: "p.m.",
				midnight: "midnight",
				noon: "noon",
				morning: "in the morning",
				afternoon: "in the afternoon",
				evening: "in the evening",
				night: "at night",
			},
		},
		Fxt = (e, t) => {
			const n = Number(e),
				r = n % 100
			if (r > 20 || r < 10)
				switch (r % 10) {
					case 1:
						return n + "st"
					case 2:
						return n + "nd"
					case 3:
						return n + "rd"
				}
			return n + "th"
		},
		Bxt = {
			ordinalNumber: Fxt,
			era: pm({ values: Mxt, defaultWidth: "wide" }),
			quarter: pm({ values: Ixt, defaultWidth: "wide", argumentCallback: (e) => e - 1 }),
			month: pm({ values: Rxt, defaultWidth: "wide" }),
			day: pm({ values: Lxt, defaultWidth: "wide" }),
			dayPeriod: pm({
				values: Pxt,
				defaultWidth: "wide",
				formattingValues: jxt,
				defaultFormattingWidth: "wide",
			}),
		}
	function hm(e) {
		return (t, n = {}) => {
			const r = n.width,
				i = (r && e.matchPatterns[r]) || e.matchPatterns[e.defaultMatchWidth],
				a = t.match(i)
			if (!a) return null
			const o = a[0],
				s = (r && e.parsePatterns[r]) || e.parsePatterns[e.defaultParseWidth],
				l = Array.isArray(s) ? $xt(s, (p) => p.test(o)) : Hxt(s, (p) => p.test(o))
			let u
			;(u = e.valueCallback ? e.valueCallback(l) : l),
				(u = n.valueCallback ? n.valueCallback(u) : u)
			const d = t.slice(o.length)
			return { value: u, rest: d }
		}
	}
	function Hxt(e, t) {
		for (const n in e) if (Object.prototype.hasOwnProperty.call(e, n) && t(e[n])) return n
	}
	function $xt(e, t) {
		for (let n = 0; n < e.length; n++) if (t(e[n])) return n
	}
	function Uxt(e) {
		return (t, n = {}) => {
			const r = t.match(e.matchPattern)
			if (!r) return null
			const i = r[0],
				a = t.match(e.parsePattern)
			if (!a) return null
			let o = e.valueCallback ? e.valueCallback(a[0]) : a[0]
			o = n.valueCallback ? n.valueCallback(o) : o
			const s = t.slice(i.length)
			return { value: o, rest: s }
		}
	}
	const zxt = /^(\d+)(th|st|nd|rd)?/i,
		qxt = /\d+/i,
		Vxt = {
			narrow: /^(b|a)/i,
			abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
			wide: /^(before christ|before common era|anno domini|common era)/i,
		},
		Wxt = { any: [/^b/i, /^(a|c)/i] },
		Yxt = { narrow: /^[1234]/i, abbreviated: /^q[1234]/i, wide: /^[1234](th|st|nd|rd)? quarter/i },
		Gxt = { any: [/1/i, /2/i, /3/i, /4/i] },
		Kxt = {
			narrow: /^[jfmasond]/i,
			abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,
			wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i,
		},
		Qxt = {
			narrow: [/^j/i, /^f/i, /^m/i, /^a/i, /^m/i, /^j/i, /^j/i, /^a/i, /^s/i, /^o/i, /^n/i, /^d/i],
			any: [
				/^ja/i,
				/^f/i,
				/^mar/i,
				/^ap/i,
				/^may/i,
				/^jun/i,
				/^jul/i,
				/^au/i,
				/^s/i,
				/^o/i,
				/^n/i,
				/^d/i,
			],
		},
		Xxt = {
			narrow: /^[smtwf]/i,
			short: /^(su|mo|tu|we|th|fr|sa)/i,
			abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i,
			wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i,
		},
		Jxt = {
			narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],
			any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i],
		},
		Zxt = {
			narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,
			any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i,
		},
		ewt = {
			any: {
				am: /^a/i,
				pm: /^p/i,
				midnight: /^mi/i,
				noon: /^no/i,
				morning: /morning/i,
				afternoon: /afternoon/i,
				evening: /evening/i,
				night: /night/i,
			},
		},
		twt = {
			ordinalNumber: Uxt({
				matchPattern: zxt,
				parsePattern: qxt,
				valueCallback: (e) => parseInt(e, 10),
			}),
			era: hm({
				matchPatterns: Vxt,
				defaultMatchWidth: "wide",
				parsePatterns: Wxt,
				defaultParseWidth: "any",
			}),
			quarter: hm({
				matchPatterns: Yxt,
				defaultMatchWidth: "wide",
				parsePatterns: Gxt,
				defaultParseWidth: "any",
				valueCallback: (e) => e + 1,
			}),
			month: hm({
				matchPatterns: Kxt,
				defaultMatchWidth: "wide",
				parsePatterns: Qxt,
				defaultParseWidth: "any",
			}),
			day: hm({
				matchPatterns: Xxt,
				defaultMatchWidth: "wide",
				parsePatterns: Jxt,
				defaultParseWidth: "any",
			}),
			dayPeriod: hm({
				matchPatterns: Zxt,
				defaultMatchWidth: "any",
				parsePatterns: ewt,
				defaultParseWidth: "any",
			}),
		},
		$Y = {
			code: "en-US",
			formatDistance: kxt,
			formatLong: Oxt,
			formatRelative: Nxt,
			localize: Bxt,
			match: twt,
			options: { weekStartsOn: 0, firstWeekContainsDate: 1 },
		}
	function nwt(e) {
		const t = ze(e)
		return Lp(t, jw(t)) + 1
	}
	function ZA(e) {
		const t = ze(e),
			n = +Rp(t) - +bxt(t)
		return Math.round(n / LY) + 1
	}
	function eN(e, t) {
		var d, p, m, v
		const n = ze(e),
			r = n.getFullYear(),
			i = Bd(),
			a =
				(t == null ? void 0 : t.firstWeekContainsDate) ??
				((p = (d = t == null ? void 0 : t.locale) == null ? void 0 : d.options) == null
					? void 0
					: p.firstWeekContainsDate) ??
				i.firstWeekContainsDate ??
				((v = (m = i.locale) == null ? void 0 : m.options) == null
					? void 0
					: v.firstWeekContainsDate) ??
				1,
			o = nn(e, 0)
		o.setFullYear(r + 1, 0, a), o.setHours(0, 0, 0, 0)
		const s = kl(o, t),
			l = nn(e, 0)
		l.setFullYear(r, 0, a), l.setHours(0, 0, 0, 0)
		const u = kl(l, t)
		return n.getTime() >= s.getTime() ? r + 1 : n.getTime() >= u.getTime() ? r : r - 1
	}
	function rwt(e, t) {
		var s, l, u, d
		const n = Bd(),
			r =
				(t == null ? void 0 : t.firstWeekContainsDate) ??
				((l = (s = t == null ? void 0 : t.locale) == null ? void 0 : s.options) == null
					? void 0
					: l.firstWeekContainsDate) ??
				n.firstWeekContainsDate ??
				((d = (u = n.locale) == null ? void 0 : u.options) == null
					? void 0
					: d.firstWeekContainsDate) ??
				1,
			i = eN(e, t),
			a = nn(e, 0)
		return a.setFullYear(i, 0, r), a.setHours(0, 0, 0, 0), kl(a, t)
	}
	function UY(e, t) {
		const n = ze(e),
			r = +kl(n, t) - +rwt(n, t)
		return Math.round(r / LY) + 1
	}
	function en(e, t) {
		const n = e < 0 ? "-" : "",
			r = Math.abs(e).toString().padStart(t, "0")
		return n + r
	}
	const su = {
			y(e, t) {
				const n = e.getFullYear(),
					r = n > 0 ? n : 1 - n
				return en(t === "yy" ? r % 100 : r, t.length)
			},
			M(e, t) {
				const n = e.getMonth()
				return t === "M" ? String(n + 1) : en(n + 1, 2)
			},
			d(e, t) {
				return en(e.getDate(), t.length)
			},
			a(e, t) {
				const n = e.getHours() / 12 >= 1 ? "pm" : "am"
				switch (t) {
					case "a":
					case "aa":
						return n.toUpperCase()
					case "aaa":
						return n
					case "aaaaa":
						return n[0]
					case "aaaa":
					default:
						return n === "am" ? "a.m." : "p.m."
				}
			},
			h(e, t) {
				return en(e.getHours() % 12 || 12, t.length)
			},
			H(e, t) {
				return en(e.getHours(), t.length)
			},
			m(e, t) {
				return en(e.getMinutes(), t.length)
			},
			s(e, t) {
				return en(e.getSeconds(), t.length)
			},
			S(e, t) {
				const n = t.length,
					r = e.getMilliseconds(),
					i = Math.trunc(r * Math.pow(10, n - 3))
				return en(i, t.length)
			},
		},
		Sf = {
			am: "am",
			pm: "pm",
			midnight: "midnight",
			noon: "noon",
			morning: "morning",
			afternoon: "afternoon",
			evening: "evening",
			night: "night",
		},
		x5 = {
			G: function (e, t, n) {
				const r = e.getFullYear() > 0 ? 1 : 0
				switch (t) {
					case "G":
					case "GG":
					case "GGG":
						return n.era(r, { width: "abbreviated" })
					case "GGGGG":
						return n.era(r, { width: "narrow" })
					case "GGGG":
					default:
						return n.era(r, { width: "wide" })
				}
			},
			y: function (e, t, n) {
				if (t === "yo") {
					const r = e.getFullYear(),
						i = r > 0 ? r : 1 - r
					return n.ordinalNumber(i, { unit: "year" })
				}
				return su.y(e, t)
			},
			Y: function (e, t, n, r) {
				const i = eN(e, r),
					a = i > 0 ? i : 1 - i
				if (t === "YY") {
					const o = a % 100
					return en(o, 2)
				}
				return t === "Yo" ? n.ordinalNumber(a, { unit: "year" }) : en(a, t.length)
			},
			R: function (e, t) {
				const n = PY(e)
				return en(n, t.length)
			},
			u: function (e, t) {
				const n = e.getFullYear()
				return en(n, t.length)
			},
			Q: function (e, t, n) {
				const r = Math.ceil((e.getMonth() + 1) / 3)
				switch (t) {
					case "Q":
						return String(r)
					case "QQ":
						return en(r, 2)
					case "Qo":
						return n.ordinalNumber(r, { unit: "quarter" })
					case "QQQ":
						return n.quarter(r, { width: "abbreviated", context: "formatting" })
					case "QQQQQ":
						return n.quarter(r, { width: "narrow", context: "formatting" })
					case "QQQQ":
					default:
						return n.quarter(r, { width: "wide", context: "formatting" })
				}
			},
			q: function (e, t, n) {
				const r = Math.ceil((e.getMonth() + 1) / 3)
				switch (t) {
					case "q":
						return String(r)
					case "qq":
						return en(r, 2)
					case "qo":
						return n.ordinalNumber(r, { unit: "quarter" })
					case "qqq":
						return n.quarter(r, { width: "abbreviated", context: "standalone" })
					case "qqqqq":
						return n.quarter(r, { width: "narrow", context: "standalone" })
					case "qqqq":
					default:
						return n.quarter(r, { width: "wide", context: "standalone" })
				}
			},
			M: function (e, t, n) {
				const r = e.getMonth()
				switch (t) {
					case "M":
					case "MM":
						return su.M(e, t)
					case "Mo":
						return n.ordinalNumber(r + 1, { unit: "month" })
					case "MMM":
						return n.month(r, { width: "abbreviated", context: "formatting" })
					case "MMMMM":
						return n.month(r, { width: "narrow", context: "formatting" })
					case "MMMM":
					default:
						return n.month(r, { width: "wide", context: "formatting" })
				}
			},
			L: function (e, t, n) {
				const r = e.getMonth()
				switch (t) {
					case "L":
						return String(r + 1)
					case "LL":
						return en(r + 1, 2)
					case "Lo":
						return n.ordinalNumber(r + 1, { unit: "month" })
					case "LLL":
						return n.month(r, { width: "abbreviated", context: "standalone" })
					case "LLLLL":
						return n.month(r, { width: "narrow", context: "standalone" })
					case "LLLL":
					default:
						return n.month(r, { width: "wide", context: "standalone" })
				}
			},
			w: function (e, t, n, r) {
				const i = UY(e, r)
				return t === "wo" ? n.ordinalNumber(i, { unit: "week" }) : en(i, t.length)
			},
			I: function (e, t, n) {
				const r = ZA(e)
				return t === "Io" ? n.ordinalNumber(r, { unit: "week" }) : en(r, t.length)
			},
			d: function (e, t, n) {
				return t === "do" ? n.ordinalNumber(e.getDate(), { unit: "date" }) : su.d(e, t)
			},
			D: function (e, t, n) {
				const r = nwt(e)
				return t === "Do" ? n.ordinalNumber(r, { unit: "dayOfYear" }) : en(r, t.length)
			},
			E: function (e, t, n) {
				const r = e.getDay()
				switch (t) {
					case "E":
					case "EE":
					case "EEE":
						return n.day(r, { width: "abbreviated", context: "formatting" })
					case "EEEEE":
						return n.day(r, { width: "narrow", context: "formatting" })
					case "EEEEEE":
						return n.day(r, { width: "short", context: "formatting" })
					case "EEEE":
					default:
						return n.day(r, { width: "wide", context: "formatting" })
				}
			},
			e: function (e, t, n, r) {
				const i = e.getDay(),
					a = (i - r.weekStartsOn + 8) % 7 || 7
				switch (t) {
					case "e":
						return String(a)
					case "ee":
						return en(a, 2)
					case "eo":
						return n.ordinalNumber(a, { unit: "day" })
					case "eee":
						return n.day(i, { width: "abbreviated", context: "formatting" })
					case "eeeee":
						return n.day(i, { width: "narrow", context: "formatting" })
					case "eeeeee":
						return n.day(i, { width: "short", context: "formatting" })
					case "eeee":
					default:
						return n.day(i, { width: "wide", context: "formatting" })
				}
			},
			c: function (e, t, n, r) {
				const i = e.getDay(),
					a = (i - r.weekStartsOn + 8) % 7 || 7
				switch (t) {
					case "c":
						return String(a)
					case "cc":
						return en(a, t.length)
					case "co":
						return n.ordinalNumber(a, { unit: "day" })
					case "ccc":
						return n.day(i, { width: "abbreviated", context: "standalone" })
					case "ccccc":
						return n.day(i, { width: "narrow", context: "standalone" })
					case "cccccc":
						return n.day(i, { width: "short", context: "standalone" })
					case "cccc":
					default:
						return n.day(i, { width: "wide", context: "standalone" })
				}
			},
			i: function (e, t, n) {
				const r = e.getDay(),
					i = r === 0 ? 7 : r
				switch (t) {
					case "i":
						return String(i)
					case "ii":
						return en(i, t.length)
					case "io":
						return n.ordinalNumber(i, { unit: "day" })
					case "iii":
						return n.day(r, { width: "abbreviated", context: "formatting" })
					case "iiiii":
						return n.day(r, { width: "narrow", context: "formatting" })
					case "iiiiii":
						return n.day(r, { width: "short", context: "formatting" })
					case "iiii":
					default:
						return n.day(r, { width: "wide", context: "formatting" })
				}
			},
			a: function (e, t, n) {
				const i = e.getHours() / 12 >= 1 ? "pm" : "am"
				switch (t) {
					case "a":
					case "aa":
						return n.dayPeriod(i, { width: "abbreviated", context: "formatting" })
					case "aaa":
						return n.dayPeriod(i, { width: "abbreviated", context: "formatting" }).toLowerCase()
					case "aaaaa":
						return n.dayPeriod(i, { width: "narrow", context: "formatting" })
					case "aaaa":
					default:
						return n.dayPeriod(i, { width: "wide", context: "formatting" })
				}
			},
			b: function (e, t, n) {
				const r = e.getHours()
				let i
				switch (
					(r === 12 ? (i = Sf.noon) : r === 0 ? (i = Sf.midnight) : (i = r / 12 >= 1 ? "pm" : "am"),
					t)
				) {
					case "b":
					case "bb":
						return n.dayPeriod(i, { width: "abbreviated", context: "formatting" })
					case "bbb":
						return n.dayPeriod(i, { width: "abbreviated", context: "formatting" }).toLowerCase()
					case "bbbbb":
						return n.dayPeriod(i, { width: "narrow", context: "formatting" })
					case "bbbb":
					default:
						return n.dayPeriod(i, { width: "wide", context: "formatting" })
				}
			},
			B: function (e, t, n) {
				const r = e.getHours()
				let i
				switch (
					(r >= 17
						? (i = Sf.evening)
						: r >= 12
						? (i = Sf.afternoon)
						: r >= 4
						? (i = Sf.morning)
						: (i = Sf.night),
					t)
				) {
					case "B":
					case "BB":
					case "BBB":
						return n.dayPeriod(i, { width: "abbreviated", context: "formatting" })
					case "BBBBB":
						return n.dayPeriod(i, { width: "narrow", context: "formatting" })
					case "BBBB":
					default:
						return n.dayPeriod(i, { width: "wide", context: "formatting" })
				}
			},
			h: function (e, t, n) {
				if (t === "ho") {
					let r = e.getHours() % 12
					return r === 0 && (r = 12), n.ordinalNumber(r, { unit: "hour" })
				}
				return su.h(e, t)
			},
			H: function (e, t, n) {
				return t === "Ho" ? n.ordinalNumber(e.getHours(), { unit: "hour" }) : su.H(e, t)
			},
			K: function (e, t, n) {
				const r = e.getHours() % 12
				return t === "Ko" ? n.ordinalNumber(r, { unit: "hour" }) : en(r, t.length)
			},
			k: function (e, t, n) {
				let r = e.getHours()
				return (
					r === 0 && (r = 24), t === "ko" ? n.ordinalNumber(r, { unit: "hour" }) : en(r, t.length)
				)
			},
			m: function (e, t, n) {
				return t === "mo" ? n.ordinalNumber(e.getMinutes(), { unit: "minute" }) : su.m(e, t)
			},
			s: function (e, t, n) {
				return t === "so" ? n.ordinalNumber(e.getSeconds(), { unit: "second" }) : su.s(e, t)
			},
			S: function (e, t) {
				return su.S(e, t)
			},
			X: function (e, t, n) {
				const r = e.getTimezoneOffset()
				if (r === 0) return "Z"
				switch (t) {
					case "X":
						return E5(r)
					case "XXXX":
					case "XX":
						return Nc(r)
					case "XXXXX":
					case "XXX":
					default:
						return Nc(r, ":")
				}
			},
			x: function (e, t, n) {
				const r = e.getTimezoneOffset()
				switch (t) {
					case "x":
						return E5(r)
					case "xxxx":
					case "xx":
						return Nc(r)
					case "xxxxx":
					case "xxx":
					default:
						return Nc(r, ":")
				}
			},
			O: function (e, t, n) {
				const r = e.getTimezoneOffset()
				switch (t) {
					case "O":
					case "OO":
					case "OOO":
						return "GMT" + w5(r, ":")
					case "OOOO":
					default:
						return "GMT" + Nc(r, ":")
				}
			},
			z: function (e, t, n) {
				const r = e.getTimezoneOffset()
				switch (t) {
					case "z":
					case "zz":
					case "zzz":
						return "GMT" + w5(r, ":")
					case "zzzz":
					default:
						return "GMT" + Nc(r, ":")
				}
			},
			t: function (e, t, n) {
				const r = Math.trunc(e.getTime() / 1e3)
				return en(r, t.length)
			},
			T: function (e, t, n) {
				const r = e.getTime()
				return en(r, t.length)
			},
		}
	function w5(e, t = "") {
		const n = e > 0 ? "-" : "+",
			r = Math.abs(e),
			i = Math.trunc(r / 60),
			a = r % 60
		return a === 0 ? n + String(i) : n + String(i) + t + en(a, 2)
	}
	function E5(e, t) {
		return e % 60 === 0 ? (e > 0 ? "-" : "+") + en(Math.abs(e) / 60, 2) : Nc(e, t)
	}
	function Nc(e, t = "") {
		const n = e > 0 ? "-" : "+",
			r = Math.abs(e),
			i = en(Math.trunc(r / 60), 2),
			a = en(r % 60, 2)
		return n + i + t + a
	}
	const C5 = (e, t) => {
			switch (e) {
				case "P":
					return t.date({ width: "short" })
				case "PP":
					return t.date({ width: "medium" })
				case "PPP":
					return t.date({ width: "long" })
				case "PPPP":
				default:
					return t.date({ width: "full" })
			}
		},
		zY = (e, t) => {
			switch (e) {
				case "p":
					return t.time({ width: "short" })
				case "pp":
					return t.time({ width: "medium" })
				case "ppp":
					return t.time({ width: "long" })
				case "pppp":
				default:
					return t.time({ width: "full" })
			}
		},
		iwt = (e, t) => {
			const n = e.match(/(P+)(p+)?/) || [],
				r = n[1],
				i = n[2]
			if (!i) return C5(e, t)
			let a
			switch (r) {
				case "P":
					a = t.dateTime({ width: "short" })
					break
				case "PP":
					a = t.dateTime({ width: "medium" })
					break
				case "PPP":
					a = t.dateTime({ width: "long" })
					break
				case "PPPP":
				default:
					a = t.dateTime({ width: "full" })
					break
			}
			return a.replace("{{date}}", C5(r, t)).replace("{{time}}", zY(i, t))
		},
		Jb = { p: zY, P: iwt },
		awt = /^D+$/,
		owt = /^Y+$/,
		swt = ["D", "DD", "YY", "YYYY"]
	function qY(e) {
		return awt.test(e)
	}
	function VY(e) {
		return owt.test(e)
	}
	function ND(e, t, n) {
		const r = lwt(e, t, n)
		if ((console.warn(r), swt.includes(e))) throw new RangeError(r)
	}
	function lwt(e, t, n) {
		const r = e[0] === "Y" ? "years" : "days of the month"
		return `Use \`${e.toLowerCase()}\` instead of \`${e}\` (in \`${t}\`) for formatting ${r} to the input \`${n}\`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md`
	}
	const uwt = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g,
		cwt = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g,
		dwt = /^'([^]*?)'?$/,
		fwt = /''/g,
		pwt = /[a-zA-Z]/
	function T5(e, t, n) {
		var d, p, m, v, y, b, x, E
		const r = Bd(),
			i = (n == null ? void 0 : n.locale) ?? r.locale ?? $Y,
			a =
				(n == null ? void 0 : n.firstWeekContainsDate) ??
				((p = (d = n == null ? void 0 : n.locale) == null ? void 0 : d.options) == null
					? void 0
					: p.firstWeekContainsDate) ??
				r.firstWeekContainsDate ??
				((v = (m = r.locale) == null ? void 0 : m.options) == null
					? void 0
					: v.firstWeekContainsDate) ??
				1,
			o =
				(n == null ? void 0 : n.weekStartsOn) ??
				((b = (y = n == null ? void 0 : n.locale) == null ? void 0 : y.options) == null
					? void 0
					: b.weekStartsOn) ??
				r.weekStartsOn ??
				((E = (x = r.locale) == null ? void 0 : x.options) == null ? void 0 : E.weekStartsOn) ??
				0,
			s = ze(e)
		if (!Gb(s)) throw new RangeError("Invalid time value")
		let l = t
			.match(cwt)
			.map((T) => {
				const C = T[0]
				if (C === "p" || C === "P") {
					const D = Jb[C]
					return D(T, i.formatLong)
				}
				return T
			})
			.join("")
			.match(uwt)
			.map((T) => {
				if (T === "''") return { isToken: !1, value: "'" }
				const C = T[0]
				if (C === "'") return { isToken: !1, value: hwt(T) }
				if (x5[C]) return { isToken: !0, value: T }
				if (C.match(pwt))
					throw new RangeError(
						"Format string contains an unescaped latin alphabet character `" + C + "`",
					)
				return { isToken: !1, value: T }
			})
		i.localize.preprocessor && (l = i.localize.preprocessor(s, l))
		const u = { firstWeekContainsDate: a, weekStartsOn: o, locale: i }
		return l
			.map((T) => {
				if (!T.isToken) return T.value
				const C = T.value
				;((!(n != null && n.useAdditionalWeekYearTokens) && VY(C)) ||
					(!(n != null && n.useAdditionalDayOfYearTokens) && qY(C))) &&
					ND(C, t, String(e))
				const D = x5[C[0]]
				return D(s, C, i.localize, u)
			})
			.join("")
	}
	function hwt(e) {
		const t = e.match(dwt)
		return t ? t[1].replace(fwt, "'") : e
	}
	function k5(e) {
		return ze(e).getDate()
	}
	function mwt(e) {
		return ze(e).getDay()
	}
	function vwt(e) {
		const t = ze(e),
			n = t.getFullYear(),
			r = t.getMonth(),
			i = nn(e, 0)
		return i.setFullYear(n, r + 1, 0), i.setHours(0, 0, 0, 0), i.getDate()
	}
	function gwt() {
		return Object.assign({}, Bd())
	}
	function us(e) {
		return ze(e).getHours()
	}
	function ywt(e) {
		let n = ze(e).getDay()
		return n === 0 && (n = 7), n
	}
	function cs(e) {
		return ze(e).getMinutes()
	}
	function bi(e) {
		return ze(e).getMonth()
	}
	function vl(e) {
		return ze(e).getSeconds()
	}
	function MD(e) {
		return ze(e).getTime()
	}
	function Tt(e) {
		return ze(e).getFullYear()
	}
	function Vu(e, t) {
		const n = ze(e),
			r = ze(t)
		return n.getTime() > r.getTime()
	}
	function Sd(e, t) {
		const n = ze(e),
			r = ze(t)
		return +n < +r
	}
	function bwt(e, t) {
		const n = ze(e),
			r = ze(t)
		return +n == +r
	}
	function xwt(e, t) {
		const n = t instanceof Date ? nn(t, 0) : new t(0)
		return (
			n.setFullYear(e.getFullYear(), e.getMonth(), e.getDate()),
			n.setHours(e.getHours(), e.getMinutes(), e.getSeconds(), e.getMilliseconds()),
			n
		)
	}
	const wwt = 10
	class WY {
		constructor() {
			q(this, "subPriority", 0)
		}
		validate(t, n) {
			return !0
		}
	}
	class Ewt extends WY {
		constructor(t, n, r, i, a) {
			super(),
				(this.value = t),
				(this.validateValue = n),
				(this.setValue = r),
				(this.priority = i),
				a && (this.subPriority = a)
		}
		validate(t, n) {
			return this.validateValue(t, this.value, n)
		}
		set(t, n, r) {
			return this.setValue(t, n, this.value, r)
		}
	}
	class Cwt extends WY {
		constructor() {
			super(...arguments)
			q(this, "priority", wwt)
			q(this, "subPriority", -1)
		}
		set(n, r) {
			return r.timestampIsSet ? n : nn(n, xwt(n, Date))
		}
	}
	class Yt {
		run(t, n, r, i) {
			const a = this.parse(t, n, r, i)
			return a
				? {
						setter: new Ewt(a.value, this.validate, this.set, this.priority, this.subPriority),
						rest: a.rest,
				  }
				: null
		}
		validate(t, n, r) {
			return !0
		}
	}
	class Twt extends Yt {
		constructor() {
			super(...arguments)
			q(this, "priority", 140)
			q(this, "incompatibleTokens", ["R", "u", "t", "T"])
		}
		parse(n, r, i) {
			switch (r) {
				case "G":
				case "GG":
				case "GGG":
					return i.era(n, { width: "abbreviated" }) || i.era(n, { width: "narrow" })
				case "GGGGG":
					return i.era(n, { width: "narrow" })
				case "GGGG":
				default:
					return (
						i.era(n, { width: "wide" }) ||
						i.era(n, { width: "abbreviated" }) ||
						i.era(n, { width: "narrow" })
					)
			}
		}
		set(n, r, i) {
			return (r.era = i), n.setFullYear(i, 0, 1), n.setHours(0, 0, 0, 0), n
		}
	}
	const Zn = {
			month: /^(1[0-2]|0?\d)/,
			date: /^(3[0-1]|[0-2]?\d)/,
			dayOfYear: /^(36[0-6]|3[0-5]\d|[0-2]?\d?\d)/,
			week: /^(5[0-3]|[0-4]?\d)/,
			hour23h: /^(2[0-3]|[0-1]?\d)/,
			hour24h: /^(2[0-4]|[0-1]?\d)/,
			hour11h: /^(1[0-1]|0?\d)/,
			hour12h: /^(1[0-2]|0?\d)/,
			minute: /^[0-5]?\d/,
			second: /^[0-5]?\d/,
			singleDigit: /^\d/,
			twoDigits: /^\d{1,2}/,
			threeDigits: /^\d{1,3}/,
			fourDigits: /^\d{1,4}/,
			anyDigitsSigned: /^-?\d+/,
			singleDigitSigned: /^-?\d/,
			twoDigitsSigned: /^-?\d{1,2}/,
			threeDigitsSigned: /^-?\d{1,3}/,
			fourDigitsSigned: /^-?\d{1,4}/,
		},
		ts = {
			basicOptionalMinutes: /^([+-])(\d{2})(\d{2})?|Z/,
			basic: /^([+-])(\d{2})(\d{2})|Z/,
			basicOptionalSeconds: /^([+-])(\d{2})(\d{2})((\d{2}))?|Z/,
			extended: /^([+-])(\d{2}):(\d{2})|Z/,
			extendedOptionalSeconds: /^([+-])(\d{2}):(\d{2})(:(\d{2}))?|Z/,
		}
	function er(e, t) {
		return e && { value: t(e.value), rest: e.rest }
	}
	function Pn(e, t) {
		const n = t.match(e)
		return n ? { value: parseInt(n[0], 10), rest: t.slice(n[0].length) } : null
	}
	function ns(e, t) {
		const n = t.match(e)
		if (!n) return null
		if (n[0] === "Z") return { value: 0, rest: t.slice(1) }
		const r = n[1] === "+" ? 1 : -1,
			i = n[2] ? parseInt(n[2], 10) : 0,
			a = n[3] ? parseInt(n[3], 10) : 0,
			o = n[5] ? parseInt(n[5], 10) : 0
		return { value: r * (i * Pw + a * Lw + o * vxt), rest: t.slice(n[0].length) }
	}
	function YY(e) {
		return Pn(Zn.anyDigitsSigned, e)
	}
	function qn(e, t) {
		switch (e) {
			case 1:
				return Pn(Zn.singleDigit, t)
			case 2:
				return Pn(Zn.twoDigits, t)
			case 3:
				return Pn(Zn.threeDigits, t)
			case 4:
				return Pn(Zn.fourDigits, t)
			default:
				return Pn(new RegExp("^\\d{1," + e + "}"), t)
		}
	}
	function Zb(e, t) {
		switch (e) {
			case 1:
				return Pn(Zn.singleDigitSigned, t)
			case 2:
				return Pn(Zn.twoDigitsSigned, t)
			case 3:
				return Pn(Zn.threeDigitsSigned, t)
			case 4:
				return Pn(Zn.fourDigitsSigned, t)
			default:
				return Pn(new RegExp("^-?\\d{1," + e + "}"), t)
		}
	}
	function tN(e) {
		switch (e) {
			case "morning":
				return 4
			case "evening":
				return 17
			case "pm":
			case "noon":
			case "afternoon":
				return 12
			case "am":
			case "midnight":
			case "night":
			default:
				return 0
		}
	}
	function GY(e, t) {
		const n = t > 0,
			r = n ? t : 1 - t
		let i
		if (r <= 50) i = e || 100
		else {
			const a = r + 50,
				o = Math.trunc(a / 100) * 100,
				s = e >= a % 100
			i = e + o - (s ? 100 : 0)
		}
		return n ? i : 1 - i
	}
	function KY(e) {
		return e % 400 === 0 || (e % 4 === 0 && e % 100 !== 0)
	}
	class kwt extends Yt {
		constructor() {
			super(...arguments)
			q(this, "priority", 130)
			q(this, "incompatibleTokens", ["Y", "R", "u", "w", "I", "i", "e", "c", "t", "T"])
		}
		parse(n, r, i) {
			const a = (o) => ({ year: o, isTwoDigitYear: r === "yy" })
			switch (r) {
				case "y":
					return er(qn(4, n), a)
				case "yo":
					return er(i.ordinalNumber(n, { unit: "year" }), a)
				default:
					return er(qn(r.length, n), a)
			}
		}
		validate(n, r) {
			return r.isTwoDigitYear || r.year > 0
		}
		set(n, r, i) {
			const a = n.getFullYear()
			if (i.isTwoDigitYear) {
				const s = GY(i.year, a)
				return n.setFullYear(s, 0, 1), n.setHours(0, 0, 0, 0), n
			}
			const o = !("era" in r) || r.era === 1 ? i.year : 1 - i.year
			return n.setFullYear(o, 0, 1), n.setHours(0, 0, 0, 0), n
		}
	}
	class Swt extends Yt {
		constructor() {
			super(...arguments)
			q(this, "priority", 130)
			q(this, "incompatibleTokens", [
				"y",
				"R",
				"u",
				"Q",
				"q",
				"M",
				"L",
				"I",
				"d",
				"D",
				"i",
				"t",
				"T",
			])
		}
		parse(n, r, i) {
			const a = (o) => ({ year: o, isTwoDigitYear: r === "YY" })
			switch (r) {
				case "Y":
					return er(qn(4, n), a)
				case "Yo":
					return er(i.ordinalNumber(n, { unit: "year" }), a)
				default:
					return er(qn(r.length, n), a)
			}
		}
		validate(n, r) {
			return r.isTwoDigitYear || r.year > 0
		}
		set(n, r, i, a) {
			const o = eN(n, a)
			if (i.isTwoDigitYear) {
				const l = GY(i.year, o)
				return n.setFullYear(l, 0, a.firstWeekContainsDate), n.setHours(0, 0, 0, 0), kl(n, a)
			}
			const s = !("era" in r) || r.era === 1 ? i.year : 1 - i.year
			return n.setFullYear(s, 0, a.firstWeekContainsDate), n.setHours(0, 0, 0, 0), kl(n, a)
		}
	}
	class Dwt extends Yt {
		constructor() {
			super(...arguments)
			q(this, "priority", 130)
			q(this, "incompatibleTokens", [
				"G",
				"y",
				"Y",
				"u",
				"Q",
				"q",
				"M",
				"L",
				"w",
				"d",
				"D",
				"e",
				"c",
				"t",
				"T",
			])
		}
		parse(n, r) {
			return Zb(r === "R" ? 4 : r.length, n)
		}
		set(n, r, i) {
			const a = nn(n, 0)
			return a.setFullYear(i, 0, 4), a.setHours(0, 0, 0, 0), Rp(a)
		}
	}
	class _wt extends Yt {
		constructor() {
			super(...arguments)
			q(this, "priority", 130)
			q(this, "incompatibleTokens", ["G", "y", "Y", "R", "w", "I", "i", "e", "c", "t", "T"])
		}
		parse(n, r) {
			return Zb(r === "u" ? 4 : r.length, n)
		}
		set(n, r, i) {
			return n.setFullYear(i, 0, 1), n.setHours(0, 0, 0, 0), n
		}
	}
	class Owt extends Yt {
		constructor() {
			super(...arguments)
			q(this, "priority", 120)
			q(this, "incompatibleTokens", [
				"Y",
				"R",
				"q",
				"M",
				"L",
				"w",
				"I",
				"d",
				"D",
				"i",
				"e",
				"c",
				"t",
				"T",
			])
		}
		parse(n, r, i) {
			switch (r) {
				case "Q":
				case "QQ":
					return qn(r.length, n)
				case "Qo":
					return i.ordinalNumber(n, { unit: "quarter" })
				case "QQQ":
					return (
						i.quarter(n, { width: "abbreviated", context: "formatting" }) ||
						i.quarter(n, { width: "narrow", context: "formatting" })
					)
				case "QQQQQ":
					return i.quarter(n, { width: "narrow", context: "formatting" })
				case "QQQQ":
				default:
					return (
						i.quarter(n, { width: "wide", context: "formatting" }) ||
						i.quarter(n, { width: "abbreviated", context: "formatting" }) ||
						i.quarter(n, { width: "narrow", context: "formatting" })
					)
			}
		}
		validate(n, r) {
			return r >= 1 && r <= 4
		}
		set(n, r, i) {
			return n.setMonth((i - 1) * 3, 1), n.setHours(0, 0, 0, 0), n
		}
	}
	class Awt extends Yt {
		constructor() {
			super(...arguments)
			q(this, "priority", 120)
			q(this, "incompatibleTokens", [
				"Y",
				"R",
				"Q",
				"M",
				"L",
				"w",
				"I",
				"d",
				"D",
				"i",
				"e",
				"c",
				"t",
				"T",
			])
		}
		parse(n, r, i) {
			switch (r) {
				case "q":
				case "qq":
					return qn(r.length, n)
				case "qo":
					return i.ordinalNumber(n, { unit: "quarter" })
				case "qqq":
					return (
						i.quarter(n, { width: "abbreviated", context: "standalone" }) ||
						i.quarter(n, { width: "narrow", context: "standalone" })
					)
				case "qqqqq":
					return i.quarter(n, { width: "narrow", context: "standalone" })
				case "qqqq":
				default:
					return (
						i.quarter(n, { width: "wide", context: "standalone" }) ||
						i.quarter(n, { width: "abbreviated", context: "standalone" }) ||
						i.quarter(n, { width: "narrow", context: "standalone" })
					)
			}
		}
		validate(n, r) {
			return r >= 1 && r <= 4
		}
		set(n, r, i) {
			return n.setMonth((i - 1) * 3, 1), n.setHours(0, 0, 0, 0), n
		}
	}
	class Nwt extends Yt {
		constructor() {
			super(...arguments)
			q(this, "incompatibleTokens", [
				"Y",
				"R",
				"q",
				"Q",
				"L",
				"w",
				"I",
				"D",
				"i",
				"e",
				"c",
				"t",
				"T",
			])
			q(this, "priority", 110)
		}
		parse(n, r, i) {
			const a = (o) => o - 1
			switch (r) {
				case "M":
					return er(Pn(Zn.month, n), a)
				case "MM":
					return er(qn(2, n), a)
				case "Mo":
					return er(i.ordinalNumber(n, { unit: "month" }), a)
				case "MMM":
					return (
						i.month(n, { width: "abbreviated", context: "formatting" }) ||
						i.month(n, { width: "narrow", context: "formatting" })
					)
				case "MMMMM":
					return i.month(n, { width: "narrow", context: "formatting" })
				case "MMMM":
				default:
					return (
						i.month(n, { width: "wide", context: "formatting" }) ||
						i.month(n, { width: "abbreviated", context: "formatting" }) ||
						i.month(n, { width: "narrow", context: "formatting" })
					)
			}
		}
		validate(n, r) {
			return r >= 0 && r <= 11
		}
		set(n, r, i) {
			return n.setMonth(i, 1), n.setHours(0, 0, 0, 0), n
		}
	}
	class Mwt extends Yt {
		constructor() {
			super(...arguments)
			q(this, "priority", 110)
			q(this, "incompatibleTokens", [
				"Y",
				"R",
				"q",
				"Q",
				"M",
				"w",
				"I",
				"D",
				"i",
				"e",
				"c",
				"t",
				"T",
			])
		}
		parse(n, r, i) {
			const a = (o) => o - 1
			switch (r) {
				case "L":
					return er(Pn(Zn.month, n), a)
				case "LL":
					return er(qn(2, n), a)
				case "Lo":
					return er(i.ordinalNumber(n, { unit: "month" }), a)
				case "LLL":
					return (
						i.month(n, { width: "abbreviated", context: "standalone" }) ||
						i.month(n, { width: "narrow", context: "standalone" })
					)
				case "LLLLL":
					return i.month(n, { width: "narrow", context: "standalone" })
				case "LLLL":
				default:
					return (
						i.month(n, { width: "wide", context: "standalone" }) ||
						i.month(n, { width: "abbreviated", context: "standalone" }) ||
						i.month(n, { width: "narrow", context: "standalone" })
					)
			}
		}
		validate(n, r) {
			return r >= 0 && r <= 11
		}
		set(n, r, i) {
			return n.setMonth(i, 1), n.setHours(0, 0, 0, 0), n
		}
	}
	function Iwt(e, t, n) {
		const r = ze(e),
			i = UY(r, n) - t
		return r.setDate(r.getDate() - i * 7), r
	}
	class Rwt extends Yt {
		constructor() {
			super(...arguments)
			q(this, "priority", 100)
			q(this, "incompatibleTokens", [
				"y",
				"R",
				"u",
				"q",
				"Q",
				"M",
				"L",
				"I",
				"d",
				"D",
				"i",
				"t",
				"T",
			])
		}
		parse(n, r, i) {
			switch (r) {
				case "w":
					return Pn(Zn.week, n)
				case "wo":
					return i.ordinalNumber(n, { unit: "week" })
				default:
					return qn(r.length, n)
			}
		}
		validate(n, r) {
			return r >= 1 && r <= 53
		}
		set(n, r, i, a) {
			return kl(Iwt(n, i, a), a)
		}
	}
	function Lwt(e, t) {
		const n = ze(e),
			r = ZA(n) - t
		return n.setDate(n.getDate() - r * 7), n
	}
	class Pwt extends Yt {
		constructor() {
			super(...arguments)
			q(this, "priority", 100)
			q(this, "incompatibleTokens", [
				"y",
				"Y",
				"u",
				"q",
				"Q",
				"M",
				"L",
				"w",
				"d",
				"D",
				"e",
				"c",
				"t",
				"T",
			])
		}
		parse(n, r, i) {
			switch (r) {
				case "I":
					return Pn(Zn.week, n)
				case "Io":
					return i.ordinalNumber(n, { unit: "week" })
				default:
					return qn(r.length, n)
			}
		}
		validate(n, r) {
			return r >= 1 && r <= 53
		}
		set(n, r, i) {
			return Rp(Lwt(n, i))
		}
	}
	const jwt = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],
		Fwt = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
	class Bwt extends Yt {
		constructor() {
			super(...arguments)
			q(this, "priority", 90)
			q(this, "subPriority", 1)
			q(this, "incompatibleTokens", ["Y", "R", "q", "Q", "w", "I", "D", "i", "e", "c", "t", "T"])
		}
		parse(n, r, i) {
			switch (r) {
				case "d":
					return Pn(Zn.date, n)
				case "do":
					return i.ordinalNumber(n, { unit: "date" })
				default:
					return qn(r.length, n)
			}
		}
		validate(n, r) {
			const i = n.getFullYear(),
				a = KY(i),
				o = n.getMonth()
			return a ? r >= 1 && r <= Fwt[o] : r >= 1 && r <= jwt[o]
		}
		set(n, r, i) {
			return n.setDate(i), n.setHours(0, 0, 0, 0), n
		}
	}
	class Hwt extends Yt {
		constructor() {
			super(...arguments)
			q(this, "priority", 90)
			q(this, "subpriority", 1)
			q(this, "incompatibleTokens", [
				"Y",
				"R",
				"q",
				"Q",
				"M",
				"L",
				"w",
				"I",
				"d",
				"E",
				"i",
				"e",
				"c",
				"t",
				"T",
			])
		}
		parse(n, r, i) {
			switch (r) {
				case "D":
				case "DD":
					return Pn(Zn.dayOfYear, n)
				case "Do":
					return i.ordinalNumber(n, { unit: "date" })
				default:
					return qn(r.length, n)
			}
		}
		validate(n, r) {
			const i = n.getFullYear()
			return KY(i) ? r >= 1 && r <= 366 : r >= 1 && r <= 365
		}
		set(n, r, i) {
			return n.setMonth(0, i), n.setHours(0, 0, 0, 0), n
		}
	}
	function nN(e, t, n) {
		var p, m, v, y
		const r = Bd(),
			i =
				(n == null ? void 0 : n.weekStartsOn) ??
				((m = (p = n == null ? void 0 : n.locale) == null ? void 0 : p.options) == null
					? void 0
					: m.weekStartsOn) ??
				r.weekStartsOn ??
				((y = (v = r.locale) == null ? void 0 : v.options) == null ? void 0 : y.weekStartsOn) ??
				0,
			a = ze(e),
			o = a.getDay(),
			l = ((t % 7) + 7) % 7,
			u = 7 - i,
			d = t < 0 || t > 6 ? t - ((o + u) % 7) : ((l + u) % 7) - ((o + u) % 7)
		return Tl(a, d)
	}
	class $wt extends Yt {
		constructor() {
			super(...arguments)
			q(this, "priority", 90)
			q(this, "incompatibleTokens", ["D", "i", "e", "c", "t", "T"])
		}
		parse(n, r, i) {
			switch (r) {
				case "E":
				case "EE":
				case "EEE":
					return (
						i.day(n, { width: "abbreviated", context: "formatting" }) ||
						i.day(n, { width: "short", context: "formatting" }) ||
						i.day(n, { width: "narrow", context: "formatting" })
					)
				case "EEEEE":
					return i.day(n, { width: "narrow", context: "formatting" })
				case "EEEEEE":
					return (
						i.day(n, { width: "short", context: "formatting" }) ||
						i.day(n, { width: "narrow", context: "formatting" })
					)
				case "EEEE":
				default:
					return (
						i.day(n, { width: "wide", context: "formatting" }) ||
						i.day(n, { width: "abbreviated", context: "formatting" }) ||
						i.day(n, { width: "short", context: "formatting" }) ||
						i.day(n, { width: "narrow", context: "formatting" })
					)
			}
		}
		validate(n, r) {
			return r >= 0 && r <= 6
		}
		set(n, r, i, a) {
			return (n = nN(n, i, a)), n.setHours(0, 0, 0, 0), n
		}
	}
	class Uwt extends Yt {
		constructor() {
			super(...arguments)
			q(this, "priority", 90)
			q(this, "incompatibleTokens", [
				"y",
				"R",
				"u",
				"q",
				"Q",
				"M",
				"L",
				"I",
				"d",
				"D",
				"E",
				"i",
				"c",
				"t",
				"T",
			])
		}
		parse(n, r, i, a) {
			const o = (s) => {
				const l = Math.floor((s - 1) / 7) * 7
				return ((s + a.weekStartsOn + 6) % 7) + l
			}
			switch (r) {
				case "e":
				case "ee":
					return er(qn(r.length, n), o)
				case "eo":
					return er(i.ordinalNumber(n, { unit: "day" }), o)
				case "eee":
					return (
						i.day(n, { width: "abbreviated", context: "formatting" }) ||
						i.day(n, { width: "short", context: "formatting" }) ||
						i.day(n, { width: "narrow", context: "formatting" })
					)
				case "eeeee":
					return i.day(n, { width: "narrow", context: "formatting" })
				case "eeeeee":
					return (
						i.day(n, { width: "short", context: "formatting" }) ||
						i.day(n, { width: "narrow", context: "formatting" })
					)
				case "eeee":
				default:
					return (
						i.day(n, { width: "wide", context: "formatting" }) ||
						i.day(n, { width: "abbreviated", context: "formatting" }) ||
						i.day(n, { width: "short", context: "formatting" }) ||
						i.day(n, { width: "narrow", context: "formatting" })
					)
			}
		}
		validate(n, r) {
			return r >= 0 && r <= 6
		}
		set(n, r, i, a) {
			return (n = nN(n, i, a)), n.setHours(0, 0, 0, 0), n
		}
	}
	class zwt extends Yt {
		constructor() {
			super(...arguments)
			q(this, "priority", 90)
			q(this, "incompatibleTokens", [
				"y",
				"R",
				"u",
				"q",
				"Q",
				"M",
				"L",
				"I",
				"d",
				"D",
				"E",
				"i",
				"e",
				"t",
				"T",
			])
		}
		parse(n, r, i, a) {
			const o = (s) => {
				const l = Math.floor((s - 1) / 7) * 7
				return ((s + a.weekStartsOn + 6) % 7) + l
			}
			switch (r) {
				case "c":
				case "cc":
					return er(qn(r.length, n), o)
				case "co":
					return er(i.ordinalNumber(n, { unit: "day" }), o)
				case "ccc":
					return (
						i.day(n, { width: "abbreviated", context: "standalone" }) ||
						i.day(n, { width: "short", context: "standalone" }) ||
						i.day(n, { width: "narrow", context: "standalone" })
					)
				case "ccccc":
					return i.day(n, { width: "narrow", context: "standalone" })
				case "cccccc":
					return (
						i.day(n, { width: "short", context: "standalone" }) ||
						i.day(n, { width: "narrow", context: "standalone" })
					)
				case "cccc":
				default:
					return (
						i.day(n, { width: "wide", context: "standalone" }) ||
						i.day(n, { width: "abbreviated", context: "standalone" }) ||
						i.day(n, { width: "short", context: "standalone" }) ||
						i.day(n, { width: "narrow", context: "standalone" })
					)
			}
		}
		validate(n, r) {
			return r >= 0 && r <= 6
		}
		set(n, r, i, a) {
			return (n = nN(n, i, a)), n.setHours(0, 0, 0, 0), n
		}
	}
	function qwt(e, t) {
		const n = ze(e),
			r = ywt(n),
			i = t - r
		return Tl(n, i)
	}
	class Vwt extends Yt {
		constructor() {
			super(...arguments)
			q(this, "priority", 90)
			q(this, "incompatibleTokens", [
				"y",
				"Y",
				"u",
				"q",
				"Q",
				"M",
				"L",
				"w",
				"d",
				"D",
				"E",
				"e",
				"c",
				"t",
				"T",
			])
		}
		parse(n, r, i) {
			const a = (o) => (o === 0 ? 7 : o)
			switch (r) {
				case "i":
				case "ii":
					return qn(r.length, n)
				case "io":
					return i.ordinalNumber(n, { unit: "day" })
				case "iii":
					return er(
						i.day(n, { width: "abbreviated", context: "formatting" }) ||
							i.day(n, { width: "short", context: "formatting" }) ||
							i.day(n, { width: "narrow", context: "formatting" }),
						a,
					)
				case "iiiii":
					return er(i.day(n, { width: "narrow", context: "formatting" }), a)
				case "iiiiii":
					return er(
						i.day(n, { width: "short", context: "formatting" }) ||
							i.day(n, { width: "narrow", context: "formatting" }),
						a,
					)
				case "iiii":
				default:
					return er(
						i.day(n, { width: "wide", context: "formatting" }) ||
							i.day(n, { width: "abbreviated", context: "formatting" }) ||
							i.day(n, { width: "short", context: "formatting" }) ||
							i.day(n, { width: "narrow", context: "formatting" }),
						a,
					)
			}
		}
		validate(n, r) {
			return r >= 1 && r <= 7
		}
		set(n, r, i) {
			return (n = qwt(n, i)), n.setHours(0, 0, 0, 0), n
		}
	}
	class Wwt extends Yt {
		constructor() {
			super(...arguments)
			q(this, "priority", 80)
			q(this, "incompatibleTokens", ["b", "B", "H", "k", "t", "T"])
		}
		parse(n, r, i) {
			switch (r) {
				case "a":
				case "aa":
				case "aaa":
					return (
						i.dayPeriod(n, { width: "abbreviated", context: "formatting" }) ||
						i.dayPeriod(n, { width: "narrow", context: "formatting" })
					)
				case "aaaaa":
					return i.dayPeriod(n, { width: "narrow", context: "formatting" })
				case "aaaa":
				default:
					return (
						i.dayPeriod(n, { width: "wide", context: "formatting" }) ||
						i.dayPeriod(n, { width: "abbreviated", context: "formatting" }) ||
						i.dayPeriod(n, { width: "narrow", context: "formatting" })
					)
			}
		}
		set(n, r, i) {
			return n.setHours(tN(i), 0, 0, 0), n
		}
	}
	class Ywt extends Yt {
		constructor() {
			super(...arguments)
			q(this, "priority", 80)
			q(this, "incompatibleTokens", ["a", "B", "H", "k", "t", "T"])
		}
		parse(n, r, i) {
			switch (r) {
				case "b":
				case "bb":
				case "bbb":
					return (
						i.dayPeriod(n, { width: "abbreviated", context: "formatting" }) ||
						i.dayPeriod(n, { width: "narrow", context: "formatting" })
					)
				case "bbbbb":
					return i.dayPeriod(n, { width: "narrow", context: "formatting" })
				case "bbbb":
				default:
					return (
						i.dayPeriod(n, { width: "wide", context: "formatting" }) ||
						i.dayPeriod(n, { width: "abbreviated", context: "formatting" }) ||
						i.dayPeriod(n, { width: "narrow", context: "formatting" })
					)
			}
		}
		set(n, r, i) {
			return n.setHours(tN(i), 0, 0, 0), n
		}
	}
	class Gwt extends Yt {
		constructor() {
			super(...arguments)
			q(this, "priority", 80)
			q(this, "incompatibleTokens", ["a", "b", "t", "T"])
		}
		parse(n, r, i) {
			switch (r) {
				case "B":
				case "BB":
				case "BBB":
					return (
						i.dayPeriod(n, { width: "abbreviated", context: "formatting" }) ||
						i.dayPeriod(n, { width: "narrow", context: "formatting" })
					)
				case "BBBBB":
					return i.dayPeriod(n, { width: "narrow", context: "formatting" })
				case "BBBB":
				default:
					return (
						i.dayPeriod(n, { width: "wide", context: "formatting" }) ||
						i.dayPeriod(n, { width: "abbreviated", context: "formatting" }) ||
						i.dayPeriod(n, { width: "narrow", context: "formatting" })
					)
			}
		}
		set(n, r, i) {
			return n.setHours(tN(i), 0, 0, 0), n
		}
	}
	class Kwt extends Yt {
		constructor() {
			super(...arguments)
			q(this, "priority", 70)
			q(this, "incompatibleTokens", ["H", "K", "k", "t", "T"])
		}
		parse(n, r, i) {
			switch (r) {
				case "h":
					return Pn(Zn.hour12h, n)
				case "ho":
					return i.ordinalNumber(n, { unit: "hour" })
				default:
					return qn(r.length, n)
			}
		}
		validate(n, r) {
			return r >= 1 && r <= 12
		}
		set(n, r, i) {
			const a = n.getHours() >= 12
			return (
				a && i < 12
					? n.setHours(i + 12, 0, 0, 0)
					: !a && i === 12
					? n.setHours(0, 0, 0, 0)
					: n.setHours(i, 0, 0, 0),
				n
			)
		}
	}
	class Qwt extends Yt {
		constructor() {
			super(...arguments)
			q(this, "priority", 70)
			q(this, "incompatibleTokens", ["a", "b", "h", "K", "k", "t", "T"])
		}
		parse(n, r, i) {
			switch (r) {
				case "H":
					return Pn(Zn.hour23h, n)
				case "Ho":
					return i.ordinalNumber(n, { unit: "hour" })
				default:
					return qn(r.length, n)
			}
		}
		validate(n, r) {
			return r >= 0 && r <= 23
		}
		set(n, r, i) {
			return n.setHours(i, 0, 0, 0), n
		}
	}
	class Xwt extends Yt {
		constructor() {
			super(...arguments)
			q(this, "priority", 70)
			q(this, "incompatibleTokens", ["h", "H", "k", "t", "T"])
		}
		parse(n, r, i) {
			switch (r) {
				case "K":
					return Pn(Zn.hour11h, n)
				case "Ko":
					return i.ordinalNumber(n, { unit: "hour" })
				default:
					return qn(r.length, n)
			}
		}
		validate(n, r) {
			return r >= 0 && r <= 11
		}
		set(n, r, i) {
			return n.getHours() >= 12 && i < 12 ? n.setHours(i + 12, 0, 0, 0) : n.setHours(i, 0, 0, 0), n
		}
	}
	class Jwt extends Yt {
		constructor() {
			super(...arguments)
			q(this, "priority", 70)
			q(this, "incompatibleTokens", ["a", "b", "h", "H", "K", "t", "T"])
		}
		parse(n, r, i) {
			switch (r) {
				case "k":
					return Pn(Zn.hour24h, n)
				case "ko":
					return i.ordinalNumber(n, { unit: "hour" })
				default:
					return qn(r.length, n)
			}
		}
		validate(n, r) {
			return r >= 1 && r <= 24
		}
		set(n, r, i) {
			const a = i <= 24 ? i % 24 : i
			return n.setHours(a, 0, 0, 0), n
		}
	}
	class Zwt extends Yt {
		constructor() {
			super(...arguments)
			q(this, "priority", 60)
			q(this, "incompatibleTokens", ["t", "T"])
		}
		parse(n, r, i) {
			switch (r) {
				case "m":
					return Pn(Zn.minute, n)
				case "mo":
					return i.ordinalNumber(n, { unit: "minute" })
				default:
					return qn(r.length, n)
			}
		}
		validate(n, r) {
			return r >= 0 && r <= 59
		}
		set(n, r, i) {
			return n.setMinutes(i, 0, 0), n
		}
	}
	class eEt extends Yt {
		constructor() {
			super(...arguments)
			q(this, "priority", 50)
			q(this, "incompatibleTokens", ["t", "T"])
		}
		parse(n, r, i) {
			switch (r) {
				case "s":
					return Pn(Zn.second, n)
				case "so":
					return i.ordinalNumber(n, { unit: "second" })
				default:
					return qn(r.length, n)
			}
		}
		validate(n, r) {
			return r >= 0 && r <= 59
		}
		set(n, r, i) {
			return n.setSeconds(i, 0), n
		}
	}
	class tEt extends Yt {
		constructor() {
			super(...arguments)
			q(this, "priority", 30)
			q(this, "incompatibleTokens", ["t", "T"])
		}
		parse(n, r) {
			const i = (a) => Math.trunc(a * Math.pow(10, -r.length + 3))
			return er(qn(r.length, n), i)
		}
		set(n, r, i) {
			return n.setMilliseconds(i), n
		}
	}
	class nEt extends Yt {
		constructor() {
			super(...arguments)
			q(this, "priority", 10)
			q(this, "incompatibleTokens", ["t", "T", "x"])
		}
		parse(n, r) {
			switch (r) {
				case "X":
					return ns(ts.basicOptionalMinutes, n)
				case "XX":
					return ns(ts.basic, n)
				case "XXXX":
					return ns(ts.basicOptionalSeconds, n)
				case "XXXXX":
					return ns(ts.extendedOptionalSeconds, n)
				case "XXX":
				default:
					return ns(ts.extended, n)
			}
		}
		set(n, r, i) {
			return r.timestampIsSet ? n : nn(n, n.getTime() - Wb(n) - i)
		}
	}
	class rEt extends Yt {
		constructor() {
			super(...arguments)
			q(this, "priority", 10)
			q(this, "incompatibleTokens", ["t", "T", "X"])
		}
		parse(n, r) {
			switch (r) {
				case "x":
					return ns(ts.basicOptionalMinutes, n)
				case "xx":
					return ns(ts.basic, n)
				case "xxxx":
					return ns(ts.basicOptionalSeconds, n)
				case "xxxxx":
					return ns(ts.extendedOptionalSeconds, n)
				case "xxx":
				default:
					return ns(ts.extended, n)
			}
		}
		set(n, r, i) {
			return r.timestampIsSet ? n : nn(n, n.getTime() - Wb(n) - i)
		}
	}
	class iEt extends Yt {
		constructor() {
			super(...arguments)
			q(this, "priority", 40)
			q(this, "incompatibleTokens", "*")
		}
		parse(n) {
			return YY(n)
		}
		set(n, r, i) {
			return [nn(n, i * 1e3), { timestampIsSet: !0 }]
		}
	}
	class aEt extends Yt {
		constructor() {
			super(...arguments)
			q(this, "priority", 20)
			q(this, "incompatibleTokens", "*")
		}
		parse(n) {
			return YY(n)
		}
		set(n, r, i) {
			return [nn(n, i), { timestampIsSet: !0 }]
		}
	}
	const oEt = {
			G: new Twt(),
			y: new kwt(),
			Y: new Swt(),
			R: new Dwt(),
			u: new _wt(),
			Q: new Owt(),
			q: new Awt(),
			M: new Nwt(),
			L: new Mwt(),
			w: new Rwt(),
			I: new Pwt(),
			d: new Bwt(),
			D: new Hwt(),
			E: new $wt(),
			e: new Uwt(),
			c: new zwt(),
			i: new Vwt(),
			a: new Wwt(),
			b: new Ywt(),
			B: new Gwt(),
			h: new Kwt(),
			H: new Qwt(),
			K: new Xwt(),
			k: new Jwt(),
			m: new Zwt(),
			s: new eEt(),
			S: new tEt(),
			X: new nEt(),
			x: new rEt(),
			t: new iEt(),
			T: new aEt(),
		},
		sEt = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g,
		lEt = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g,
		uEt = /^'([^]*?)'?$/,
		cEt = /''/g,
		dEt = /\S/,
		fEt = /[a-zA-Z]/
	function hS(e, t, n, r) {
		var b, x, E, T, C, D, O, A
		const i = gwt(),
			a = (r == null ? void 0 : r.locale) ?? i.locale ?? $Y,
			o =
				(r == null ? void 0 : r.firstWeekContainsDate) ??
				((x = (b = r == null ? void 0 : r.locale) == null ? void 0 : b.options) == null
					? void 0
					: x.firstWeekContainsDate) ??
				i.firstWeekContainsDate ??
				((T = (E = i.locale) == null ? void 0 : E.options) == null
					? void 0
					: T.firstWeekContainsDate) ??
				1,
			s =
				(r == null ? void 0 : r.weekStartsOn) ??
				((D = (C = r == null ? void 0 : r.locale) == null ? void 0 : C.options) == null
					? void 0
					: D.weekStartsOn) ??
				i.weekStartsOn ??
				((A = (O = i.locale) == null ? void 0 : O.options) == null ? void 0 : A.weekStartsOn) ??
				0
		if (t === "") return e === "" ? ze(n) : nn(n, NaN)
		const l = { firstWeekContainsDate: o, weekStartsOn: s, locale: a },
			u = [new Cwt()],
			d = t
				.match(lEt)
				.map((N) => {
					const I = N[0]
					if (I in Jb) {
						const P = Jb[I]
						return P(N, a.formatLong)
					}
					return N
				})
				.join("")
				.match(sEt),
			p = []
		for (let N of d) {
			!(r != null && r.useAdditionalWeekYearTokens) && VY(N) && ND(N, t, e),
				!(r != null && r.useAdditionalDayOfYearTokens) && qY(N) && ND(N, t, e)
			const I = N[0],
				P = oEt[I]
			if (P) {
				const { incompatibleTokens: L } = P
				if (Array.isArray(L)) {
					const z = p.find((V) => L.includes(V.token) || V.token === I)
					if (z)
						throw new RangeError(
							`The format string mustn't contain \`${z.fullToken}\` and \`${N}\` at the same time`,
						)
				} else if (P.incompatibleTokens === "*" && p.length > 0)
					throw new RangeError(
						`The format string mustn't contain \`${N}\` and any other token at the same time`,
					)
				p.push({ token: I, fullToken: N })
				const B = P.run(e, N, a.match, l)
				if (!B) return nn(n, NaN)
				u.push(B.setter), (e = B.rest)
			} else {
				if (I.match(fEt))
					throw new RangeError(
						"Format string contains an unescaped latin alphabet character `" + I + "`",
					)
				if ((N === "''" ? (N = "'") : I === "'" && (N = pEt(N)), e.indexOf(N) === 0))
					e = e.slice(N.length)
				else return nn(n, NaN)
			}
		}
		if (e.length > 0 && dEt.test(e)) return nn(n, NaN)
		const m = u
			.map((N) => N.priority)
			.sort((N, I) => I - N)
			.filter((N, I, P) => P.indexOf(N) === I)
			.map((N) => u.filter((I) => I.priority === N).sort((I, P) => P.subPriority - I.subPriority))
			.map((N) => N[0])
		let v = ze(n)
		if (isNaN(v.getTime())) return nn(n, NaN)
		const y = {}
		for (const N of m) {
			if (!N.validate(v, l)) return nn(n, NaN)
			const I = N.set(v, y, l)
			Array.isArray(I) ? ((v = I[0]), Object.assign(y, I[1])) : (v = I)
		}
		return nn(n, v)
	}
	function pEt(e) {
		return e.match(uEt)[1].replace(cEt, "'")
	}
	function hEt(e, t) {
		const n = ze(e),
			r = ze(t)
		return n.getFullYear() === r.getFullYear() && n.getMonth() === r.getMonth()
	}
	function mEt(e, t) {
		const n = AD(e),
			r = AD(t)
		return +n == +r
	}
	function vEt(e, t) {
		const n = ze(e),
			r = ze(t)
		return n.getFullYear() === r.getFullYear()
	}
	function Fv(e, t) {
		const n = +ze(e),
			[r, i] = [+ze(t.start), +ze(t.end)].sort((a, o) => a - o)
		return n >= r && n <= i
	}
	function gEt(e, t) {
		return Tl(e, -t)
	}
	function yEt(e, t) {
		const r = EEt(e)
		let i
		if (r.date) {
			const l = CEt(r.date, 2)
			i = TEt(l.restDateString, l.year)
		}
		if (!i || isNaN(i.getTime())) return new Date(NaN)
		const a = i.getTime()
		let o = 0,
			s
		if (r.time && ((o = kEt(r.time)), isNaN(o))) return new Date(NaN)
		if (r.timezone) {
			if (((s = SEt(r.timezone)), isNaN(s))) return new Date(NaN)
		} else {
			const l = new Date(a + o),
				u = new Date(0)
			return (
				u.setFullYear(l.getUTCFullYear(), l.getUTCMonth(), l.getUTCDate()),
				u.setHours(l.getUTCHours(), l.getUTCMinutes(), l.getUTCSeconds(), l.getUTCMilliseconds()),
				u
			)
		}
		return new Date(a + o + s)
	}
	const _y = { dateTimeDelimiter: /[T ]/, timeZoneDelimiter: /[Z ]/i, timezone: /([Z+-].*)$/ },
		bEt = /^-?(?:(\d{3})|(\d{2})(?:-?(\d{2}))?|W(\d{2})(?:-?(\d{1}))?|)$/,
		xEt = /^(\d{2}(?:[.,]\d*)?)(?::?(\d{2}(?:[.,]\d*)?))?(?::?(\d{2}(?:[.,]\d*)?))?$/,
		wEt = /^([+-])(\d{2})(?::?(\d{2}))?$/
	function EEt(e) {
		const t = {},
			n = e.split(_y.dateTimeDelimiter)
		let r
		if (n.length > 2) return t
		if (
			(/:/.test(n[0])
				? (r = n[0])
				: ((t.date = n[0]),
				  (r = n[1]),
				  _y.timeZoneDelimiter.test(t.date) &&
						((t.date = e.split(_y.timeZoneDelimiter)[0]), (r = e.substr(t.date.length, e.length)))),
			r)
		) {
			const i = _y.timezone.exec(r)
			i ? ((t.time = r.replace(i[1], "")), (t.timezone = i[1])) : (t.time = r)
		}
		return t
	}
	function CEt(e, t) {
		const n = new RegExp(
				"^(?:(\\d{4}|[+-]\\d{" + (4 + t) + "})|(\\d{2}|[+-]\\d{" + (2 + t) + "})$)",
			),
			r = e.match(n)
		if (!r) return { year: NaN, restDateString: "" }
		const i = r[1] ? parseInt(r[1]) : null,
			a = r[2] ? parseInt(r[2]) : null
		return { year: a === null ? i : a * 100, restDateString: e.slice((r[1] || r[2]).length) }
	}
	function TEt(e, t) {
		if (t === null) return new Date(NaN)
		const n = e.match(bEt)
		if (!n) return new Date(NaN)
		const r = !!n[4],
			i = mm(n[1]),
			a = mm(n[2]) - 1,
			o = mm(n[3]),
			s = mm(n[4]),
			l = mm(n[5]) - 1
		if (r) return NEt(t, s, l) ? DEt(t, s, l) : new Date(NaN)
		{
			const u = new Date(0)
			return !OEt(t, a, o) || !AEt(t, i)
				? new Date(NaN)
				: (u.setUTCFullYear(t, a, Math.max(i, o)), u)
		}
	}
	function mm(e) {
		return e ? parseInt(e) : 1
	}
	function kEt(e) {
		const t = e.match(xEt)
		if (!t) return NaN
		const n = mS(t[1]),
			r = mS(t[2]),
			i = mS(t[3])
		return MEt(n, r, i) ? n * Pw + r * Lw + i * 1e3 : NaN
	}
	function mS(e) {
		return (e && parseFloat(e.replace(",", "."))) || 0
	}
	function SEt(e) {
		if (e === "Z") return 0
		const t = e.match(wEt)
		if (!t) return 0
		const n = t[1] === "+" ? -1 : 1,
			r = parseInt(t[2]),
			i = (t[3] && parseInt(t[3])) || 0
		return IEt(r, i) ? n * (r * Pw + i * Lw) : NaN
	}
	function DEt(e, t, n) {
		const r = new Date(0)
		r.setUTCFullYear(e, 0, 4)
		const i = r.getUTCDay() || 7,
			a = (t - 1) * 7 + n + 1 - i
		return r.setUTCDate(r.getUTCDate() + a), r
	}
	const _Et = [31, null, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
	function QY(e) {
		return e % 400 === 0 || (e % 4 === 0 && e % 100 !== 0)
	}
	function OEt(e, t, n) {
		return t >= 0 && t <= 11 && n >= 1 && n <= (_Et[t] || (QY(e) ? 29 : 28))
	}
	function AEt(e, t) {
		return t >= 1 && t <= (QY(e) ? 366 : 365)
	}
	function NEt(e, t, n) {
		return t >= 1 && t <= 53 && n >= 0 && n <= 6
	}
	function MEt(e, t, n) {
		return e === 24 ? t === 0 && n === 0 : n >= 0 && n < 60 && t >= 0 && t < 60 && e >= 0 && e < 25
	}
	function IEt(e, t) {
		return t >= 0 && t <= 59
	}
	function ia(e, t) {
		const n = ze(e),
			r = n.getFullYear(),
			i = n.getDate(),
			a = nn(e, 0)
		a.setFullYear(r, t, 15), a.setHours(0, 0, 0, 0)
		const o = vwt(a)
		return n.setMonth(t, Math.min(i, o)), n
	}
	function REt(e, t) {
		let n = ze(e)
		return isNaN(+n)
			? nn(e, NaN)
			: (t.year != null && n.setFullYear(t.year),
			  t.month != null && (n = ia(n, t.month)),
			  t.date != null && n.setDate(t.date),
			  t.hours != null && n.setHours(t.hours),
			  t.minutes != null && n.setMinutes(t.minutes),
			  t.seconds != null && n.setSeconds(t.seconds),
			  t.milliseconds != null && n.setMilliseconds(t.milliseconds),
			  n)
	}
	function C1(e, t) {
		const n = ze(e)
		return n.setHours(t), n
	}
	function T1(e, t) {
		const n = ze(e)
		return n.setMinutes(t), n
	}
	function Mf(e, t) {
		const n = ze(e),
			r = Math.trunc(n.getMonth() / 3) + 1,
			i = t - r
		return ia(n, n.getMonth() + i * 3)
	}
	function k1(e, t) {
		const n = ze(e)
		return n.setSeconds(t), n
	}
	function Go(e, t) {
		const n = ze(e)
		return isNaN(+n) ? nn(e, NaN) : (n.setFullYear(t), n)
	}
	function Pp(e, t) {
		return No(e, -t)
	}
	function XY(e, t) {
		return JA(e, -t)
	}
	function S5(e, t) {
		return Yb(e, -t)
	}
	function jp(e, t) {
		return hl(e, -t)
	}
	function Fw() {
		return typeof window < "u"
	}
	function lh(e) {
		return JY(e) ? (e.nodeName || "").toLowerCase() : "#document"
	}
	function ga(e) {
		var t
		return (e == null || (t = e.ownerDocument) == null ? void 0 : t.defaultView) || window
	}
	function Ns(e) {
		var t
		return (t = (JY(e) ? e.ownerDocument : e.document) || window.document) == null
			? void 0
			: t.documentElement
	}
	function JY(e) {
		return Fw() ? e instanceof Node || e instanceof ga(e).Node : !1
	}
	function xi(e) {
		return Fw() ? e instanceof Element || e instanceof ga(e).Element : !1
	}
	function bs(e) {
		return Fw() ? e instanceof HTMLElement || e instanceof ga(e).HTMLElement : !1
	}
	function D5(e) {
		return !Fw() || typeof ShadowRoot > "u"
			? !1
			: e instanceof ShadowRoot || e instanceof ga(e).ShadowRoot
	}
	function Cg(e) {
		const { overflow: t, overflowX: n, overflowY: r, display: i } = Qa(e)
		return /auto|scroll|overlay|hidden|clip/.test(t + r + n) && !["inline", "contents"].includes(i)
	}
	function LEt(e) {
		return ["table", "td", "th"].includes(lh(e))
	}
	function Bw(e) {
		return [":popover-open", ":modal"].some((t) => {
			try {
				return e.matches(t)
			} catch {
				return !1
			}
		})
	}
	function rN(e) {
		const t = iN(),
			n = xi(e) ? Qa(e) : e
		return (
			n.transform !== "none" ||
			n.perspective !== "none" ||
			(n.containerType ? n.containerType !== "normal" : !1) ||
			(!t && (n.backdropFilter ? n.backdropFilter !== "none" : !1)) ||
			(!t && (n.filter ? n.filter !== "none" : !1)) ||
			["transform", "perspective", "filter"].some((r) => (n.willChange || "").includes(r)) ||
			["paint", "layout", "strict", "content"].some((r) => (n.contain || "").includes(r))
		)
	}
	function PEt(e) {
		let t = Wu(e)
		for (; bs(t) && !Fp(t); ) {
			if (rN(t)) return t
			if (Bw(t)) return null
			t = Wu(t)
		}
		return null
	}
	function iN() {
		return typeof CSS > "u" || !CSS.supports ? !1 : CSS.supports("-webkit-backdrop-filter", "none")
	}
	function Fp(e) {
		return ["html", "body", "#document"].includes(lh(e))
	}
	function Qa(e) {
		return ga(e).getComputedStyle(e)
	}
	function Hw(e) {
		return xi(e)
			? { scrollLeft: e.scrollLeft, scrollTop: e.scrollTop }
			: { scrollLeft: e.scrollX, scrollTop: e.scrollY }
	}
	function Wu(e) {
		if (lh(e) === "html") return e
		const t = e.assignedSlot || e.parentNode || (D5(e) && e.host) || Ns(e)
		return D5(t) ? t.host : t
	}
	function ZY(e) {
		const t = Wu(e)
		return Fp(t) ? (e.ownerDocument ? e.ownerDocument.body : e.body) : bs(t) && Cg(t) ? t : ZY(t)
	}
	function Bv(e, t, n) {
		var r
		t === void 0 && (t = []), n === void 0 && (n = !0)
		const i = ZY(e),
			a = i === ((r = e.ownerDocument) == null ? void 0 : r.body),
			o = ga(i)
		if (a) {
			const s = ID(o)
			return t.concat(o, o.visualViewport || [], Cg(i) ? i : [], s && n ? Bv(s) : [])
		}
		return t.concat(i, Bv(i, [], n))
	}
	function ID(e) {
		return e.parent && Object.getPrototypeOf(e.parent) ? e.frameElement : null
	}
	const Bp = Math.min,
		ad = Math.max,
		ex = Math.round,
		Oy = Math.floor,
		ds = (e) => ({ x: e, y: e }),
		jEt = { left: "right", right: "left", bottom: "top", top: "bottom" },
		FEt = { start: "end", end: "start" }
	function BEt(e, t, n) {
		return ad(e, Bp(t, n))
	}
	function $w(e, t) {
		return typeof e == "function" ? e(t) : e
	}
	function Hp(e) {
		return e.split("-")[0]
	}
	function Tg(e) {
		return e.split("-")[1]
	}
	function HEt(e) {
		return e === "x" ? "y" : "x"
	}
	function aN(e) {
		return e === "y" ? "height" : "width"
	}
	function Hv(e) {
		return ["top", "bottom"].includes(Hp(e)) ? "y" : "x"
	}
	function oN(e) {
		return HEt(Hv(e))
	}
	function $Et(e, t, n) {
		n === void 0 && (n = !1)
		const r = Tg(e),
			i = oN(e),
			a = aN(i)
		let o =
			i === "x"
				? r === (n ? "end" : "start")
					? "right"
					: "left"
				: r === "start"
				? "bottom"
				: "top"
		return t.reference[a] > t.floating[a] && (o = tx(o)), [o, tx(o)]
	}
	function UEt(e) {
		const t = tx(e)
		return [RD(e), t, RD(t)]
	}
	function RD(e) {
		return e.replace(/start|end/g, (t) => FEt[t])
	}
	function zEt(e, t, n) {
		const r = ["left", "right"],
			i = ["right", "left"],
			a = ["top", "bottom"],
			o = ["bottom", "top"]
		switch (e) {
			case "top":
			case "bottom":
				return n ? (t ? i : r) : t ? r : i
			case "left":
			case "right":
				return t ? a : o
			default:
				return []
		}
	}
	function qEt(e, t, n, r) {
		const i = Tg(e)
		let a = zEt(Hp(e), n === "start", r)
		return i && ((a = a.map((o) => o + "-" + i)), t && (a = a.concat(a.map(RD)))), a
	}
	function tx(e) {
		return e.replace(/left|right|bottom|top/g, (t) => jEt[t])
	}
	function VEt(e) {
		return { top: 0, right: 0, bottom: 0, left: 0, ...e }
	}
	function eG(e) {
		return typeof e != "number" ? VEt(e) : { top: e, right: e, bottom: e, left: e }
	}
	function nx(e) {
		const { x: t, y: n, width: r, height: i } = e
		return { width: r, height: i, top: n, left: t, right: t + r, bottom: n + i, x: t, y: n }
	}
	function _5(e, t, n) {
		let { reference: r, floating: i } = e
		const a = Hv(t),
			o = oN(t),
			s = aN(o),
			l = Hp(t),
			u = a === "y",
			d = r.x + r.width / 2 - i.width / 2,
			p = r.y + r.height / 2 - i.height / 2,
			m = r[s] / 2 - i[s] / 2
		let v
		switch (l) {
			case "top":
				v = { x: d, y: r.y - i.height }
				break
			case "bottom":
				v = { x: d, y: r.y + r.height }
				break
			case "right":
				v = { x: r.x + r.width, y: p }
				break
			case "left":
				v = { x: r.x - i.width, y: p }
				break
			default:
				v = { x: r.x, y: r.y }
		}
		switch (Tg(t)) {
			case "start":
				v[o] -= m * (n && u ? -1 : 1)
				break
			case "end":
				v[o] += m * (n && u ? -1 : 1)
				break
		}
		return v
	}
	const WEt = async (e, t, n) => {
		const {
				placement: r = "bottom",
				strategy: i = "absolute",
				middleware: a = [],
				platform: o,
			} = n,
			s = a.filter(Boolean),
			l = await (o.isRTL == null ? void 0 : o.isRTL(t))
		let u = await o.getElementRects({ reference: e, floating: t, strategy: i }),
			{ x: d, y: p } = _5(u, r, l),
			m = r,
			v = {},
			y = 0
		for (let b = 0; b < s.length; b++) {
			const { name: x, fn: E } = s[b],
				{
					x: T,
					y: C,
					data: D,
					reset: O,
				} = await E({
					x: d,
					y: p,
					initialPlacement: r,
					placement: m,
					strategy: i,
					middlewareData: v,
					rects: u,
					platform: o,
					elements: { reference: e, floating: t },
				})
			;(d = T ?? d),
				(p = C ?? p),
				(v = { ...v, [x]: { ...v[x], ...D } }),
				O &&
					y <= 50 &&
					(y++,
					typeof O == "object" &&
						(O.placement && (m = O.placement),
						O.rects &&
							(u =
								O.rects === !0
									? await o.getElementRects({ reference: e, floating: t, strategy: i })
									: O.rects),
						({ x: d, y: p } = _5(u, m, l))),
					(b = -1))
		}
		return { x: d, y: p, placement: m, strategy: i, middlewareData: v }
	}
	async function YEt(e, t) {
		var n
		t === void 0 && (t = {})
		const { x: r, y: i, platform: a, rects: o, elements: s, strategy: l } = e,
			{
				boundary: u = "clippingAncestors",
				rootBoundary: d = "viewport",
				elementContext: p = "floating",
				altBoundary: m = !1,
				padding: v = 0,
			} = $w(t, e),
			y = eG(v),
			x = s[m ? (p === "floating" ? "reference" : "floating") : p],
			E = nx(
				await a.getClippingRect({
					element:
						(n = await (a.isElement == null ? void 0 : a.isElement(x))) == null || n
							? x
							: x.contextElement ||
							  (await (a.getDocumentElement == null ? void 0 : a.getDocumentElement(s.floating))),
					boundary: u,
					rootBoundary: d,
					strategy: l,
				}),
			),
			T =
				p === "floating"
					? { x: r, y: i, width: o.floating.width, height: o.floating.height }
					: o.reference,
			C = await (a.getOffsetParent == null ? void 0 : a.getOffsetParent(s.floating)),
			D = (await (a.isElement == null ? void 0 : a.isElement(C)))
				? (await (a.getScale == null ? void 0 : a.getScale(C))) || { x: 1, y: 1 }
				: { x: 1, y: 1 },
			O = nx(
				a.convertOffsetParentRelativeRectToViewportRelativeRect
					? await a.convertOffsetParentRelativeRectToViewportRelativeRect({
							elements: s,
							rect: T,
							offsetParent: C,
							strategy: l,
					  })
					: T,
			)
		return {
			top: (E.top - O.top + y.top) / D.y,
			bottom: (O.bottom - E.bottom + y.bottom) / D.y,
			left: (E.left - O.left + y.left) / D.x,
			right: (O.right - E.right + y.right) / D.x,
		}
	}
	const GEt = (e) => ({
			name: "arrow",
			options: e,
			async fn(t) {
				const {
						x: n,
						y: r,
						placement: i,
						rects: a,
						platform: o,
						elements: s,
						middlewareData: l,
					} = t,
					{ element: u, padding: d = 0 } = $w(e, t) || {}
				if (u == null) return {}
				const p = eG(d),
					m = { x: n, y: r },
					v = oN(i),
					y = aN(v),
					b = await o.getDimensions(u),
					x = v === "y",
					E = x ? "top" : "left",
					T = x ? "bottom" : "right",
					C = x ? "clientHeight" : "clientWidth",
					D = a.reference[y] + a.reference[v] - m[v] - a.floating[y],
					O = m[v] - a.reference[v],
					A = await (o.getOffsetParent == null ? void 0 : o.getOffsetParent(u))
				let N = A ? A[C] : 0
				;(!N || !(await (o.isElement == null ? void 0 : o.isElement(A)))) &&
					(N = s.floating[C] || a.floating[y])
				const I = D / 2 - O / 2,
					P = N / 2 - b[y] / 2 - 1,
					L = Bp(p[E], P),
					B = Bp(p[T], P),
					z = L,
					V = N - b[y] - B,
					K = N / 2 - b[y] / 2 + I,
					ne = BEt(z, K, V),
					re =
						!l.arrow &&
						Tg(i) != null &&
						K !== ne &&
						a.reference[y] / 2 - (K < z ? L : B) - b[y] / 2 < 0,
					ie = re ? (K < z ? K - z : K - V) : 0
				return {
					[v]: m[v] + ie,
					data: { [v]: ne, centerOffset: K - ne - ie, ...(re && { alignmentOffset: ie }) },
					reset: re,
				}
			},
		}),
		KEt = function (e) {
			return (
				e === void 0 && (e = {}),
				{
					name: "flip",
					options: e,
					async fn(t) {
						var n, r
						const {
								placement: i,
								middlewareData: a,
								rects: o,
								initialPlacement: s,
								platform: l,
								elements: u,
							} = t,
							{
								mainAxis: d = !0,
								crossAxis: p = !0,
								fallbackPlacements: m,
								fallbackStrategy: v = "bestFit",
								fallbackAxisSideDirection: y = "none",
								flipAlignment: b = !0,
								...x
							} = $w(e, t)
						if ((n = a.arrow) != null && n.alignmentOffset) return {}
						const E = Hp(i),
							T = Hv(s),
							C = Hp(s) === s,
							D = await (l.isRTL == null ? void 0 : l.isRTL(u.floating)),
							O = m || (C || !b ? [tx(s)] : UEt(s)),
							A = y !== "none"
						!m && A && O.push(...qEt(s, b, y, D))
						const N = [s, ...O],
							I = await YEt(t, x),
							P = []
						let L = ((r = a.flip) == null ? void 0 : r.overflows) || []
						if ((d && P.push(I[E]), p)) {
							const K = $Et(i, o, D)
							P.push(I[K[0]], I[K[1]])
						}
						if (((L = [...L, { placement: i, overflows: P }]), !P.every((K) => K <= 0))) {
							var B, z
							const K = (((B = a.flip) == null ? void 0 : B.index) || 0) + 1,
								ne = N[K]
							if (ne) return { data: { index: K, overflows: L }, reset: { placement: ne } }
							let re =
								(z = L.filter((ie) => ie.overflows[0] <= 0).sort(
									(ie, J) => ie.overflows[1] - J.overflows[1],
								)[0]) == null
									? void 0
									: z.placement
							if (!re)
								switch (v) {
									case "bestFit": {
										var V
										const ie =
											(V = L.filter((J) => {
												if (A) {
													const le = Hv(J.placement)
													return le === T || le === "y"
												}
												return !0
											})
												.map((J) => [
													J.placement,
													J.overflows.filter((le) => le > 0).reduce((le, F) => le + F, 0),
												])
												.sort((J, le) => J[1] - le[1])[0]) == null
												? void 0
												: V[0]
										ie && (re = ie)
										break
									}
									case "initialPlacement":
										re = s
										break
								}
							if (i !== re) return { reset: { placement: re } }
						}
						return {}
					},
				}
			)
		}
	async function QEt(e, t) {
		const { placement: n, platform: r, elements: i } = e,
			a = await (r.isRTL == null ? void 0 : r.isRTL(i.floating)),
			o = Hp(n),
			s = Tg(n),
			l = Hv(n) === "y",
			u = ["left", "top"].includes(o) ? -1 : 1,
			d = a && l ? -1 : 1,
			p = $w(t, e)
		let {
			mainAxis: m,
			crossAxis: v,
			alignmentAxis: y,
		} = typeof p == "number"
			? { mainAxis: p, crossAxis: 0, alignmentAxis: null }
			: { mainAxis: p.mainAxis || 0, crossAxis: p.crossAxis || 0, alignmentAxis: p.alignmentAxis }
		return (
			s && typeof y == "number" && (v = s === "end" ? y * -1 : y),
			l ? { x: v * d, y: m * u } : { x: m * u, y: v * d }
		)
	}
	const XEt = function (e) {
		return (
			e === void 0 && (e = 0),
			{
				name: "offset",
				options: e,
				async fn(t) {
					var n, r
					const { x: i, y: a, placement: o, middlewareData: s } = t,
						l = await QEt(t, e)
					return o === ((n = s.offset) == null ? void 0 : n.placement) &&
						(r = s.arrow) != null &&
						r.alignmentOffset
						? {}
						: { x: i + l.x, y: a + l.y, data: { ...l, placement: o } }
				},
			}
		)
	}
	function tG(e) {
		const t = Qa(e)
		let n = parseFloat(t.width) || 0,
			r = parseFloat(t.height) || 0
		const i = bs(e),
			a = i ? e.offsetWidth : n,
			o = i ? e.offsetHeight : r,
			s = ex(n) !== a || ex(r) !== o
		return s && ((n = a), (r = o)), { width: n, height: r, $: s }
	}
	function sN(e) {
		return xi(e) ? e : e.contextElement
	}
	function Xf(e) {
		const t = sN(e)
		if (!bs(t)) return ds(1)
		const n = t.getBoundingClientRect(),
			{ width: r, height: i, $: a } = tG(t)
		let o = (a ? ex(n.width) : n.width) / r,
			s = (a ? ex(n.height) : n.height) / i
		return (
			(!o || !Number.isFinite(o)) && (o = 1), (!s || !Number.isFinite(s)) && (s = 1), { x: o, y: s }
		)
	}
	const JEt = ds(0)
	function nG(e) {
		const t = ga(e)
		return !iN() || !t.visualViewport
			? JEt
			: { x: t.visualViewport.offsetLeft, y: t.visualViewport.offsetTop }
	}
	function ZEt(e, t, n) {
		return t === void 0 && (t = !1), !n || (t && n !== ga(e)) ? !1 : t
	}
	function Dd(e, t, n, r) {
		t === void 0 && (t = !1), n === void 0 && (n = !1)
		const i = e.getBoundingClientRect(),
			a = sN(e)
		let o = ds(1)
		t && (r ? xi(r) && (o = Xf(r)) : (o = Xf(e)))
		const s = ZEt(a, n, r) ? nG(a) : ds(0)
		let l = (i.left + s.x) / o.x,
			u = (i.top + s.y) / o.y,
			d = i.width / o.x,
			p = i.height / o.y
		if (a) {
			const m = ga(a),
				v = r && xi(r) ? ga(r) : r
			let y = m,
				b = ID(y)
			for (; b && r && v !== y; ) {
				const x = Xf(b),
					E = b.getBoundingClientRect(),
					T = Qa(b),
					C = E.left + (b.clientLeft + parseFloat(T.paddingLeft)) * x.x,
					D = E.top + (b.clientTop + parseFloat(T.paddingTop)) * x.y
				;(l *= x.x),
					(u *= x.y),
					(d *= x.x),
					(p *= x.y),
					(l += C),
					(u += D),
					(y = ga(b)),
					(b = ID(y))
			}
		}
		return nx({ width: d, height: p, x: l, y: u })
	}
	function lN(e, t) {
		const n = Hw(e).scrollLeft
		return t ? t.left + n : Dd(Ns(e)).left + n
	}
	function rG(e, t, n) {
		n === void 0 && (n = !1)
		const r = e.getBoundingClientRect(),
			i = r.left + t.scrollLeft - (n ? 0 : lN(e, r)),
			a = r.top + t.scrollTop
		return { x: i, y: a }
	}
	function eCt(e) {
		let { elements: t, rect: n, offsetParent: r, strategy: i } = e
		const a = i === "fixed",
			o = Ns(r),
			s = t ? Bw(t.floating) : !1
		if (r === o || (s && a)) return n
		let l = { scrollLeft: 0, scrollTop: 0 },
			u = ds(1)
		const d = ds(0),
			p = bs(r)
		if ((p || (!p && !a)) && ((lh(r) !== "body" || Cg(o)) && (l = Hw(r)), bs(r))) {
			const v = Dd(r)
			;(u = Xf(r)), (d.x = v.x + r.clientLeft), (d.y = v.y + r.clientTop)
		}
		const m = o && !p && !a ? rG(o, l, !0) : ds(0)
		return {
			width: n.width * u.x,
			height: n.height * u.y,
			x: n.x * u.x - l.scrollLeft * u.x + d.x + m.x,
			y: n.y * u.y - l.scrollTop * u.y + d.y + m.y,
		}
	}
	function tCt(e) {
		return Array.from(e.getClientRects())
	}
	function nCt(e) {
		const t = Ns(e),
			n = Hw(e),
			r = e.ownerDocument.body,
			i = ad(t.scrollWidth, t.clientWidth, r.scrollWidth, r.clientWidth),
			a = ad(t.scrollHeight, t.clientHeight, r.scrollHeight, r.clientHeight)
		let o = -n.scrollLeft + lN(e)
		const s = -n.scrollTop
		return (
			Qa(r).direction === "rtl" && (o += ad(t.clientWidth, r.clientWidth) - i),
			{ width: i, height: a, x: o, y: s }
		)
	}
	function rCt(e, t) {
		const n = ga(e),
			r = Ns(e),
			i = n.visualViewport
		let a = r.clientWidth,
			o = r.clientHeight,
			s = 0,
			l = 0
		if (i) {
			;(a = i.width), (o = i.height)
			const u = iN()
			;(!u || (u && t === "fixed")) && ((s = i.offsetLeft), (l = i.offsetTop))
		}
		return { width: a, height: o, x: s, y: l }
	}
	function iCt(e, t) {
		const n = Dd(e, !0, t === "fixed"),
			r = n.top + e.clientTop,
			i = n.left + e.clientLeft,
			a = bs(e) ? Xf(e) : ds(1),
			o = e.clientWidth * a.x,
			s = e.clientHeight * a.y,
			l = i * a.x,
			u = r * a.y
		return { width: o, height: s, x: l, y: u }
	}
	function O5(e, t, n) {
		let r
		if (t === "viewport") r = rCt(e, n)
		else if (t === "document") r = nCt(Ns(e))
		else if (xi(t)) r = iCt(t, n)
		else {
			const i = nG(e)
			r = { x: t.x - i.x, y: t.y - i.y, width: t.width, height: t.height }
		}
		return nx(r)
	}
	function iG(e, t) {
		const n = Wu(e)
		return n === t || !xi(n) || Fp(n) ? !1 : Qa(n).position === "fixed" || iG(n, t)
	}
	function aCt(e, t) {
		const n = t.get(e)
		if (n) return n
		let r = Bv(e, [], !1).filter((s) => xi(s) && lh(s) !== "body"),
			i = null
		const a = Qa(e).position === "fixed"
		let o = a ? Wu(e) : e
		for (; xi(o) && !Fp(o); ) {
			const s = Qa(o),
				l = rN(o)
			!l && s.position === "fixed" && (i = null),
				(
					a
						? !l && !i
						: (!l &&
								s.position === "static" &&
								!!i &&
								["absolute", "fixed"].includes(i.position)) ||
						  (Cg(o) && !l && iG(e, o))
				)
					? (r = r.filter((d) => d !== o))
					: (i = s),
				(o = Wu(o))
		}
		return t.set(e, r), r
	}
	function oCt(e) {
		let { element: t, boundary: n, rootBoundary: r, strategy: i } = e
		const o = [...(n === "clippingAncestors" ? (Bw(t) ? [] : aCt(t, this._c)) : [].concat(n)), r],
			s = o[0],
			l = o.reduce((u, d) => {
				const p = O5(t, d, i)
				return (
					(u.top = ad(p.top, u.top)),
					(u.right = Bp(p.right, u.right)),
					(u.bottom = Bp(p.bottom, u.bottom)),
					(u.left = ad(p.left, u.left)),
					u
				)
			}, O5(t, s, i))
		return { width: l.right - l.left, height: l.bottom - l.top, x: l.left, y: l.top }
	}
	function sCt(e) {
		const { width: t, height: n } = tG(e)
		return { width: t, height: n }
	}
	function lCt(e, t, n) {
		const r = bs(t),
			i = Ns(t),
			a = n === "fixed",
			o = Dd(e, !0, a, t)
		let s = { scrollLeft: 0, scrollTop: 0 }
		const l = ds(0)
		if (r || (!r && !a))
			if (((lh(t) !== "body" || Cg(i)) && (s = Hw(t)), r)) {
				const m = Dd(t, !0, a, t)
				;(l.x = m.x + t.clientLeft), (l.y = m.y + t.clientTop)
			} else i && (l.x = lN(i))
		const u = i && !r && !a ? rG(i, s) : ds(0),
			d = o.left + s.scrollLeft - l.x - u.x,
			p = o.top + s.scrollTop - l.y - u.y
		return { x: d, y: p, width: o.width, height: o.height }
	}
	function vS(e) {
		return Qa(e).position === "static"
	}
	function A5(e, t) {
		if (!bs(e) || Qa(e).position === "fixed") return null
		if (t) return t(e)
		let n = e.offsetParent
		return Ns(e) === n && (n = n.ownerDocument.body), n
	}
	function aG(e, t) {
		const n = ga(e)
		if (Bw(e)) return n
		if (!bs(e)) {
			let i = Wu(e)
			for (; i && !Fp(i); ) {
				if (xi(i) && !vS(i)) return i
				i = Wu(i)
			}
			return n
		}
		let r = A5(e, t)
		for (; r && LEt(r) && vS(r); ) r = A5(r, t)
		return r && Fp(r) && vS(r) && !rN(r) ? n : r || PEt(e) || n
	}
	const uCt = async function (e) {
		const t = this.getOffsetParent || aG,
			n = this.getDimensions,
			r = await n(e.floating)
		return {
			reference: lCt(e.reference, await t(e.floating), e.strategy),
			floating: { x: 0, y: 0, width: r.width, height: r.height },
		}
	}
	function cCt(e) {
		return Qa(e).direction === "rtl"
	}
	const dCt = {
		convertOffsetParentRelativeRectToViewportRelativeRect: eCt,
		getDocumentElement: Ns,
		getClippingRect: oCt,
		getOffsetParent: aG,
		getElementRects: uCt,
		getClientRects: tCt,
		getDimensions: sCt,
		getScale: Xf,
		isElement: xi,
		isRTL: cCt,
	}
	function fCt(e, t) {
		let n = null,
			r
		const i = Ns(e)
		function a() {
			var s
			clearTimeout(r), (s = n) == null || s.disconnect(), (n = null)
		}
		function o(s, l) {
			s === void 0 && (s = !1), l === void 0 && (l = 1), a()
			const { left: u, top: d, width: p, height: m } = e.getBoundingClientRect()
			if ((s || t(), !p || !m)) return
			const v = Oy(d),
				y = Oy(i.clientWidth - (u + p)),
				b = Oy(i.clientHeight - (d + m)),
				x = Oy(u),
				T = {
					rootMargin: -v + "px " + -y + "px " + -b + "px " + -x + "px",
					threshold: ad(0, Bp(1, l)) || 1,
				}
			let C = !0
			function D(O) {
				const A = O[0].intersectionRatio
				if (A !== l) {
					if (!C) return o()
					A
						? o(!1, A)
						: (r = setTimeout(() => {
								o(!1, 1e-7)
						  }, 1e3))
				}
				C = !1
			}
			try {
				n = new IntersectionObserver(D, { ...T, root: i.ownerDocument })
			} catch {
				n = new IntersectionObserver(D, T)
			}
			n.observe(e)
		}
		return o(!0), a
	}
	function pCt(e, t, n, r) {
		r === void 0 && (r = {})
		const {
				ancestorScroll: i = !0,
				ancestorResize: a = !0,
				elementResize: o = typeof ResizeObserver == "function",
				layoutShift: s = typeof IntersectionObserver == "function",
				animationFrame: l = !1,
			} = r,
			u = sN(e),
			d = i || a ? [...(u ? Bv(u) : []), ...Bv(t)] : []
		d.forEach((E) => {
			i && E.addEventListener("scroll", n, { passive: !0 }), a && E.addEventListener("resize", n)
		})
		const p = u && s ? fCt(u, n) : null
		let m = -1,
			v = null
		o &&
			((v = new ResizeObserver((E) => {
				let [T] = E
				T &&
					T.target === u &&
					v &&
					(v.unobserve(t),
					cancelAnimationFrame(m),
					(m = requestAnimationFrame(() => {
						var C
						;(C = v) == null || C.observe(t)
					}))),
					n()
			})),
			u && !l && v.observe(u),
			v.observe(t))
		let y,
			b = l ? Dd(e) : null
		l && x()
		function x() {
			const E = Dd(e)
			b && (E.x !== b.x || E.y !== b.y || E.width !== b.width || E.height !== b.height) && n(),
				(b = E),
				(y = requestAnimationFrame(x))
		}
		return (
			n(),
			() => {
				var E
				d.forEach((T) => {
					i && T.removeEventListener("scroll", n), a && T.removeEventListener("resize", n)
				}),
					p == null || p(),
					(E = v) == null || E.disconnect(),
					(v = null),
					l && cancelAnimationFrame(y)
			}
		)
	}
	const hCt = XEt,
		mCt = KEt,
		N5 = GEt,
		vCt = (e, t, n) => {
			const r = new Map(),
				i = { platform: dCt, ...n },
				a = { ...i.platform, _c: r }
			return WEt(e, t, { ...i, platform: a })
		}
	var S1 = typeof document < "u" ? _.useLayoutEffect : _.useEffect
	function rx(e, t) {
		if (e === t) return !0
		if (typeof e != typeof t) return !1
		if (typeof e == "function" && e.toString() === t.toString()) return !0
		let n, r, i
		if (e && t && typeof e == "object") {
			if (Array.isArray(e)) {
				if (((n = e.length), n !== t.length)) return !1
				for (r = n; r-- !== 0; ) if (!rx(e[r], t[r])) return !1
				return !0
			}
			if (((i = Object.keys(e)), (n = i.length), n !== Object.keys(t).length)) return !1
			for (r = n; r-- !== 0; ) if (!{}.hasOwnProperty.call(t, i[r])) return !1
			for (r = n; r-- !== 0; ) {
				const a = i[r]
				if (!(a === "_owner" && e.$$typeof) && !rx(e[a], t[a])) return !1
			}
			return !0
		}
		return e !== e && t !== t
	}
	function oG(e) {
		return typeof window > "u" ? 1 : (e.ownerDocument.defaultView || window).devicePixelRatio || 1
	}
	function M5(e, t) {
		const n = oG(e)
		return Math.round(t * n) / n
	}
	function gS(e) {
		const t = _.useRef(e)
		return (
			S1(() => {
				t.current = e
			}),
			t
		)
	}
	function gCt(e) {
		e === void 0 && (e = {})
		const {
				placement: t = "bottom",
				strategy: n = "absolute",
				middleware: r = [],
				platform: i,
				elements: { reference: a, floating: o } = {},
				transform: s = !0,
				whileElementsMounted: l,
				open: u,
			} = e,
			[d, p] = _.useState({
				x: 0,
				y: 0,
				strategy: n,
				placement: t,
				middlewareData: {},
				isPositioned: !1,
			}),
			[m, v] = _.useState(r)
		rx(m, r) || v(r)
		const [y, b] = _.useState(null),
			[x, E] = _.useState(null),
			T = _.useCallback((J) => {
				J !== A.current && ((A.current = J), b(J))
			}, []),
			C = _.useCallback((J) => {
				J !== N.current && ((N.current = J), E(J))
			}, []),
			D = a || y,
			O = o || x,
			A = _.useRef(null),
			N = _.useRef(null),
			I = _.useRef(d),
			P = l != null,
			L = gS(l),
			B = gS(i),
			z = gS(u),
			V = _.useCallback(() => {
				if (!A.current || !N.current) return
				const J = { placement: t, strategy: n, middleware: m }
				B.current && (J.platform = B.current),
					vCt(A.current, N.current, J).then((le) => {
						const F = { ...le, isPositioned: z.current !== !1 }
						K.current &&
							!rx(I.current, F) &&
							((I.current = F),
							$D.flushSync(() => {
								p(F)
							}))
					})
			}, [m, t, n, B, z])
		S1(() => {
			u === !1 &&
				I.current.isPositioned &&
				((I.current.isPositioned = !1), p((J) => ({ ...J, isPositioned: !1 })))
		}, [u])
		const K = _.useRef(!1)
		S1(
			() => (
				(K.current = !0),
				() => {
					K.current = !1
				}
			),
			[],
		),
			S1(() => {
				if ((D && (A.current = D), O && (N.current = O), D && O)) {
					if (L.current) return L.current(D, O, V)
					V()
				}
			}, [D, O, V, L, P])
		const ne = _.useMemo(
				() => ({ reference: A, floating: N, setReference: T, setFloating: C }),
				[T, C],
			),
			re = _.useMemo(() => ({ reference: D, floating: O }), [D, O]),
			ie = _.useMemo(() => {
				const J = { position: n, left: 0, top: 0 }
				if (!re.floating) return J
				const le = M5(re.floating, d.x),
					F = M5(re.floating, d.y)
				return s
					? {
							...J,
							transform: "translate(" + le + "px, " + F + "px)",
							...(oG(re.floating) >= 1.5 && { willChange: "transform" }),
					  }
					: { position: n, left: le, top: F }
			}, [n, s, re.floating, d.x, d.y])
		return _.useMemo(
			() => ({ ...d, update: V, refs: ne, elements: re, floatingStyles: ie }),
			[d, V, ne, re, ie],
		)
	}
	const yCt = (e) => {
			function t(n) {
				return {}.hasOwnProperty.call(n, "current")
			}
			return {
				name: "arrow",
				options: e,
				fn(n) {
					const { element: r, padding: i } = typeof e == "function" ? e(n) : e
					return r && t(r)
						? r.current != null
							? N5({ element: r.current, padding: i }).fn(n)
							: {}
						: r
						? N5({ element: r, padding: i }).fn(n)
						: {}
				},
			}
		},
		bCt = (e, t) => ({ ...hCt(e), options: [e, t] }),
		xCt = (e, t) => ({ ...mCt(e), options: [e, t] }),
		wCt = (e, t) => ({ ...yCt(e), options: [e, t] }),
		sG = { ...CS },
		ECt = sG.useInsertionEffect,
		CCt = ECt || ((e) => e())
	function TCt(e) {
		const t = _.useRef(() => {})
		return (
			CCt(() => {
				t.current = e
			}),
			_.useCallback(function () {
				for (var n = arguments.length, r = new Array(n), i = 0; i < n; i++) r[i] = arguments[i]
				return t.current == null ? void 0 : t.current(...r)
			}, [])
		)
	}
	var ix = typeof document < "u" ? _.useLayoutEffect : _.useEffect
	function LD() {
		return (
			(LD = Object.assign
				? Object.assign.bind()
				: function (e) {
						for (var t = 1; t < arguments.length; t++) {
							var n = arguments[t]
							for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r])
						}
						return e
				  }),
			LD.apply(this, arguments)
		)
	}
	let I5 = !1,
		kCt = 0
	const R5 = () => "floating-ui-" + Math.random().toString(36).slice(2, 6) + kCt++
	function SCt() {
		const [e, t] = _.useState(() => (I5 ? R5() : void 0))
		return (
			ix(() => {
				e == null && t(R5())
			}, []),
			_.useEffect(() => {
				I5 = !0
			}, []),
			e
		)
	}
	const DCt = sG.useId,
		lG = DCt || SCt,
		_Ct = _.forwardRef(function (t, n) {
			const {
					context: {
						placement: r,
						elements: { floating: i },
						middlewareData: { arrow: a, shift: o },
					},
					width: s = 14,
					height: l = 7,
					tipRadius: u = 0,
					strokeWidth: d = 0,
					staticOffset: p,
					stroke: m,
					d: v,
					style: { transform: y, ...b } = {},
					...x
				} = t,
				E = lG(),
				[T, C] = _.useState(!1)
			if (
				(ix(() => {
					if (!i) return
					Qa(i).direction === "rtl" && C(!0)
				}, [i]),
				!i)
			)
				return null
			const [D, O] = r.split("-"),
				A = D === "top" || D === "bottom"
			let N = p
			;((A && o != null && o.x) || (!A && o != null && o.y)) && (N = null)
			const I = d * 2,
				P = I / 2,
				L = (s / 2) * (u / -8 + 1),
				B = ((l / 2) * u) / 4,
				z = !!v,
				V = N && O === "end" ? "bottom" : "top"
			let K = N && O === "end" ? "right" : "left"
			N && T && (K = O === "end" ? "left" : "right")
			const ne = (a == null ? void 0 : a.x) != null ? N || a.x : "",
				re = (a == null ? void 0 : a.y) != null ? N || a.y : "",
				ie =
					v ||
					"M0,0" +
						(" H" + s) +
						(" L" + (s - L) + "," + (l - B)) +
						(" Q" + s / 2 + "," + l + " " + L + "," + (l - B)) +
						" Z",
				J = {
					top: z ? "rotate(180deg)" : "",
					left: z ? "rotate(90deg)" : "rotate(-90deg)",
					bottom: z ? "" : "rotate(180deg)",
					right: z ? "rotate(-90deg)" : "rotate(90deg)",
				}[D]
			return _.createElement(
				"svg",
				LD({}, x, {
					"aria-hidden": !0,
					ref: n,
					width: z ? s : s + I,
					height: s,
					viewBox: "0 0 " + s + " " + (l > s ? l : s),
					style: {
						position: "absolute",
						pointerEvents: "none",
						[K]: ne,
						[V]: re,
						[D]: A || z ? "100%" : "calc(100% - " + I / 2 + "px)",
						transform: [J, y].filter((le) => !!le).join(" "),
						...b,
					},
				}),
				I > 0 &&
					_.createElement("path", {
						clipPath: "url(#" + E + ")",
						fill: "none",
						stroke: m,
						strokeWidth: I + (v ? 0 : 1),
						d: ie,
					}),
				_.createElement("path", { stroke: I && !v ? x.fill : "none", d: ie }),
				_.createElement(
					"clipPath",
					{ id: E },
					_.createElement("rect", { x: -P, y: P * (z ? -1 : 1), width: s + I, height: s }),
				),
			)
		})
	function OCt() {
		const e = new Map()
		return {
			emit(t, n) {
				var r
				;(r = e.get(t)) == null || r.forEach((i) => i(n))
			},
			on(t, n) {
				e.set(t, [...(e.get(t) || []), n])
			},
			off(t, n) {
				var r
				e.set(t, ((r = e.get(t)) == null ? void 0 : r.filter((i) => i !== n)) || [])
			},
		}
	}
	const ACt = _.createContext(null),
		NCt = _.createContext(null),
		MCt = () => {
			var e
			return ((e = _.useContext(ACt)) == null ? void 0 : e.id) || null
		},
		ICt = () => _.useContext(NCt)
	function RCt(e) {
		const { open: t = !1, onOpenChange: n, elements: r } = e,
			i = lG(),
			a = _.useRef({}),
			[o] = _.useState(() => OCt()),
			s = MCt() != null,
			[l, u] = _.useState(r.reference),
			d = TCt((v, y, b) => {
				;(a.current.openEvent = v ? y : void 0),
					o.emit("openchange", { open: v, event: y, reason: b, nested: s }),
					n == null || n(v, y, b)
			}),
			p = _.useMemo(() => ({ setPositionReference: u }), []),
			m = _.useMemo(
				() => ({
					reference: l || r.reference || null,
					floating: r.floating || null,
					domReference: r.reference,
				}),
				[l, r.reference, r.floating],
			)
		return _.useMemo(
			() => ({
				dataRef: a,
				open: t,
				onOpenChange: d,
				elements: m,
				events: o,
				floatingId: i,
				refs: p,
			}),
			[t, d, m, o, i, p],
		)
	}
	function LCt(e) {
		e === void 0 && (e = {})
		const { nodeId: t } = e,
			n = RCt({ ...e, elements: { reference: null, floating: null, ...e.elements } }),
			r = e.rootContext || n,
			i = r.elements,
			[a, o] = _.useState(null),
			[s, l] = _.useState(null),
			d = (i == null ? void 0 : i.domReference) || a,
			p = _.useRef(null),
			m = ICt()
		ix(() => {
			d && (p.current = d)
		}, [d])
		const v = gCt({ ...e, elements: { ...i, ...(s && { reference: s }) } }),
			y = _.useCallback(
				(C) => {
					const D = xi(C)
						? { getBoundingClientRect: () => C.getBoundingClientRect(), contextElement: C }
						: C
					l(D), v.refs.setReference(D)
				},
				[v.refs],
			),
			b = _.useCallback(
				(C) => {
					;(xi(C) || C === null) && ((p.current = C), o(C)),
						(xi(v.refs.reference.current) ||
							v.refs.reference.current === null ||
							(C !== null && !xi(C))) &&
							v.refs.setReference(C)
				},
				[v.refs],
			),
			x = _.useMemo(
				() => ({ ...v.refs, setReference: b, setPositionReference: y, domReference: p }),
				[v.refs, b, y],
			),
			E = _.useMemo(() => ({ ...v.elements, domReference: d }), [v.elements, d]),
			T = _.useMemo(() => ({ ...v, ...r, refs: x, elements: E, nodeId: t }), [v, x, E, t, r])
		return (
			ix(() => {
				r.dataRef.current.floatingContext = T
				const C = m == null ? void 0 : m.nodesRef.current.find((D) => D.id === t)
				C && (C.context = T)
			}),
			_.useMemo(() => ({ ...v, context: T, refs: x, elements: E }), [v, x, E, T])
		)
	}
	/*!
  react-datepicker v7.5.0
  https://github.com/Hacker0x01/react-datepicker
  Released under the MIT License.
*/ var PD = function (t, n) {
		return (
			(PD =
				Object.setPrototypeOf ||
				({ __proto__: [] } instanceof Array &&
					function (r, i) {
						r.__proto__ = i
					}) ||
				function (r, i) {
					for (var a in i) Object.prototype.hasOwnProperty.call(i, a) && (r[a] = i[a])
				}),
			PD(t, n)
		)
	}
	function Ir(e, t) {
		if (typeof t != "function" && t !== null)
			throw new TypeError("Class extends value " + String(t) + " is not a constructor or null")
		PD(e, t)
		function n() {
			this.constructor = e
		}
		e.prototype = t === null ? Object.create(t) : ((n.prototype = t.prototype), new n())
	}
	var Rt = function () {
		return (
			(Rt =
				Object.assign ||
				function (n) {
					for (var r, i = 1, a = arguments.length; i < a; i++) {
						r = arguments[i]
						for (var o in r) Object.prototype.hasOwnProperty.call(r, o) && (n[o] = r[o])
					}
					return n
				}),
			Rt.apply(this, arguments)
		)
	}
	function is(e, t, n) {
		if (n || arguments.length === 2)
			for (var r = 0, i = t.length, a; r < i; r++)
				(a || !(r in t)) && (a || (a = Array.prototype.slice.call(t, 0, r)), (a[r] = t[r]))
		return e.concat(a || Array.prototype.slice.call(t))
	}
	var PCt = function (e) {
			var t = e.showTimeSelectOnly,
				n = t === void 0 ? !1 : t,
				r = e.showTime,
				i = r === void 0 ? !1 : r,
				a = e.className,
				o = e.children,
				s = n ? "Choose Time" : "Choose Date".concat(i ? " and Time" : "")
			return H.createElement(
				"div",
				{ className: a, role: "dialog", "aria-label": s, "aria-modal": "true" },
				o,
			)
		},
		jCt = function (e, t) {
			var n = _.useRef(null),
				r = _.useRef(e)
			r.current = e
			var i = _.useCallback(
				function (a) {
					var o
					n.current &&
						!n.current.contains(a.target) &&
						((t && a.target instanceof HTMLElement && a.target.classList.contains(t)) ||
							(o = r.current) === null ||
							o === void 0 ||
							o.call(r, a))
				},
				[t],
			)
			return (
				_.useEffect(
					function () {
						return (
							document.addEventListener("mousedown", i),
							function () {
								document.removeEventListener("mousedown", i)
							}
						)
					},
					[i],
				),
				n
			)
		},
		Uw = function (e) {
			var t = e.children,
				n = e.onClickOutside,
				r = e.className,
				i = e.containerRef,
				a = e.style,
				o = e.ignoreClass,
				s = jCt(n, o)
			return H.createElement(
				"div",
				{
					className: r,
					style: a,
					ref: function (l) {
						;(s.current = l), i && (i.current = l)
					},
				},
				t,
			)
		},
		He
	;(function (e) {
		;(e.ArrowUp = "ArrowUp"),
			(e.ArrowDown = "ArrowDown"),
			(e.ArrowLeft = "ArrowLeft"),
			(e.ArrowRight = "ArrowRight"),
			(e.PageUp = "PageUp"),
			(e.PageDown = "PageDown"),
			(e.Home = "Home"),
			(e.End = "End"),
			(e.Enter = "Enter"),
			(e.Space = " "),
			(e.Tab = "Tab"),
			(e.Escape = "Escape"),
			(e.Backspace = "Backspace"),
			(e.X = "x")
	})(He || (He = {}))
	function uG() {
		var e = typeof window < "u" ? window : globalThis
		return e
	}
	var kg = 12,
		FCt = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g
	function rn(e) {
		if (e == null) return new Date()
		var t = typeof e == "string" ? yEt(e) : ze(e)
		return Zs(t) ? t : new Date()
	}
	function yS(e, t, n, r, i) {
		var a,
			o = null,
			s = od(n) || od(Zm()),
			l = !0
		if (Array.isArray(t))
			return (
				t.forEach(function (d) {
					var p = hS(e, d, new Date(), {
						locale: s,
						useAdditionalWeekYearTokens: !0,
						useAdditionalDayOfYearTokens: !0,
					})
					r && (l = Zs(p, i) && e === wn(p, d, n)), Zs(p, i) && l && (o = p)
				}),
				o
			)
		if (
			((o = hS(e, t, new Date(), {
				locale: s,
				useAdditionalWeekYearTokens: !0,
				useAdditionalDayOfYearTokens: !0,
			})),
			r)
		)
			l = Zs(o) && e === wn(o, t, n)
		else if (!Zs(o)) {
			var u = ((a = t.match(FCt)) !== null && a !== void 0 ? a : [])
				.map(function (d) {
					var p = d[0]
					if (p === "p" || p === "P") {
						var m = Jb[p]
						return s ? m(d, s.formatLong) : p
					}
					return d
				})
				.join("")
			e.length > 0 &&
				(o = hS(e, u.slice(0, e.length), new Date(), {
					useAdditionalWeekYearTokens: !0,
					useAdditionalDayOfYearTokens: !0,
				})),
				Zs(o) || (o = new Date(e))
		}
		return Zs(o) && l ? o : null
	}
	function Zs(e, t) {
		return Gb(e) && !Sd(e, t ?? new Date("1/1/1800"))
	}
	function wn(e, t, n) {
		if (n === "en")
			return T5(e, t, { useAdditionalWeekYearTokens: !0, useAdditionalDayOfYearTokens: !0 })
		var r = n ? od(n) : void 0
		return (
			n &&
				!r &&
				console.warn('A locale object was not found for the provided string ["'.concat(n, '"].')),
			!r && Zm() && od(Zm()) && (r = od(Zm())),
			T5(e, t, { locale: r, useAdditionalWeekYearTokens: !0, useAdditionalDayOfYearTokens: !0 })
		)
	}
	function La(e, t) {
		var n = t.dateFormat,
			r = t.locale,
			i = Array.isArray(n) && n.length > 0 ? n[0] : n
		return (e && wn(e, i, r)) || ""
	}
	function BCt(e, t, n) {
		if (!e) return ""
		var r = La(e, n),
			i = t ? La(t, n) : ""
		return "".concat(r, " - ").concat(i)
	}
	function HCt(e, t) {
		if (!(e != null && e.length)) return ""
		var n = e[0] ? La(e[0], t) : ""
		if (e.length === 1) return n
		if (e.length === 2 && e[1]) {
			var r = La(e[1], t)
			return "".concat(n, ", ").concat(r)
		}
		var i = e.length - 1
		return "".concat(n, " (+").concat(i, ")")
	}
	function bS(e, t) {
		var n = t.hour,
			r = n === void 0 ? 0 : n,
			i = t.minute,
			a = i === void 0 ? 0 : i,
			o = t.second,
			s = o === void 0 ? 0 : o
		return C1(T1(k1(e, s), a), r)
	}
	function $Ct(e) {
		return ZA(e)
	}
	function UCt(e, t) {
		return wn(e, "ddd", t)
	}
	function D1(e) {
		return kd(e)
	}
	function Nu(e, t, n) {
		var r = od(t || Zm())
		return kl(e, { locale: r, weekStartsOn: n })
	}
	function gl(e) {
		return BY(e)
	}
	function Dm(e) {
		return jw(e)
	}
	function L5(e) {
		return AD(e)
	}
	function P5() {
		return kd(rn())
	}
	function j5(e) {
		return jY(e)
	}
	function zCt(e) {
		return Cxt(e)
	}
	function qCt(e) {
		return FY(e)
	}
	function Xo(e, t) {
		return e && t ? vEt(e, t) : !e && !t
	}
	function pi(e, t) {
		return e && t ? hEt(e, t) : !e && !t
	}
	function ax(e, t) {
		return e && t ? mEt(e, t) : !e && !t
	}
	function At(e, t) {
		return e && t ? wxt(e, t) : !e && !t
	}
	function zc(e, t) {
		return e && t ? bwt(e, t) : !e && !t
	}
	function _m(e, t, n) {
		var r,
			i = kd(t),
			a = jY(n)
		try {
			r = Fv(e, { start: i, end: a })
		} catch {
			r = !1
		}
		return r
	}
	function Zm() {
		var e = uG()
		return e.__localeId__
	}
	function od(e) {
		if (typeof e == "string") {
			var t = uG()
			return t.__localeData__ ? t.__localeData__[e] : void 0
		} else return e
	}
	function VCt(e, t, n) {
		return t(wn(e, "EEEE", n))
	}
	function WCt(e, t) {
		return wn(e, "EEEEEE", t)
	}
	function YCt(e, t) {
		return wn(e, "EEE", t)
	}
	function uN(e, t) {
		return wn(ia(rn(), e), "LLLL", t)
	}
	function cG(e, t) {
		return wn(ia(rn(), e), "LLL", t)
	}
	function GCt(e, t) {
		return wn(Mf(rn(), e), "QQQ", t)
	}
	function $a(e, t) {
		var n = t === void 0 ? {} : t,
			r = n.minDate,
			i = n.maxDate,
			a = n.excludeDates,
			o = n.excludeDateIntervals,
			s = n.includeDates,
			l = n.includeDateIntervals,
			u = n.filterDate
		return (
			Sg(e, { minDate: r, maxDate: i }) ||
			(a &&
				a.some(function (d) {
					return d instanceof Date ? At(e, d) : At(e, d.date)
				})) ||
			(o &&
				o.some(function (d) {
					var p = d.start,
						m = d.end
					return Fv(e, { start: p, end: m })
				})) ||
			(s &&
				!s.some(function (d) {
					return At(e, d)
				})) ||
			(l &&
				!l.some(function (d) {
					var p = d.start,
						m = d.end
					return Fv(e, { start: p, end: m })
				})) ||
			(u && !u(rn(e))) ||
			!1
		)
	}
	function cN(e, t) {
		var n = t === void 0 ? {} : t,
			r = n.excludeDates,
			i = n.excludeDateIntervals
		return i && i.length > 0
			? i.some(function (a) {
					var o = a.start,
						s = a.end
					return Fv(e, { start: o, end: s })
			  })
			: (r &&
					r.some(function (a) {
						var o
						return a instanceof Date
							? At(e, a)
							: At(e, (o = a.date) !== null && o !== void 0 ? o : new Date())
					})) ||
					!1
	}
	function dG(e, t) {
		var n = t === void 0 ? {} : t,
			r = n.minDate,
			i = n.maxDate,
			a = n.excludeDates,
			o = n.includeDates,
			s = n.filterDate
		return (
			Sg(e, { minDate: r ? BY(r) : void 0, maxDate: i ? FY(i) : void 0 }) ||
			(a == null
				? void 0
				: a.some(function (l) {
						return pi(e, l instanceof Date ? l : l.date)
				  })) ||
			(o &&
				!o.some(function (l) {
					return pi(e, l)
				})) ||
			(s && !s(rn(e))) ||
			!1
		)
	}
	function Ay(e, t, n, r) {
		var i = Tt(e),
			a = bi(e),
			o = Tt(t),
			s = bi(t),
			l = Tt(r)
		return i === o && i === l
			? a <= n && n <= s
			: i < o
			? (l === i && a <= n) || (l === o && s >= n) || (l < o && l > i)
			: !1
	}
	function KCt(e, t) {
		var n = t === void 0 ? {} : t,
			r = n.minDate,
			i = n.maxDate,
			a = n.excludeDates,
			o = n.includeDates
		return (
			Sg(e, { minDate: r, maxDate: i }) ||
			(a &&
				a.some(function (s) {
					return pi(s instanceof Date ? s : s.date, e)
				})) ||
			(o &&
				!o.some(function (s) {
					return pi(s, e)
				})) ||
			!1
		)
	}
	function Ny(e, t) {
		var n = t === void 0 ? {} : t,
			r = n.minDate,
			i = n.maxDate,
			a = n.excludeDates,
			o = n.includeDates,
			s = n.filterDate
		return (
			Sg(e, { minDate: r, maxDate: i }) ||
			(a == null
				? void 0
				: a.some(function (l) {
						return ax(e, l instanceof Date ? l : l.date)
				  })) ||
			(o &&
				!o.some(function (l) {
					return ax(e, l)
				})) ||
			(s && !s(rn(e))) ||
			!1
		)
	}
	function My(e, t, n) {
		if (!t || !n || !Gb(t) || !Gb(n)) return !1
		var r = Tt(t),
			i = Tt(n)
		return r <= e && i >= e
	}
	function _1(e, t) {
		var n = t === void 0 ? {} : t,
			r = n.minDate,
			i = n.maxDate,
			a = n.excludeDates,
			o = n.includeDates,
			s = n.filterDate,
			l = new Date(e, 0, 1)
		return (
			Sg(l, { minDate: r ? jw(r) : void 0, maxDate: i ? HY(i) : void 0 }) ||
			(a == null
				? void 0
				: a.some(function (u) {
						return Xo(l, u instanceof Date ? u : u.date)
				  })) ||
			(o &&
				!o.some(function (u) {
					return Xo(l, u)
				})) ||
			(s && !s(rn(l))) ||
			!1
		)
	}
	function Iy(e, t, n, r) {
		var i = Tt(e),
			a = id(e),
			o = Tt(t),
			s = id(t),
			l = Tt(r)
		return i === o && i === l
			? a <= n && n <= s
			: i < o
			? (l === i && a <= n) || (l === o && s >= n) || (l < o && l > i)
			: !1
	}
	function Sg(e, t) {
		var n,
			r = t === void 0 ? {} : t,
			i = r.minDate,
			a = r.maxDate
		return (n = (i && Lp(e, i) < 0) || (a && Lp(e, a) > 0)) !== null && n !== void 0 ? n : !1
	}
	function F5(e, t) {
		return t.some(function (n) {
			return us(n) === us(e) && cs(n) === cs(e) && vl(n) === vl(e)
		})
	}
	function B5(e, t) {
		var n = t === void 0 ? {} : t,
			r = n.excludeTimes,
			i = n.includeTimes,
			a = n.filterTime
		return (r && F5(e, r)) || (i && !F5(e, i)) || (a && !a(e)) || !1
	}
	function H5(e, t) {
		var n = t.minTime,
			r = t.maxTime
		if (!n || !r) throw new Error("Both minTime and maxTime props required")
		var i = rn()
		;(i = C1(i, us(e))), (i = T1(i, cs(e))), (i = k1(i, vl(e)))
		var a = rn()
		;(a = C1(a, us(n))), (a = T1(a, cs(n))), (a = k1(a, vl(n)))
		var o = rn()
		;(o = C1(o, us(r))), (o = T1(o, cs(r))), (o = k1(o, vl(r)))
		var s
		try {
			s = !Fv(i, { start: a, end: o })
		} catch {
			s = !1
		}
		return s
	}
	function $5(e, t) {
		var n = t === void 0 ? {} : t,
			r = n.minDate,
			i = n.includeDates,
			a = Pp(e, 1)
		return (
			(r && Kb(r, a) > 0) ||
			(i &&
				i.every(function (o) {
					return Kb(o, a) > 0
				})) ||
			!1
		)
	}
	function U5(e, t) {
		var n = t === void 0 ? {} : t,
			r = n.maxDate,
			i = n.includeDates,
			a = No(e, 1)
		return (
			(r && Kb(a, r) > 0) ||
			(i &&
				i.every(function (o) {
					return Kb(a, o) > 0
				})) ||
			!1
		)
	}
	function QCt(e, t) {
		var n = t === void 0 ? {} : t,
			r = n.minDate,
			i = n.includeDates,
			a = jw(e),
			o = XY(a, 1)
		return (
			(r && Qb(r, o) > 0) ||
			(i &&
				i.every(function (s) {
					return Qb(s, o) > 0
				})) ||
			!1
		)
	}
	function XCt(e, t) {
		var n = t === void 0 ? {} : t,
			r = n.maxDate,
			i = n.includeDates,
			a = HY(e),
			o = JA(a, 1)
		return (
			(r && Qb(o, r) > 0) ||
			(i &&
				i.every(function (s) {
					return Qb(o, s) > 0
				})) ||
			!1
		)
	}
	function z5(e, t) {
		var n = t === void 0 ? {} : t,
			r = n.minDate,
			i = n.includeDates,
			a = jp(e, 1)
		return (
			(r && Xb(r, a) > 0) ||
			(i &&
				i.every(function (o) {
					return Xb(o, a) > 0
				})) ||
			!1
		)
	}
	function JCt(e, t) {
		var n = t === void 0 ? {} : t,
			r = n.minDate,
			i = n.yearItemNumber,
			a = i === void 0 ? kg : i,
			o = Dm(jp(e, a)),
			s = wu(o, a).endPeriod,
			l = r && Tt(r)
		return (l && l > s) || !1
	}
	function q5(e, t) {
		var n = t === void 0 ? {} : t,
			r = n.maxDate,
			i = n.includeDates,
			a = hl(e, 1)
		return (
			(r && Xb(a, r) > 0) ||
			(i &&
				i.every(function (o) {
					return Xb(a, o) > 0
				})) ||
			!1
		)
	}
	function ZCt(e, t) {
		var n = t === void 0 ? {} : t,
			r = n.maxDate,
			i = n.yearItemNumber,
			a = i === void 0 ? kg : i,
			o = hl(e, a),
			s = wu(o, a).startPeriod,
			l = r && Tt(r)
		return (l && l < s) || !1
	}
	function fG(e) {
		var t = e.minDate,
			n = e.includeDates
		if (n && t) {
			var r = n.filter(function (i) {
				return Lp(i, t) >= 0
			})
			return y5(r)
		} else return n ? y5(n) : t
	}
	function pG(e) {
		var t = e.maxDate,
			n = e.includeDates
		if (n && t) {
			var r = n.filter(function (i) {
				return Lp(i, t) <= 0
			})
			return g5(r)
		} else return n ? g5(n) : t
	}
	function V5(e, t) {
		var n
		e === void 0 && (e = []), t === void 0 && (t = "react-datepicker__day--highlighted")
		for (var r = new Map(), i = 0, a = e.length; i < a; i++) {
			var o = e[i]
			if (ml(o)) {
				var s = wn(o, "MM.dd.yyyy"),
					l = r.get(s) || []
				l.includes(t) || (l.push(t), r.set(s, l))
			} else if (typeof o == "object") {
				var u = Object.keys(o),
					d = (n = u[0]) !== null && n !== void 0 ? n : "",
					p = o[d]
				if (typeof d == "string" && Array.isArray(p))
					for (var m = 0, v = p.length; m < v; m++) {
						var y = p[m]
						if (y) {
							var s = wn(y, "MM.dd.yyyy"),
								l = r.get(s) || []
							l.includes(d) || (l.push(d), r.set(s, l))
						}
					}
			}
		}
		return r
	}
	function eTt(e, t) {
		return e.length !== t.length
			? !1
			: e.every(function (n, r) {
					return n === t[r]
			  })
	}
	function tTt(e, t) {
		e === void 0 && (e = []), t === void 0 && (t = "react-datepicker__day--holidays")
		var n = new Map()
		return (
			e.forEach(function (r) {
				var i = r.date,
					a = r.holidayName
				if (ml(i)) {
					var o = wn(i, "MM.dd.yyyy"),
						s = n.get(o) || { className: "", holidayNames: [] }
					if (!("className" in s && s.className === t && eTt(s.holidayNames, [a]))) {
						s.className = t
						var l = s.holidayNames
						;(s.holidayNames = l ? is(is([], l, !0), [a], !1) : [a]), n.set(o, s)
					}
				}
			}),
			n
		)
	}
	function nTt(e, t, n, r, i) {
		for (var a = i.length, o = [], s = 0; s < a; s++) {
			var l = e,
				u = i[s]
			u && ((l = gxt(l, us(u))), (l = OD(l, cs(u))), (l = xxt(l, vl(u))))
			var d = OD(e, (n + 1) * r)
			Vu(l, t) && Sd(l, d) && u != null && o.push(u)
		}
		return o
	}
	function W5(e) {
		return e < 10 ? "0".concat(e) : "".concat(e)
	}
	function wu(e, t) {
		t === void 0 && (t = kg)
		var n = Math.ceil(Tt(e) / t) * t,
			r = n - (t - 1)
		return { startPeriod: r, endPeriod: n }
	}
	function rTt(e) {
		var t = new Date(e.getFullYear(), e.getMonth(), e.getDate()),
			n = new Date(e.getFullYear(), e.getMonth(), e.getDate(), 24)
		return Math.round((+n - +t) / 36e5)
	}
	function Y5(e) {
		var t = e.getSeconds(),
			n = e.getMilliseconds()
		return ze(e.getTime() - t * 1e3 - n)
	}
	function iTt(e, t) {
		return Y5(e).getTime() === Y5(t).getTime()
	}
	function G5(e) {
		if (!ml(e)) throw new Error("Invalid date")
		var t = new Date(e)
		return t.setHours(0, 0, 0, 0), t
	}
	function K5(e, t) {
		if (!ml(e) || !ml(t)) throw new Error("Invalid date received")
		var n = G5(e),
			r = G5(t)
		return Sd(n, r)
	}
	function hG(e) {
		return e.key === He.Space
	}
	var aTt = (function (e) {
			Ir(t, e)
			function t(n) {
				var r = e.call(this, n) || this
				return (
					(r.inputRef = H.createRef()),
					(r.onTimeChange = function (i) {
						var a, o
						r.setState({ time: i })
						var s = r.props.date,
							l = s instanceof Date && !isNaN(+s),
							u = l ? s : new Date()
						if (i != null && i.includes(":")) {
							var d = i.split(":"),
								p = d[0],
								m = d[1]
							u.setHours(Number(p)), u.setMinutes(Number(m))
						}
						;(o = (a = r.props).onChange) === null || o === void 0 || o.call(a, u)
					}),
					(r.renderTimeInput = function () {
						var i = r.state.time,
							a = r.props,
							o = a.date,
							s = a.timeString,
							l = a.customTimeInput
						return l
							? _.cloneElement(l, { date: o, value: i, onChange: r.onTimeChange })
							: H.createElement("input", {
									type: "time",
									className: "react-datepicker-time__input",
									placeholder: "Time",
									name: "time-input",
									ref: r.inputRef,
									onClick: function () {
										var u
										;(u = r.inputRef.current) === null || u === void 0 || u.focus()
									},
									required: !0,
									value: i,
									onChange: function (u) {
										r.onTimeChange(u.target.value || s)
									},
							  })
					}),
					(r.state = { time: r.props.timeString }),
					r
				)
			}
			return (
				(t.getDerivedStateFromProps = function (n, r) {
					return n.timeString !== r.time ? { time: n.timeString } : null
				}),
				(t.prototype.render = function () {
					return H.createElement(
						"div",
						{ className: "react-datepicker__input-time-container" },
						H.createElement(
							"div",
							{ className: "react-datepicker-time__caption" },
							this.props.timeInputLabel,
						),
						H.createElement(
							"div",
							{ className: "react-datepicker-time__input-container" },
							H.createElement(
								"div",
								{ className: "react-datepicker-time__input" },
								this.renderTimeInput(),
							),
						),
					)
				}),
				t
			)
		})(_.Component),
		oTt = (function (e) {
			Ir(t, e)
			function t() {
				var n = (e !== null && e.apply(this, arguments)) || this
				return (
					(n.dayEl = _.createRef()),
					(n.handleClick = function (r) {
						!n.isDisabled() && n.props.onClick && n.props.onClick(r)
					}),
					(n.handleMouseEnter = function (r) {
						!n.isDisabled() && n.props.onMouseEnter && n.props.onMouseEnter(r)
					}),
					(n.handleOnKeyDown = function (r) {
						var i,
							a,
							o = r.key
						o === He.Space && (r.preventDefault(), (r.key = He.Enter)),
							(a = (i = n.props).handleOnKeyDown) === null || a === void 0 || a.call(i, r)
					}),
					(n.isSameDay = function (r) {
						return At(n.props.day, r)
					}),
					(n.isKeyboardSelected = function () {
						var r
						if (n.props.disabledKeyboardNavigation) return !1
						var i = n.props.selectsMultiple
								? (r = n.props.selectedDates) === null || r === void 0
									? void 0
									: r.some(function (o) {
											return n.isSameDayOrWeek(o)
									  })
								: n.isSameDayOrWeek(n.props.selected),
							a = n.props.preSelection && n.isDisabled(n.props.preSelection)
						return !i && n.isSameDayOrWeek(n.props.preSelection) && !a
					}),
					(n.isDisabled = function (r) {
						return (
							r === void 0 && (r = n.props.day),
							$a(r, {
								minDate: n.props.minDate,
								maxDate: n.props.maxDate,
								excludeDates: n.props.excludeDates,
								excludeDateIntervals: n.props.excludeDateIntervals,
								includeDateIntervals: n.props.includeDateIntervals,
								includeDates: n.props.includeDates,
								filterDate: n.props.filterDate,
							})
						)
					}),
					(n.isExcluded = function () {
						return cN(n.props.day, {
							excludeDates: n.props.excludeDates,
							excludeDateIntervals: n.props.excludeDateIntervals,
						})
					}),
					(n.isStartOfWeek = function () {
						return At(n.props.day, Nu(n.props.day, n.props.locale, n.props.calendarStartDay))
					}),
					(n.isSameWeek = function (r) {
						return (
							n.props.showWeekPicker &&
							At(r, Nu(n.props.day, n.props.locale, n.props.calendarStartDay))
						)
					}),
					(n.isSameDayOrWeek = function (r) {
						return n.isSameDay(r) || n.isSameWeek(r)
					}),
					(n.getHighLightedClass = function () {
						var r = n.props,
							i = r.day,
							a = r.highlightDates
						if (!a) return !1
						var o = wn(i, "MM.dd.yyyy")
						return a.get(o)
					}),
					(n.getHolidaysClass = function () {
						var r,
							i = n.props,
							a = i.day,
							o = i.holidays
						if (!o) return [void 0]
						var s = wn(a, "MM.dd.yyyy")
						return o.has(s)
							? [(r = o.get(s)) === null || r === void 0 ? void 0 : r.className]
							: [void 0]
					}),
					(n.isInRange = function () {
						var r = n.props,
							i = r.day,
							a = r.startDate,
							o = r.endDate
						return !a || !o ? !1 : _m(i, a, o)
					}),
					(n.isInSelectingRange = function () {
						var r,
							i = n.props,
							a = i.day,
							o = i.selectsStart,
							s = i.selectsEnd,
							l = i.selectsRange,
							u = i.selectsDisabledDaysInRange,
							d = i.startDate,
							p = i.endDate,
							m = (r = n.props.selectingDate) !== null && r !== void 0 ? r : n.props.preSelection
						return !(o || s || l) || !m || (!u && n.isDisabled())
							? !1
							: o && p && (Sd(m, p) || zc(m, p))
							? _m(a, m, p)
							: (s && d && (Vu(m, d) || zc(m, d))) || (l && d && !p && (Vu(m, d) || zc(m, d)))
							? _m(a, d, m)
							: !1
					}),
					(n.isSelectingRangeStart = function () {
						var r
						if (!n.isInSelectingRange()) return !1
						var i = n.props,
							a = i.day,
							o = i.startDate,
							s = i.selectsStart,
							l = (r = n.props.selectingDate) !== null && r !== void 0 ? r : n.props.preSelection
						return s ? At(a, l) : At(a, o)
					}),
					(n.isSelectingRangeEnd = function () {
						var r
						if (!n.isInSelectingRange()) return !1
						var i = n.props,
							a = i.day,
							o = i.endDate,
							s = i.selectsEnd,
							l = i.selectsRange,
							u = (r = n.props.selectingDate) !== null && r !== void 0 ? r : n.props.preSelection
						return s || l ? At(a, u) : At(a, o)
					}),
					(n.isRangeStart = function () {
						var r = n.props,
							i = r.day,
							a = r.startDate,
							o = r.endDate
						return !a || !o ? !1 : At(a, i)
					}),
					(n.isRangeEnd = function () {
						var r = n.props,
							i = r.day,
							a = r.startDate,
							o = r.endDate
						return !a || !o ? !1 : At(o, i)
					}),
					(n.isWeekend = function () {
						var r = mwt(n.props.day)
						return r === 0 || r === 6
					}),
					(n.isAfterMonth = function () {
						return n.props.month !== void 0 && (n.props.month + 1) % 12 === bi(n.props.day)
					}),
					(n.isBeforeMonth = function () {
						return n.props.month !== void 0 && (bi(n.props.day) + 1) % 12 === n.props.month
					}),
					(n.isCurrentDay = function () {
						return n.isSameDay(rn())
					}),
					(n.isSelected = function () {
						var r
						return n.props.selectsMultiple
							? (r = n.props.selectedDates) === null || r === void 0
								? void 0
								: r.some(function (i) {
										return n.isSameDayOrWeek(i)
								  })
							: n.isSameDayOrWeek(n.props.selected)
					}),
					(n.getClassNames = function (r) {
						var i = n.props.dayClassName ? n.props.dayClassName(r) : void 0
						return hn(
							"react-datepicker__day",
							i,
							"react-datepicker__day--" + UCt(n.props.day),
							{
								"react-datepicker__day--disabled": n.isDisabled(),
								"react-datepicker__day--excluded": n.isExcluded(),
								"react-datepicker__day--selected": n.isSelected(),
								"react-datepicker__day--keyboard-selected": n.isKeyboardSelected(),
								"react-datepicker__day--range-start": n.isRangeStart(),
								"react-datepicker__day--range-end": n.isRangeEnd(),
								"react-datepicker__day--in-range": n.isInRange(),
								"react-datepicker__day--in-selecting-range": n.isInSelectingRange(),
								"react-datepicker__day--selecting-range-start": n.isSelectingRangeStart(),
								"react-datepicker__day--selecting-range-end": n.isSelectingRangeEnd(),
								"react-datepicker__day--today": n.isCurrentDay(),
								"react-datepicker__day--weekend": n.isWeekend(),
								"react-datepicker__day--outside-month": n.isAfterMonth() || n.isBeforeMonth(),
							},
							n.getHighLightedClass(),
							n.getHolidaysClass(),
						)
					}),
					(n.getAriaLabel = function () {
						var r = n.props,
							i = r.day,
							a = r.ariaLabelPrefixWhenEnabled,
							o = a === void 0 ? "Choose" : a,
							s = r.ariaLabelPrefixWhenDisabled,
							l = s === void 0 ? "Not available" : s,
							u = n.isDisabled() || n.isExcluded() ? l : o
						return "".concat(u, " ").concat(wn(i, "PPPP", n.props.locale))
					}),
					(n.getTitle = function () {
						var r = n.props,
							i = r.day,
							a = r.holidays,
							o = a === void 0 ? new Map() : a,
							s = r.excludeDates,
							l = wn(i, "MM.dd.yyyy"),
							u = []
						return (
							o.has(l) && u.push.apply(u, o.get(l).holidayNames),
							n.isExcluded() &&
								u.push(
									s == null
										? void 0
										: s
												.filter(function (d) {
													return d instanceof Date ? At(d, i) : At(d == null ? void 0 : d.date, i)
												})
												.map(function (d) {
													if (!(d instanceof Date)) return d == null ? void 0 : d.message
												}),
								),
							u.join(", ")
						)
					}),
					(n.getTabIndex = function () {
						var r = n.props.selected,
							i = n.props.preSelection,
							a =
								!(n.props.showWeekPicker && (n.props.showWeekNumber || !n.isStartOfWeek())) &&
								(n.isKeyboardSelected() || (n.isSameDay(r) && At(i, r)))
									? 0
									: -1
						return a
					}),
					(n.handleFocusDay = function () {
						var r
						n.shouldFocusDay() &&
							((r = n.dayEl.current) === null || r === void 0 || r.focus({ preventScroll: !0 }))
					}),
					(n.renderDayContents = function () {
						return (n.props.monthShowsDuplicateDaysEnd && n.isAfterMonth()) ||
							(n.props.monthShowsDuplicateDaysStart && n.isBeforeMonth())
							? null
							: n.props.renderDayContents
							? n.props.renderDayContents(k5(n.props.day), n.props.day)
							: k5(n.props.day)
					}),
					(n.render = function () {
						return H.createElement(
							"div",
							{
								ref: n.dayEl,
								className: n.getClassNames(n.props.day),
								onKeyDown: n.handleOnKeyDown,
								onClick: n.handleClick,
								onMouseEnter: n.props.usePointerEvent ? void 0 : n.handleMouseEnter,
								onPointerEnter: n.props.usePointerEvent ? n.handleMouseEnter : void 0,
								tabIndex: n.getTabIndex(),
								"aria-label": n.getAriaLabel(),
								role: "option",
								title: n.getTitle(),
								"aria-disabled": n.isDisabled(),
								"aria-current": n.isCurrentDay() ? "date" : void 0,
								"aria-selected": n.isSelected() || n.isInRange(),
							},
							n.renderDayContents(),
							n.getTitle() !== "" &&
								H.createElement("span", { className: "overlay" }, n.getTitle()),
						)
					}),
					n
				)
			}
			return (
				(t.prototype.componentDidMount = function () {
					this.handleFocusDay()
				}),
				(t.prototype.componentDidUpdate = function () {
					this.handleFocusDay()
				}),
				(t.prototype.shouldFocusDay = function () {
					var n = !1
					return (
						this.getTabIndex() === 0 &&
							this.isSameDay(this.props.preSelection) &&
							((!document.activeElement || document.activeElement === document.body) && (n = !0),
							this.props.inline && !this.props.shouldFocusDayInline && (n = !1),
							this.isDayActiveElement() && (n = !0),
							this.isDuplicateDay() && (n = !1)),
						n
					)
				}),
				(t.prototype.isDayActiveElement = function () {
					var n, r, i
					return (
						((r = (n = this.props.containerRef) === null || n === void 0 ? void 0 : n.current) ===
							null || r === void 0
							? void 0
							: r.contains(document.activeElement)) &&
						((i = document.activeElement) === null || i === void 0
							? void 0
							: i.classList.contains("react-datepicker__day"))
					)
				}),
				(t.prototype.isDuplicateDay = function () {
					return (
						(this.props.monthShowsDuplicateDaysEnd && this.isAfterMonth()) ||
						(this.props.monthShowsDuplicateDaysStart && this.isBeforeMonth())
					)
				}),
				t
			)
		})(_.Component),
		sTt = (function (e) {
			Ir(t, e)
			function t() {
				var n = (e !== null && e.apply(this, arguments)) || this
				return (
					(n.weekNumberEl = _.createRef()),
					(n.handleClick = function (r) {
						n.props.onClick && n.props.onClick(r)
					}),
					(n.handleOnKeyDown = function (r) {
						var i,
							a,
							o = r.key
						o === He.Space && (r.preventDefault(), (r.key = He.Enter)),
							(a = (i = n.props).handleOnKeyDown) === null || a === void 0 || a.call(i, r)
					}),
					(n.isKeyboardSelected = function () {
						return (
							!n.props.disabledKeyboardNavigation &&
							!At(n.props.date, n.props.selected) &&
							At(n.props.date, n.props.preSelection)
						)
					}),
					(n.getTabIndex = function () {
						return n.props.showWeekPicker &&
							n.props.showWeekNumber &&
							(n.isKeyboardSelected() ||
								(At(n.props.date, n.props.selected) && At(n.props.preSelection, n.props.selected)))
							? 0
							: -1
					}),
					(n.handleFocusWeekNumber = function (r) {
						var i = !1
						n.getTabIndex() === 0 &&
							!(r != null && r.isInputFocused) &&
							At(n.props.date, n.props.preSelection) &&
							((!document.activeElement || document.activeElement === document.body) && (i = !0),
							n.props.inline && !n.props.shouldFocusDayInline && (i = !1),
							n.props.containerRef &&
								n.props.containerRef.current &&
								n.props.containerRef.current.contains(document.activeElement) &&
								document.activeElement &&
								document.activeElement.classList.contains("react-datepicker__week-number") &&
								(i = !0)),
							i && n.weekNumberEl.current && n.weekNumberEl.current.focus({ preventScroll: !0 })
					}),
					n
				)
			}
			return (
				Object.defineProperty(t, "defaultProps", {
					get: function () {
						return { ariaLabelPrefix: "week " }
					},
					enumerable: !1,
					configurable: !0,
				}),
				(t.prototype.componentDidMount = function () {
					this.handleFocusWeekNumber()
				}),
				(t.prototype.componentDidUpdate = function (n) {
					this.handleFocusWeekNumber(n)
				}),
				(t.prototype.render = function () {
					var n = this.props,
						r = n.weekNumber,
						i = n.ariaLabelPrefix,
						a = i === void 0 ? t.defaultProps.ariaLabelPrefix : i,
						o = n.onClick,
						s = {
							"react-datepicker__week-number": !0,
							"react-datepicker__week-number--clickable": !!o,
							"react-datepicker__week-number--selected":
								!!o && At(this.props.date, this.props.selected),
							"react-datepicker__week-number--keyboard-selected": this.isKeyboardSelected(),
						}
					return H.createElement(
						"div",
						{
							ref: this.weekNumberEl,
							className: hn(s),
							"aria-label": "".concat(a, " ").concat(this.props.weekNumber),
							onClick: this.handleClick,
							onKeyDown: this.handleOnKeyDown,
							tabIndex: this.getTabIndex(),
						},
						r,
					)
				}),
				t
			)
		})(_.Component),
		lTt = (function (e) {
			Ir(t, e)
			function t() {
				var n = (e !== null && e.apply(this, arguments)) || this
				return (
					(n.isDisabled = function (r) {
						return $a(r, {
							minDate: n.props.minDate,
							maxDate: n.props.maxDate,
							excludeDates: n.props.excludeDates,
							excludeDateIntervals: n.props.excludeDateIntervals,
							includeDateIntervals: n.props.includeDateIntervals,
							includeDates: n.props.includeDates,
							filterDate: n.props.filterDate,
						})
					}),
					(n.handleDayClick = function (r, i) {
						n.props.onDayClick && n.props.onDayClick(r, i)
					}),
					(n.handleDayMouseEnter = function (r) {
						n.props.onDayMouseEnter && n.props.onDayMouseEnter(r)
					}),
					(n.handleWeekClick = function (r, i, a) {
						for (var o, s, l, u = new Date(r), d = 0; d < 7; d++) {
							var p = new Date(r)
							p.setDate(p.getDate() + d)
							var m = !n.isDisabled(p)
							if (m) {
								u = p
								break
							}
						}
						typeof n.props.onWeekSelect == "function" && n.props.onWeekSelect(u, i, a),
							n.props.showWeekPicker && n.handleDayClick(u, a),
							((o = n.props.shouldCloseOnSelect) !== null && o !== void 0
								? o
								: t.defaultProps.shouldCloseOnSelect) &&
								((l = (s = n.props).setOpen) === null || l === void 0 || l.call(s, !1))
					}),
					(n.formatWeekNumber = function (r) {
						return n.props.formatWeekNumber ? n.props.formatWeekNumber(r) : $Ct(r)
					}),
					(n.renderDays = function () {
						var r = n.startOfWeek(),
							i = [],
							a = n.formatWeekNumber(r)
						if (n.props.showWeekNumber) {
							var o =
								n.props.onWeekSelect || n.props.showWeekPicker
									? n.handleWeekClick.bind(n, r, a)
									: void 0
							i.push(
								H.createElement(
									sTt,
									Rt({ key: "W" }, t.defaultProps, n.props, { weekNumber: a, date: r, onClick: o }),
								),
							)
						}
						return i.concat(
							[0, 1, 2, 3, 4, 5, 6].map(function (s) {
								var l = Tl(r, s)
								return H.createElement(
									oTt,
									Rt({}, t.defaultProps, n.props, {
										ariaLabelPrefixWhenEnabled: n.props.chooseDayAriaLabelPrefix,
										ariaLabelPrefixWhenDisabled: n.props.disabledDayAriaLabelPrefix,
										key: l.valueOf(),
										day: l,
										onClick: n.handleDayClick.bind(n, l),
										onMouseEnter: n.handleDayMouseEnter.bind(n, l),
									}),
								)
							}),
						)
					}),
					(n.startOfWeek = function () {
						return Nu(n.props.day, n.props.locale, n.props.calendarStartDay)
					}),
					(n.isKeyboardSelected = function () {
						return (
							!n.props.disabledKeyboardNavigation &&
							!At(n.startOfWeek(), n.props.selected) &&
							At(n.startOfWeek(), n.props.preSelection)
						)
					}),
					n
				)
			}
			return (
				Object.defineProperty(t, "defaultProps", {
					get: function () {
						return { shouldCloseOnSelect: !0 }
					},
					enumerable: !1,
					configurable: !0,
				}),
				(t.prototype.render = function () {
					var n = {
						"react-datepicker__week": !0,
						"react-datepicker__week--selected": At(this.startOfWeek(), this.props.selected),
						"react-datepicker__week--keyboard-selected": this.isKeyboardSelected(),
					}
					return H.createElement("div", { className: hn(n) }, this.renderDays())
				}),
				t
			)
		})(_.Component),
		vm,
		uTt = 6,
		Jf = {
			TWO_COLUMNS: "two_columns",
			THREE_COLUMNS: "three_columns",
			FOUR_COLUMNS: "four_columns",
		},
		xS =
			((vm = {}),
			(vm[Jf.TWO_COLUMNS] = {
				grid: [
					[0, 1],
					[2, 3],
					[4, 5],
					[6, 7],
					[8, 9],
					[10, 11],
				],
				verticalNavigationOffset: 2,
			}),
			(vm[Jf.THREE_COLUMNS] = {
				grid: [
					[0, 1, 2],
					[3, 4, 5],
					[6, 7, 8],
					[9, 10, 11],
				],
				verticalNavigationOffset: 3,
			}),
			(vm[Jf.FOUR_COLUMNS] = {
				grid: [
					[0, 1, 2, 3],
					[4, 5, 6, 7],
					[8, 9, 10, 11],
				],
				verticalNavigationOffset: 4,
			}),
			vm),
		Ry = 1
	function Q5(e, t) {
		return e ? Jf.FOUR_COLUMNS : t ? Jf.TWO_COLUMNS : Jf.THREE_COLUMNS
	}
	var cTt = (function (e) {
			Ir(t, e)
			function t() {
				var n = (e !== null && e.apply(this, arguments)) || this
				return (
					(n.MONTH_REFS = is([], Array(12), !0).map(function () {
						return _.createRef()
					})),
					(n.QUARTER_REFS = is([], Array(4), !0).map(function () {
						return _.createRef()
					})),
					(n.isDisabled = function (r) {
						return $a(r, {
							minDate: n.props.minDate,
							maxDate: n.props.maxDate,
							excludeDates: n.props.excludeDates,
							excludeDateIntervals: n.props.excludeDateIntervals,
							includeDateIntervals: n.props.includeDateIntervals,
							includeDates: n.props.includeDates,
							filterDate: n.props.filterDate,
						})
					}),
					(n.isExcluded = function (r) {
						return cN(r, {
							excludeDates: n.props.excludeDates,
							excludeDateIntervals: n.props.excludeDateIntervals,
						})
					}),
					(n.handleDayClick = function (r, i) {
						var a, o
						;(o = (a = n.props).onDayClick) === null ||
							o === void 0 ||
							o.call(a, r, i, n.props.orderInDisplay)
					}),
					(n.handleDayMouseEnter = function (r) {
						var i, a
						;(a = (i = n.props).onDayMouseEnter) === null || a === void 0 || a.call(i, r)
					}),
					(n.handleMouseLeave = function () {
						var r, i
						;(i = (r = n.props).onMouseLeave) === null || i === void 0 || i.call(r)
					}),
					(n.isRangeStartMonth = function (r) {
						var i = n.props,
							a = i.day,
							o = i.startDate,
							s = i.endDate
						return !o || !s ? !1 : pi(ia(a, r), o)
					}),
					(n.isRangeStartQuarter = function (r) {
						var i = n.props,
							a = i.day,
							o = i.startDate,
							s = i.endDate
						return !o || !s ? !1 : ax(Mf(a, r), o)
					}),
					(n.isRangeEndMonth = function (r) {
						var i = n.props,
							a = i.day,
							o = i.startDate,
							s = i.endDate
						return !o || !s ? !1 : pi(ia(a, r), s)
					}),
					(n.isRangeEndQuarter = function (r) {
						var i = n.props,
							a = i.day,
							o = i.startDate,
							s = i.endDate
						return !o || !s ? !1 : ax(Mf(a, r), s)
					}),
					(n.isInSelectingRangeMonth = function (r) {
						var i,
							a = n.props,
							o = a.day,
							s = a.selectsStart,
							l = a.selectsEnd,
							u = a.selectsRange,
							d = a.startDate,
							p = a.endDate,
							m = (i = n.props.selectingDate) !== null && i !== void 0 ? i : n.props.preSelection
						return !(s || l || u) || !m
							? !1
							: s && p
							? Ay(m, p, r, o)
							: (l && d) || (u && d && !p)
							? Ay(d, m, r, o)
							: !1
					}),
					(n.isSelectingMonthRangeStart = function (r) {
						var i
						if (!n.isInSelectingRangeMonth(r)) return !1
						var a = n.props,
							o = a.day,
							s = a.startDate,
							l = a.selectsStart,
							u = ia(o, r),
							d = (i = n.props.selectingDate) !== null && i !== void 0 ? i : n.props.preSelection
						return l ? pi(u, d) : pi(u, s)
					}),
					(n.isSelectingMonthRangeEnd = function (r) {
						var i
						if (!n.isInSelectingRangeMonth(r)) return !1
						var a = n.props,
							o = a.day,
							s = a.endDate,
							l = a.selectsEnd,
							u = a.selectsRange,
							d = ia(o, r),
							p = (i = n.props.selectingDate) !== null && i !== void 0 ? i : n.props.preSelection
						return l || u ? pi(d, p) : pi(d, s)
					}),
					(n.isInSelectingRangeQuarter = function (r) {
						var i,
							a = n.props,
							o = a.day,
							s = a.selectsStart,
							l = a.selectsEnd,
							u = a.selectsRange,
							d = a.startDate,
							p = a.endDate,
							m = (i = n.props.selectingDate) !== null && i !== void 0 ? i : n.props.preSelection
						return !(s || l || u) || !m
							? !1
							: s && p
							? Iy(m, p, r, o)
							: (l && d) || (u && d && !p)
							? Iy(d, m, r, o)
							: !1
					}),
					(n.isWeekInMonth = function (r) {
						var i = n.props.day,
							a = Tl(r, 6)
						return pi(r, i) || pi(a, i)
					}),
					(n.isCurrentMonth = function (r, i) {
						return Tt(r) === Tt(rn()) && i === bi(rn())
					}),
					(n.isCurrentQuarter = function (r, i) {
						return Tt(r) === Tt(rn()) && i === id(rn())
					}),
					(n.isSelectedMonth = function (r, i, a) {
						return bi(a) === i && Tt(r) === Tt(a)
					}),
					(n.isSelectMonthInList = function (r, i, a) {
						return a.some(function (o) {
							return n.isSelectedMonth(r, i, o)
						})
					}),
					(n.isSelectedQuarter = function (r, i, a) {
						return id(r) === i && Tt(r) === Tt(a)
					}),
					(n.renderWeeks = function () {
						for (
							var r = [],
								i = n.props.fixedHeight,
								a = 0,
								o = !1,
								s = Nu(gl(n.props.day), n.props.locale, n.props.calendarStartDay),
								l = function (y) {
									return n.props.showWeekPicker
										? Nu(y, n.props.locale, n.props.calendarStartDay)
										: n.props.preSelection
								},
								u = function (y) {
									return n.props.showWeekPicker
										? Nu(y, n.props.locale, n.props.calendarStartDay)
										: n.props.selected
								},
								d = n.props.selected ? u(n.props.selected) : void 0,
								p = n.props.preSelection ? l(n.props.preSelection) : void 0;
							r.push(
								H.createElement(
									lTt,
									Rt({}, n.props, {
										ariaLabelPrefix: n.props.weekAriaLabelPrefix,
										key: a,
										day: s,
										month: bi(n.props.day),
										onDayClick: n.handleDayClick,
										onDayMouseEnter: n.handleDayMouseEnter,
										selected: d,
										preSelection: p,
										showWeekNumber: n.props.showWeekNumbers,
									}),
								),
							),
								!o;

						) {
							a++, (s = Yb(s, 1))
							var m = i && a >= uTt,
								v = !i && !n.isWeekInMonth(s)
							if (m || v)
								if (n.props.peekNextMonth) o = !0
								else break
						}
						return r
					}),
					(n.onMonthClick = function (r, i) {
						var a = n.isMonthDisabledForLabelDate(i),
							o = a.isDisabled,
							s = a.labelDate
						o || n.handleDayClick(gl(s), r)
					}),
					(n.onMonthMouseEnter = function (r) {
						var i = n.isMonthDisabledForLabelDate(r),
							a = i.isDisabled,
							o = i.labelDate
						a || n.handleDayMouseEnter(gl(o))
					}),
					(n.handleMonthNavigation = function (r, i) {
						var a, o, s, l
						;(o = (a = n.props).setPreSelection) === null || o === void 0 || o.call(a, i),
							(l = (s = n.MONTH_REFS[r]) === null || s === void 0 ? void 0 : s.current) === null ||
								l === void 0 ||
								l.focus()
					}),
					(n.handleKeyboardNavigation = function (r, i, a) {
						var o,
							s = n.props,
							l = s.selected,
							u = s.preSelection,
							d = s.setPreSelection,
							p = s.minDate,
							m = s.maxDate,
							v = s.showFourColumnMonthYearPicker,
							y = s.showTwoColumnMonthYearPicker
						if (u) {
							var b = Q5(v, y),
								x = n.getVerticalOffset(b),
								E = (o = xS[b]) === null || o === void 0 ? void 0 : o.grid,
								T = function (N, I, P) {
									var L,
										B,
										z = I,
										V = P
									switch (N) {
										case He.ArrowRight:
											;(z = No(I, Ry)), (V = P === 11 ? 0 : P + Ry)
											break
										case He.ArrowLeft:
											;(z = Pp(I, Ry)), (V = P === 0 ? 11 : P - Ry)
											break
										case He.ArrowUp:
											;(z = Pp(I, x)),
												(V =
													!((L = E == null ? void 0 : E[0]) === null || L === void 0) &&
													L.includes(P)
														? P + 12 - x
														: P - x)
											break
										case He.ArrowDown:
											;(z = No(I, x)),
												(V =
													!((B = E == null ? void 0 : E[E.length - 1]) === null || B === void 0) &&
													B.includes(P)
														? P - 12 + x
														: P + x)
											break
									}
									return { newCalculatedDate: z, newCalculatedMonth: V }
								},
								C = function (N, I, P) {
									for (
										var L = 40,
											B = N,
											z = !1,
											V = 0,
											K = T(B, I, P),
											ne = K.newCalculatedDate,
											re = K.newCalculatedMonth;
										!z;

									) {
										if (V >= L) {
											;(ne = I), (re = P)
											break
										}
										if (p && ne < p) {
											B = He.ArrowRight
											var ie = T(B, ne, re)
											;(ne = ie.newCalculatedDate), (re = ie.newCalculatedMonth)
										}
										if (m && ne > m) {
											B = He.ArrowLeft
											var ie = T(B, ne, re)
											;(ne = ie.newCalculatedDate), (re = ie.newCalculatedMonth)
										}
										if (KCt(ne, n.props)) {
											var ie = T(B, ne, re)
											;(ne = ie.newCalculatedDate), (re = ie.newCalculatedMonth)
										} else z = !0
										V++
									}
									return { newCalculatedDate: ne, newCalculatedMonth: re }
								}
							if (i === He.Enter) {
								n.isMonthDisabled(a) || (n.onMonthClick(r, a), d == null || d(l))
								return
							}
							var D = C(i, u, a),
								O = D.newCalculatedDate,
								A = D.newCalculatedMonth
							switch (i) {
								case He.ArrowRight:
								case He.ArrowLeft:
								case He.ArrowUp:
								case He.ArrowDown:
									n.handleMonthNavigation(A, O)
									break
							}
						}
					}),
					(n.getVerticalOffset = function (r) {
						var i, a
						return (a =
							(i = xS[r]) === null || i === void 0 ? void 0 : i.verticalNavigationOffset) !==
							null && a !== void 0
							? a
							: 0
					}),
					(n.onMonthKeyDown = function (r, i) {
						var a = n.props,
							o = a.disabledKeyboardNavigation,
							s = a.handleOnMonthKeyDown,
							l = r.key
						l !== He.Tab && r.preventDefault(), o || n.handleKeyboardNavigation(r, l, i), s && s(r)
					}),
					(n.onQuarterClick = function (r, i) {
						var a = Mf(n.props.day, i)
						Ny(a, n.props) || n.handleDayClick(L5(a), r)
					}),
					(n.onQuarterMouseEnter = function (r) {
						var i = Mf(n.props.day, r)
						Ny(i, n.props) || n.handleDayMouseEnter(L5(i))
					}),
					(n.handleQuarterNavigation = function (r, i) {
						var a, o, s, l
						n.isDisabled(i) ||
							n.isExcluded(i) ||
							((o = (a = n.props).setPreSelection) === null || o === void 0 || o.call(a, i),
							(l = (s = n.QUARTER_REFS[r - 1]) === null || s === void 0 ? void 0 : s.current) ===
								null ||
								l === void 0 ||
								l.focus())
					}),
					(n.onQuarterKeyDown = function (r, i) {
						var a,
							o,
							s = r.key
						if (!n.props.disabledKeyboardNavigation)
							switch (s) {
								case He.Enter:
									n.onQuarterClick(r, i),
										(o = (a = n.props).setPreSelection) === null ||
											o === void 0 ||
											o.call(a, n.props.selected)
									break
								case He.ArrowRight:
									if (!n.props.preSelection) break
									n.handleQuarterNavigation(i === 4 ? 1 : i + 1, JA(n.props.preSelection, 1))
									break
								case He.ArrowLeft:
									if (!n.props.preSelection) break
									n.handleQuarterNavigation(i === 1 ? 4 : i - 1, XY(n.props.preSelection, 1))
									break
							}
					}),
					(n.isMonthDisabledForLabelDate = function (r) {
						var i,
							a = n.props,
							o = a.day,
							s = a.minDate,
							l = a.maxDate,
							u = a.excludeDates,
							d = a.includeDates,
							p = ia(o, r)
						return {
							isDisabled:
								(i = (s || l || u || d) && dG(p, n.props)) !== null && i !== void 0 ? i : !1,
							labelDate: p,
						}
					}),
					(n.isMonthDisabled = function (r) {
						var i = n.isMonthDisabledForLabelDate(r).isDisabled
						return i
					}),
					(n.getMonthClassNames = function (r) {
						var i = n.props,
							a = i.day,
							o = i.startDate,
							s = i.endDate,
							l = i.preSelection,
							u = i.monthClassName,
							d = u ? u(ia(a, r)) : void 0,
							p = n.getSelection()
						return hn("react-datepicker__month-text", "react-datepicker__month-".concat(r), d, {
							"react-datepicker__month-text--disabled": n.isMonthDisabled(r),
							"react-datepicker__month-text--selected": p ? n.isSelectMonthInList(a, r, p) : void 0,
							"react-datepicker__month-text--keyboard-selected":
								!n.props.disabledKeyboardNavigation &&
								l &&
								n.isSelectedMonth(a, r, l) &&
								!n.isMonthDisabled(r),
							"react-datepicker__month-text--in-selecting-range": n.isInSelectingRangeMonth(r),
							"react-datepicker__month-text--in-range": o && s ? Ay(o, s, r, a) : void 0,
							"react-datepicker__month-text--range-start": n.isRangeStartMonth(r),
							"react-datepicker__month-text--range-end": n.isRangeEndMonth(r),
							"react-datepicker__month-text--selecting-range-start":
								n.isSelectingMonthRangeStart(r),
							"react-datepicker__month-text--selecting-range-end": n.isSelectingMonthRangeEnd(r),
							"react-datepicker__month-text--today": n.isCurrentMonth(a, r),
						})
					}),
					(n.getTabIndex = function (r) {
						if (n.props.preSelection == null) return "-1"
						var i = bi(n.props.preSelection),
							a = n.isMonthDisabledForLabelDate(i).isDisabled,
							o = r === i && !(a || n.props.disabledKeyboardNavigation) ? "0" : "-1"
						return o
					}),
					(n.getQuarterTabIndex = function (r) {
						if (n.props.preSelection == null) return "-1"
						var i = id(n.props.preSelection),
							a = Ny(n.props.day, n.props),
							o = r === i && !(a || n.props.disabledKeyboardNavigation) ? "0" : "-1"
						return o
					}),
					(n.getAriaLabel = function (r) {
						var i = n.props,
							a = i.chooseDayAriaLabelPrefix,
							o = a === void 0 ? "Choose" : a,
							s = i.disabledDayAriaLabelPrefix,
							l = s === void 0 ? "Not available" : s,
							u = i.day,
							d = i.locale,
							p = ia(u, r),
							m = n.isDisabled(p) || n.isExcluded(p) ? l : o
						return "".concat(m, " ").concat(wn(p, "MMMM yyyy", d))
					}),
					(n.getQuarterClassNames = function (r) {
						var i = n.props,
							a = i.day,
							o = i.startDate,
							s = i.endDate,
							l = i.selected,
							u = i.minDate,
							d = i.maxDate,
							p = i.excludeDates,
							m = i.includeDates,
							v = i.filterDate,
							y = i.preSelection,
							b = i.disabledKeyboardNavigation,
							x = (u || d || p || m || v) && Ny(Mf(a, r), n.props)
						return hn("react-datepicker__quarter-text", "react-datepicker__quarter-".concat(r), {
							"react-datepicker__quarter-text--disabled": x,
							"react-datepicker__quarter-text--selected": l ? n.isSelectedQuarter(a, r, l) : void 0,
							"react-datepicker__quarter-text--keyboard-selected":
								!b && y && n.isSelectedQuarter(a, r, y) && !x,
							"react-datepicker__quarter-text--in-selecting-range": n.isInSelectingRangeQuarter(r),
							"react-datepicker__quarter-text--in-range": o && s ? Iy(o, s, r, a) : void 0,
							"react-datepicker__quarter-text--range-start": n.isRangeStartQuarter(r),
							"react-datepicker__quarter-text--range-end": n.isRangeEndQuarter(r),
						})
					}),
					(n.getMonthContent = function (r) {
						var i = n.props,
							a = i.showFullMonthYearPicker,
							o = i.renderMonthContent,
							s = i.locale,
							l = i.day,
							u = cG(r, s),
							d = uN(r, s)
						return o ? o(r, u, d, l) : a ? d : u
					}),
					(n.getQuarterContent = function (r) {
						var i,
							a = n.props,
							o = a.renderQuarterContent,
							s = a.locale,
							l = GCt(r, s)
						return (i = o == null ? void 0 : o(r, l)) !== null && i !== void 0 ? i : l
					}),
					(n.renderMonths = function () {
						var r,
							i = n.props,
							a = i.showTwoColumnMonthYearPicker,
							o = i.showFourColumnMonthYearPicker,
							s = i.day,
							l = i.selected,
							u = (r = xS[Q5(o, a)]) === null || r === void 0 ? void 0 : r.grid
						return u == null
							? void 0
							: u.map(function (d, p) {
									return H.createElement(
										"div",
										{ className: "react-datepicker__month-wrapper", key: p },
										d.map(function (m, v) {
											return H.createElement(
												"div",
												{
													ref: n.MONTH_REFS[m],
													key: v,
													onClick: function (y) {
														n.onMonthClick(y, m)
													},
													onKeyDown: function (y) {
														hG(y) && (y.preventDefault(), (y.key = He.Enter)),
															n.onMonthKeyDown(y, m)
													},
													onMouseEnter: n.props.usePointerEvent
														? void 0
														: function () {
																return n.onMonthMouseEnter(m)
														  },
													onPointerEnter: n.props.usePointerEvent
														? function () {
																return n.onMonthMouseEnter(m)
														  }
														: void 0,
													tabIndex: Number(n.getTabIndex(m)),
													className: n.getMonthClassNames(m),
													"aria-disabled": n.isMonthDisabled(m),
													role: "option",
													"aria-label": n.getAriaLabel(m),
													"aria-current": n.isCurrentMonth(s, m) ? "date" : void 0,
													"aria-selected": l ? n.isSelectedMonth(s, m, l) : void 0,
												},
												n.getMonthContent(m),
											)
										}),
									)
							  })
					}),
					(n.renderQuarters = function () {
						var r = n.props,
							i = r.day,
							a = r.selected,
							o = [1, 2, 3, 4]
						return H.createElement(
							"div",
							{ className: "react-datepicker__quarter-wrapper" },
							o.map(function (s, l) {
								return H.createElement(
									"div",
									{
										key: l,
										ref: n.QUARTER_REFS[l],
										role: "option",
										onClick: function (u) {
											n.onQuarterClick(u, s)
										},
										onKeyDown: function (u) {
											n.onQuarterKeyDown(u, s)
										},
										onMouseEnter: n.props.usePointerEvent
											? void 0
											: function () {
													return n.onQuarterMouseEnter(s)
											  },
										onPointerEnter: n.props.usePointerEvent
											? function () {
													return n.onQuarterMouseEnter(s)
											  }
											: void 0,
										className: n.getQuarterClassNames(s),
										"aria-selected": a ? n.isSelectedQuarter(i, s, a) : void 0,
										tabIndex: Number(n.getQuarterTabIndex(s)),
										"aria-current": n.isCurrentQuarter(i, s) ? "date" : void 0,
									},
									n.getQuarterContent(s),
								)
							}),
						)
					}),
					(n.getClassNames = function () {
						var r = n.props,
							i = r.selectingDate,
							a = r.selectsStart,
							o = r.selectsEnd,
							s = r.showMonthYearPicker,
							l = r.showQuarterYearPicker,
							u = r.showWeekPicker
						return hn(
							"react-datepicker__month",
							{ "react-datepicker__month--selecting-range": i && (a || o) },
							{ "react-datepicker__monthPicker": s },
							{ "react-datepicker__quarterPicker": l },
							{ "react-datepicker__weekPicker": u },
						)
					}),
					n
				)
			}
			return (
				(t.prototype.getSelection = function () {
					var n = this.props,
						r = n.selected,
						i = n.selectedDates,
						a = n.selectsMultiple
					if (a) return i
					if (r) return [r]
				}),
				(t.prototype.render = function () {
					var n = this.props,
						r = n.showMonthYearPicker,
						i = n.showQuarterYearPicker,
						a = n.day,
						o = n.ariaLabelPrefix,
						s = o === void 0 ? "Month " : o,
						l = s ? s.trim() + " " : ""
					return H.createElement(
						"div",
						{
							className: this.getClassNames(),
							onMouseLeave: this.props.usePointerEvent ? void 0 : this.handleMouseLeave,
							onPointerLeave: this.props.usePointerEvent ? this.handleMouseLeave : void 0,
							"aria-label": "".concat(l).concat(wn(a, "MMMM, yyyy", this.props.locale)),
							role: "listbox",
						},
						r ? this.renderMonths() : i ? this.renderQuarters() : this.renderWeeks(),
					)
				}),
				t
			)
		})(_.Component),
		dTt = (function (e) {
			Ir(t, e)
			function t() {
				var n = (e !== null && e.apply(this, arguments)) || this
				return (
					(n.isSelectedMonth = function (r) {
						return n.props.month === r
					}),
					(n.renderOptions = function () {
						return n.props.monthNames.map(function (r, i) {
							return H.createElement(
								"div",
								{
									className: n.isSelectedMonth(i)
										? "react-datepicker__month-option react-datepicker__month-option--selected_month"
										: "react-datepicker__month-option",
									key: r,
									onClick: n.onChange.bind(n, i),
									"aria-selected": n.isSelectedMonth(i) ? "true" : void 0,
								},
								n.isSelectedMonth(i)
									? H.createElement(
											"span",
											{ className: "react-datepicker__month-option--selected" },
											"",
									  )
									: "",
								r,
							)
						})
					}),
					(n.onChange = function (r) {
						return n.props.onChange(r)
					}),
					(n.handleClickOutside = function () {
						return n.props.onCancel()
					}),
					n
				)
			}
			return (
				(t.prototype.render = function () {
					return H.createElement(
						Uw,
						{
							className: "react-datepicker__month-dropdown",
							onClickOutside: this.handleClickOutside,
						},
						this.renderOptions(),
					)
				}),
				t
			)
		})(_.Component),
		fTt = (function (e) {
			Ir(t, e)
			function t() {
				var n = (e !== null && e.apply(this, arguments)) || this
				return (
					(n.state = { dropdownVisible: !1 }),
					(n.renderSelectOptions = function (r) {
						return r.map(function (i, a) {
							return H.createElement("option", { key: i, value: a }, i)
						})
					}),
					(n.renderSelectMode = function (r) {
						return H.createElement(
							"select",
							{
								value: n.props.month,
								className: "react-datepicker__month-select",
								onChange: function (i) {
									return n.onChange(parseInt(i.target.value))
								},
							},
							n.renderSelectOptions(r),
						)
					}),
					(n.renderReadView = function (r, i) {
						return H.createElement(
							"div",
							{
								key: "read",
								style: { visibility: r ? "visible" : "hidden" },
								className: "react-datepicker__month-read-view",
								onClick: n.toggleDropdown,
							},
							H.createElement("span", {
								className: "react-datepicker__month-read-view--down-arrow",
							}),
							H.createElement(
								"span",
								{ className: "react-datepicker__month-read-view--selected-month" },
								i[n.props.month],
							),
						)
					}),
					(n.renderDropdown = function (r) {
						return H.createElement(
							dTt,
							Rt({ key: "dropdown" }, n.props, {
								monthNames: r,
								onChange: n.onChange,
								onCancel: n.toggleDropdown,
							}),
						)
					}),
					(n.renderScrollMode = function (r) {
						var i = n.state.dropdownVisible,
							a = [n.renderReadView(!i, r)]
						return i && a.unshift(n.renderDropdown(r)), a
					}),
					(n.onChange = function (r) {
						n.toggleDropdown(), r !== n.props.month && n.props.onChange(r)
					}),
					(n.toggleDropdown = function () {
						return n.setState({ dropdownVisible: !n.state.dropdownVisible })
					}),
					n
				)
			}
			return (
				(t.prototype.render = function () {
					var n = this,
						r = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11].map(
							this.props.useShortMonthInDropdown
								? function (a) {
										return cG(a, n.props.locale)
								  }
								: function (a) {
										return uN(a, n.props.locale)
								  },
						),
						i
					switch (this.props.dropdownMode) {
						case "scroll":
							i = this.renderScrollMode(r)
							break
						case "select":
							i = this.renderSelectMode(r)
							break
					}
					return H.createElement(
						"div",
						{
							className:
								"react-datepicker__month-dropdown-container react-datepicker__month-dropdown-container--".concat(
									this.props.dropdownMode,
								),
						},
						i,
					)
				}),
				t
			)
		})(_.Component)
	function pTt(e, t) {
		for (var n = [], r = gl(e), i = gl(t); !Vu(r, i); ) n.push(rn(r)), (r = No(r, 1))
		return n
	}
	var hTt = (function (e) {
			Ir(t, e)
			function t(n) {
				var r = e.call(this, n) || this
				return (
					(r.renderOptions = function () {
						return r.state.monthYearsList.map(function (i) {
							var a = MD(i),
								o = Xo(r.props.date, i) && pi(r.props.date, i)
							return H.createElement(
								"div",
								{
									className: o
										? "react-datepicker__month-year-option--selected_month-year"
										: "react-datepicker__month-year-option",
									key: a,
									onClick: r.onChange.bind(r, a),
									"aria-selected": o ? "true" : void 0,
								},
								o
									? H.createElement(
											"span",
											{ className: "react-datepicker__month-year-option--selected" },
											"",
									  )
									: "",
								wn(i, r.props.dateFormat, r.props.locale),
							)
						})
					}),
					(r.onChange = function (i) {
						return r.props.onChange(i)
					}),
					(r.handleClickOutside = function () {
						r.props.onCancel()
					}),
					(r.state = { monthYearsList: pTt(r.props.minDate, r.props.maxDate) }),
					r
				)
			}
			return (
				(t.prototype.render = function () {
					var n = hn({
						"react-datepicker__month-year-dropdown": !0,
						"react-datepicker__month-year-dropdown--scrollable":
							this.props.scrollableMonthYearDropdown,
					})
					return H.createElement(
						Uw,
						{ className: n, onClickOutside: this.handleClickOutside },
						this.renderOptions(),
					)
				}),
				t
			)
		})(_.Component),
		mTt = (function (e) {
			Ir(t, e)
			function t() {
				var n = (e !== null && e.apply(this, arguments)) || this
				return (
					(n.state = { dropdownVisible: !1 }),
					(n.renderSelectOptions = function () {
						for (var r = gl(n.props.minDate), i = gl(n.props.maxDate), a = []; !Vu(r, i); ) {
							var o = MD(r)
							a.push(
								H.createElement(
									"option",
									{ key: o, value: o },
									wn(r, n.props.dateFormat, n.props.locale),
								),
							),
								(r = No(r, 1))
						}
						return a
					}),
					(n.onSelectChange = function (r) {
						n.onChange(parseInt(r.target.value))
					}),
					(n.renderSelectMode = function () {
						return H.createElement(
							"select",
							{
								value: MD(gl(n.props.date)),
								className: "react-datepicker__month-year-select",
								onChange: n.onSelectChange,
							},
							n.renderSelectOptions(),
						)
					}),
					(n.renderReadView = function (r) {
						var i = wn(n.props.date, n.props.dateFormat, n.props.locale)
						return H.createElement(
							"div",
							{
								key: "read",
								style: { visibility: r ? "visible" : "hidden" },
								className: "react-datepicker__month-year-read-view",
								onClick: n.toggleDropdown,
							},
							H.createElement("span", {
								className: "react-datepicker__month-year-read-view--down-arrow",
							}),
							H.createElement(
								"span",
								{ className: "react-datepicker__month-year-read-view--selected-month-year" },
								i,
							),
						)
					}),
					(n.renderDropdown = function () {
						return H.createElement(
							hTt,
							Rt({ key: "dropdown" }, n.props, {
								onChange: n.onChange,
								onCancel: n.toggleDropdown,
							}),
						)
					}),
					(n.renderScrollMode = function () {
						var r = n.state.dropdownVisible,
							i = [n.renderReadView(!r)]
						return r && i.unshift(n.renderDropdown()), i
					}),
					(n.onChange = function (r) {
						n.toggleDropdown()
						var i = rn(r)
						;(Xo(n.props.date, i) && pi(n.props.date, i)) || n.props.onChange(i)
					}),
					(n.toggleDropdown = function () {
						return n.setState({ dropdownVisible: !n.state.dropdownVisible })
					}),
					n
				)
			}
			return (
				(t.prototype.render = function () {
					var n
					switch (this.props.dropdownMode) {
						case "scroll":
							n = this.renderScrollMode()
							break
						case "select":
							n = this.renderSelectMode()
							break
					}
					return H.createElement(
						"div",
						{
							className:
								"react-datepicker__month-year-dropdown-container react-datepicker__month-year-dropdown-container--".concat(
									this.props.dropdownMode,
								),
						},
						n,
					)
				}),
				t
			)
		})(_.Component),
		vTt = (function (e) {
			Ir(t, e)
			function t() {
				var n = (e !== null && e.apply(this, arguments)) || this
				return (
					(n.state = { height: null }),
					(n.scrollToTheSelectedTime = function () {
						requestAnimationFrame(function () {
							var r, i, a
							n.list &&
								(n.list.scrollTop =
									(a =
										n.centerLi &&
										t.calcCenterPosition(
											n.props.monthRef
												? n.props.monthRef.clientHeight -
														((i =
															(r = n.header) === null || r === void 0 ? void 0 : r.clientHeight) !==
															null && i !== void 0
															? i
															: 0)
												: n.list.clientHeight,
											n.centerLi,
										)) !== null && a !== void 0
										? a
										: 0)
						})
					}),
					(n.handleClick = function (r) {
						var i, a
						;((n.props.minTime || n.props.maxTime) && H5(r, n.props)) ||
							((n.props.excludeTimes || n.props.includeTimes || n.props.filterTime) &&
								B5(r, n.props)) ||
							(a = (i = n.props).onChange) === null ||
							a === void 0 ||
							a.call(i, r)
					}),
					(n.isSelectedTime = function (r) {
						return n.props.selected && iTt(n.props.selected, r)
					}),
					(n.isDisabledTime = function (r) {
						return (
							((n.props.minTime || n.props.maxTime) && H5(r, n.props)) ||
							((n.props.excludeTimes || n.props.includeTimes || n.props.filterTime) &&
								B5(r, n.props))
						)
					}),
					(n.liClasses = function (r) {
						var i,
							a = [
								"react-datepicker__time-list-item",
								n.props.timeClassName ? n.props.timeClassName(r) : void 0,
							]
						return (
							n.isSelectedTime(r) && a.push("react-datepicker__time-list-item--selected"),
							n.isDisabledTime(r) && a.push("react-datepicker__time-list-item--disabled"),
							n.props.injectTimes &&
								(us(r) * 3600 + cs(r) * 60 + vl(r)) %
									(((i = n.props.intervals) !== null && i !== void 0
										? i
										: t.defaultProps.intervals) *
										60) !==
									0 &&
								a.push("react-datepicker__time-list-item--injected"),
							a.join(" ")
						)
					}),
					(n.handleOnKeyDown = function (r, i) {
						var a, o
						r.key === He.Space && (r.preventDefault(), (r.key = He.Enter)),
							(r.key === He.ArrowUp || r.key === He.ArrowLeft) &&
								r.target instanceof HTMLElement &&
								r.target.previousSibling &&
								(r.preventDefault(),
								r.target.previousSibling instanceof HTMLElement &&
									r.target.previousSibling.focus()),
							(r.key === He.ArrowDown || r.key === He.ArrowRight) &&
								r.target instanceof HTMLElement &&
								r.target.nextSibling &&
								(r.preventDefault(),
								r.target.nextSibling instanceof HTMLElement && r.target.nextSibling.focus()),
							r.key === He.Enter && n.handleClick(i),
							(o = (a = n.props).handleOnKeyDown) === null || o === void 0 || o.call(a, r)
					}),
					(n.renderTimes = function () {
						for (
							var r,
								i = [],
								a = typeof n.props.format == "string" ? n.props.format : "p",
								o = (r = n.props.intervals) !== null && r !== void 0 ? r : t.defaultProps.intervals,
								s = n.props.selected || n.props.openToDate || rn(),
								l = D1(s),
								u =
									n.props.injectTimes &&
									n.props.injectTimes.sort(function (x, E) {
										return x.getTime() - E.getTime()
									}),
								d = 60 * rTt(s),
								p = d / o,
								m = 0;
							m < p;
							m++
						) {
							var v = OD(l, m * o)
							if ((i.push(v), u)) {
								var y = nTt(l, v, m, o, u)
								i = i.concat(y)
							}
						}
						var b = i.reduce(function (x, E) {
							return E.getTime() <= s.getTime() ? E : x
						}, i[0])
						return i.map(function (x) {
							return H.createElement(
								"li",
								{
									key: x.valueOf(),
									onClick: n.handleClick.bind(n, x),
									className: n.liClasses(x),
									ref: function (E) {
										x === b && (n.centerLi = E)
									},
									onKeyDown: function (E) {
										n.handleOnKeyDown(E, x)
									},
									tabIndex: x === b ? 0 : -1,
									role: "option",
									"aria-selected": n.isSelectedTime(x) ? "true" : void 0,
									"aria-disabled": n.isDisabledTime(x) ? "true" : void 0,
								},
								wn(x, a, n.props.locale),
							)
						})
					}),
					(n.renderTimeCaption = function () {
						return n.props.showTimeCaption === !1
							? H.createElement(H.Fragment, null)
							: H.createElement(
									"div",
									{
										className: "react-datepicker__header react-datepicker__header--time ".concat(
											n.props.showTimeSelectOnly ? "react-datepicker__header--time--only" : "",
										),
										ref: function (r) {
											n.header = r
										},
									},
									H.createElement(
										"div",
										{ className: "react-datepicker-time__header" },
										n.props.timeCaption,
									),
							  )
					}),
					n
				)
			}
			return (
				Object.defineProperty(t, "defaultProps", {
					get: function () {
						return { intervals: 30, todayButton: null, timeCaption: "Time", showTimeCaption: !0 }
					},
					enumerable: !1,
					configurable: !0,
				}),
				(t.prototype.componentDidMount = function () {
					this.scrollToTheSelectedTime(),
						this.props.monthRef &&
							this.header &&
							this.setState({ height: this.props.monthRef.clientHeight - this.header.clientHeight })
				}),
				(t.prototype.render = function () {
					var n = this,
						r,
						i = this.state.height
					return H.createElement(
						"div",
						{
							className: "react-datepicker__time-container ".concat(
								(
									(r = this.props.todayButton) !== null && r !== void 0
										? r
										: t.defaultProps.todayButton
								)
									? "react-datepicker__time-container--with-today-button"
									: "",
							),
						},
						this.renderTimeCaption(),
						H.createElement(
							"div",
							{ className: "react-datepicker__time" },
							H.createElement(
								"div",
								{ className: "react-datepicker__time-box" },
								H.createElement(
									"ul",
									{
										className: "react-datepicker__time-list",
										ref: function (a) {
											n.list = a
										},
										style: i ? { height: i } : {},
										role: "listbox",
										"aria-label": this.props.timeCaption,
									},
									this.renderTimes(),
								),
							),
						),
					)
				}),
				(t.calcCenterPosition = function (n, r) {
					return r.offsetTop - (n / 2 - r.clientHeight / 2)
				}),
				t
			)
		})(_.Component),
		X5 = 3,
		gTt = (function (e) {
			Ir(t, e)
			function t(n) {
				var r = e.call(this, n) || this
				return (
					(r.YEAR_REFS = is([], Array(r.props.yearItemNumber), !0).map(function () {
						return _.createRef()
					})),
					(r.isDisabled = function (i) {
						return $a(i, {
							minDate: r.props.minDate,
							maxDate: r.props.maxDate,
							excludeDates: r.props.excludeDates,
							includeDates: r.props.includeDates,
							filterDate: r.props.filterDate,
						})
					}),
					(r.isExcluded = function (i) {
						return cN(i, { excludeDates: r.props.excludeDates })
					}),
					(r.selectingDate = function () {
						var i
						return (i = r.props.selectingDate) !== null && i !== void 0 ? i : r.props.preSelection
					}),
					(r.updateFocusOnPaginate = function (i) {
						var a = function () {
							var o, s
							;(s = (o = r.YEAR_REFS[i]) === null || o === void 0 ? void 0 : o.current) === null ||
								s === void 0 ||
								s.focus()
						}
						window.requestAnimationFrame(a)
					}),
					(r.handleYearClick = function (i, a) {
						r.props.onDayClick && r.props.onDayClick(i, a)
					}),
					(r.handleYearNavigation = function (i, a) {
						var o,
							s,
							l,
							u,
							d = r.props,
							p = d.date,
							m = d.yearItemNumber
						if (!(p === void 0 || m === void 0)) {
							var v = wu(p, m).startPeriod
							r.isDisabled(a) ||
								r.isExcluded(a) ||
								((s = (o = r.props).setPreSelection) === null || s === void 0 || s.call(o, a),
								i - v < 0
									? r.updateFocusOnPaginate(m - (v - i))
									: i - v >= m
									? r.updateFocusOnPaginate(Math.abs(m - (i - v)))
									: (u = (l = r.YEAR_REFS[i - v]) === null || l === void 0 ? void 0 : l.current) ===
											null ||
									  u === void 0 ||
									  u.focus())
						}
					}),
					(r.isSameDay = function (i, a) {
						return At(i, a)
					}),
					(r.isCurrentYear = function (i) {
						return i === Tt(rn())
					}),
					(r.isRangeStart = function (i) {
						return r.props.startDate && r.props.endDate && Xo(Go(rn(), i), r.props.startDate)
					}),
					(r.isRangeEnd = function (i) {
						return r.props.startDate && r.props.endDate && Xo(Go(rn(), i), r.props.endDate)
					}),
					(r.isInRange = function (i) {
						return My(i, r.props.startDate, r.props.endDate)
					}),
					(r.isInSelectingRange = function (i) {
						var a = r.props,
							o = a.selectsStart,
							s = a.selectsEnd,
							l = a.selectsRange,
							u = a.startDate,
							d = a.endDate
						return !(o || s || l) || !r.selectingDate()
							? !1
							: o && d
							? My(i, r.selectingDate(), d)
							: (s && u) || (l && u && !d)
							? My(i, u, r.selectingDate())
							: !1
					}),
					(r.isSelectingRangeStart = function (i) {
						var a
						if (!r.isInSelectingRange(i)) return !1
						var o = r.props,
							s = o.startDate,
							l = o.selectsStart,
							u = Go(rn(), i)
						return l
							? Xo(u, (a = r.selectingDate()) !== null && a !== void 0 ? a : null)
							: Xo(u, s ?? null)
					}),
					(r.isSelectingRangeEnd = function (i) {
						var a
						if (!r.isInSelectingRange(i)) return !1
						var o = r.props,
							s = o.endDate,
							l = o.selectsEnd,
							u = o.selectsRange,
							d = Go(rn(), i)
						return l || u
							? Xo(d, (a = r.selectingDate()) !== null && a !== void 0 ? a : null)
							: Xo(d, s ?? null)
					}),
					(r.isKeyboardSelected = function (i) {
						if (
							!(r.props.date === void 0 || r.props.selected == null || r.props.preSelection == null)
						) {
							var a = r.props,
								o = a.minDate,
								s = a.maxDate,
								l = a.excludeDates,
								u = a.includeDates,
								d = a.filterDate,
								p = Dm(Go(r.props.date, i)),
								m = (o || s || l || u || d) && _1(i, r.props)
							return (
								!r.props.disabledKeyboardNavigation &&
								!r.props.inline &&
								!At(p, Dm(r.props.selected)) &&
								At(p, Dm(r.props.preSelection)) &&
								!m
							)
						}
					}),
					(r.onYearClick = function (i, a) {
						var o = r.props.date
						o !== void 0 && r.handleYearClick(Dm(Go(o, a)), i)
					}),
					(r.onYearKeyDown = function (i, a) {
						var o,
							s,
							l = i.key,
							u = r.props,
							d = u.date,
							p = u.yearItemNumber,
							m = u.handleOnKeyDown
						if ((l !== He.Tab && i.preventDefault(), !r.props.disabledKeyboardNavigation))
							switch (l) {
								case He.Enter:
									if (r.props.selected == null) break
									r.onYearClick(i, a),
										(s = (o = r.props).setPreSelection) === null ||
											s === void 0 ||
											s.call(o, r.props.selected)
									break
								case He.ArrowRight:
									if (r.props.preSelection == null) break
									r.handleYearNavigation(a + 1, hl(r.props.preSelection, 1))
									break
								case He.ArrowLeft:
									if (r.props.preSelection == null) break
									r.handleYearNavigation(a - 1, jp(r.props.preSelection, 1))
									break
								case He.ArrowUp: {
									if (d === void 0 || p === void 0 || r.props.preSelection == null) break
									var v = wu(d, p).startPeriod,
										y = X5,
										b = a - y
									if (b < v) {
										var x = p % y
										a >= v && a < v + x ? (y = x) : (y += x), (b = a - y)
									}
									r.handleYearNavigation(b, jp(r.props.preSelection, y))
									break
								}
								case He.ArrowDown: {
									if (d === void 0 || p === void 0 || r.props.preSelection == null) break
									var E = wu(d, p).endPeriod,
										y = X5,
										b = a + y
									if (b > E) {
										var x = p % y
										a <= E && a > E - x ? (y = x) : (y += x), (b = a + y)
									}
									r.handleYearNavigation(b, hl(r.props.preSelection, y))
									break
								}
							}
						m && m(i)
					}),
					(r.getYearClassNames = function (i) {
						var a = r.props,
							o = a.date,
							s = a.minDate,
							l = a.maxDate,
							u = a.selected,
							d = a.excludeDates,
							p = a.includeDates,
							m = a.filterDate,
							v = a.yearClassName
						return hn(
							"react-datepicker__year-text",
							"react-datepicker__year-".concat(i),
							o ? (v == null ? void 0 : v(Go(o, i))) : void 0,
							{
								"react-datepicker__year-text--selected": u ? i === Tt(u) : void 0,
								"react-datepicker__year-text--disabled": (s || l || d || p || m) && _1(i, r.props),
								"react-datepicker__year-text--keyboard-selected": r.isKeyboardSelected(i),
								"react-datepicker__year-text--range-start": r.isRangeStart(i),
								"react-datepicker__year-text--range-end": r.isRangeEnd(i),
								"react-datepicker__year-text--in-range": r.isInRange(i),
								"react-datepicker__year-text--in-selecting-range": r.isInSelectingRange(i),
								"react-datepicker__year-text--selecting-range-start": r.isSelectingRangeStart(i),
								"react-datepicker__year-text--selecting-range-end": r.isSelectingRangeEnd(i),
								"react-datepicker__year-text--today": r.isCurrentYear(i),
							},
						)
					}),
					(r.getYearTabIndex = function (i) {
						if (r.props.disabledKeyboardNavigation || r.props.preSelection == null) return "-1"
						var a = Tt(r.props.preSelection),
							o = _1(i, r.props)
						return i === a && !o ? "0" : "-1"
					}),
					(r.getYearContainerClassNames = function () {
						var i = r.props,
							a = i.selectingDate,
							o = i.selectsStart,
							s = i.selectsEnd,
							l = i.selectsRange
						return hn("react-datepicker__year", {
							"react-datepicker__year--selecting-range": a && (o || s || l),
						})
					}),
					(r.getYearContent = function (i) {
						return r.props.renderYearContent ? r.props.renderYearContent(i) : i
					}),
					r
				)
			}
			return (
				(t.prototype.render = function () {
					var n = this,
						r = [],
						i = this.props,
						a = i.date,
						o = i.yearItemNumber,
						s = i.onYearMouseEnter,
						l = i.onYearMouseLeave
					if (a === void 0) return null
					for (
						var u = wu(a, o),
							d = u.startPeriod,
							p = u.endPeriod,
							m = function (b) {
								r.push(
									H.createElement(
										"div",
										{
											ref: v.YEAR_REFS[b - d],
											onClick: function (x) {
												n.onYearClick(x, b)
											},
											onKeyDown: function (x) {
												hG(x) && (x.preventDefault(), (x.key = He.Enter)), n.onYearKeyDown(x, b)
											},
											tabIndex: Number(v.getYearTabIndex(b)),
											className: v.getYearClassNames(b),
											onMouseEnter: v.props.usePointerEvent
												? void 0
												: function (x) {
														return s(x, b)
												  },
											onPointerEnter: v.props.usePointerEvent
												? function (x) {
														return s(x, b)
												  }
												: void 0,
											onMouseLeave: v.props.usePointerEvent
												? void 0
												: function (x) {
														return l(x, b)
												  },
											onPointerLeave: v.props.usePointerEvent
												? function (x) {
														return l(x, b)
												  }
												: void 0,
											key: b,
											"aria-current": v.isCurrentYear(b) ? "date" : void 0,
										},
										v.getYearContent(b),
									),
								)
							},
							v = this,
							y = d;
						y <= p;
						y++
					)
						m(y)
					return H.createElement(
						"div",
						{ className: this.getYearContainerClassNames() },
						H.createElement(
							"div",
							{
								className: "react-datepicker__year-wrapper",
								onMouseLeave: this.props.usePointerEvent ? void 0 : this.props.clearSelectingDate,
								onPointerLeave: this.props.usePointerEvent ? this.props.clearSelectingDate : void 0,
							},
							r,
						),
					)
				}),
				t
			)
		})(_.Component)
	function yTt(e, t, n, r) {
		for (var i = [], a = 0; a < 2 * t + 1; a++) {
			var o = e + t - a,
				s = !0
			n && (s = Tt(n) <= o), r && s && (s = Tt(r) >= o), s && i.push(o)
		}
		return i
	}
	var bTt = (function (e) {
			Ir(t, e)
			function t(n) {
				var r = e.call(this, n) || this
				;(r.renderOptions = function () {
					var s = r.props.year,
						l = r.state.yearsList.map(function (p) {
							return H.createElement(
								"div",
								{
									className:
										s === p
											? "react-datepicker__year-option react-datepicker__year-option--selected_year"
											: "react-datepicker__year-option",
									key: p,
									onClick: r.onChange.bind(r, p),
									"aria-selected": s === p ? "true" : void 0,
								},
								s === p
									? H.createElement(
											"span",
											{ className: "react-datepicker__year-option--selected" },
											"",
									  )
									: "",
								p,
							)
						}),
						u = r.props.minDate ? Tt(r.props.minDate) : null,
						d = r.props.maxDate ? Tt(r.props.maxDate) : null
					return (
						(!d ||
							!r.state.yearsList.find(function (p) {
								return p === d
							})) &&
							l.unshift(
								H.createElement(
									"div",
									{
										className: "react-datepicker__year-option",
										key: "upcoming",
										onClick: r.incrementYears,
									},
									H.createElement("a", {
										className:
											"react-datepicker__navigation react-datepicker__navigation--years react-datepicker__navigation--years-upcoming",
									}),
								),
							),
						(!u ||
							!r.state.yearsList.find(function (p) {
								return p === u
							})) &&
							l.push(
								H.createElement(
									"div",
									{
										className: "react-datepicker__year-option",
										key: "previous",
										onClick: r.decrementYears,
									},
									H.createElement("a", {
										className:
											"react-datepicker__navigation react-datepicker__navigation--years react-datepicker__navigation--years-previous",
									}),
								),
							),
						l
					)
				}),
					(r.onChange = function (s) {
						r.props.onChange(s)
					}),
					(r.handleClickOutside = function () {
						r.props.onCancel()
					}),
					(r.shiftYears = function (s) {
						var l = r.state.yearsList.map(function (u) {
							return u + s
						})
						r.setState({ yearsList: l })
					}),
					(r.incrementYears = function () {
						return r.shiftYears(1)
					}),
					(r.decrementYears = function () {
						return r.shiftYears(-1)
					})
				var i = n.yearDropdownItemNumber,
					a = n.scrollableYearDropdown,
					o = i || (a ? 10 : 5)
				return (
					(r.state = { yearsList: yTt(r.props.year, o, r.props.minDate, r.props.maxDate) }),
					(r.dropdownRef = _.createRef()),
					r
				)
			}
			return (
				(t.prototype.componentDidMount = function () {
					var n = this.dropdownRef.current
					if (n) {
						var r = n.children ? Array.from(n.children) : null,
							i = r
								? r.find(function (a) {
										return a.ariaSelected
								  })
								: null
						n.scrollTop =
							i && i instanceof HTMLElement
								? i.offsetTop + (i.clientHeight - n.clientHeight) / 2
								: (n.scrollHeight - n.clientHeight) / 2
					}
				}),
				(t.prototype.render = function () {
					var n = hn({
						"react-datepicker__year-dropdown": !0,
						"react-datepicker__year-dropdown--scrollable": this.props.scrollableYearDropdown,
					})
					return H.createElement(
						Uw,
						{
							className: n,
							containerRef: this.dropdownRef,
							onClickOutside: this.handleClickOutside,
						},
						this.renderOptions(),
					)
				}),
				t
			)
		})(_.Component),
		xTt = (function (e) {
			Ir(t, e)
			function t() {
				var n = (e !== null && e.apply(this, arguments)) || this
				return (
					(n.state = { dropdownVisible: !1 }),
					(n.renderSelectOptions = function () {
						for (
							var r = n.props.minDate ? Tt(n.props.minDate) : 1900,
								i = n.props.maxDate ? Tt(n.props.maxDate) : 2100,
								a = [],
								o = r;
							o <= i;
							o++
						)
							a.push(H.createElement("option", { key: o, value: o }, o))
						return a
					}),
					(n.onSelectChange = function (r) {
						n.onChange(parseInt(r.target.value))
					}),
					(n.renderSelectMode = function () {
						return H.createElement(
							"select",
							{
								value: n.props.year,
								className: "react-datepicker__year-select",
								onChange: n.onSelectChange,
							},
							n.renderSelectOptions(),
						)
					}),
					(n.renderReadView = function (r) {
						return H.createElement(
							"div",
							{
								key: "read",
								style: { visibility: r ? "visible" : "hidden" },
								className: "react-datepicker__year-read-view",
								onClick: function (i) {
									return n.toggleDropdown(i)
								},
							},
							H.createElement("span", {
								className: "react-datepicker__year-read-view--down-arrow",
							}),
							H.createElement(
								"span",
								{ className: "react-datepicker__year-read-view--selected-year" },
								n.props.year,
							),
						)
					}),
					(n.renderDropdown = function () {
						return H.createElement(
							bTt,
							Rt({ key: "dropdown" }, n.props, {
								onChange: n.onChange,
								onCancel: n.toggleDropdown,
							}),
						)
					}),
					(n.renderScrollMode = function () {
						var r = n.state.dropdownVisible,
							i = [n.renderReadView(!r)]
						return r && i.unshift(n.renderDropdown()), i
					}),
					(n.onChange = function (r) {
						n.toggleDropdown(), r !== n.props.year && n.props.onChange(r)
					}),
					(n.toggleDropdown = function (r) {
						n.setState({ dropdownVisible: !n.state.dropdownVisible }, function () {
							n.props.adjustDateOnChange && n.handleYearChange(n.props.date, r)
						})
					}),
					(n.handleYearChange = function (r, i) {
						var a
						;(a = n.onSelect) === null || a === void 0 || a.call(n, r, i), n.setOpen()
					}),
					(n.onSelect = function (r, i) {
						var a, o
						;(o = (a = n.props).onSelect) === null || o === void 0 || o.call(a, r, i)
					}),
					(n.setOpen = function () {
						var r, i
						;(i = (r = n.props).setOpen) === null || i === void 0 || i.call(r, !0)
					}),
					n
				)
			}
			return (
				(t.prototype.render = function () {
					var n
					switch (this.props.dropdownMode) {
						case "scroll":
							n = this.renderScrollMode()
							break
						case "select":
							n = this.renderSelectMode()
							break
					}
					return H.createElement(
						"div",
						{
							className:
								"react-datepicker__year-dropdown-container react-datepicker__year-dropdown-container--".concat(
									this.props.dropdownMode,
								),
						},
						n,
					)
				}),
				t
			)
		})(_.Component),
		wTt = [
			"react-datepicker__year-select",
			"react-datepicker__month-select",
			"react-datepicker__month-year-select",
		],
		ETt = function (e) {
			var t = (e.className || "").split(/\s+/)
			return wTt.some(function (n) {
				return t.indexOf(n) >= 0
			})
		},
		CTt = (function (e) {
			Ir(t, e)
			function t(n) {
				var r = e.call(this, n) || this
				return (
					(r.monthContainer = void 0),
					(r.handleClickOutside = function (i) {
						r.props.onClickOutside(i)
					}),
					(r.setClickOutsideRef = function () {
						return r.containerRef.current
					}),
					(r.handleDropdownFocus = function (i) {
						var a, o
						ETt(i.target) &&
							((o = (a = r.props).onDropdownFocus) === null || o === void 0 || o.call(a, i))
					}),
					(r.getDateInView = function () {
						var i = r.props,
							a = i.preSelection,
							o = i.selected,
							s = i.openToDate,
							l = fG(r.props),
							u = pG(r.props),
							d = rn(),
							p = s || o || a
						return p || (l && Sd(d, l) ? l : u && Vu(d, u) ? u : d)
					}),
					(r.increaseMonth = function () {
						r.setState(
							function (i) {
								var a = i.date
								return { date: No(a, 1) }
							},
							function () {
								return r.handleMonthChange(r.state.date)
							},
						)
					}),
					(r.decreaseMonth = function () {
						r.setState(
							function (i) {
								var a = i.date
								return { date: Pp(a, 1) }
							},
							function () {
								return r.handleMonthChange(r.state.date)
							},
						)
					}),
					(r.handleDayClick = function (i, a, o) {
						r.props.onSelect(i, a, o), r.props.setPreSelection && r.props.setPreSelection(i)
					}),
					(r.handleDayMouseEnter = function (i) {
						r.setState({ selectingDate: i }), r.props.onDayMouseEnter && r.props.onDayMouseEnter(i)
					}),
					(r.handleMonthMouseLeave = function () {
						r.setState({ selectingDate: void 0 }),
							r.props.onMonthMouseLeave && r.props.onMonthMouseLeave()
					}),
					(r.handleYearMouseEnter = function (i, a) {
						r.setState({ selectingDate: Go(rn(), a) }),
							r.props.onYearMouseEnter && r.props.onYearMouseEnter(i, a)
					}),
					(r.handleYearMouseLeave = function (i, a) {
						r.props.onYearMouseLeave && r.props.onYearMouseLeave(i, a)
					}),
					(r.handleYearChange = function (i) {
						var a, o, s, l
						;(o = (a = r.props).onYearChange) === null || o === void 0 || o.call(a, i),
							r.setState({ isRenderAriaLiveMessage: !0 }),
							r.props.adjustDateOnChange &&
								(r.props.onSelect(i),
								(l = (s = r.props).setOpen) === null || l === void 0 || l.call(s, !0)),
							r.props.setPreSelection && r.props.setPreSelection(i)
					}),
					(r.getEnabledPreSelectionDateForMonth = function (i) {
						if (!$a(i, r.props)) return i
						for (var a = gl(i), o = qCt(i), s = Ext(o, a), l = null, u = 0; u <= s; u++) {
							var d = Tl(a, u)
							if (!$a(d, r.props)) {
								l = d
								break
							}
						}
						return l
					}),
					(r.handleMonthChange = function (i) {
						var a,
							o,
							s,
							l = (a = r.getEnabledPreSelectionDateForMonth(i)) !== null && a !== void 0 ? a : i
						r.handleCustomMonthChange(l),
							r.props.adjustDateOnChange &&
								(r.props.onSelect(l),
								(s = (o = r.props).setOpen) === null || s === void 0 || s.call(o, !0)),
							r.props.setPreSelection && r.props.setPreSelection(l)
					}),
					(r.handleCustomMonthChange = function (i) {
						var a, o
						;(o = (a = r.props).onMonthChange) === null || o === void 0 || o.call(a, i),
							r.setState({ isRenderAriaLiveMessage: !0 })
					}),
					(r.handleMonthYearChange = function (i) {
						r.handleYearChange(i), r.handleMonthChange(i)
					}),
					(r.changeYear = function (i) {
						r.setState(
							function (a) {
								var o = a.date
								return { date: Go(o, Number(i)) }
							},
							function () {
								return r.handleYearChange(r.state.date)
							},
						)
					}),
					(r.changeMonth = function (i) {
						r.setState(
							function (a) {
								var o = a.date
								return { date: ia(o, Number(i)) }
							},
							function () {
								return r.handleMonthChange(r.state.date)
							},
						)
					}),
					(r.changeMonthYear = function (i) {
						r.setState(
							function (a) {
								var o = a.date
								return { date: Go(ia(o, bi(i)), Tt(i)) }
							},
							function () {
								return r.handleMonthYearChange(r.state.date)
							},
						)
					}),
					(r.header = function (i) {
						i === void 0 && (i = r.state.date)
						var a = Nu(i, r.props.locale, r.props.calendarStartDay),
							o = []
						return (
							r.props.showWeekNumbers &&
								o.push(
									H.createElement(
										"div",
										{ key: "W", className: "react-datepicker__day-name" },
										r.props.weekLabel || "#",
									),
								),
							o.concat(
								[0, 1, 2, 3, 4, 5, 6].map(function (s) {
									var l = Tl(a, s),
										u = r.formatWeekday(l, r.props.locale),
										d = r.props.weekDayClassName ? r.props.weekDayClassName(l) : void 0
									return H.createElement(
										"div",
										{
											key: s,
											"aria-label": wn(l, "EEEE", r.props.locale),
											className: hn("react-datepicker__day-name", d),
										},
										u,
									)
								}),
							)
						)
					}),
					(r.formatWeekday = function (i, a) {
						return r.props.formatWeekDay
							? VCt(i, r.props.formatWeekDay, a)
							: r.props.useWeekdaysShort
							? YCt(i, a)
							: WCt(i, a)
					}),
					(r.decreaseYear = function () {
						r.setState(
							function (i) {
								var a,
									o = i.date
								return {
									date: jp(
										o,
										r.props.showYearPicker
											? (a = r.props.yearItemNumber) !== null && a !== void 0
												? a
												: t.defaultProps.yearItemNumber
											: 1,
									),
								}
							},
							function () {
								return r.handleYearChange(r.state.date)
							},
						)
					}),
					(r.clearSelectingDate = function () {
						r.setState({ selectingDate: void 0 })
					}),
					(r.renderPreviousButton = function () {
						var i
						if (!r.props.renderCustomHeader) {
							var a
							switch (!0) {
								case r.props.showMonthYearPicker:
									a = z5(r.state.date, r.props)
									break
								case r.props.showYearPicker:
									a = JCt(r.state.date, r.props)
									break
								case r.props.showQuarterYearPicker:
									a = QCt(r.state.date, r.props)
									break
								default:
									a = $5(r.state.date, r.props)
									break
							}
							if (
								!(
									(!((i = r.props.forceShowMonthNavigation) !== null && i !== void 0
										? i
										: t.defaultProps.forceShowMonthNavigation) &&
										!r.props.showDisabledMonthNavigation &&
										a) ||
									r.props.showTimeSelectOnly
								)
							) {
								var o = [
										"react-datepicker__navigation-icon",
										"react-datepicker__navigation-icon--previous",
									],
									s = ["react-datepicker__navigation", "react-datepicker__navigation--previous"],
									l = r.decreaseMonth
								;(r.props.showMonthYearPicker ||
									r.props.showQuarterYearPicker ||
									r.props.showYearPicker) &&
									(l = r.decreaseYear),
									a &&
										r.props.showDisabledMonthNavigation &&
										(s.push("react-datepicker__navigation--previous--disabled"), (l = void 0))
								var u =
										r.props.showMonthYearPicker ||
										r.props.showQuarterYearPicker ||
										r.props.showYearPicker,
									d = r.props,
									p = d.previousMonthButtonLabel,
									m = p === void 0 ? t.defaultProps.previousMonthButtonLabel : p,
									v = d.previousYearButtonLabel,
									y = v === void 0 ? t.defaultProps.previousYearButtonLabel : v,
									b = r.props,
									x = b.previousMonthAriaLabel,
									E = x === void 0 ? (typeof m == "string" ? m : "Previous Month") : x,
									T = b.previousYearAriaLabel,
									C = T === void 0 ? (typeof y == "string" ? y : "Previous Year") : T
								return H.createElement(
									"button",
									{
										type: "button",
										className: s.join(" "),
										onClick: l,
										onKeyDown: r.props.handleOnKeyDown,
										"aria-label": u ? C : E,
									},
									H.createElement("span", { className: o.join(" ") }, u ? y : m),
								)
							}
						}
					}),
					(r.increaseYear = function () {
						r.setState(
							function (i) {
								var a,
									o = i.date
								return {
									date: hl(
										o,
										r.props.showYearPicker
											? (a = r.props.yearItemNumber) !== null && a !== void 0
												? a
												: t.defaultProps.yearItemNumber
											: 1,
									),
								}
							},
							function () {
								return r.handleYearChange(r.state.date)
							},
						)
					}),
					(r.renderNextButton = function () {
						var i
						if (!r.props.renderCustomHeader) {
							var a
							switch (!0) {
								case r.props.showMonthYearPicker:
									a = q5(r.state.date, r.props)
									break
								case r.props.showYearPicker:
									a = ZCt(r.state.date, r.props)
									break
								case r.props.showQuarterYearPicker:
									a = XCt(r.state.date, r.props)
									break
								default:
									a = U5(r.state.date, r.props)
									break
							}
							if (
								!(
									(!((i = r.props.forceShowMonthNavigation) !== null && i !== void 0
										? i
										: t.defaultProps.forceShowMonthNavigation) &&
										!r.props.showDisabledMonthNavigation &&
										a) ||
									r.props.showTimeSelectOnly
								)
							) {
								var o = ["react-datepicker__navigation", "react-datepicker__navigation--next"],
									s = [
										"react-datepicker__navigation-icon",
										"react-datepicker__navigation-icon--next",
									]
								r.props.showTimeSelect && o.push("react-datepicker__navigation--next--with-time"),
									r.props.todayButton &&
										o.push("react-datepicker__navigation--next--with-today-button")
								var l = r.increaseMonth
								;(r.props.showMonthYearPicker ||
									r.props.showQuarterYearPicker ||
									r.props.showYearPicker) &&
									(l = r.increaseYear),
									a &&
										r.props.showDisabledMonthNavigation &&
										(o.push("react-datepicker__navigation--next--disabled"), (l = void 0))
								var u =
										r.props.showMonthYearPicker ||
										r.props.showQuarterYearPicker ||
										r.props.showYearPicker,
									d = r.props,
									p = d.nextMonthButtonLabel,
									m = p === void 0 ? t.defaultProps.nextMonthButtonLabel : p,
									v = d.nextYearButtonLabel,
									y = v === void 0 ? t.defaultProps.nextYearButtonLabel : v,
									b = r.props,
									x = b.nextMonthAriaLabel,
									E = x === void 0 ? (typeof m == "string" ? m : "Next Month") : x,
									T = b.nextYearAriaLabel,
									C = T === void 0 ? (typeof y == "string" ? y : "Next Year") : T
								return H.createElement(
									"button",
									{
										type: "button",
										className: o.join(" "),
										onClick: l,
										onKeyDown: r.props.handleOnKeyDown,
										"aria-label": u ? C : E,
									},
									H.createElement("span", { className: s.join(" ") }, u ? y : m),
								)
							}
						}
					}),
					(r.renderCurrentMonth = function (i) {
						i === void 0 && (i = r.state.date)
						var a = ["react-datepicker__current-month"]
						return (
							r.props.showYearDropdown &&
								a.push("react-datepicker__current-month--hasYearDropdown"),
							r.props.showMonthDropdown &&
								a.push("react-datepicker__current-month--hasMonthDropdown"),
							r.props.showMonthYearDropdown &&
								a.push("react-datepicker__current-month--hasMonthYearDropdown"),
							H.createElement(
								"h2",
								{ className: a.join(" ") },
								wn(i, r.props.dateFormat, r.props.locale),
							)
						)
					}),
					(r.renderYearDropdown = function (i) {
						if ((i === void 0 && (i = !1), !(!r.props.showYearDropdown || i)))
							return H.createElement(
								xTt,
								Rt({}, t.defaultProps, r.props, {
									date: r.state.date,
									onChange: r.changeYear,
									year: Tt(r.state.date),
								}),
							)
					}),
					(r.renderMonthDropdown = function (i) {
						if ((i === void 0 && (i = !1), !(!r.props.showMonthDropdown || i)))
							return H.createElement(
								fTt,
								Rt({}, t.defaultProps, r.props, {
									month: bi(r.state.date),
									onChange: r.changeMonth,
								}),
							)
					}),
					(r.renderMonthYearDropdown = function (i) {
						if ((i === void 0 && (i = !1), !(!r.props.showMonthYearDropdown || i)))
							return H.createElement(
								mTt,
								Rt({}, t.defaultProps, r.props, {
									date: r.state.date,
									onChange: r.changeMonthYear,
								}),
							)
					}),
					(r.handleTodayButtonClick = function (i) {
						r.props.onSelect(P5(), i), r.props.setPreSelection && r.props.setPreSelection(P5())
					}),
					(r.renderTodayButton = function () {
						if (!(!r.props.todayButton || r.props.showTimeSelectOnly))
							return H.createElement(
								"div",
								{ className: "react-datepicker__today-button", onClick: r.handleTodayButtonClick },
								r.props.todayButton,
							)
					}),
					(r.renderDefaultHeader = function (i) {
						var a = i.monthDate,
							o = i.i
						return H.createElement(
							"div",
							{
								className: "react-datepicker__header ".concat(
									r.props.showTimeSelect ? "react-datepicker__header--has-time-select" : "",
								),
							},
							r.renderCurrentMonth(a),
							H.createElement(
								"div",
								{
									className:
										"react-datepicker__header__dropdown react-datepicker__header__dropdown--".concat(
											r.props.dropdownMode,
										),
									onFocus: r.handleDropdownFocus,
								},
								r.renderMonthDropdown(o !== 0),
								r.renderMonthYearDropdown(o !== 0),
								r.renderYearDropdown(o !== 0),
							),
							H.createElement("div", { className: "react-datepicker__day-names" }, r.header(a)),
						)
					}),
					(r.renderCustomHeader = function (i) {
						var a,
							o,
							s = i.monthDate,
							l = i.i
						if ((r.props.showTimeSelect && !r.state.monthContainer) || r.props.showTimeSelectOnly)
							return null
						var u = $5(r.state.date, r.props),
							d = U5(r.state.date, r.props),
							p = z5(r.state.date, r.props),
							m = q5(r.state.date, r.props),
							v =
								!r.props.showMonthYearPicker &&
								!r.props.showQuarterYearPicker &&
								!r.props.showYearPicker
						return H.createElement(
							"div",
							{
								className: "react-datepicker__header react-datepicker__header--custom",
								onFocus: r.props.onDropdownFocus,
							},
							(o = (a = r.props).renderCustomHeader) === null || o === void 0
								? void 0
								: o.call(
										a,
										Rt(Rt({}, r.state), {
											customHeaderCount: l,
											monthDate: s,
											changeMonth: r.changeMonth,
											changeYear: r.changeYear,
											decreaseMonth: r.decreaseMonth,
											increaseMonth: r.increaseMonth,
											decreaseYear: r.decreaseYear,
											increaseYear: r.increaseYear,
											prevMonthButtonDisabled: u,
											nextMonthButtonDisabled: d,
											prevYearButtonDisabled: p,
											nextYearButtonDisabled: m,
										}),
								  ),
							v &&
								H.createElement("div", { className: "react-datepicker__day-names" }, r.header(s)),
						)
					}),
					(r.renderYearHeader = function (i) {
						var a = i.monthDate,
							o = r.props,
							s = o.showYearPicker,
							l = o.yearItemNumber,
							u = l === void 0 ? t.defaultProps.yearItemNumber : l,
							d = wu(a, u),
							p = d.startPeriod,
							m = d.endPeriod
						return H.createElement(
							"div",
							{ className: "react-datepicker__header react-datepicker-year-header" },
							s ? "".concat(p, " - ").concat(m) : Tt(a),
						)
					}),
					(r.renderHeader = function (i) {
						var a = i.monthDate,
							o = i.i,
							s = o === void 0 ? 0 : o,
							l = { monthDate: a, i: s }
						switch (!0) {
							case r.props.renderCustomHeader !== void 0:
								return r.renderCustomHeader(l)
							case r.props.showMonthYearPicker ||
								r.props.showQuarterYearPicker ||
								r.props.showYearPicker:
								return r.renderYearHeader(l)
							default:
								return r.renderDefaultHeader(l)
						}
					}),
					(r.renderMonths = function () {
						var i, a
						if (!(r.props.showTimeSelectOnly || r.props.showYearPicker)) {
							for (
								var o = [],
									s =
										(i = r.props.monthsShown) !== null && i !== void 0
											? i
											: t.defaultProps.monthsShown,
									l = r.props.showPreviousMonths ? s - 1 : 0,
									u =
										r.props.showMonthYearPicker || r.props.showQuarterYearPicker
											? hl(r.state.date, l)
											: Pp(r.state.date, l),
									d = (a = r.props.monthSelectedIn) !== null && a !== void 0 ? a : l,
									p = 0;
								p < s;
								++p
							) {
								var m = p - d + l,
									v =
										r.props.showMonthYearPicker || r.props.showQuarterYearPicker
											? hl(u, m)
											: No(u, m),
									y = "month-".concat(p),
									b = p < s - 1,
									x = p > 0
								o.push(
									H.createElement(
										"div",
										{
											key: y,
											ref: function (E) {
												r.monthContainer = E ?? void 0
											},
											className: "react-datepicker__month-container",
										},
										r.renderHeader({ monthDate: v, i: p }),
										H.createElement(
											cTt,
											Rt({}, t.defaultProps, r.props, {
												ariaLabelPrefix: r.props.monthAriaLabelPrefix,
												day: v,
												onDayClick: r.handleDayClick,
												handleOnKeyDown: r.props.handleOnDayKeyDown,
												handleOnMonthKeyDown: r.props.handleOnKeyDown,
												onDayMouseEnter: r.handleDayMouseEnter,
												onMouseLeave: r.handleMonthMouseLeave,
												orderInDisplay: p,
												selectingDate: r.state.selectingDate,
												monthShowsDuplicateDaysEnd: b,
												monthShowsDuplicateDaysStart: x,
											}),
										),
									),
								)
							}
							return o
						}
					}),
					(r.renderYears = function () {
						if (!r.props.showTimeSelectOnly && r.props.showYearPicker)
							return H.createElement(
								"div",
								{ className: "react-datepicker__year--container" },
								r.renderHeader({ monthDate: r.state.date }),
								H.createElement(
									gTt,
									Rt({}, t.defaultProps, r.props, {
										selectingDate: r.state.selectingDate,
										date: r.state.date,
										onDayClick: r.handleDayClick,
										clearSelectingDate: r.clearSelectingDate,
										onYearMouseEnter: r.handleYearMouseEnter,
										onYearMouseLeave: r.handleYearMouseLeave,
									}),
								),
							)
					}),
					(r.renderTimeSection = function () {
						if (r.props.showTimeSelect && (r.state.monthContainer || r.props.showTimeSelectOnly))
							return H.createElement(
								vTt,
								Rt({}, t.defaultProps, r.props, {
									onChange: r.props.onTimeChange,
									format: r.props.timeFormat,
									intervals: r.props.timeIntervals,
									monthRef: r.state.monthContainer,
								}),
							)
					}),
					(r.renderInputTimeSection = function () {
						var i = r.props.selected ? new Date(r.props.selected) : void 0,
							a = i && Zs(i) && !!r.props.selected,
							o = a ? "".concat(W5(i.getHours()), ":").concat(W5(i.getMinutes())) : ""
						if (r.props.showTimeInput)
							return H.createElement(
								aTt,
								Rt({}, t.defaultProps, r.props, {
									date: i,
									timeString: o,
									onChange: r.props.onTimeChange,
								}),
							)
					}),
					(r.renderAriaLiveRegion = function () {
						var i,
							a = wu(
								r.state.date,
								(i = r.props.yearItemNumber) !== null && i !== void 0
									? i
									: t.defaultProps.yearItemNumber,
							),
							o = a.startPeriod,
							s = a.endPeriod,
							l
						return (
							r.props.showYearPicker
								? (l = "".concat(o, " - ").concat(s))
								: r.props.showMonthYearPicker || r.props.showQuarterYearPicker
								? (l = Tt(r.state.date))
								: (l = ""
										.concat(uN(bi(r.state.date), r.props.locale), " ")
										.concat(Tt(r.state.date))),
							H.createElement(
								"span",
								{ role: "alert", "aria-live": "polite", className: "react-datepicker__aria-live" },
								r.state.isRenderAriaLiveMessage && l,
							)
						)
					}),
					(r.renderChildren = function () {
						if (r.props.children)
							return H.createElement(
								"div",
								{ className: "react-datepicker__children-container" },
								r.props.children,
							)
					}),
					(r.containerRef = _.createRef()),
					(r.state = {
						date: r.getDateInView(),
						selectingDate: void 0,
						monthContainer: void 0,
						isRenderAriaLiveMessage: !1,
					}),
					r
				)
			}
			return (
				Object.defineProperty(t, "defaultProps", {
					get: function () {
						return {
							monthsShown: 1,
							forceShowMonthNavigation: !1,
							timeCaption: "Time",
							previousYearButtonLabel: "Previous Year",
							nextYearButtonLabel: "Next Year",
							previousMonthButtonLabel: "Previous Month",
							nextMonthButtonLabel: "Next Month",
							yearItemNumber: kg,
						}
					},
					enumerable: !1,
					configurable: !0,
				}),
				(t.prototype.componentDidMount = function () {
					var n = this
					this.props.showTimeSelect &&
						(this.assignMonthContainer = (function () {
							n.setState({ monthContainer: n.monthContainer })
						})())
				}),
				(t.prototype.componentDidUpdate = function (n) {
					var r = this
					if (
						this.props.preSelection &&
						(!At(this.props.preSelection, n.preSelection) ||
							this.props.monthSelectedIn !== n.monthSelectedIn)
					) {
						var i = !pi(this.state.date, this.props.preSelection)
						this.setState({ date: this.props.preSelection }, function () {
							return i && r.handleCustomMonthChange(r.state.date)
						})
					} else
						this.props.openToDate &&
							!At(this.props.openToDate, n.openToDate) &&
							this.setState({ date: this.props.openToDate })
				}),
				(t.prototype.render = function () {
					var n = this.props.container || PCt
					return H.createElement(
						Uw,
						{
							onClickOutside: this.handleClickOutside,
							style: { display: "contents" },
							containerRef: this.containerRef,
							ignoreClass: this.props.outsideClickIgnoreClass,
						},
						H.createElement(
							n,
							{
								className: hn("react-datepicker", this.props.className, {
									"react-datepicker--time-only": this.props.showTimeSelectOnly,
								}),
								showTime: this.props.showTimeSelect || this.props.showTimeInput,
								showTimeSelectOnly: this.props.showTimeSelectOnly,
							},
							this.renderAriaLiveRegion(),
							this.renderPreviousButton(),
							this.renderNextButton(),
							this.renderMonths(),
							this.renderYears(),
							this.renderTodayButton(),
							this.renderTimeSection(),
							this.renderInputTimeSection(),
							this.renderChildren(),
						),
					)
				}),
				t
			)
		})(_.Component),
		TTt = function (e) {
			var t = e.icon,
				n = e.className,
				r = n === void 0 ? "" : n,
				i = e.onClick,
				a = "react-datepicker__calendar-icon"
			return typeof t == "string"
				? H.createElement("i", {
						className: "".concat(a, " ").concat(t, " ").concat(r),
						"aria-hidden": "true",
						onClick: i,
				  })
				: H.isValidElement(t)
				? H.cloneElement(t, {
						className: ""
							.concat(t.props.className || "", " ")
							.concat(a, " ")
							.concat(r),
						onClick: function (o) {
							typeof t.props.onClick == "function" && t.props.onClick(o),
								typeof i == "function" && i(o)
						},
				  })
				: H.createElement(
						"svg",
						{
							className: "".concat(a, " ").concat(r),
							xmlns: "http://www.w3.org/2000/svg",
							viewBox: "0 0 448 512",
							onClick: i,
						},
						H.createElement("path", {
							d: "M96 32V64H48C21.5 64 0 85.5 0 112v48H448V112c0-26.5-21.5-48-48-48H352V32c0-17.7-14.3-32-32-32s-32 14.3-32 32V64H160V32c0-17.7-14.3-32-32-32S96 14.3 96 32zM448 192H0V464c0 26.5 21.5 48 48 48H400c26.5 0 48-21.5 48-48V192z",
						}),
				  )
		},
		mG = (function (e) {
			Ir(t, e)
			function t(n) {
				var r = e.call(this, n) || this
				return (r.portalRoot = null), (r.el = document.createElement("div")), r
			}
			return (
				(t.prototype.componentDidMount = function () {
					;(this.portalRoot = (this.props.portalHost || document).getElementById(
						this.props.portalId,
					)),
						this.portalRoot ||
							((this.portalRoot = document.createElement("div")),
							this.portalRoot.setAttribute("id", this.props.portalId),
							(this.props.portalHost || document.body).appendChild(this.portalRoot)),
						this.portalRoot.appendChild(this.el)
				}),
				(t.prototype.componentWillUnmount = function () {
					this.portalRoot && this.portalRoot.removeChild(this.el)
				}),
				(t.prototype.render = function () {
					return nl.createPortal(this.props.children, this.el)
				}),
				t
			)
		})(_.Component),
		kTt = "[tabindex], a, button, input, select, textarea",
		STt = function (e) {
			return (e instanceof HTMLAnchorElement || !e.disabled) && e.tabIndex !== -1
		},
		vG = (function (e) {
			Ir(t, e)
			function t(n) {
				var r = e.call(this, n) || this
				return (
					(r.getTabChildren = function () {
						var i
						return Array.prototype.slice
							.call(
								(i = r.tabLoopRef.current) === null || i === void 0
									? void 0
									: i.querySelectorAll(kTt),
								1,
								-1,
							)
							.filter(STt)
					}),
					(r.handleFocusStart = function () {
						var i = r.getTabChildren()
						i && i.length > 1 && i[i.length - 1].focus()
					}),
					(r.handleFocusEnd = function () {
						var i = r.getTabChildren()
						i && i.length > 1 && i[0].focus()
					}),
					(r.tabLoopRef = _.createRef()),
					r
				)
			}
			return (
				(t.prototype.render = function () {
					var n
					return (
						(n = this.props.enableTabLoop) !== null && n !== void 0
							? n
							: t.defaultProps.enableTabLoop
					)
						? H.createElement(
								"div",
								{ className: "react-datepicker__tab-loop", ref: this.tabLoopRef },
								H.createElement("div", {
									className: "react-datepicker__tab-loop__start",
									tabIndex: 0,
									onFocus: this.handleFocusStart,
								}),
								this.props.children,
								H.createElement("div", {
									className: "react-datepicker__tab-loop__end",
									tabIndex: 0,
									onFocus: this.handleFocusEnd,
								}),
						  )
						: this.props.children
				}),
				(t.defaultProps = { enableTabLoop: !0 }),
				t
			)
		})(_.Component)
	function DTt(e) {
		var t = function (n) {
			var r,
				i = typeof n.hidePopper == "boolean" ? n.hidePopper : !0,
				a = _.useRef(null),
				o = LCt(
					Rt(
						{
							open: !i,
							whileElementsMounted: pCt,
							placement: n.popperPlacement,
							middleware: is(
								[xCt({ padding: 15 }), bCt(10), wCt({ element: a })],
								(r = n.popperModifiers) !== null && r !== void 0 ? r : [],
								!0,
							),
						},
						n.popperProps,
					),
				),
				s = Rt(Rt({}, n), { hidePopper: i, popperProps: Rt(Rt({}, o), { arrowRef: a }) })
			return H.createElement(e, Rt({}, s))
		}
		return t
	}
	var _Tt = (function (e) {
			Ir(t, e)
			function t() {
				return (e !== null && e.apply(this, arguments)) || this
			}
			return (
				Object.defineProperty(t, "defaultProps", {
					get: function () {
						return { hidePopper: !0 }
					},
					enumerable: !1,
					configurable: !0,
				}),
				(t.prototype.render = function () {
					var n = this.props,
						r = n.className,
						i = n.wrapperClassName,
						a = n.hidePopper,
						o = a === void 0 ? t.defaultProps.hidePopper : a,
						s = n.popperComponent,
						l = n.targetComponent,
						u = n.enableTabLoop,
						d = n.popperOnKeyDown,
						p = n.portalId,
						m = n.portalHost,
						v = n.popperProps,
						y = n.showArrow,
						b = void 0
					if (!o) {
						var x = hn("react-datepicker-popper", r)
						b = H.createElement(
							vG,
							{ enableTabLoop: u },
							H.createElement(
								"div",
								{
									ref: v.refs.setFloating,
									style: v.floatingStyles,
									className: x,
									"data-placement": v.placement,
									onKeyDown: d,
								},
								s,
								y &&
									H.createElement(_Ct, {
										ref: v.arrowRef,
										context: v.context,
										fill: "currentColor",
										strokeWidth: 1,
										height: 8,
										width: 16,
										style: { transform: "translateY(-1px)" },
										className: "react-datepicker__triangle",
									}),
							),
						)
					}
					this.props.popperContainer && (b = _.createElement(this.props.popperContainer, {}, b)),
						p && !o && (b = H.createElement(mG, { portalId: p, portalHost: m }, b))
					var E = hn("react-datepicker-wrapper", i)
					return H.createElement(
						H.Fragment,
						null,
						H.createElement("div", { ref: v.refs.setReference, className: E }, l),
						b,
					)
				}),
				t
			)
		})(_.Component),
		OTt = DTt(_Tt),
		J5 = "react-datepicker-ignore-onclickoutside"
	function ATt(e, t) {
		return e && t ? bi(e) !== bi(t) || Tt(e) !== Tt(t) : e !== t
	}
	var wS = "Date input not valid.",
		NTt = (function (e) {
			Ir(t, e)
			function t(n) {
				var r = e.call(this, n) || this
				return (
					(r.calendar = null),
					(r.input = null),
					(r.getPreSelection = function () {
						return r.props.openToDate
							? r.props.openToDate
							: r.props.selectsEnd && r.props.startDate
							? r.props.startDate
							: r.props.selectsStart && r.props.endDate
							? r.props.endDate
							: rn()
					}),
					(r.modifyHolidays = function () {
						var i
						return (i = r.props.holidays) === null || i === void 0
							? void 0
							: i.reduce(function (a, o) {
									var s = new Date(o.date)
									return Zs(s) ? is(is([], a, !0), [Rt(Rt({}, o), { date: s })], !1) : a
							  }, [])
					}),
					(r.calcInitialState = function () {
						var i,
							a = r.getPreSelection(),
							o = fG(r.props),
							s = pG(r.props),
							l = o && Sd(a, D1(o)) ? o : s && Vu(a, j5(s)) ? s : a
						return {
							open: r.props.startOpen || !1,
							preventFocus: !1,
							inputValue: null,
							preSelection:
								(i = r.props.selectsRange ? r.props.startDate : r.props.selected) !== null &&
								i !== void 0
									? i
									: l,
							highlightDates: V5(r.props.highlightDates),
							focused: !1,
							shouldFocusDayInline: !1,
							isRenderAriaLiveMessage: !1,
							wasHidden: !1,
						}
					}),
					(r.resetHiddenStatus = function () {
						r.setState(Rt(Rt({}, r.state), { wasHidden: !1 }))
					}),
					(r.setHiddenStatus = function () {
						r.setState(Rt(Rt({}, r.state), { wasHidden: !0 }))
					}),
					(r.setHiddenStateOnVisibilityHidden = function () {
						document.visibilityState === "hidden" && r.setHiddenStatus()
					}),
					(r.clearPreventFocusTimeout = function () {
						r.preventFocusTimeout && clearTimeout(r.preventFocusTimeout)
					}),
					(r.setFocus = function () {
						r.input && r.input.focus && r.input.focus({ preventScroll: !0 })
					}),
					(r.setBlur = function () {
						r.input && r.input.blur && r.input.blur(), r.cancelFocusInput()
					}),
					(r.setOpen = function (i, a) {
						a === void 0 && (a = !1),
							r.setState(
								{
									open: i,
									preSelection:
										i && r.state.open ? r.state.preSelection : r.calcInitialState().preSelection,
									lastPreSelectChange: ES,
								},
								function () {
									i ||
										r.setState(
											function (o) {
												return { focused: a ? o.focused : !1 }
											},
											function () {
												!a && r.setBlur(), r.setState({ inputValue: null })
											},
										)
								},
							)
					}),
					(r.inputOk = function () {
						return ml(r.state.preSelection)
					}),
					(r.isCalendarOpen = function () {
						return r.props.open === void 0
							? r.state.open && !r.props.disabled && !r.props.readOnly
							: r.props.open
					}),
					(r.handleFocus = function (i) {
						var a,
							o,
							s = r.state.wasHidden,
							l = s ? r.state.open : !0
						s && r.resetHiddenStatus(),
							!r.state.preventFocus &&
								l &&
								((o = (a = r.props).onFocus) === null || o === void 0 || o.call(a, i),
								!r.props.preventOpenOnFocus && !r.props.readOnly && r.setOpen(!0)),
							r.setState({ focused: !0 })
					}),
					(r.sendFocusBackToInput = function () {
						r.preventFocusTimeout && r.clearPreventFocusTimeout(),
							r.setState({ preventFocus: !0 }, function () {
								r.preventFocusTimeout = setTimeout(function () {
									r.setFocus(), r.setState({ preventFocus: !1 })
								})
							})
					}),
					(r.cancelFocusInput = function () {
						clearTimeout(r.inputFocusTimeout), (r.inputFocusTimeout = void 0)
					}),
					(r.deferFocusInput = function () {
						r.cancelFocusInput(),
							(r.inputFocusTimeout = setTimeout(function () {
								return r.setFocus()
							}, 1))
					}),
					(r.handleDropdownFocus = function () {
						r.cancelFocusInput()
					}),
					(r.handleBlur = function (i) {
						var a, o
						;(!r.state.open || r.props.withPortal || r.props.showTimeInput) &&
							((o = (a = r.props).onBlur) === null || o === void 0 || o.call(a, i)),
							r.setState({ focused: !1 })
					}),
					(r.handleCalendarClickOutside = function (i) {
						var a, o
						r.props.inline || r.setOpen(!1),
							(o = (a = r.props).onClickOutside) === null || o === void 0 || o.call(a, i),
							r.props.withPortal && i.preventDefault()
					}),
					(r.handleChange = function () {
						for (var i, a, o = [], s = 0; s < arguments.length; s++) o[s] = arguments[s]
						var l = o[0]
						if (
							!(
								r.props.onChangeRaw &&
								(r.props.onChangeRaw.apply(r, o),
								!l || typeof l.isDefaultPrevented != "function" || l.isDefaultPrevented())
							)
						) {
							r.setState({
								inputValue:
									(l == null ? void 0 : l.target) instanceof HTMLInputElement
										? l.target.value
										: null,
								lastPreSelectChange: MTt,
							})
							var u = r.props,
								d = u.dateFormat,
								p = d === void 0 ? t.defaultProps.dateFormat : d,
								m = u.strictParsing,
								v = m === void 0 ? t.defaultProps.strictParsing : m,
								y = u.selectsRange,
								b = u.startDate,
								x = u.endDate,
								E =
									(l == null ? void 0 : l.target) instanceof HTMLInputElement ? l.target.value : ""
							if (y) {
								var T = E.split("-", 2).map(function (L) {
										return L.trim()
									}),
									C = T[0],
									D = T[1],
									O = yS(C ?? "", p, r.props.locale, v),
									A = yS(D ?? "", p, r.props.locale, v),
									N = (b == null ? void 0 : b.getTime()) !== (O == null ? void 0 : O.getTime()),
									I = (x == null ? void 0 : x.getTime()) !== (A == null ? void 0 : A.getTime())
								if ((!N && !I) || (O && $a(O, r.props)) || (A && $a(A, r.props))) return
								;(a = (i = r.props).onChange) === null || a === void 0 || a.call(i, [O, A], l)
							} else {
								var P = yS(E, p, r.props.locale, v, r.props.minDate)
								r.props.showTimeSelectOnly &&
									r.props.selected &&
									P &&
									!At(P, r.props.selected) &&
									(P = REt(r.props.selected, { hours: us(P), minutes: cs(P), seconds: vl(P) })),
									(P || !E) && r.setSelected(P, l, !0)
							}
						}
					}),
					(r.handleSelect = function (i, a, o) {
						if (
							(r.props.shouldCloseOnSelect && !r.props.showTimeSelect && r.sendFocusBackToInput(),
							r.props.onChangeRaw && r.props.onChangeRaw(a),
							r.setSelected(i, a, !1, o),
							r.props.showDateSelect && r.setState({ isRenderAriaLiveMessage: !0 }),
							!r.props.shouldCloseOnSelect || r.props.showTimeSelect)
						)
							r.setPreSelection(i)
						else if (!r.props.inline) {
							r.props.selectsRange || r.setOpen(!1)
							var s = r.props,
								l = s.startDate,
								u = s.endDate
							l && !u && (r.props.swapRange || !K5(i, l)) && r.setOpen(!1)
						}
					}),
					(r.setSelected = function (i, a, o, s) {
						var l,
							u,
							d = i
						if (r.props.showYearPicker) {
							if (d !== null && _1(Tt(d), r.props)) return
						} else if (r.props.showMonthYearPicker) {
							if (d !== null && dG(d, r.props)) return
						} else if (d !== null && $a(d, r.props)) return
						var p = r.props,
							m = p.onChange,
							v = p.selectsRange,
							y = p.startDate,
							b = p.endDate,
							x = p.selectsMultiple,
							E = p.selectedDates,
							T = p.minTime,
							C = p.swapRange
						if (!zc(r.props.selected, d) || r.props.allowSameDay || v || x)
							if (
								(d !== null &&
									(r.props.selected &&
										(!o ||
											(!r.props.showTimeSelect &&
												!r.props.showTimeSelectOnly &&
												!r.props.showTimeInput)) &&
										(d = bS(d, {
											hour: us(r.props.selected),
											minute: cs(r.props.selected),
											second: vl(r.props.selected),
										})),
									!o &&
										(r.props.showTimeSelect || r.props.showTimeSelectOnly) &&
										T &&
										(d = bS(d, {
											hour: T.getHours(),
											minute: T.getMinutes(),
											second: T.getSeconds(),
										})),
									r.props.inline || r.setState({ preSelection: d }),
									r.props.focusSelectedMonth || r.setState({ monthSelectedIn: s })),
								v)
							) {
								var D = !y && !b,
									O = y && !b,
									A = y && b
								D
									? m == null || m([d, null], a)
									: O &&
									  (d === null
											? m == null || m([null, null], a)
											: K5(d, y)
											? C
												? m == null || m([d, y], a)
												: m == null || m([d, null], a)
											: m == null || m([y, d], a)),
									A && (m == null || m([d, null], a))
							} else if (x) {
								if (d !== null)
									if (!(E != null && E.length)) m == null || m([d], a)
									else {
										var N = E.some(function (P) {
											return At(P, d)
										})
										if (N) {
											var I = E.filter(function (P) {
												return !At(P, d)
											})
											m == null || m(I, a)
										} else m == null || m(is(is([], E, !0), [d], !1), a)
									}
							} else m == null || m(d, a)
						o ||
							((u = (l = r.props).onSelect) === null || u === void 0 || u.call(l, d, a),
							r.setState({ inputValue: null }))
					}),
					(r.setPreSelection = function (i) {
						var a = ml(r.props.minDate),
							o = ml(r.props.maxDate),
							s = !0
						if (i) {
							var l = D1(i)
							if (a && o) s = _m(i, r.props.minDate, r.props.maxDate)
							else if (a) {
								var u = D1(r.props.minDate)
								s = Vu(i, u) || zc(l, u)
							} else if (o) {
								var d = j5(r.props.maxDate)
								s = Sd(i, d) || zc(l, d)
							}
						}
						s && r.setState({ preSelection: i })
					}),
					(r.toggleCalendar = function () {
						r.setOpen(!r.state.open)
					}),
					(r.handleTimeChange = function (i) {
						var a, o
						if (!(r.props.selectsRange || r.props.selectsMultiple)) {
							var s = r.props.selected ? r.props.selected : r.getPreSelection(),
								l = r.props.selected ? i : bS(s, { hour: us(i), minute: cs(i) })
							r.setState({ preSelection: l }),
								(o = (a = r.props).onChange) === null || o === void 0 || o.call(a, l),
								r.props.shouldCloseOnSelect &&
									!r.props.showTimeInput &&
									(r.sendFocusBackToInput(), r.setOpen(!1)),
								r.props.showTimeInput && r.setOpen(!0),
								(r.props.showTimeSelectOnly || r.props.showTimeSelect) &&
									r.setState({ isRenderAriaLiveMessage: !0 }),
								r.setState({ inputValue: null })
						}
					}),
					(r.onInputClick = function () {
						var i, a
						!r.props.disabled && !r.props.readOnly && r.setOpen(!0),
							(a = (i = r.props).onInputClick) === null || a === void 0 || a.call(i)
					}),
					(r.onInputKeyDown = function (i) {
						var a, o, s, l, u, d
						;(o = (a = r.props).onKeyDown) === null || o === void 0 || o.call(a, i)
						var p = i.key
						if (!r.state.open && !r.props.inline && !r.props.preventOpenOnFocus) {
							;(p === He.ArrowDown || p === He.ArrowUp || p === He.Enter) &&
								((s = r.onInputClick) === null || s === void 0 || s.call(r))
							return
						}
						if (r.state.open) {
							if (p === He.ArrowDown || p === He.ArrowUp) {
								i.preventDefault()
								var m = r.props.showTimeSelectOnly
										? ".react-datepicker__time-list-item[tabindex='0']"
										: r.props.showWeekPicker && r.props.showWeekNumbers
										? '.react-datepicker__week-number[tabindex="0"]'
										: r.props.showFullMonthYearPicker || r.props.showMonthYearPicker
										? '.react-datepicker__month-text[tabindex="0"]'
										: '.react-datepicker__day[tabindex="0"]',
									v =
										((l = r.calendar) === null || l === void 0
											? void 0
											: l.containerRef.current) instanceof Element &&
										r.calendar.containerRef.current.querySelector(m)
								v instanceof HTMLElement && v.focus({ preventScroll: !0 })
								return
							}
							var y = rn(r.state.preSelection)
							p === He.Enter
								? (i.preventDefault(),
								  r.inputOk() && r.state.lastPreSelectChange === ES
										? (r.handleSelect(y, i), !r.props.shouldCloseOnSelect && r.setPreSelection(y))
										: r.setOpen(!1))
								: p === He.Escape
								? (i.preventDefault(), r.sendFocusBackToInput(), r.setOpen(!1))
								: p === He.Tab && r.setOpen(!1),
								r.inputOk() ||
									(d = (u = r.props).onInputError) === null ||
									d === void 0 ||
									d.call(u, { code: 1, msg: wS })
						}
					}),
					(r.onPortalKeyDown = function (i) {
						var a = i.key
						a === He.Escape &&
							(i.preventDefault(),
							r.setState({ preventFocus: !0 }, function () {
								r.setOpen(!1),
									setTimeout(function () {
										r.setFocus(), r.setState({ preventFocus: !1 })
									})
							}))
					}),
					(r.onDayKeyDown = function (i) {
						var a,
							o,
							s,
							l,
							u,
							d,
							p = r.props,
							m = p.minDate,
							v = p.maxDate,
							y = p.disabledKeyboardNavigation,
							b = p.showWeekPicker,
							x = p.shouldCloseOnSelect,
							E = p.locale,
							T = p.calendarStartDay,
							C = p.adjustDateOnChange,
							D = p.inline
						if (((o = (a = r.props).onKeyDown) === null || o === void 0 || o.call(a, i), !y)) {
							var O = i.key,
								A = i.shiftKey,
								N = rn(r.state.preSelection),
								I = function (ne, re) {
									var ie = re
									switch (ne) {
										case He.ArrowRight:
											ie = b ? Yb(re, 1) : Tl(re, 1)
											break
										case He.ArrowLeft:
											ie = b ? S5(re, 1) : gEt(re, 1)
											break
										case He.ArrowUp:
											ie = S5(re, 1)
											break
										case He.ArrowDown:
											ie = Yb(re, 1)
											break
										case He.PageUp:
											ie = A ? jp(re, 1) : Pp(re, 1)
											break
										case He.PageDown:
											ie = A ? hl(re, 1) : No(re, 1)
											break
										case He.Home:
											ie = Nu(re, E, T)
											break
										case He.End:
											ie = zCt(re)
											break
									}
									return ie
								},
								P = function (ne, re) {
									for (var ie = 40, J = ne, le = !1, F = 0, Y = I(ne, re); !le; ) {
										if (F >= ie) {
											Y = re
											break
										}
										m && Y < m && ((J = He.ArrowRight), (Y = $a(m, r.props) ? I(J, Y) : m)),
											v && Y > v && ((J = He.ArrowLeft), (Y = $a(v, r.props) ? I(J, Y) : v)),
											$a(Y, r.props)
												? ((J === He.PageUp || J === He.Home) && (J = He.ArrowRight),
												  (J === He.PageDown || J === He.End) && (J = He.ArrowLeft),
												  (Y = I(J, Y)))
												: (le = !0),
											F++
									}
									return Y
								}
							if (O === He.Enter) {
								i.preventDefault(), r.handleSelect(N, i), !x && r.setPreSelection(N)
								return
							} else if (O === He.Escape) {
								i.preventDefault(),
									r.setOpen(!1),
									r.inputOk() ||
										(l = (s = r.props).onInputError) === null ||
										l === void 0 ||
										l.call(s, { code: 1, msg: wS })
								return
							}
							var L = null
							switch (O) {
								case He.ArrowLeft:
								case He.ArrowRight:
								case He.ArrowUp:
								case He.ArrowDown:
								case He.PageUp:
								case He.PageDown:
								case He.Home:
								case He.End:
									L = P(O, N)
									break
							}
							if (!L) {
								;(d = (u = r.props).onInputError) === null ||
									d === void 0 ||
									d.call(u, { code: 1, msg: wS })
								return
							}
							if (
								(i.preventDefault(),
								r.setState({ lastPreSelectChange: ES }),
								C && r.setSelected(L),
								r.setPreSelection(L),
								D)
							) {
								var B = bi(N),
									z = bi(L),
									V = Tt(N),
									K = Tt(L)
								B !== z || V !== K
									? r.setState({ shouldFocusDayInline: !0 })
									: r.setState({ shouldFocusDayInline: !1 })
							}
						}
					}),
					(r.onPopperKeyDown = function (i) {
						var a = i.key
						a === He.Escape && (i.preventDefault(), r.sendFocusBackToInput())
					}),
					(r.onClearClick = function (i) {
						i && i.preventDefault && i.preventDefault(), r.sendFocusBackToInput()
						var a = r.props,
							o = a.selectsRange,
							s = a.onChange
						o ? s == null || s([null, null], i) : s == null || s(null, i),
							r.setState({ inputValue: null })
					}),
					(r.clear = function () {
						r.onClearClick()
					}),
					(r.onScroll = function (i) {
						typeof r.props.closeOnScroll == "boolean" && r.props.closeOnScroll
							? (i.target === document ||
									i.target === document.documentElement ||
									i.target === document.body) &&
							  r.setOpen(!1)
							: typeof r.props.closeOnScroll == "function" &&
							  r.props.closeOnScroll(i) &&
							  r.setOpen(!1)
					}),
					(r.renderCalendar = function () {
						var i, a
						return !r.props.inline && !r.isCalendarOpen()
							? null
							: H.createElement(
									CTt,
									Rt(
										{
											showMonthYearDropdown: void 0,
											ref: function (o) {
												r.calendar = o
											},
										},
										r.props,
										r.state,
										{
											setOpen: r.setOpen,
											dateFormat:
												(i = r.props.dateFormatCalendar) !== null && i !== void 0
													? i
													: t.defaultProps.dateFormatCalendar,
											onSelect: r.handleSelect,
											onClickOutside: r.handleCalendarClickOutside,
											holidays: tTt(r.modifyHolidays()),
											outsideClickIgnoreClass: J5,
											onDropdownFocus: r.handleDropdownFocus,
											onTimeChange: r.handleTimeChange,
											className: r.props.calendarClassName,
											container: r.props.calendarContainer,
											handleOnKeyDown: r.props.onKeyDown,
											handleOnDayKeyDown: r.onDayKeyDown,
											setPreSelection: r.setPreSelection,
											dropdownMode:
												(a = r.props.dropdownMode) !== null && a !== void 0
													? a
													: t.defaultProps.dropdownMode,
										},
									),
									r.props.children,
							  )
					}),
					(r.renderAriaLiveRegion = function () {
						var i = r.props,
							a = i.dateFormat,
							o = a === void 0 ? t.defaultProps.dateFormat : a,
							s = i.locale,
							l = r.props.showTimeInput || r.props.showTimeSelect,
							u = l ? "PPPPp" : "PPPP",
							d
						return (
							r.props.selectsRange
								? (d = "Selected start date: "
										.concat(La(r.props.startDate, { dateFormat: u, locale: s }), ". ")
										.concat(
											r.props.endDate
												? "End date: " + La(r.props.endDate, { dateFormat: u, locale: s })
												: "",
										))
								: r.props.showTimeSelectOnly
								? (d = "Selected time: ".concat(La(r.props.selected, { dateFormat: o, locale: s })))
								: r.props.showYearPicker
								? (d = "Selected year: ".concat(
										La(r.props.selected, { dateFormat: "yyyy", locale: s }),
								  ))
								: r.props.showMonthYearPicker
								? (d = "Selected month: ".concat(
										La(r.props.selected, { dateFormat: "MMMM yyyy", locale: s }),
								  ))
								: r.props.showQuarterYearPicker
								? (d = "Selected quarter: ".concat(
										La(r.props.selected, { dateFormat: "yyyy, QQQ", locale: s }),
								  ))
								: (d = "Selected date: ".concat(
										La(r.props.selected, { dateFormat: u, locale: s }),
								  )),
							H.createElement(
								"span",
								{ role: "alert", "aria-live": "polite", className: "react-datepicker__aria-live" },
								d,
							)
						)
					}),
					(r.renderDateInput = function () {
						var i,
							a,
							o,
							s = hn(r.props.className, ((i = {}), (i[J5] = r.state.open), i)),
							l = r.props.customInput || H.createElement("input", { type: "text" }),
							u = r.props.customInputRef || "ref",
							d = r.props,
							p = d.dateFormat,
							m = p === void 0 ? t.defaultProps.dateFormat : p,
							v = d.locale,
							y =
								typeof r.props.value == "string"
									? r.props.value
									: typeof r.state.inputValue == "string"
									? r.state.inputValue
									: r.props.selectsRange
									? BCt(r.props.startDate, r.props.endDate, { dateFormat: m, locale: v })
									: r.props.selectsMultiple
									? HCt((o = r.props.selectedDates) !== null && o !== void 0 ? o : [], {
											dateFormat: m,
											locale: v,
									  })
									: La(r.props.selected, { dateFormat: m, locale: v })
						return _.cloneElement(
							l,
							((a = {}),
							(a[u] = function (b) {
								r.input = b
							}),
							(a.value = y),
							(a.onBlur = r.handleBlur),
							(a.onChange = r.handleChange),
							(a.onClick = r.onInputClick),
							(a.onFocus = r.handleFocus),
							(a.onKeyDown = r.onInputKeyDown),
							(a.id = r.props.id),
							(a.name = r.props.name),
							(a.form = r.props.form),
							(a.autoFocus = r.props.autoFocus),
							(a.placeholder = r.props.placeholderText),
							(a.disabled = r.props.disabled),
							(a.autoComplete = r.props.autoComplete),
							(a.className = hn(l.props.className, s)),
							(a.title = r.props.title),
							(a.readOnly = r.props.readOnly),
							(a.required = r.props.required),
							(a.tabIndex = r.props.tabIndex),
							(a["aria-describedby"] = r.props.ariaDescribedBy),
							(a["aria-invalid"] = r.props.ariaInvalid),
							(a["aria-labelledby"] = r.props.ariaLabelledBy),
							(a["aria-required"] = r.props.ariaRequired),
							a),
						)
					}),
					(r.renderClearButton = function () {
						var i = r.props,
							a = i.isClearable,
							o = i.disabled,
							s = i.selected,
							l = i.startDate,
							u = i.endDate,
							d = i.clearButtonTitle,
							p = i.clearButtonClassName,
							m = p === void 0 ? "" : p,
							v = i.ariaLabelClose,
							y = v === void 0 ? "Close" : v,
							b = i.selectedDates
						return a && (s != null || l != null || u != null || (b != null && b.length))
							? H.createElement("button", {
									type: "button",
									className: hn("react-datepicker__close-icon", m, {
										"react-datepicker__close-icon--disabled": o,
									}),
									disabled: o,
									"aria-label": y,
									onClick: r.onClearClick,
									title: d,
									tabIndex: -1,
							  })
							: null
					}),
					(r.state = r.calcInitialState()),
					(r.preventFocusTimeout = void 0),
					r
				)
			}
			return (
				Object.defineProperty(t, "defaultProps", {
					get: function () {
						return {
							allowSameDay: !1,
							dateFormat: "MM/dd/yyyy",
							dateFormatCalendar: "LLLL yyyy",
							disabled: !1,
							disabledKeyboardNavigation: !1,
							dropdownMode: "scroll",
							preventOpenOnFocus: !1,
							monthsShown: 1,
							readOnly: !1,
							withPortal: !1,
							selectsDisabledDaysInRange: !1,
							shouldCloseOnSelect: !0,
							showTimeSelect: !1,
							showTimeInput: !1,
							showPreviousMonths: !1,
							showMonthYearPicker: !1,
							showFullMonthYearPicker: !1,
							showTwoColumnMonthYearPicker: !1,
							showFourColumnMonthYearPicker: !1,
							showYearPicker: !1,
							showQuarterYearPicker: !1,
							showWeekPicker: !1,
							strictParsing: !1,
							swapRange: !1,
							timeIntervals: 30,
							timeCaption: "Time",
							previousMonthAriaLabel: "Previous Month",
							previousMonthButtonLabel: "Previous Month",
							nextMonthAriaLabel: "Next Month",
							nextMonthButtonLabel: "Next Month",
							previousYearAriaLabel: "Previous Year",
							previousYearButtonLabel: "Previous Year",
							nextYearAriaLabel: "Next Year",
							nextYearButtonLabel: "Next Year",
							timeInputLabel: "Time",
							enableTabLoop: !0,
							yearItemNumber: kg,
							focusSelectedMonth: !1,
							showPopperArrow: !0,
							excludeScrollbar: !0,
							customTimeInput: null,
							calendarStartDay: void 0,
							toggleCalendarOnIconClick: !1,
							usePointerEvent: !1,
						}
					},
					enumerable: !1,
					configurable: !0,
				}),
				(t.prototype.componentDidMount = function () {
					window.addEventListener("scroll", this.onScroll, !0),
						document.addEventListener("visibilitychange", this.setHiddenStateOnVisibilityHidden)
				}),
				(t.prototype.componentDidUpdate = function (n, r) {
					var i, a, o, s
					n.inline &&
						ATt(n.selected, this.props.selected) &&
						this.setPreSelection(this.props.selected),
						this.state.monthSelectedIn !== void 0 &&
							n.monthsShown !== this.props.monthsShown &&
							this.setState({ monthSelectedIn: 0 }),
						n.highlightDates !== this.props.highlightDates &&
							this.setState({ highlightDates: V5(this.props.highlightDates) }),
						!r.focused &&
							!zc(n.selected, this.props.selected) &&
							this.setState({ inputValue: null }),
						r.open !== this.state.open &&
							(r.open === !1 &&
								this.state.open === !0 &&
								((a = (i = this.props).onCalendarOpen) === null || a === void 0 || a.call(i)),
							r.open === !0 &&
								this.state.open === !1 &&
								((s = (o = this.props).onCalendarClose) === null || s === void 0 || s.call(o)))
				}),
				(t.prototype.componentWillUnmount = function () {
					this.clearPreventFocusTimeout(),
						window.removeEventListener("scroll", this.onScroll, !0),
						document.removeEventListener("visibilitychange", this.setHiddenStateOnVisibilityHidden)
				}),
				(t.prototype.renderInputContainer = function () {
					var n = this.props,
						r = n.showIcon,
						i = n.icon,
						a = n.calendarIconClassname,
						o = n.calendarIconClassName,
						s = n.toggleCalendarOnIconClick,
						l = this.state.open
					return (
						a &&
							console.warn(
								"calendarIconClassname props is deprecated. should use calendarIconClassName props.",
							),
						H.createElement(
							"div",
							{
								className: "react-datepicker__input-container".concat(
									r ? " react-datepicker__view-calendar-icon" : "",
								),
							},
							r &&
								H.createElement(
									TTt,
									Rt(
										{
											icon: i,
											className: hn(o, !o && a, l && "react-datepicker-ignore-onclickoutside"),
										},
										s ? { onClick: this.toggleCalendar } : null,
									),
								),
							this.state.isRenderAriaLiveMessage && this.renderAriaLiveRegion(),
							this.renderDateInput(),
							this.renderClearButton(),
						)
					)
				}),
				(t.prototype.render = function () {
					var n = this.renderCalendar()
					if (this.props.inline) return n
					if (this.props.withPortal) {
						var r = this.state.open
							? H.createElement(
									vG,
									{ enableTabLoop: this.props.enableTabLoop },
									H.createElement(
										"div",
										{
											className: "react-datepicker__portal",
											tabIndex: -1,
											onKeyDown: this.onPortalKeyDown,
										},
										n,
									),
							  )
							: null
						return (
							this.state.open &&
								this.props.portalId &&
								(r = H.createElement(mG, Rt({ portalId: this.props.portalId }, this.props), r)),
							H.createElement("div", null, this.renderInputContainer(), r)
						)
					}
					return H.createElement(
						OTt,
						Rt({}, this.props, {
							className: this.props.popperClassName,
							hidePopper: !this.isCalendarOpen(),
							targetComponent: this.renderInputContainer(),
							popperComponent: n,
							popperOnKeyDown: this.onPopperKeyDown,
							showArrow: this.props.showPopperArrow,
						}),
					)
				}),
				t
			)
		})(_.Component),
		MTt = "input",
		ES = "navigate"
	const $p = ({ ...e }) => {
			const { setFieldValue: t } = Bx(),
				[n] = bH(e)
			return h.jsx(NTt, {
				...n,
				...e,
				selected: (n.value && new Date(n.value)) || null,
				onChange: (r) => {
					t(n.name, r)
				},
			})
		},
		ITt = Bt({ registrationStart: Fu().required(), registrationEnd: Fu().required() }),
		RTt = (e) => {
			const { eventDetail: t, onClose: n } = e,
				[r, { isLoading: i }] = MY(),
				a = async (o) => {
					const s = OY(o)
					await r(s)
						.unwrap()
						.then(() => {
							je.success(`Registration information for ${t.name} has been saved.`), n()
						})
						.catch((l) => {
							je.error(" " + l)
						})
				}
			return h.jsx(ht, {
				loading: i,
				children: h.jsx(Vt, {
					validationSchema: ITt,
					onSubmit: a,
					initialValues: t,
					children: ({ handleSubmit: o, setFieldValue: s, handleBlur: l, values: u, errors: d }) =>
						h.jsxs(R, {
							noValidate: !0,
							onSubmit: o,
							children: [
								h.jsxs(R.Group, {
									controlId: "eventDetail.registrationStart",
									children: [
										h.jsx(R.Label, { className: "full-width", children: "Registration Start" }),
										h.jsx($p, {
											name: "registrationStart",
											value: u.registrationStart,
											onChange: s,
											onBlur: l,
											showTimeSelect: !0,
											timeFormat: "HH:mm",
											timeIntervals: 60,
											timeCaption: "Time",
											dateFormat: "yyyy-MM-dd h:mm aa",
										}),
										h.jsx(R.Control.Feedback, {
											type: "invalid",
											children: h.jsx(h.Fragment, { children: d.registrationStart }),
										}),
										h.jsx(R.Text, {
											className: "text-muted",
											children: "Registration starts at this date and time.",
										}),
									],
								}),
								h.jsxs(R.Group, {
									controlId: "eventDetail.registrationEnd",
									children: [
										h.jsx(R.Label, {
											className: "full-width",
											children: "Online Registration End",
										}),
										h.jsx($p, {
											name: "registrationEnd",
											value: u.registrationEnd,
											onChange: s,
											onBlur: l,
											showTimeSelect: !0,
											timeFormat: "HH:mm",
											timeIntervals: 60,
											timeCaption: "Time",
											dateFormat: "yyyy-MM-dd h:mm aa",
										}),
										h.jsx(R.Control.Feedback, {
											type: "invalid",
											children: h.jsx(h.Fragment, { children: d.registrationEnd }),
										}),
										h.jsx(R.Text, {
											className: "text-muted",
											children: "Registration ends at this date and time.",
										}),
									],
								}),
								h.jsx(lr, {}),
								h.jsx(br, { canCancel: !0, OnCancel: n }),
							],
						}),
				}),
			})
		},
		LTt = (e) => {
			const { eventDetail: t } = e
			return h.jsx("div", {
				children: h.jsxs(H.Fragment, {
					children: [
						t.registrationIsClosed &&
							h.jsx("p", { className: "text-warning", children: "Registration is closed" }),
						!t.registrationIsClosed &&
							h.jsxs("div", {
								children: [
									h.jsxs(ln, {
										children: [
											h.jsx(it, { children: "Registration Opens:" }),
											h.jsx(it, { children: Te(t.registrationStart).format("MMM Do YYYY") }),
										],
									}),
									h.jsxs(ln, {
										children: [
											h.jsx(it, { children: "Registration Ends:" }),
											h.jsx(it, { children: Te(t.registrationEnd).format("MMM Do YYYY") }),
										],
									}),
									h.jsx(ln, {
										children: h.jsx(it, {
											children: h.jsx("span", {
												className: "text-muted",
												children: "Online registration ends at midnight on the end date above.",
											}),
										}),
									}),
								],
							}),
					],
				}),
			})
		},
		PTt = (e) => {
			const { eventDetail: t } = e,
				n = Wt(),
				r = H.useRef(),
				i = () => {
					r.current.close()
				}
			return h.jsx(Wr, {
				ref: r,
				initEdit: !1,
				canEdit: n.canManageEvent(),
				viewComponent: h.jsx(LTt, { eventDetail: t }),
				editComponent: h.jsx(RTt, { eventDetail: t, onClose: i }),
			})
		},
		jTt = (e) => {
			const { eventDetail: t } = e
			return h.jsxs("div", {
				children: [
					h.jsx("h3", { className: "text-primary", children: "Registration" }),
					h.jsx(PTt, { eventDetail: t }),
				],
			})
		},
		jD = Ft.div`
  border-width: 1px;
  border-color: silver;
  border-style: solid;
  padding: 10px;
  margin-bottom: 10px;
`
	jD.displayName = "FormContainer"
	function FTt(e) {
		const { eventDetail: t } = e,
			[n, r] = _.useState(!1),
			[i, a] = _.useState(!1),
			o = Wt(),
			s = t.startDate.getFullYear(),
			{ data: l, isLoading: u } = sh({
				key: `${s}-${t.tournament.systemName}-event-detail`,
				year: s,
				tournamentId: t.tournament.id,
			}),
			d = () => {
				r(!1), a(!1)
			}
		return h.jsxs(H.Fragment, {
			children: [
				o.canManageEvent() &&
					h.jsxs("div", {
						children: [
							h.jsx(Ge, {
								variant: "link",
								className: "text-warning",
								onClick: () => r(!0),
								children: "Add an Event Document",
							}),
							h.jsx(Ge, {
								variant: "link",
								className: "text-warning",
								onClick: () => a(!0),
								children: "Add an Event Link",
							}),
						],
					}),
				i &&
					h.jsx(jD, {
						children: h.jsx(RY, { eventLink: new CY({ id: 0, event: t.id }), onClose: d }),
					}),
				n &&
					h.jsx(jD, {
						children: h.jsx(YA, {
							document: new zu({ id: 0, year: s, tournament: t.tournament.id }),
							onClose: d,
						}),
					}),
				t.eventType !== "C" &&
					t.eventType !== "P" &&
					h.jsxs(ht, {
						loading: u,
						children: [
							h.jsx(jTt, { eventDetail: t }),
							h.jsx(Dy, { eventDetail: t, title: "Register Now", linkType: "Registration" }),
							h.jsx(Sy, { documents: l, title: "Register by Mail", documentType: "Registration" }),
							h.jsx(Dy, { eventDetail: t, title: "Online Tee Times", linkType: "Tee Times" }),
							h.jsx(Sy, { documents: l, title: "Tee Times", documentType: "Tee Times" }),
							h.jsx(Dy, { eventDetail: t, title: "Online Results", linkType: "Results" }),
							h.jsx(Sy, { documents: l, title: "Results", documentType: "Results" }),
							h.jsx(Dy, { eventDetail: t, title: "Media", linkType: "Media" }),
							h.jsx(Sy, { documents: l, title: "Other Event Documents", documentType: "Other" }),
						],
					}),
			],
		})
	}
	const Z5 = (e) => {
			const { photo: t, file: n } = e,
				r = new FormData()
			return (
				t.id && r.append("id", t.id.toString()),
				t.tournament && r.append("tournament", t.tournament.toString()),
				t.tags && r.append("tags", t.tags.map((i) => i.tag).join("|")),
				r.append("photo_type", t.photo_type),
				r.append("year", t.year.toString()),
				r.append("caption", t.caption || ""),
				r.append("raw_image", n, n.name),
				r
			)
		},
		BTt = (e) => {
			let t = "?d=1"
			const n = e.year || 0,
				r = e.tournamentId || 0
			return n > 0 && (t = t + `&year=${n}`), r > 0 && (t = t + `&tournament=${r}`), t
		},
		HTt = Ui.injectEndpoints({
			endpoints: (e) => ({
				getPhotos: e.query({
					query: (t) => ({ url: "/photos/" + BTt(t), method: "GET" }),
					providesTags: [{ type: "Photos", id: "LIST" }],
				}),
				getRandomPhoto: e.query({
					query: (t) => ({ url: `/tournament-photos/random/${t}/`, method: "GET" }),
				}),
				updatePhoto: e.mutation({
					query(t) {
						const { id: n } = t.photo
						return { url: `/photos/${n}/`, method: "PUT", data: Z5(t) }
					},
					invalidatesTags: [{ type: "Photos", id: "LIST" }],
				}),
				addPhoto: e.mutation({
					query(t) {
						return { url: "/photos/", method: "POST", data: Z5(t) }
					},
					invalidatesTags: [{ type: "Photos", id: "LIST" }],
				}),
				deletePhoto: e.mutation({
					query(t) {
						return { url: `/photos/${t}/`, method: "DELETE" }
					},
					invalidatesTags: [{ type: "Photos", id: "LIST" }],
				}),
			}),
		}),
		{
			useGetPhotosQuery: $Tt,
			useGetRandomPhotoQuery: UTt,
			useAddPhotoMutation: zTt,
			useUpdatePhotoMutation: qTt,
			useDeletePhotoMutation: e2t,
		} = HTt,
		VTt = Bt({ year: gi().required(), caption: Oe().max(240) }),
		WTt = (e) => {
			const { tournamentId: t, year: n, onClose: r } = e,
				i = { year: n, caption: "", tags: [] },
				[a, { isLoading: o }] = zTt(),
				s = async (l) => {
					const u = new LA(l)
					;(u.id = 0), (u.tournament = t), (u.photoType = "Other"), (u.tags = l.tags)
					const d = { photo: u.prepJson(), file: l.file }
					await a(d)
						.unwrap()
						.then(() => {
							je.success("Your photo has been saved."), r()
						})
						.catch((p) => {
							je.error(" " + p)
						})
				}
			return h.jsx(ht, {
				loading: o,
				children: h.jsx(Vt, {
					validationSchema: VTt,
					onSubmit: s,
					initialValues: i,
					children: ({
						handleSubmit: l,
						handleChange: u,
						handleBlur: d,
						values: p,
						touched: m,
						errors: v,
					}) => {
						var y
						return h.jsxs(R, {
							noValidate: !0,
							onSubmit: l,
							children: [
								e.year === void 0 &&
									h.jsxs(R.Group, {
										controlId: "doc.Year",
										children: [
											h.jsx(R.Label, { children: "Year" }),
											h.jsx(R.Control, {
												placeholder: "Year",
												name: "year",
												value: (y = p.year) == null ? void 0 : y.toString(),
												isValid: m.year && !v.year,
												isInvalid: !!v.year,
												onChange: u,
												onBlur: d,
											}),
											h.jsx(R.Control.Feedback, { type: "invalid", children: v.year }),
										],
									}),
								h.jsxs(R.Group, {
									controlId: "caption",
									children: [
										h.jsx(R.Label, { children: "Caption" }),
										h.jsx(R.Control, {
											placeholder: "Caption - please include name(s)",
											name: "caption",
											value: p.caption,
											isValid: m.caption && !v.caption,
											isInvalid: !!v.caption,
											onChange: u,
											onBlur: d,
										}),
										h.jsx(R.Control.Feedback, { type: "invalid", children: v.caption }),
									],
								}),
								h.jsx(KW, { onDrop: (b) => (p.file = b[0]), onSelected: (b) => (p.file = b[0]) }),
								h.jsx(WA, { selectedTags: p.tags || [], OnChange: (b) => (p.tags = b) }),
								h.jsx(lr, {}),
								h.jsx(br, { canCancel: !0, OnCancel: r }),
							],
						})
					},
				}),
			})
		},
		gG = Ft.img`
  max-width: 95%;
`
	gG.displayName = "RandomPhoto"
	const YTt = (e) => {
			var r
			const { samplePhoto: t, eventDetail: n } = e
			return h.jsxs(H.Fragment, {
				children: [
					h.jsx("h3", { className: "text-primary", children: "Tournament Photos" }),
					h.jsx(gG, { src: t.imageUrl, alt: t.caption }),
					h.jsx("p", { className: "mb-0", children: h.jsx("strong", { children: t.year }) }),
					h.jsx("p", { children: t.caption }),
					h.jsxs(Un, {
						to: `/tournaments/gallery/${(r = n.tournament) == null ? void 0 : r.systemName}/${
							n.mostRecentYear
						}`,
						className: (i) => ("nav-link" + i ? "active" : ""),
						children: [n.mostRecentYear, " Tournament Gallery"],
					}),
				],
			})
		},
		GTt = (e) => {
			const { eventDetail: t } = e,
				[n, r] = _.useState(!1),
				i = Wt(),
				{ data: a, isLoading: o } = UTt(t.tournament.id || ho)
			return h.jsx(ht, {
				loading: o,
				hide: !1,
				children: h.jsxs(gO, {
					doEdit: n,
					children: [
						i.canManageEvent() &&
							h.jsx(y7, {
								isEditting: n,
								openIcon: h.jsx(Ame, { size: 20, color: "warning" }),
								onToggled: () => r(!n),
							}),
						n &&
							h.jsx(WTt, {
								tournamentId: t.tournament.id,
								year: t.eventYear,
								onClose: () => r(!1),
							}),
						!n && h.jsx(YTt, { eventDetail: t, samplePhoto: new LA(a) }),
					],
				}),
			})
		},
		KTt = Bt({
			year: gi().required(),
			location: Oe().max(100).required(),
			winner: Oe().max(100).required(),
			winnerClub: Oe().max(100).required(),
			coWinner: Oe().max(100).nullable(),
			coWinnerClub: Oe().max(100).nullable(),
			flightOrDivision: Oe().max(20).required(),
			score: Oe().max(20),
			isNet: dd(),
			isMatch: dd(),
			notes: Oe().nullable(),
		}),
		yG = (e) => {
			const { winner: t, onClose: n } = e,
				[r, { isLoading: i }] = L0t(),
				[a, { isLoading: o }] = I0t(),
				s = async (l) => {
					const u = l.prepJson()
					await (t.id > 0 ? r(u) : a(u))
						.unwrap()
						.then(() => {
							je.success(`A tournament winner (${t.winner}) has been saved.`), n()
						})
						.catch((p) => {
							je.error(" " + p)
						})
				}
			return h.jsx(ht, {
				loading: o || i,
				children: h.jsx(Vt, {
					validationSchema: KTt,
					onSubmit: s,
					initialValues: t,
					children: ({
						handleSubmit: l,
						handleChange: u,
						handleBlur: d,
						values: p,
						touched: m,
						errors: v,
					}) =>
						h.jsxs(R, {
							noValidate: !0,
							onSubmit: l,
							children: [
								h.jsxs(R.Group, {
									controlId: "winner.year",
									children: [
										h.jsx(R.Label, { children: "Year" }),
										h.jsx(R.Control, {
											name: "year",
											value: p.year.toString(),
											isValid: m.year && !v.year,
											isInvalid: !!v.year,
											onChange: u,
											onBlur: d,
										}),
										h.jsx(R.Control.Feedback, { type: "invalid", children: v.year }),
									],
								}),
								h.jsxs(R.Group, {
									controlId: "winner.location",
									children: [
										h.jsx(R.Label, { children: "Location" }),
										h.jsx(R.Control, {
											name: "location",
											placeholder: "Location",
											value: p.location,
											isValid: m.location && !v.location,
											isInvalid: !!v.location,
											onChange: u,
											onBlur: d,
										}),
										h.jsx(R.Control.Feedback, { type: "invalid", children: v.location }),
									],
								}),
								h.jsxs(R.Group, {
									controlId: "winner.flightOrDivision",
									children: [
										h.jsx(R.Label, { children: "Flight/Division" }),
										h.jsx(R.Control, {
											name: "flightOrDivision",
											placeholder: "Flight/Division",
											value: p.flightOrDivision,
											isValid: m.flightOrDivision && !v.flightOrDivision,
											isInvalid: !!v.flightOrDivision,
											onChange: u,
											onBlur: d,
										}),
										h.jsx(R.Control.Feedback, { type: "invalid", children: v.flightOrDivision }),
									],
								}),
								h.jsxs(R.Group, {
									controlId: "winner.winner",
									children: [
										h.jsx(R.Label, { children: "Winner" }),
										h.jsx(R.Control, {
											name: "winner",
											placeholder: "Winner",
											value: p.winner,
											isValid: m.winner && !v.winner,
											isInvalid: !!v.winner,
											onChange: u,
											onBlur: d,
										}),
										h.jsx(R.Control.Feedback, { type: "invalid", children: v.winner }),
									],
								}),
								h.jsxs(R.Group, {
									controlId: "winner.winnerClub",
									children: [
										h.jsx(R.Label, { children: "Winner Club" }),
										h.jsx(R.Control, {
											name: "winnerClub",
											placeholder: "Winner's Club",
											value: p.winnerClub,
											isValid: m.winnerClub && !v.winnerClub,
											isInvalid: !!v.winnerClub,
											onChange: u,
											onBlur: d,
										}),
										h.jsx(R.Control.Feedback, { type: "invalid", children: v.winnerClub }),
									],
								}),
								h.jsxs(R.Group, {
									controlId: "winner.coWinner",
									children: [
										h.jsx(R.Label, { children: "Co-Winner (team events)" }),
										h.jsx(R.Control, {
											name: "coWinner",
											placeholder: "Co-Winner",
											value: p.coWinner,
											isValid: m.coWinner && !v.coWinner,
											isInvalid: !!v.coWinner,
											onChange: u,
											onBlur: d,
										}),
										h.jsx(R.Control.Feedback, { type: "invalid", children: v.coWinner }),
									],
								}),
								h.jsxs(R.Group, {
									controlId: "winner.coWinnerClub",
									children: [
										h.jsx(R.Label, { children: "Co-Winner Club" }),
										h.jsx(R.Control, {
											name: "coWinnerClub",
											placeholder: "Co-Winner's Club",
											value: p.coWinnerClub,
											isValid: m.coWinnerClub && !v.coWinnerClub,
											isInvalid: !!v.coWinnerClub,
											onChange: u,
											onBlur: d,
										}),
										h.jsx(R.Control.Feedback, { type: "invalid", children: v.coWinnerClub }),
									],
								}),
								h.jsxs(R.Group, {
									controlId: "winner.score",
									children: [
										h.jsx(R.Label, { children: "Score" }),
										h.jsx(R.Control, {
											name: "score",
											placeholder: "Score",
											value: p.score,
											isValid: m.score && !v.score,
											isInvalid: !!v.score,
											onChange: u,
											onBlur: d,
										}),
										h.jsx(R.Control.Feedback, { type: "invalid", children: v.score }),
									],
								}),
								h.jsx(R.Group, {
									controlId: "winner.isNet",
									children: h.jsx(R.Check, {
										type: "switch",
										name: "isNet",
										value: p.isNet.toString(),
										checked: p.isNet,
										label: "This is a net score",
										onChange: u,
									}),
								}),
								h.jsx(R.Group, {
									controlId: "winner.isMatch",
									children: h.jsx(R.Check, {
										type: "switch",
										name: "isMatch",
										value: p.isMatch.toString(),
										checked: p.isMatch,
										label: "Match play",
										onChange: u,
									}),
								}),
								h.jsxs(R.Group, {
									controlId: "winner.notes",
									children: [
										h.jsx(R.Label, { children: "Notes" }),
										h.jsx(_s, { name: "notes", value: p.notes, height: "240px" }),
									],
								}),
								h.jsx(lr, {}),
								h.jsx(br, { canCancel: !0, OnCancel: n }),
							],
						}),
				}),
			})
		},
		QTt = (e) => {
			const t = (r) =>
					h.jsxs("p", {
						className: "mb-0",
						children: [
							r.winner,
							" (",
							r.winnerClub,
							")",
							r.coWinner &&
								h.jsxs("span", { children: [" ", "/ ", r.coWinner, " (", r.coWinnerClub, ")"] }),
						],
					}),
				n = (r) =>
					r.isNet
						? h.jsxs("p", { children: ["Score: ", r.score, h.jsx("span", { children: "*" })] })
						: h.jsxs("p", { children: ["Score: ", r.score] })
			return h.jsxs(
				"div",
				{
					children: [
						h.jsx("h5", { className: "text-secondary", children: e.winner.flightOrDivision }),
						t(e.winner),
						n(e.winner),
					],
				},
				e.winner.id,
			)
		},
		e8 = (e) => {
			const { winner: t, edit: n, onClose: r } = e,
				i = Wt(),
				a = H.useRef(),
				o = () => {
					a.current.close(), r()
				}
			return h.jsx(Wr, {
				ref: a,
				initEdit: n,
				canEdit: i.canManageEvent(),
				viewComponent: h.jsx(QTt, { winner: t }),
				editComponent: h.jsx(yG, { winner: t, onClose: o }),
			})
		},
		XTt = (e) => {
			var l
			const { eventDetail: t } = e,
				n = Wt(),
				[r, i] = _.useState(!1),
				{ groups: a, isLoading: o } = QW(t.tournament.systemName, {
					selectFromResult: ({ data: u }) => ({
						groups:
							u == null
								? void 0
								: u.reduce((d, p) => {
										const m = d.find((v) => v.year === p.year)
										return (
											m
												? m.winners.push(new Au(p))
												: d.push({
														year: p.year,
														location: p.location,
														tournament: t.tournament,
														winners: [new Au(p)],
												  }),
											d
										)
								  }, []),
						isLoading: o,
					}),
				}),
				s =
					(a == null ? void 0 : a.length) > 0
						? a[0]
						: { year: t.eventYear - 1, location: "loading...", winners: [] }
			return h.jsxs(ht, {
				loading: o,
				hide: (a == null ? void 0 : a.length) === 0,
				children: [
					h.jsxs("h3", { className: "text-primary", children: [s.year, " Winners"] }),
					h.jsx("h4", { children: s.location }),
					s.winners.map((u) => h.jsx(e8, { edit: !1, winner: u, onClose: () => i(!1) }, u.id)),
					r &&
						h.jsx(
							e8,
							{
								edit: !0,
								winner: new Au({
									tournament: t.tournament.id,
									year: t.eventYear,
									location: t.location.name,
								}),
								onClose: () => i(!1),
							},
							0,
						),
					h.jsx("p", { children: "* Net Score" }),
					n.canManageEvent() &&
						h.jsx(Ge, {
							variant: "link",
							className: "text-warning",
							onClick: () => i(!0),
							children: "New Winner",
						}),
					h.jsx(Un, {
						to: `/tournaments/history/${(l = t.tournament) == null ? void 0 : l.systemName}`,
						className: (u) => ("nav-link" + u ? "active" : ""),
						children: "Championship History",
					}),
				],
			})
		},
		JTt = () => {
			const { name: e, year: t } = Sl(),
				{ eventDetail: n, isLoading: r } = AY(
					{ name: e, year: +t },
					{
						selectFromResult: ({ data: i }) => ({
							eventDetail: i ? new Ip(i) : Ip.CreateDefault(),
							isLoading: r,
						}),
					},
				)
			return h.jsx(ii, {
				fluid: !0,
				children: h.jsx(ht, {
					loading: r,
					children: h.jsx(Ybt, {
						LeftColumn: h.jsx(uxt, { eventDetail: n }),
						RightColumn: h.jsxs(H.Fragment, {
							children: [
								h.jsx(FTt, { eventDetail: n }),
								h.jsx(XTt, { eventDetail: n }),
								h.jsx(GTt, { eventDetail: n }),
							],
						}),
					}),
				}),
			})
		},
		ZTt = Bt({ name: Oe().max(30).required(), title: Oe().max(120).required() }),
		ekt = (e) => {
			const { policy: t, onClose: n } = e,
				[r, i] = _.useState(!1),
				[a, { isLoading: o }] = ave(),
				[s, { isLoading: l }] = cve(),
				[u, { isLoading: d }] = ove(),
				p = o || l || d,
				m = () => {
					i(!1)
				},
				v = async () => {
					i(!1)
					const b = t.prepJson()
					await u(b)
						.unwrap()
						.then(() => {
							je.success(`${t.name} has been removed.`), n()
						})
						.catch((x) => {
							je.error(" " + x)
						})
				},
				y = async (b) => {
					const x = b.prepJson()
					await (x.id > 0 ? s(x) : a(x))
						.unwrap()
						.then(() => {
							je.success(`${b.name} has been saved.`), n()
						})
						.catch((T) => {
							je.error(" " + T)
						})
				}
			return h.jsxs("div", {
				children: [
					h.jsx(cg, { loading: p }),
					h.jsx(Vt, {
						validationSchema: ZTt,
						onSubmit: y,
						initialValues: t,
						children: ({
							handleSubmit: b,
							handleChange: x,
							handleBlur: E,
							values: T,
							touched: C,
							errors: D,
						}) =>
							h.jsxs(R, {
								noValidate: !0,
								onSubmit: b,
								children: [
									h.jsxs(R.Group, {
										controlId: "policy.Name",
										children: [
											h.jsx(R.Label, { children: "Name" }),
											h.jsx(R.Control, {
												name: "name",
												placeholder: "Unique policy name",
												value: T.name,
												isValid: C.name && !D.name,
												isInvalid: !!D.name,
												onChange: x,
												onBlur: E,
											}),
											h.jsx(R.Control.Feedback, { type: "invalid", children: D.name }),
											h.jsx(R.Text, {
												className: "text-muted",
												children: "This name is not displayed on the website",
											}),
										],
									}),
									h.jsxs(R.Group, {
										controlId: "policy.Title",
										children: [
											h.jsx(R.Label, { children: "Title" }),
											h.jsx(R.Control, {
												name: "title",
												placeholder: "Title",
												value: T.title,
												isValid: C.title && !D.title,
												isInvalid: !!D.title,
												onChange: x,
												onBlur: E,
											}),
											h.jsx(R.Control.Feedback, { type: "invalid", children: D.title }),
										],
									}),
									h.jsxs(R.Group, {
										controlId: "policy.Description",
										children: [
											h.jsx(R.Label, { children: "Description" }),
											h.jsx(_s, { name: "description", value: T.description, height: "240px" }),
										],
									}),
									h.jsx(lr, {}),
									h.jsx(jd, { canDelete: t.id !== 0, OnDelete: () => i(!0) }),
									h.jsx(br, { canCancel: !0, OnCancel: n }),
								],
							}),
					}),
					h.jsx(Pd, {
						show: r,
						titleText: "Delete Policy?",
						messageText: "Please confirm that we should delete this policy.",
						confirmText: "Delete Policy",
						DoCancel: m,
						DoConfirm: v,
					}),
				],
			})
		},
		tkt = (e) => {
			const { policy: t } = e
			return h.jsxs("div", {
				children: [
					h.jsx("h5", { className: "text-secondary", children: t.title }),
					h.jsx(tc, { text: t.description }),
				],
			})
		},
		t8 = (e) => {
			const { policy: t, edit: n, onClose: r } = e,
				i = Wt(),
				a = _.useRef(),
				o = () => {
					var s
					;(s = a.current) == null || s.close(), r()
				}
			return h.jsx(Wr, {
				ref: a,
				initEdit: n,
				canEdit: i.canEditPolicies(),
				viewComponent: h.jsx(tkt, { policy: t }),
				editComponent: h.jsx(ekt, { policy: t, onClose: o }),
			})
		},
		$v = (e) => {
			const { policyCode: t } = e,
				[n, r] = _.useState(!1),
				i = Wt(),
				{ data: a, isLoading: o } = lve(t)
			return h.jsxs("div", {
				children: [
					h.jsx(cg, { loading: o }),
					i.canEditPolicies() &&
						h.jsx(Ge, {
							variant: "link",
							className: "text-warning",
							onClick: () => r(!0),
							children: "Add New",
						}),
					n && h.jsx(t8, { policy: new g2({ id: 0 }), edit: !0, onClose: () => r(!1) }, 0),
					a == null
						? void 0
						: a.map((s) => h.jsx(t8, { policy: new g2(s), edit: !1, onClose: () => r(!1) }, s.id)),
				],
			})
		},
		nkt = () => {
			const e = { key: "hard-card", documentTypes: ["Hard Card"] }
			return h.jsx(ii, {
				fluid: !0,
				children: h.jsxs(ug, {
					children: [
						h.jsx("h4", { className: "text-primary mb-2", children: "MPGA Terms of Competition" }),
						h.jsx(Iw, { query: e }),
						h.jsxs("p", {
							children: [
								"Minnesota Public Golf Association (MPGA) tournament play is governed by the Rules of Golf and by the following Terms of Competition and Definitions. Any changes or additions to these will be supplied on a Notice to Players and/or supplemental Local Rules sheet at the specific championship site. Unless otherwise noted, the penalty for the breach of a Local Rule or Condition is the ",
								h.jsx("strong", { children: "General Penalty" }),
								":",
							],
						}),
						h.jsxs("ul", {
							children: [
								h.jsx("li", { children: "Match Play: Loss of hole" }),
								h.jsx("li", { children: "Stroke Play: Two strokes" }),
							],
						}),
						h.jsx($v, { policyCode: Pi.LocalRule }),
						h.jsx("div", {
							style: { paddingLeft: "60px", paddingRight: "60px", textAlign: "center" },
							children: h.jsx("p", {
								children: h.jsx("strong", {
									children:
										"The Minnesota Public Golf Association has adopted the Terms of Competition (with minor adjustments) as authorized by the Minnesota Golf Associations Rules & Competitions and Executive Committees",
								}),
							}),
						}),
					],
				}),
			})
		},
		ox = class ox extends _n {
			constructor(n) {
				super()
				q(this, "title", "")
				q(this, "text", "")
				q(this, "starts", new Date())
				q(this, "expires", new Date())
				q(this, "externalUrl")
				q(this, "externalName")
				q(this, "event")
				q(this, "document")
				q(this, "toJson", () => {
					var n
					return {
						title: this.title,
						text: this.text,
						starts: this.starts,
						expires: this.expires,
						external_url: this.externalUrl,
						external_name: this.externalName,
						document: (n = this.document) == null ? void 0 : n.id,
						event: this.event,
					}
				})
				const r = super.fromJson(n)
				;(r.starts = new Date(n.starts)),
					(r.expires = new Date(n.expires)),
					(r.document = new zu(n.document)),
					Object.assign(this, r)
			}
		}
	q(
		ox,
		"Create",
		() =>
			new ox({
				id: 0,
				title: "",
				text: "",
				starts: Te().toDate(),
				expires: Te().add(7, "days").toDate(),
			}),
	)
	let Uv = ox
	const rkt = Ui.injectEndpoints({
			endpoints: (e) => ({
				getAnnouncements: e.query({
					query: () => ({ url: "/announcements/", method: "GET" }),
					providesTags: (t) =>
						t
							? [
									...t.map(({ id: n }) => ({ type: "Announcements", id: n })),
									{ type: "Announcements", id: "LIST" },
							  ]
							: [{ type: "Announcements", id: "LIST" }],
				}),
				updateAnnouncement: e.mutation({
					query(t) {
						const { id: n } = t
						return { url: `/announcements/${n}/`, method: "PUT", data: t }
					},
					invalidatesTags: (t, n, { id: r }) => [{ type: "Announcements", id: r }],
				}),
				addAnnouncement: e.mutation({
					query(t) {
						return { url: "/announcements/", method: "POST", data: t }
					},
					invalidatesTags: [{ type: "Announcements", id: "LIST" }],
				}),
				deleteAnnouncement: e.mutation({
					query(t) {
						const { id: n } = t
						return { url: `/announcements/${n}/`, method: "DELETE" }
					},
					invalidatesTags: (t, n, { id: r }) => [{ type: "Announcements", id: r }],
				}),
				sendMessage: e.mutation({
					query(t) {
						return { url: "/messages/", method: "POST", data: t }
					},
				}),
			}),
		}),
		{
			useGetAnnouncementsQuery: ikt,
			useAddAnnouncementMutation: akt,
			useUpdateAnnouncementMutation: okt,
			useDeleteAnnouncementMutation: t2t,
		} = rkt,
		skt = Bt({
			title: Oe().required(),
			starts: Fu().required(),
			expires: Fu().required(),
			documentId: Oe().nullable(),
			externalUrl: Oe().url().nullable(),
			externalName: Oe().when("externalUrl", ([e], t) =>
				e ? t.required("a display name is required for the url") : t.notRequired(),
			),
		}),
		lkt = (e) => {
			var p, m
			const { announcement: t, documents: n, onClose: r } = e,
				[i, { isLoading: a }] = akt(),
				[o, { isLoading: s }] = okt(),
				l = a || s,
				u = {
					title: t.title,
					text: t.text,
					starts: t.starts,
					expires: t.expires,
					externalUrl: t.externalUrl,
					externalName: t.externalName,
					event: t.event,
					document: (m = (p = t.document) == null ? void 0 : p.id) == null ? void 0 : m.toString(),
				},
				d = async (v, y) => {
					const b = v.prepJson()
					;(b.document = y == null ? void 0 : y.id),
						await (v.id > 0 ? o(b) : i(b))
							.unwrap()
							.then(() => {
								je.success(`${v.title} has been saved.`), r()
							})
							.catch((E) => {
								je.error(" " + E)
							})
				}
			return h.jsx(ht, {
				loading: l,
				children: h.jsx(Vt, {
					validationSchema: skt,
					onSubmit: (v) => {
						const y = new Uv(v),
							b = n.find((x) => {
								var E
								return ((E = x.id) == null ? void 0 : E.toString()) === v.document
							})
						;(y.id = t.id), d(y, b)
					},
					initialValues: u,
					children: ({
						handleSubmit: v,
						setFieldValue: y,
						handleChange: b,
						handleBlur: x,
						values: E,
						touched: T,
						errors: C,
					}) =>
						h.jsxs(R, {
							noValidate: !0,
							onSubmit: v,
							children: [
								h.jsxs(R.Group, {
									controlId: "announcement.Title",
									children: [
										h.jsx(R.Label, { children: "Title" }),
										h.jsx(R.Control, {
											placeholder: "Announcement title",
											name: "title",
											value: E.title,
											isValid: T.title && !C.title,
											isInvalid: !!C.title,
											onChange: b,
											onBlur: x,
										}),
										h.jsx(R.Control.Feedback, { type: "invalid", children: C.title }),
									],
								}),
								h.jsxs(R.Group, {
									controlId: "description",
									children: [
										h.jsx(R.Label, { children: "Text" }),
										h.jsx(_s, { name: "text", value: E.text, height: "300px" }),
									],
								}),
								h.jsxs(R.Group, {
									controlId: "announcement.Starts",
									children: [
										h.jsx(R.Label, { className: "full-width", children: "Display Start" }),
										h.jsx($p, {
											name: "starts",
											value: E.starts,
											onChange: y,
											onBlur: x,
											showTimeSelect: !0,
											timeFormat: "HH:mm",
											timeIntervals: 60,
											timeCaption: "Time",
											dateFormat: "yyyy-MM-dd h:mm aa",
										}),
										h.jsx(R.Control.Feedback, {
											type: "invalid",
											children: h.jsx(h.Fragment, { children: C.starts }),
										}),
										h.jsx(R.Text, {
											className: "text-muted",
											children: "Message is visible starting on this date.",
										}),
									],
								}),
								h.jsxs(R.Group, {
									controlId: "announcement.Expires",
									children: [
										h.jsx(R.Label, { className: "full-width", children: "Expires" }),
										h.jsx($p, {
											name: "expires",
											value: E.expires,
											onChange: y,
											onBlur: x,
											showTimeSelect: !0,
											timeFormat: "HH:mm",
											timeIntervals: 60,
											timeCaption: "Time",
											dateFormat: "yyyy-MM-dd h:mm aa",
										}),
										h.jsx(R.Control.Feedback, {
											type: "invalid",
											children: h.jsx(h.Fragment, { children: C.expires }),
										}),
										h.jsx(R.Text, {
											className: "text-muted",
											children: "Message is no longer visible after this date.",
										}),
									],
								}),
								h.jsxs(R.Group, {
									controlId: "document",
									children: [
										h.jsx(R.Label, { children: "Attach a Document (optional)" }),
										h.jsxs(R.Control, {
											as: "select",
											name: "document",
											value: E.document || "",
											onChange: b,
											onBlur: x,
											children: [
												h.jsx("option", { value: void 0 }),
												e.documents.map((D) =>
													h.jsx("option", { value: D.id, children: D.title }, D.id),
												),
											],
										}),
									],
								}),
								h.jsxs(R.Group, {
									controlId: "announcement.ExternalUrl",
									children: [
										h.jsx(R.Label, { children: "Link (optional)" }),
										h.jsx(R.Control, {
											type: "url",
											placeholder: "Url",
											name: "externalUrl",
											value: E.externalUrl,
											isValid: T.externalUrl && !C.externalUrl,
											isInvalid: !!C.externalUrl,
											onChange: b,
											onBlur: x,
										}),
										h.jsx(R.Control.Feedback, { type: "invalid", children: C.externalUrl }),
									],
								}),
								h.jsxs(R.Group, {
									controlId: "announcement.ExternalName",
									children: [
										h.jsx(R.Label, { children: "Link name (optional)" }),
										h.jsx(R.Control, {
											placeholder: "Display name for url",
											name: "externalName",
											value: E.externalName,
											isValid: T.externalName && !C.externalName,
											isInvalid: !!C.externalName,
											onChange: b,
											onBlur: x,
										}),
										h.jsx(R.Control.Feedback, { type: "invalid", children: C.externalName }),
									],
								}),
								h.jsx(lr, {}),
								h.jsx(br, { canCancel: !0, OnCancel: r }),
							],
						}),
				}),
			})
		},
		ukt = (e) => {
			const t = e.announcement
			return h.jsxs("div", {
				children: [
					h.jsx("h5", { className: "text-secondary", children: t.title }),
					h.jsx(tc, { text: t.text }),
					t.externalUrl && h.jsx("a", { href: t.externalUrl, children: t.externalName }),
					t.document && h.jsx("a", { href: t.document.file, children: t.document.title }),
				],
			})
		},
		n8 = (e) => {
			const { announcement: t, documents: n, edit: r, onClose: i } = e,
				a = Wt(),
				o = _.useRef(),
				s = () => {
					o.current.close(), i()
				}
			return h.jsx(Wr, {
				ref: o,
				initEdit: r,
				canEdit: a.canEditAnnouncements(),
				viewComponent: h.jsx(ukt, { announcement: t }),
				editComponent: h.jsx(lkt, { announcement: t, documents: n, onClose: s }),
			})
		},
		ckt = () => {
			const [e, t] = H.useState(!1),
				n = Wt(),
				{ data: r, isLoading: i } = ikt(),
				{ documents: a, docsLoading: o } = sh(
					{ key: "current-documents", year: lt.EventCalendarYear },
					{
						selectFromResult: ({ data: l, isLoading: u }) => ({
							documents: (l == null ? void 0 : l.map((d) => new zu(d))) || [],
							docsLoading: u,
						}),
					},
				),
				s = () =>
					new Uv({ id: 0, starts: new Date().toISOString(), expires: new Date().toISOString() })
			return h.jsxs(ht, {
				loading: i || o,
				children: [
					h.jsx("h3", { className: "text-primary", children: "MPGA News" }),
					n.canEditAnnouncements() &&
						!e &&
						h.jsx(Ge, {
							variant: "link",
							className: "text-warning",
							disabled: e,
							onClick: () => t(!0),
							children: "Add Announcement",
						}),
					e && h.jsx(n8, { announcement: s(), edit: !0, documents: a, onClose: () => t(!1) }, 0),
					r == null
						? void 0
						: r.map((l) =>
								h.jsx(
									n8,
									{ announcement: new Uv(l), edit: !1, documents: a, onClose: () => t(!1) },
									l.id,
								),
						  ),
				],
			})
		},
		bG = Ft.div`
  cursor: pointer;
  margin-bottom: 25px;
  img {
    width: 60px;
    height: 60px;
    background-size: contain;
    object-fit: scale-down;
    float: left;
  }
  p {
    float: none;
    margin: 0px 0px 0px 80px;
  }
`
	bG.displayName = "CalendarItem"
	const dkt = (e) => {
			var r, i
			const { eventDetail: t, onSelect: n } = e
			return h.jsxs(bG, {
				onClick: () => n(t.tournament.systemName),
				children: [
					((r = t.location) == null ? void 0 : r.logoUrl) &&
						h.jsx("img", { src: t.location.logoUrl, alt: t.location.name }),
					h.jsx("p", {
						className: "text-secondary",
						children: h.jsx("strong", { children: (i = t.tournament) == null ? void 0 : i.name }),
					}),
					h.jsx("p", { children: t.location.name }),
					t.eventType === "P" &&
						h.jsx("p", { className: "text-danger", children: "POSTPONED: new date is TBD" }),
					t.eventType === "C" && h.jsx("p", { className: "text-danger", children: "CANCELED" }),
					t.eventType !== "P" && t.eventType !== "C" && h.jsx("p", { children: t.eventDates }),
				],
			})
		},
		fkt = () => {
			const { data: e, isLoading: t } = NY(lt.EventCalendarYear),
				n = Xa(),
				r = (i) => {
					const a = { pathname: "/tournaments/", hash: `#${i}` }
					n(a)
				}
			return h.jsxs("div", {
				children: [
					h.jsxs("h3", {
						className: "text-primary mb-3",
						children: [lt.EventCalendarYear, " Tournament Calendar"],
					}),
					h.jsx(ht, {
						loading: t,
						children:
							e == null
								? void 0
								: e
										.map((i) => new Ip(i))
										.map((i) => h.jsx(dkt, { eventDetail: i, onSelect: r }, i.id)),
					}),
				],
			})
		},
		r8 = () =>
			h.jsx(ii, {
				fluid: !0,
				children: h.jsxs(ln, {
					children: [
						h.jsxs(it, {
							sm: 12,
							md: 5,
							children: [h.jsx(Rl, { pageCode: Rn.Home }), h.jsx($v, { policyCode: Pi.AboutUs })],
						}),
						h.jsx(it, { sm: 12, md: 4, children: h.jsx(ckt, {}) }),
						h.jsx(it, { sm: 12, md: 3, children: h.jsx(fkt, {}) }),
					],
				}),
			}),
		pkt = (e) => {
			const { show: t, winner: n, onClose: r } = e
			return h.jsxs(Or, {
				show: t,
				onHide: r,
				children: [
					h.jsx(Or.Header, {
						closeButton: !0,
						children: h.jsx(Or.Title, { children: "Tournament Champion Form" }),
					}),
					h.jsx(Or.Body, { children: h.jsx(yG, { winner: n || new Au({ id: 0 }), onClose: r }) }),
				],
			})
		},
		hkt = (e) => {
			const { winner: t, onEdit: n } = e,
				r = Wt(),
				[i, a] = _.useState(!1)
			return h.jsxs(H.Fragment, {
				children: [
					h.jsxs("tr", {
						children: [
							h.jsx("td", { children: t.year }),
							h.jsx("td", { children: t.location }),
							h.jsx("td", { children: t.flightOrDivision }),
							h.jsx("td", { children: t.winnersFormatted }),
							h.jsx("td", { children: t.scoreFormatted }),
							h.jsx("td", {
								className: "clickable text-secondary",
								onClick: () => a(!i),
								children: t.notes && h.jsx(mO, { size: 18, color: "primary" }),
							}),
							r.canEditTournamentHistory()
								? h.jsx("td", {
										className: "clickable text-warning",
										onClick: () => n(t),
										children: h.jsx(nb, { size: 18, color: "warning" }),
								  })
								: null,
						],
					}),
					t.notes && i
						? h.jsx("tr", {
								children: h.jsx("td", {
									colSpan: r.canEditTournamentHistory() ? 7 : 6,
									children: h.jsx(Rw, { children: t.notes }),
								}),
						  })
						: null,
				],
			})
		},
		mkt = (e) => {
			const { group: t, onEdit: n } = e
			return h.jsx(H.Fragment, {
				children: t.winners.map((r) => h.jsx(hkt, { winner: r, onEdit: n }, r.id)),
			})
		},
		xG = (e) => {
			const { tournament: t } = e,
				[n, r] = _.useState(!1),
				[i, a] = _.useState(),
				o = Wt(),
				{ groups: s, isLoading: l } = QW(t.systemName, {
					selectFromResult: ({ data: p }) => ({
						groups:
							p == null
								? void 0
								: p.reduce((m, v) => {
										const y = m.find((b) => b.year === v.year)
										return (
											y
												? y.winners.push(new Au(v))
												: m.push({
														year: v.year,
														location: v.location,
														tournament: t,
														winners: [new Au(v)],
												  }),
											m
										)
								  }, []),
						isLoading: l,
					}),
				}),
				u = () => {
					r(!1)
				},
				d = (p) => {
					a(p || new Au({ id: 0, tournament: t.id })), r(!0)
				}
			return h.jsxs(H.Fragment, {
				children: [
					h.jsxs("h3", { className: "text-primary mb-2", children: [t.name, " History"] }),
					h.jsxs(ht, {
						loading: l,
						children: [
							o.canEditTournamentHistory() &&
								h.jsx(Ge, {
									variant: "link",
									className: "text-warning",
									onClick: () => d(),
									children: "Add New Champion",
								}),
							h.jsxs(nc, {
								striped: !0,
								size: "sm",
								children: [
									h.jsx("thead", {
										children: h.jsxs("tr", {
											children: [
												h.jsx("th", { children: "Year" }),
												h.jsx("th", { children: "Location" }),
												h.jsx("th", { children: "Division/Flight" }),
												h.jsx("th", { children: "Champion" }),
												h.jsx("th", { children: "Score" }),
												h.jsx("th", { children: "Notes" }),
												o.canEditTournamentHistory() ? h.jsx("th", { children: "Edit" }) : null,
											],
										}),
									}),
									h.jsx("tbody", {
										children: s
											? s.map((p, m) => h.jsx(mkt, { group: p, onEdit: (v) => d(v) }, m))
											: null,
									}),
								],
							}),
							h.jsx(pkt, { show: n, winner: i, onClose: u }),
						],
					}),
				],
			})
		},
		vkt = () => {
			const { data: e, isLoading: t } = FA("match-play")
			return h.jsx(ii, {
				fluid: !0,
				children: h.jsx(ug, {
					children: h.jsx(ht, { loading: t, children: h.jsx(xG, { tournament: new Mp(e) }) }),
				}),
			})
		},
		wG = (e) =>
			h.jsxs(ln, {
				children: [
					h.jsx(it, { md: 6, lg: 4, children: e.LeftColumn }),
					h.jsx(it, { md: 6, lg: 8, children: e.RightColumn }),
				],
			}),
		gkt = Ui.injectEndpoints({
			endpoints: (e) => ({
				getTeams: e.query({
					query: () => ({ url: `/teams/?year=${lt.MatchPlayYear}`, method: "GET" }),
				}),
				getMatchResults: e.query({
					query: () => ({ url: `/match-results/?year=${lt.MatchPlayYear}`, method: "GET" }),
					providesTags: (t) =>
						t
							? [
									...t.map(({ id: n }) => ({ type: "MatchPlayResults", id: n })),
									{ type: "MatchPlayResults", id: "LIST" },
							  ]
							: [{ type: "MatchPlayResults", id: "LIST" }],
				}),
				addMatchResult: e.mutation({
					query(t) {
						return { url: "/match-results/", method: "POST", data: t }
					},
					invalidatesTags: (t, n, { id: r }) => [
						{ type: "MatchPlayResults", id: r },
						{ type: "MatchPlayResults", id: "LIST" },
					],
				}),
			}),
		}),
		{ useGetTeamsQuery: EG, useGetMatchResultsQuery: ykt, useAddMatchResultMutation: bkt } = gkt,
		xkt = (e) => {
			const { captains: t } = e
			return h.jsx(ln, {
				children: t.map((n) => {
					var r, i, a, o, s, l
					return h.jsxs(
						it,
						{
							className: "pl-1",
							children: [
								h.jsx("p", {
									className: "mb-0",
									children: h.jsxs("strong", {
										children: [
											(r = n.contact) == null ? void 0 : r.firstName,
											" ",
											(i = n.contact) == null ? void 0 : i.lastName,
										],
									}),
								}),
								h.jsx("p", {
									className: "mb-0",
									children: (a = n.contact) == null ? void 0 : a.email,
								}),
								h.jsxs("p", {
									className: "mb-0",
									children: [
										(o = n.contact) == null ? void 0 : o.primaryPhone,
										((s = n.contact) == null ? void 0 : s.alternatePhone) &&
											h.jsxs("span", {
												children: [" / ", (l = n.contact) == null ? void 0 : l.alternatePhone],
											}),
									],
								}),
								n.notes &&
									h.jsx("p", { className: "mb-0", children: h.jsx(Rw, { children: n.notes }) }),
							],
						},
						n.id,
					)
				}),
			})
		},
		wkt = (e) => {
			var i
			const { team: t } = e,
				[n, r] = _.useState(!1)
			return h.jsxs(H.Fragment, {
				children: [
					h.jsxs("tr", {
						children: [
							h.jsx("td", {
								style: { borderTop: e.addSpace ? "4px solid #bcc0c4" : "1px solid #dee2e6" },
								children: t.isSenior ? "Sr." : "",
							}),
							h.jsx("td", {
								style: { borderTop: e.addSpace ? "4px solid #bcc0c4" : "1px solid #dee2e6" },
								children: t.groupName,
							}),
							h.jsx("td", {
								style: { borderTop: e.addSpace ? "4px solid #bcc0c4" : "1px solid #dee2e6" },
								children: (i = t.club) == null ? void 0 : i.name,
							}),
							h.jsx("td", {
								style: { borderTop: e.addSpace ? "4px solid #bcc0c4" : "1px solid #dee2e6" },
								children: h.jsx(Ge, {
									variant: "link",
									className: "text-info pb-0 pt-0",
									onClick: () => r(!n),
									children: t.captainNames(t.isSenior),
								}),
							}),
						],
					}),
					t.captains(t.isSenior) &&
						n &&
						h.jsxs("tr", {
							children: [
								h.jsx("td", { colSpan: 3 }),
								h.jsx("td", { children: h.jsx(xkt, { captains: t.captains(t.isSenior) }) }),
							],
						}),
				],
			})
		},
		Ekt = Ft.a`
  margin: 0;
  cursor: pointer;
`
	Ekt.displayName = "FilterButton"
	const CG = Ft.th`
  min-width: 120px;
  max-width: 150px;
`
	CG.displayName = "GroupColumn"
	function Ckt() {
		const { teams: e, isLoading: t } = EG(void 0, {
			selectFromResult: ({ data: r }) => ({
				teams: (r == null ? void 0 : r.map((i) => new m9(i))) || [],
				isLoading: t,
			}),
		})
		let n = ""
		return h.jsx(ht, {
			loading: t,
			children: h.jsxs(nc, {
				striped: !0,
				size: "sm",
				children: [
					h.jsx("thead", {
						children: h.jsxs("tr", {
							children: [
								h.jsx("th", {}),
								h.jsx(CG, { children: "Group" }),
								h.jsx("th", { children: "Club" }),
								h.jsx("th", { children: "Captain(s)" }),
							],
						}),
					}),
					h.jsx("tbody", {
						children:
							e == null
								? void 0
								: e.map((r) => {
										const i = n !== "" && r.groupName !== n
										return (n = r.groupName), h.jsx(wkt, { team: r, addSpace: i }, r.id)
								  }),
					}),
				],
			}),
		})
	}
	const Tkt = () =>
			h.jsx(wG, {
				LeftColumn: h.jsx(Rl, { pageCode: Rn.MatchPlay }),
				RightColumn: h.jsxs(H.Fragment, {
					children: [
						h.jsxs("h3", {
							className: "text-primary",
							children: [lt.MatchPlayYear, " Match Play Teams"],
						}),
						h.jsx("div", {}),
						h.jsx(Ckt, {}),
					],
				}),
			}),
		kkt = () => {
			const t = {
					key: "match-play",
					documentTypes: ["Match Play", "Match Play Brackets"],
					year: lt.MatchPlayYear,
				},
				{ data: n, isLoading: r } = sh(t),
				i = { viewType: Ou.Button, variant: "outline-secondary", external: !0 }
			return h.jsx(ht, { loading: r, children: h.jsx(Mw, { documents: n || [], render: i }) })
		},
		Skt = Bt({
			matchDate: Fu().required(),
			groupName: Oe().max(20).required(),
			homeTeam: gi().required(),
			homeTeamScore: gi().required(),
			awayTeam: gi().required(),
			awayTeamScore: gi().required(),
			forfeit: dd(),
			notes: Oe().max(140),
		}),
		Dkt = (e) => {
			const { result: t, onClose: n } = e,
				{ user: r } = ks(),
				{ teams: i } = EG(void 0, {
					selectFromResult: ({ data: u }) => ({
						teams: (u == null ? void 0 : u.map((d) => new m9(d))) || [],
					}),
				}),
				[a, { isLoading: o }] = bkt(),
				s = new Set((i == null ? void 0 : i.map((u) => u.groupName)) || []),
				l = async (u) => {
					const d = u.prepJson()
					;(d.match_date = d.match_date.substring(0, 10)),
						(d.entered_by = r.email),
						await a(d)
							.unwrap()
							.then(() => {
								je.success("Match results have been saved. Thank you!"), n()
							})
							.catch((p) => {
								je.error(" Something went wrong " + p)
							})
				}
			return h.jsx(ht, {
				loading: o,
				children: h.jsx(Vt, {
					validationSchema: Skt,
					onSubmit: l,
					initialValues: t,
					children: ({
						handleSubmit: u,
						setFieldValue: d,
						handleChange: p,
						handleBlur: m,
						values: v,
						touched: y,
						errors: b,
					}) =>
						h.jsxs(R, {
							noValidate: !0,
							onSubmit: u,
							children: [
								h.jsxs(R.Group, {
									controlId: "matchDate",
									children: [
										h.jsx(R.Label, { children: "Match Date" }),
										h.jsx("br", {}),
										h.jsx($p, {
											name: "matchDate",
											className: "full-width",
											value: v.matchDate,
											onChange: d,
											onBlur: m,
											dateFormat: "MMM dd",
										}),
										h.jsx(R.Control.Feedback, {
											type: "invalid",
											children: h.jsx(h.Fragment, { children: b.matchDate }),
										}),
									],
								}),
								h.jsxs(R.Group, {
									controlId: "groupName",
									children: [
										h.jsx(R.Label, { children: "Group" }),
										h.jsxs(R.Control, {
											as: "select",
											name: "groupName",
											value: v.groupName,
											isValid: y.groupName && !b.groupName,
											isInvalid: !!b.groupName,
											onChange: p,
											onBlur: m,
											children: [
												h.jsx("option", { value: void 0, children: "--Select a Group--" }),
												[...s].map((x, E) => h.jsx("option", { value: x, children: x }, E)),
											],
										}),
										h.jsx(R.Control.Feedback, { type: "invalid", children: b.groupName }),
									],
								}),
								h.jsxs(R.Group, {
									controlId: "homeTeam",
									children: [
										h.jsx(R.Label, { children: "Home Team" }),
										h.jsxs(R.Control, {
											as: "select",
											name: "homeTeam",
											value: v.homeTeam.toString(),
											isValid: y.homeTeam && !b.homeTeam,
											isInvalid: !!b.homeTeam,
											onChange: p,
											onBlur: m,
											children: [
												h.jsx("option", { value: void 0, children: "--Home Team--" }),
												i
													.filter((x) => x.groupName === v.groupName)
													.map((x) =>
														h.jsx("option", { value: x.club.id, children: x.club.name }, x.id),
													),
											],
										}),
										h.jsx(R.Control.Feedback, { type: "invalid", children: b.groupName }),
									],
								}),
								h.jsxs(R.Group, {
									controlId: "homeTeamScore",
									children: [
										h.jsx(R.Label, { children: "Home Team Score" }),
										h.jsx(R.Control, {
											name: "homeTeamScore",
											value: v.homeTeamScore.toString(),
											isValid: y.homeTeamScore && !b.homeTeamScore,
											isInvalid: !!b.homeTeamScore,
											onChange: p,
											onBlur: m,
										}),
										h.jsx(R.Control.Feedback, { type: "invalid", children: b.homeTeamScore }),
									],
								}),
								h.jsxs(R.Group, {
									controlId: "awayTeam",
									children: [
										h.jsx(R.Label, { children: "Away Team" }),
										h.jsxs(R.Control, {
											as: "select",
											name: "awayTeam",
											value: v.awayTeam.toString(),
											isValid: y.awayTeam && !b.awayTeam,
											isInvalid: !!b.awayTeam,
											onChange: p,
											onBlur: m,
											children: [
												h.jsx("option", { value: void 0, children: "--Away Team--" }),
												i
													.filter((x) => x.groupName === v.groupName)
													.map((x) =>
														h.jsx("option", { value: x.club.id, children: x.club.name }, x.id),
													),
											],
										}),
										h.jsx(R.Control.Feedback, { type: "invalid", children: b.groupName }),
									],
								}),
								h.jsxs(R.Group, {
									controlId: "awayTeamScore",
									children: [
										h.jsx(R.Label, { children: "Away Team Score" }),
										h.jsx(R.Control, {
											name: "awayTeamScore",
											value: v.awayTeamScore.toString(),
											isValid: y.awayTeamScore && !b.awayTeamScore,
											isInvalid: !!b.awayTeamScore,
											onChange: p,
											onBlur: m,
										}),
										h.jsx(R.Control.Feedback, { type: "invalid", children: b.awayTeamScore }),
									],
								}),
								h.jsx(R.Group, {
									controlId: "forfeit",
									children: h.jsx(R.Check, {
										type: "switch",
										name: "forfeit",
										value: v.forfeit.toString(),
										label: "Match was a forfeit",
										onChange: p,
									}),
								}),
								h.jsxs(R.Group, {
									controlId: "notes",
									children: [
										h.jsx(R.Label, { children: "Notes" }),
										h.jsx(R.Control, {
											as: "textarea",
											rows: 3,
											name: "notes",
											placeholder: "Notes",
											value: v.notes,
											isValid: y.notes && !b.notes,
											isInvalid: !!b.notes,
											onChange: p,
											onBlur: m,
										}),
										h.jsx(R.Control.Feedback, { type: "invalid", children: b.notes }),
									],
								}),
								h.jsx(lr, {}),
								h.jsx(br, { canCancel: !0, OnCancel: n }),
							],
						}),
				}),
			})
		},
		_kt = () => {
			const [e, t] = _.useState(!1),
				n = Wt(),
				r = Xa(),
				i = Ea(),
				a = ki(),
				o = () => {
					a(dB(i.pathname)), r("/account/register")
				}
			return h.jsx(H.Fragment, {
				children: h.jsx(b7, {
					doEdit: e,
					hideEdit: !0,
					canEdit: n.canPostMatchResult(),
					onToggleEdit: () => t(!e),
					viewComponent: h.jsxs(H.Fragment, {
						children: [
							n.canPostMatchResult() &&
								h.jsx(Ge, {
									variant: "secondary",
									size: "lg",
									onClick: () => t(!0),
									children: "Post Result",
								}),
							!n.canPostMatchResult() &&
								h.jsxs("div", {
									children: [
										h.jsx("p", {
											children:
												"To post a match play result, please log in. If you don't have an account, click the button below to sign up.",
										}),
										h.jsx(Ge, {
											variant: "secondary",
											className: "ml-2",
											onClick: () => o(),
											children: "Create an Account",
										}),
									],
								}),
						],
					}),
					editComponent: h.jsx(Dkt, { result: new v9({ id: 0 }), onClose: () => t(!1) }),
				}),
			})
		},
		FD = Ft.td`
  ${(e) =>
		e.teamName === e.winner &&
		`
        font-weight: bold;
        color: #28a745;
    `}
`
	FD.displayName = "TeamCell"
	const Okt = (e) => {
			const { result: t } = e,
				[n, r] = _.useState(!1)
			return h.jsxs(H.Fragment, {
				children: [
					h.jsxs("tr", {
						children: [
							h.jsx("td", { children: Te(t.matchDate).format("MMM DD") }),
							h.jsx("td", { children: t.groupName }),
							h.jsx(FD, { teamName: t.homeTeamName, winner: t.winner, children: t.homeTeamName }),
							h.jsx("td", { children: t.homeTeamScore }),
							h.jsx(FD, { teamName: t.awayTeamName, winner: t.winner, children: t.awayTeamName }),
							h.jsx("td", { children: t.awayTeamScore }),
							h.jsx("td", {
								className: "clickable text-secondary",
								onClick: () => r(!n),
								children: t.notes && h.jsx(mO, { size: 18, color: "primary" }),
							}),
						],
					}),
					t.notes &&
						n &&
						h.jsx("tr", {
							children: h.jsx("td", { colSpan: 7, children: h.jsx(Rw, { children: t.notes }) }),
						}),
				],
			})
		},
		Akt = Ft.a`
	margin: 0;
	cursor: pointer;
`
	Akt.displayName = "FilterButton"
	const TG = Ft.th`
	min-width: 120px;
	max-width: 120px;
`
	TG.displayName = "DateColumn"
	const kG = Ft.th`
	min-width: 150px;
	max-width: 150px;
`
	kG.displayName = "GroupColumn"
	const SG = Ft.th`
	min-width: 180px;
	max-width: 180px;
`
	SG.displayName = "TeamColumn"
	function Nkt() {
		const [e, t] = _.useState(""),
			{ results: n, isLoading: r } = ykt(void 0, {
				selectFromResult: ({ data: o }) => ({
					results: (o == null ? void 0 : o.map((s) => new v9(s))) || [],
					isLoading: r,
				}),
			}),
			i = new Set((n == null ? void 0 : n.map((o) => o.groupName)) || []),
			a = () => (e ? n.slice(0).filter((s) => s.groupName === e) : n)
		return h.jsxs(ht, {
			loading: r,
			children: [
				h.jsxs("h3", {
					className: "text-primary",
					children: [
						lt.MatchPlayYear,
						" Match Results",
						h.jsxs("select", {
							className: "form-control form-control-sm",
							onChange: (o) => t(o.target.value),
							children: [
								h.jsx("option", { value: "", children: "Show All" }),
								[...i].map((o, s) =>
									h.jsx("option", { value: o.toString(), children: o.toString() }, s),
								),
							],
						}),
					],
				}),
				(n == null ? void 0 : n.length) === 0 &&
					h.jsx("p", { children: "No results reported yet." }),
				(n == null ? void 0 : n.length) > 0 &&
					h.jsxs(nc, {
						striped: !0,
						size: "sm",
						children: [
							h.jsx("thead", {
								children: h.jsxs("tr", {
									children: [
										h.jsx(TG, { children: "Date" }),
										h.jsx(kG, { children: "Group" }),
										h.jsx(SG, { children: "Home Team" }),
										h.jsx("th", { children: "Score" }),
										h.jsx("th", { children: "Away Team" }),
										h.jsx("th", { children: "Score" }),
										h.jsx("th", {}),
									],
								}),
							}),
							h.jsx("tbody", { children: a().map((o) => h.jsx(Okt, { result: o }, o.id)) }),
						],
					}),
			],
		})
	}
	const Mkt = () =>
			h.jsx(wG, {
				LeftColumn: h.jsxs(H.Fragment, {
					children: [
						h.jsx("h3", { className: "text-primary", children: "Schedule and Results" }),
						h.jsx(kkt, {}),
						h.jsx("h3", { className: "text-primary", children: "Post a Match Result" }),
						h.jsx(_kt, {}),
					],
				}),
				RightColumn: h.jsx(H.Fragment, { children: h.jsx(Nkt, {}) }),
			}),
		DG = (e) =>
			h.jsxs(ln, {
				children: [
					h.jsx(it, { lg: !0, children: e.LeftColumn }),
					h.jsx(it, { lg: !0, children: e.RightColumn }),
				],
			}),
		Ikt = () =>
			h.jsx(ii, {
				fluid: !0,
				children: h.jsx(DG, {
					LeftColumn: h.jsxs(H.Fragment, {
						children: [
							h.jsx("h3", { className: "text-primary mb-2", children: "Match Play Rules" }),
							h.jsx($v, { policyCode: Pi.MatchPlay }),
						],
					}),
					RightColumn: h.jsxs(H.Fragment, {
						children: [
							h.jsx("h3", { className: "text-primary mb-2", children: "Senior Match Play Rules" }),
							h.jsx($v, { policyCode: Pi.SeniorMatchPlay }),
						],
					}),
				}),
			}),
		_G = Ft.a`
  color: white;
  cursor: pointer;
`
	_G.displayName = "RoleRemover"
	const Rkt = (e) => {
			const { role: t } = e
			return h.jsxs(Eg, {
				text: "secondary",
				children: [
					t.role,
					" ",
					h.jsx(_G, { onClick: () => e.RemoveRole(t), children: h.jsx(m7, { size: 16 }) }),
				],
			})
		},
		OG = Ft.ul`
  margin: 0;
  padding: 0;
  list-style-type: none;
  li {
    display: inline;
    padding-right: 5px;
  }
`
	OG.displayName = "RoleContainer"
	const Lkt = (e) => {
			const { roles: t } = e
			return h.jsx(OG, {
				children:
					t &&
					t.map((n) =>
						h.jsx(
							"li",
							{ children: h.jsx(Rkt, { role: n, RemoveRole: () => e.RemoveRole(n) }) },
							n.id,
						),
					),
			})
		},
		Pkt = (e, t) => {
			switch (t.type) {
				case "GET_ROLES_INIT":
					return { ...e, isLoading: !0, isError: !1 }
				case "GET_ROLES_SUCCESS":
					return { ...e, isLoading: !1, isError: !1, data: t.payload.map((n) => n.name) }
				case "GET_ROLES_FAILURE":
					return { ...e, isLoading: !1, isError: !0 }
				default:
					throw new Error()
			}
		},
		jkt = (e, t) => {
			const n = "/roles/",
				[r, i] = _.useState(e),
				[a, o] = _.useReducer(Pkt, { isLoading: !1, isError: !1, data: t })
			return (
				_.useEffect(() => {
					let s = !1
					return (
						(async () => {
							if (r) {
								o({ type: "GET_ROLES_INIT" })
								try {
									const u = await ws.get(n + "?pattern=" + r)
									s || o({ type: "GET_ROLES_SUCCESS", payload: u.data })
								} catch {
									s || o({ type: "GET_ROLES_FAILURE" })
								}
							}
						})(),
						() => {
							s = !0
						}
					)
				}, [n, r]),
				[a, i]
			)
		},
		Fkt = (e) => {
			const [{ isLoading: t, isError: n, data: r }, i] = jkt("", []),
				[a, o] = _.useState(e.selectedRoles),
				s = _.useRef(),
				l = (u) => {
					const d = a.findIndex((p) => p.role === u.role)
					if (d >= 0) {
						const p = a.slice(0)
						p.splice(d, 1), o(p), e.OnChange(p)
					}
				}
			return h.jsxs("div", {
				children: [
					h.jsx(VA, {
						id: "role-picker",
						ref: s,
						placeholder: "Search for roles...",
						isLoading: t,
						minLength: 1,
						onChange: (u) => {
							var p
							a.push({ id: 0, role: u[0] })
							const d = a.slice(0)
							o(d), e.OnChange(d), (p = s.current) == null || p.clear()
						},
						options: r,
					}),
					h.jsx(Lkt, { roles: a, RemoveRole: l }),
					n && h.jsx("span", { className: "text-danger", children: "Doh!" }),
				],
			})
		},
		Bkt = Bt({
			firstName: Oe().max(30).required(),
			lastName: Oe().max(30),
			email: Oe().email().required(),
			primaryPhone: Oe().required(),
			notes: Oe().max(150).nullable(),
			isPrimary: dd().required(),
			useForMailings: dd().required(),
			addressTxt: Oe().when("useForMailings", ([e], t) =>
				e ? t.required("a valid address is required for mailing") : t.nullable(),
			),
			city: Oe().when("useForMailings", ([e], t) => (e ? t.required() : t.nullable())),
			state: Oe().when("useForMailings", ([e], t) => (e ? t.required() : t.nullable())),
			zip: Oe().when("useForMailings", ([e], t) => (e ? t.required() : t.nullable())),
		}),
		Hkt = (e) => {
			var n
			const t = e.contact || new ha({})
			return {
				firstName: t.firstName,
				lastName: t.lastName,
				primaryPhone: t.primaryPhone,
				email: t.email,
				addressTxt: t.addressTxt,
				city: t.city,
				state: t.state,
				zip: t.zip,
				notes: e.notes,
				isPrimary: e.isPrimary,
				sendEmail: e.sendEmail,
				useForMailings: e.useForMailings,
				roles: (n = e.roles) == null ? void 0 : n.map((r) => ({ id: r.id, role: r.role })),
			}
		},
		$kt = (e) => {
			const { clubContact: t, onClose: n } = e,
				r = Hkt(t),
				[i, a] = _.useState(!1),
				[o, s] = _.useState(r.useForMailings),
				[l, { isLoading: u }] = Pae(),
				[d, { isLoading: p }] = Lae(),
				[m, { isLoading: v }] = Fae(),
				y = u || p || v,
				b = () => {
					a(!1)
				},
				x = async (T) => {
					const C = Pu.Create(t.club, T).prepJson()
					;(C.id = t.id),
						(C.contact.id = t.contact.id),
						await (C.id > 0 ? l(C) : d(C))
							.unwrap()
							.then(() => {
								je.success(`${T.firstName + " " + T.lastName} has been saved.`), n()
							})
							.catch((O) => {
								je.error(" " + O)
							})
				},
				E = async () => {
					a(!1),
						await m(t.prepJson())
							.unwrap()
							.then(() => {
								je.success(`${t.contact.firstName + " " + t.contact.lastName} has been removed.`),
									n()
							})
							.catch((T) => {
								je.error(" " + T)
							})
				}
			return h.jsxs(ht, {
				loading: y,
				children: [
					h.jsx(Vt, {
						validationSchema: Bkt,
						onSubmit: x,
						initialValues: r,
						children: ({
							handleSubmit: T,
							handleChange: C,
							handleBlur: D,
							values: O,
							touched: A,
							errors: N,
						}) =>
							h.jsxs(R, {
								noValidate: !0,
								onSubmit: T,
								children: [
									h.jsxs(R.Group, {
										controlId: "cc.firstName",
										children: [
											h.jsx(R.Label, { children: "First name" }),
											h.jsx(R.Control, {
												placeholder: "First name",
												name: "firstName",
												value: O.firstName,
												isValid: A.firstName && !N.firstName,
												isInvalid: !!N.firstName,
												onChange: C,
												onBlur: D,
											}),
											h.jsx(R.Control.Feedback, { type: "invalid", children: N.firstName }),
										],
									}),
									h.jsxs(R.Group, {
										controlId: "cc.lastName",
										children: [
											h.jsx(R.Label, { children: "Last name" }),
											h.jsx(R.Control, {
												placeholder: "Last name",
												name: "lastName",
												value: O.lastName,
												isValid: A.lastName && !N.lastName,
												isInvalid: !!N.lastName,
												onChange: C,
												onBlur: D,
											}),
											h.jsx(R.Control.Feedback, { type: "invalid", children: N.lastName }),
										],
									}),
									h.jsxs(R.Group, {
										controlId: "cc.email",
										children: [
											h.jsx(R.Label, { children: "Email" }),
											h.jsx(R.Control, {
												placeholder: "Email",
												name: "email",
												value: O.email,
												isValid: A.email && !N.email,
												isInvalid: !!N.email,
												onChange: C,
												onBlur: D,
											}),
											h.jsx(R.Control.Feedback, { type: "invalid", children: N.email }),
										],
									}),
									h.jsxs(R.Group, {
										controlId: "cc.primaryPhone",
										children: [
											h.jsx(R.Label, { children: "Primary phone" }),
											h.jsx(R.Control, {
												placeholder: "xxx-xxx-xxxx",
												name: "primaryPhone",
												value: O.primaryPhone,
												isValid: A.primaryPhone && !N.primaryPhone,
												isInvalid: !!N.primaryPhone,
												onChange: C,
												onBlur: D,
											}),
											h.jsx(R.Control.Feedback, { type: "invalid", children: N.primaryPhone }),
											h.jsx(R.Text, { className: "text-muted", children: "Format: xxx-xxx-xxxx" }),
										],
									}),
									h.jsxs(R.Group, {
										controlId: "cc.roles",
										children: [
											h.jsx(R.Label, { children: "Roles" }),
											h.jsx(Fkt, { selectedRoles: O.roles || [], OnChange: (I) => (O.roles = I) }),
										],
									}),
									h.jsx(R.Group, {
										controlId: "cc.isPrimary",
										children: h.jsx(R.Check, {
											name: "isPrimary",
											label: "This is a primary contact",
											value: O.isPrimary.toString(),
											checked: O.isPrimary,
											onChange: C,
											onBlur: D,
										}),
									}),
									h.jsx(R.Group, {
										controlId: "cc.useForMailings",
										children: h.jsx(R.Check, {
											name: "useForMailings",
											label: "Send mailings to this contact",
											value: O.useForMailings.toString(),
											checked: O.useForMailings,
											onChange: (I) => {
												s(!o), C(I)
											},
											onBlur: D,
										}),
									}),
									h.jsxs(R.Group, {
										controlId: "cc.notes",
										children: [
											h.jsx(R.Label, { children: "Notes" }),
											h.jsx(R.Control, {
												name: "notes",
												value: O.notes || "",
												isValid: A.notes && !N.notes,
												isInvalid: !!N.notes,
												onChange: C,
												onBlur: D,
											}),
											h.jsx(R.Control.Feedback, { type: "invalid", children: N.notes }),
											h.jsx(R.Text, {
												className: "text-muted",
												children: "For multiple captains, indicate the team here.",
											}),
										],
									}),
									o &&
										h.jsxs(h.Fragment, {
											children: [
												h.jsxs(R.Group, {
													controlId: "cc.addressTxt",
													children: [
														h.jsx(R.Label, { children: "Address" }),
														h.jsx(R.Control, {
															placeholder: "Street address",
															name: "addressTxt",
															value: O.addressTxt,
															isValid: A.addressTxt && !N.addressTxt,
															isInvalid: !!N.addressTxt,
															onChange: C,
															onBlur: D,
														}),
														h.jsx(R.Control.Feedback, { type: "invalid", children: N.addressTxt }),
													],
												}),
												h.jsxs(R.Group, {
													controlId: "cc.city",
													children: [
														h.jsx(R.Label, { children: "City" }),
														h.jsx(R.Control, {
															placeholder: "City",
															name: "city",
															value: O.city,
															isValid: A.city && !N.city,
															isInvalid: !!N.city,
															onChange: C,
															onBlur: D,
														}),
														h.jsx(R.Control.Feedback, { type: "invalid", children: N.city }),
													],
												}),
												h.jsxs(R.Group, {
													controlId: "cc.state",
													children: [
														h.jsx(R.Label, { children: "State" }),
														h.jsx(R.Control, {
															placeholder: "State",
															name: "state",
															value: O.state,
															isValid: A.state && !N.state,
															isInvalid: !!N.state,
															onChange: C,
															onBlur: D,
														}),
														h.jsx(R.Control.Feedback, { type: "invalid", children: N.state }),
														h.jsx(R.Text, {
															className: "text-muted",
															children: "Two-letter state code (MN, WI, etc.)",
														}),
													],
												}),
												h.jsxs(R.Group, {
													controlId: "cc.zip",
													children: [
														h.jsx(R.Label, { children: "Zip code" }),
														h.jsx(R.Control, {
															placeholder: "Zip code",
															name: "zip",
															value: O.zip,
															isValid: A.zip && !N.zip,
															isInvalid: !!N.zip,
															onChange: C,
															onBlur: D,
														}),
														h.jsx(R.Control.Feedback, { type: "invalid", children: N.zip }),
													],
												}),
											],
										}),
									h.jsx(lr, {}),
									h.jsx(jd, {
										canDelete: e.clubContact.id !== 0,
										title: "Remove",
										OnDelete: () => a(!0),
									}),
									h.jsx(br, { canCancel: !0, OnCancel: n }),
								],
							}),
					}),
					h.jsx(Pd, {
						show: i,
						titleText: "Remove Contact?",
						messageText: "Please confirm that we should remove this contact from your club.",
						confirmText: "Remove Contact",
						DoCancel: b,
						DoConfirm: E,
					}),
				],
			})
		},
		Ukt = (e) => {
			var n, r, i, a, o
			const { clubContact: t } = e
			return h.jsxs("div", {
				children: [
					h.jsxs("h5", {
						className: "text-secondary",
						children: [
							((n = t.contact) == null ? void 0 : n.firstName) +
								" " +
								((r = t.contact) == null ? void 0 : r.lastName),
							t.isPrimary &&
								h.jsx(Lme, {
									className: "ml-1",
									size: 16,
									color: "secondary",
									title: "Primary contact",
								}),
							t.useForMailings &&
								h.jsx(Nme, {
									className: "ml-1",
									size: 16,
									color: "secondary",
									title: "Mailing contact",
								}),
						],
					}),
					h.jsx(la, {
						label: "Roles",
						value: ((i = t.roles) == null ? void 0 : i.map((s) => s.role).join(", ")) || [],
						defaultValue: "No roles defined",
						labelStyle: Fi.Inline,
						valueType: Bi.Text,
					}),
					h.jsx(la, {
						label: "Primary phone",
						value: (a = t.contact) == null ? void 0 : a.primaryPhone,
						defaultValue: "no phone",
						labelStyle: Fi.Inline,
						valueType: Bi.Text,
					}),
					h.jsx(la, {
						label: "Email",
						value: (o = t.contact) == null ? void 0 : o.email,
						defaultValue: "no email",
						labelStyle: Fi.Inline,
						valueType: Bi.Text,
					}),
				],
			})
		},
		i8 = (e) => {
			const { clubContact: t, edit: n, onClose: r } = e,
				i = Wt(),
				a = _.useRef(),
				o = () => {
					a.current.close(), r()
				}
			return h.jsx(Wr, {
				ref: a,
				initEdit: n,
				canEdit: i.canEditClubPage(),
				viewComponent: h.jsx(Ukt, { clubContact: t }),
				editComponent: h.jsx($kt, { clubContact: t, onClose: o }),
			})
		},
		zkt = (e) => {
			const { club: t } = e,
				n = Wt(),
				[r, i] = _.useState(new Pu({ id: 0, club: t.id })),
				[a, o] = _.useState(!1),
				[s, l] = H.useState(!1),
				u = t.clubContacts.findIndex((p) => p.id === 0) < 0,
				d = (p) => {
					p ? ((r.contact = p), i(r)) : i(new Pu({ id: 0, club: t.id })), o(!1), l(!0)
				}
			return h.jsxs("div", {
				children: [
					h.jsx("h3", { className: "text-primary", children: "Club Contacts" }),
					n.canEditClubPage() &&
						u &&
						h.jsx(Ge, {
							variant: "link",
							className: "text-warning",
							onClick: () => o(!0),
							children: "Add New Contact",
						}),
					a && h.jsx(TY, { allowNew: !0, OnSelect: d }),
					s && h.jsx(i8, { clubContact: r, edit: !0, onClose: () => l(!1) }, 0),
					t.clubContacts.map((p) =>
						h.jsx(i8, { clubContact: p, edit: !1, onClose: () => l(!1) }, p.id),
					),
				],
			})
		},
		qkt = Bt({
			name: Oe().required(),
			addressTxt: Oe().required(),
			city: Oe().required(),
			state: Oe().required(),
			zip: Oe().required(),
			website: Oe().url().nullable(),
			email: Oe().email().nullable(),
			phone: Oe().nullable(),
		}),
		Vkt = (e) => {
			const { club: t, onClose: n } = e,
				[r, { isLoading: i }] = jae(),
				a = async (o) => {
					const s = t.prepJson()
					;(s.id = t.id),
						(s.golf_course = o.prepJson()),
						await r(s)
							.unwrap()
							.then(() => {
								je.success("Your changes have been saved."), n()
							})
							.catch((l) => {
								je.error(" " + l)
							})
				}
			return h.jsx(ht, {
				loading: i,
				children: h.jsx(Vt, {
					validationSchema: qkt,
					onSubmit: a,
					initialValues: t.golfCourse,
					children: ({
						handleSubmit: o,
						handleChange: s,
						handleBlur: l,
						values: u,
						touched: d,
						errors: p,
					}) =>
						h.jsxs(R, {
							noValidate: !0,
							onSubmit: o,
							children: [
								h.jsxs(R.Group, {
									controlId: "name",
									children: [
										h.jsx(R.Label, { children: "Name" }),
										h.jsx(R.Control, {
											name: "name",
											placeholder: "Golf course name",
											value: u.name,
											isValid: d.name && !p.name,
											isInvalid: !!p.name,
											onChange: s,
											onBlur: l,
										}),
										h.jsx(R.Control.Feedback, { type: "invalid", children: p.name }),
									],
								}),
								h.jsxs(R.Group, {
									controlId: "addressTxt",
									children: [
										h.jsx(R.Label, { children: "Address" }),
										h.jsx(R.Control, {
											name: "addressTxt",
											placeholder: "Street address",
											value: u.addressTxt,
											isValid: d.addressTxt && !p.addressTxt,
											isInvalid: !!p.addressTxt,
											onChange: s,
											onBlur: l,
										}),
										h.jsx(R.Control.Feedback, { type: "invalid", children: p.addressTxt }),
									],
								}),
								h.jsxs(R.Group, {
									controlId: "city",
									children: [
										h.jsx(R.Label, { children: "City" }),
										h.jsx(R.Control, {
											name: "city",
											placeholder: "City",
											value: u.city,
											isValid: d.city && !p.city,
											isInvalid: !!p.city,
											onChange: s,
											onBlur: l,
										}),
										h.jsx(R.Control.Feedback, { type: "invalid", children: p.city }),
									],
								}),
								h.jsxs(R.Group, {
									controlId: "state",
									children: [
										h.jsx(R.Label, { children: "State" }),
										h.jsx(R.Control, {
											name: "state",
											placeholder: "State",
											value: u.state,
											isValid: d.state && !p.state,
											isInvalid: !!p.state,
											onChange: s,
											onBlur: l,
										}),
										h.jsx(R.Control.Feedback, { type: "invalid", children: p.state }),
									],
								}),
								h.jsxs(R.Group, {
									controlId: "zip",
									children: [
										h.jsx(R.Label, { children: "Zip" }),
										h.jsx(R.Control, {
											name: "zip",
											placeholder: "Zip",
											value: u.zip,
											isValid: d.zip && !p.zip,
											isInvalid: !!p.zip,
											onChange: s,
											onBlur: l,
										}),
										h.jsx(R.Control.Feedback, { type: "invalid", children: p.zip }),
									],
								}),
								h.jsxs(R.Group, {
									controlId: "website",
									children: [
										h.jsx(R.Label, { children: "Website" }),
										h.jsx(R.Control, {
											name: "website",
											placeholder: "Website",
											value: u.website,
											isValid: d.website && !p.website,
											isInvalid: !!p.website,
											onChange: s,
											onBlur: l,
										}),
										h.jsx(R.Control.Feedback, { type: "invalid", children: p.website }),
										h.jsx(R.Text, {
											className: "text-muted",
											children: "Full url, included protocol (http/https)",
										}),
									],
								}),
								h.jsxs(R.Group, {
									controlId: "email",
									children: [
										h.jsx(R.Label, { children: "Contact email" }),
										h.jsx(R.Control, {
											name: "email",
											value: u.email,
											isValid: d.email && !p.email,
											isInvalid: !!p.email,
											onChange: s,
											onBlur: l,
										}),
										h.jsx(R.Control.Feedback, { type: "invalid", children: p.email }),
									],
								}),
								h.jsxs(R.Group, {
									controlId: "phone",
									children: [
										h.jsx(R.Label, { children: "Contact phone number" }),
										h.jsx(R.Control, {
											name: "phone",
											value: u.phone,
											isValid: d.phone && !p.phone,
											isInvalid: !!p.phone,
											onChange: s,
											onBlur: l,
										}),
										h.jsx(R.Control.Feedback, { type: "invalid", children: p.phone }),
									],
								}),
								h.jsx(lr, {}),
								h.jsx(br, { OnCancel: n, canCancel: !0 }),
							],
						}),
				}),
			})
		},
		Wkt = (e) => {
			const { club: t } = e,
				n = t.golfCourse
			return h.jsxs(h.Fragment, {
				children: [
					!(n != null && n.name) &&
						h.jsx("h3", { className: "text-primary mb-3", children: "No Home Course" }),
					(n == null ? void 0 : n.name) &&
						h.jsxs("div", {
							children: [
								h.jsx("h3", {
									className: "text-primary mb-3",
									children: n == null ? void 0 : n.name,
								}),
								h.jsx(la, {
									label: "Address",
									value: n,
									labelStyle: Fi.Stacked,
									valueType: Bi.Address,
								}),
								h.jsx(la, {
									label: "Course website",
									value: n == null ? void 0 : n.website,
									labelStyle: Fi.Stacked,
									valueType: Bi.ExternalLink,
								}),
								h.jsx(la, {
									label: "Phone",
									value: n == null ? void 0 : n.phone,
									labelStyle: Fi.Stacked,
									valueType: Bi.Text,
								}),
								h.jsx(la, {
									label: "Email",
									value: n == null ? void 0 : n.email,
									labelStyle: Fi.Stacked,
									valueType: Bi.Markdown,
								}),
							],
						}),
				],
			})
		},
		Ykt = (e) => {
			const { club: t } = e,
				n = Wt(),
				r = _.useRef(),
				i = () => {
					r.current.close()
				}
			return h.jsx(Wr, {
				ref: r,
				initEdit: !1,
				canEdit: n.canEditClubPage(),
				viewComponent: h.jsx(Wkt, { club: t }),
				editComponent: h.jsx(Vkt, { club: t, onClose: i }),
			})
		},
		AG = Ft.div`
    display: flex;
    flex-direction: column;  
    justify-content: center; 
    align-items: center;    
    height: 60px;
    > div {
        text-align: center;
    }
    > p {
        text-align: center;
        margin-bottom: 12px;
    }
`
	AG.displayName = "ProcessingContainer"
	const Gkt = (e) =>
			h.jsxs(AG, {
				children: [
					h.jsx("p", { className: "text-primary", children: e.message || "Processing..." }),
					h.jsx(Qv, {
						animation: "border",
						variant: "primary",
						role: "status",
						children: h.jsx("span", { className: "visually-hidden", children: "Processing..." }),
					}),
				],
			}),
		Kkt = Bt({
			name: Oe().required("Please enter your name"),
			email: Oe().email().required("A valid email is required"),
		}),
		Qkt = (e) => {
			const { user: t } = ks(),
				[n, r] = _.useState(void 0),
				i = d8(),
				a = ZQ(),
				o = async (s) => {
					if (!i || !a) return
					const l = a.getElement(XI),
						{ error: u, paymentMethod: d } = await i.createPaymentMethod({
							type: "card",
							card: l,
							billing_details: { email: s.email, name: s.name },
						})
					if (u) r(u)
					else if (d !== void 0) e.OnPayment(d)
					else throw new Error("No payment method was created!")
				}
			return h.jsx(Vt, {
				validationSchema: Kkt,
				validateOnBlur: !1,
				validateOnChange: !1,
				onSubmit: (s) => {
					o(s)
				},
				initialValues: { name: t.isAuthenticated ? t.name : "", email: t.email || "" },
				children: ({
					handleSubmit: s,
					handleChange: l,
					handleBlur: u,
					values: d,
					touched: p,
					errors: m,
				}) =>
					h.jsxs(R, {
						noValidate: !0,
						onSubmit: s,
						children: [
							h.jsxs(R.Group, {
								controlId: "name",
								children: [
									h.jsx(R.Control, {
										placeholder: "Name",
										name: "name",
										value: d.name || "",
										isValid: p.name && !m.name,
										isInvalid: !!m.name,
										onChange: l,
										onBlur: u,
									}),
									h.jsx(R.Control.Feedback, { type: "invalid", children: m.name }),
								],
							}),
							h.jsxs(R.Group, {
								controlId: "email",
								children: [
									h.jsx(R.Control, {
										placeholder: "Email",
										name: "email",
										type: "email",
										value: d.email || "",
										isValid: p.email && !m.email,
										isInvalid: !!m.email,
										onChange: l,
										onBlur: u,
									}),
									h.jsx(R.Control.Feedback, { type: "invalid", children: m.email }),
								],
							}),
							h.jsxs(R.Group, {
								controlId: "card",
								children: [
									h.jsx(XI, {
										className: "form-control",
										options: {
											style: {
												base: { color: "#212529", lineHeight: "1.429" },
												invalid: { color: "red" },
											},
										},
									}),
									n && h.jsx("p", { className: "text-danger mt-1", children: n.message }),
								],
							}),
							h.jsx(Ge, {
								variant: "secondary",
								type: "submit",
								size: "sm",
								className: "mt-2",
								disabled: !i,
								children: "Pay Dues",
							}),
							h.jsx(Ge, {
								variant: "light",
								type: "reset",
								size: "sm",
								className: "mt-2 ml-2",
								onClick: () => e.Cancel(),
								children: "Cancel",
							}),
						],
					}),
			})
		},
		NG = Ft.div`
	padding: 10px;
	margin: 20px;
`
	NG.displayName = "PaymentContainer"
	const Xkt = (e) => {
			const t = Up((a) => a.payments),
				n = ki(),
				r = d8(),
				i = async (a) => {
					r && n(Uy({ stripe: r, club: e.club, method: a }))
				}
			return h.jsxs(NG, {
				children: [
					t.paymentProcessing && h.jsx(Gkt, { message: "Processing your payment..." }),
					!t.paymentConfirmationId &&
						!t.paymentProcessing &&
						h.jsxs(H.Fragment, {
							children: [
								h.jsx("h4", { className: "text-secondary", children: e.title }),
								h.jsx(Qkt, { OnPayment: (a) => i(a), Cancel: () => e.Cancel() }),
							],
						}),
					t.paymentConfirmationId &&
						h.jsxs("p", {
							className: "text-success",
							children: [
								"Thank you for your payment. Here is your confirmation id",
								" ",
								t.paymentConfirmationId,
								". The webite may take a few minutes to reflect this payment. Refresh your browser to see the latest status.",
							],
						}),
					t.paymentError && h.jsx("p", { className: "text-danger", children: t.paymentError }),
				],
			})
		},
		Jkt = Bt({
			name: Oe().max(200).required(),
			website: Oe().max(300).url(),
			size: gi(),
			notes: Oe(),
		}),
		Zkt = (e) => {
			const { club: t, onClose: n } = e,
				[r, { isLoading: i }] = Rae(),
				a = async (o) => {
					const s = o.prepJson()
					;(s.id = t.id),
						await r(s)
							.unwrap()
							.then(() => {
								je.success("Your changes have been saved."), n()
							})
							.catch((l) => {
								je.error(" " + l)
							})
				}
			return h.jsx(ht, {
				loading: i,
				children: h.jsx(Vt, {
					validationSchema: Jkt,
					onSubmit: a,
					initialValues: t,
					children: ({
						handleSubmit: o,
						handleChange: s,
						handleBlur: l,
						values: u,
						touched: d,
						errors: p,
					}) => {
						var m
						return h.jsxs(R, {
							noValidate: !0,
							onSubmit: o,
							children: [
								h.jsxs(R.Group, {
									controlId: "club.Name",
									children: [
										h.jsx(R.Label, { children: "Name" }),
										h.jsx(R.Control, {
											name: "name",
											placeholder: "Official club name",
											value: u.name,
											isValid: d.name && !p.name,
											isInvalid: !!p.name,
											onChange: s,
											onBlur: l,
										}),
										h.jsx(R.Control.Feedback, { type: "invalid", children: p.name }),
									],
								}),
								h.jsxs(R.Group, {
									controlId: "club.Website",
									children: [
										h.jsx(R.Label, { children: "Website" }),
										h.jsx(R.Control, {
											name: "website",
											placeholder: "Website",
											value: u.website,
											isValid: d.website && !p.website,
											isInvalid: !!p.website,
											onChange: s,
											onBlur: l,
										}),
										h.jsx(R.Control.Feedback, { type: "invalid", children: p.website }),
										h.jsx(R.Text, {
											className: "text-muted",
											children: "Full url, included protocol (http/https)",
										}),
									],
								}),
								h.jsxs(R.Group, {
									controlId: "club.Size",
									children: [
										h.jsx(R.Label, { children: "Club size" }),
										h.jsx(R.Control, {
											name: "size",
											value: (m = u.size) == null ? void 0 : m.toString(),
											isValid: d.size && !p.size,
											isInvalid: !!p.size,
											onChange: s,
											onBlur: l,
										}),
										h.jsx(R.Control.Feedback, { type: "invalid", children: p.size }),
										h.jsx(R.Text, {
											className: "text-muted",
											children: "Current number of members.",
										}),
									],
								}),
								h.jsxs(R.Group, {
									controlId: "club.Notes",
									children: [
										h.jsx(R.Label, { children: "Notes" }),
										h.jsx(_s, { name: "notes", value: u.notes, height: "360px" }),
									],
								}),
								h.jsx(lr, {}),
								h.jsx(br, { OnCancel: n, canCancel: !0 }),
							],
						})
					},
				}),
			})
		},
		eSt = (e) => {
			const { club: t, membership: n } = e
			return h.jsxs("div", {
				children: [
					h.jsx("h3", { className: "text-primary mb-3", children: t.name }),
					h.jsx(la, {
						label: "Last joined",
						value: n == null ? void 0 : n.year,
						labelStyle: Fi.Stacked,
						valueType: Bi.Text,
					}),
					h.jsx(la, {
						label: "Date joined",
						value: n == null ? void 0 : n.paymentDate,
						labelStyle: Fi.Stacked,
						valueType: Bi.Text,
					}),
					h.jsx(la, {
						label: "Club website",
						value: t.website,
						labelStyle: Fi.Stacked,
						valueType: Bi.ExternalLink,
					}),
					h.jsx(la, {
						label: "Number of members",
						value: t.size,
						labelStyle: Fi.Stacked,
						valueType: Bi.Text,
					}),
					h.jsx(la, {
						label: "About " + t.name,
						value: t.notes,
						labelStyle: Fi.Stacked,
						valueType: Bi.Markdown,
					}),
				],
			})
		},
		tSt = Ui.injectEndpoints({
			endpoints: (e) => ({
				getMembershipsForYear: e.query({
					query: (t) => ({ url: `/memberships/?year=${t}`, method: "GET" }),
					providesTags: (t) =>
						t
							? [
									...t.map(({ id: n }) => ({ type: "Memberships", id: n })),
									{ type: "Memberships", id: "LIST" },
							  ]
							: [{ type: "Memberships", id: "LIST" }],
				}),
				getMembershipsForClub: e.query({
					query: (t) => ({ url: `/memberships/?club=${t}`, method: "GET" }),
					providesTags: (t, n, r) => [{ type: "Memberships", id: r }],
				}),
				addMembershipForClub: e.mutation({
					query(t) {
						const { club: n } = t
						return { url: `/memberships/?club=${n}`, method: "POST", data: t }
					},
					invalidatesTags: (t, n, { club: r }) => [{ type: "Memberships", id: r }],
				}),
			}),
		}),
		{
			useGetMembershipsForClubQuery: nSt,
			useGetMembershipsForYearQuery: MG,
			useAddMembershipForClubMutation: rSt,
		} = tSt,
		iSt = Bt({
			paymentDate: Fu().required(),
			paymentType: Oe().required(),
			paymentCode: Oe().nullable(),
			notes: Oe().max(150).nullable(),
		}),
		aSt = (e) => {
			const { club: t, onCancel: n, onSave: r } = e,
				[i, { isLoading: a }] = rSt(),
				o = new h9({ year: lt.MemberClubYear, club: t.id, payment_type: "CK" }),
				s = async (l) => {
					const u = l.prepJson()
					;(u.payment_date = u.payment_date.substring(0, 10)),
						await i(u)
							.unwrap()
							.then(() => {
								je.success("Membership record has been created."), r(l)
							})
							.catch((d) => {
								je.error(" " + d)
							})
				}
			return h.jsx(ht, {
				loading: a,
				children: h.jsx(Vt, {
					validationSchema: iSt,
					onSubmit: s,
					initialValues: o,
					children: ({
						handleSubmit: l,
						setFieldValue: u,
						handleChange: d,
						handleBlur: p,
						values: m,
						touched: v,
						errors: y,
					}) =>
						h.jsxs(R, {
							noValidate: !0,
							onSubmit: l,
							children: [
								h.jsxs(R.Group, {
									controlId: "paymentDate",
									children: [
										h.jsx(R.Label, { children: "Payment Date" }),
										h.jsx($p, {
											name: "paymentDate",
											value: m.paymentDate,
											onChange: u,
											onBlur: p,
											dateFormat: "yyyy-MM-dd",
										}),
										h.jsx(R.Control.Feedback, { type: "invalid", children: y.paymentDate }),
									],
								}),
								h.jsxs(R.Group, {
									controlId: "paymentType",
									children: [
										h.jsx(R.Label, { children: "Payment Type" }),
										h.jsxs(R.Control, {
											as: "select",
											name: "paymentType",
											value: m.paymentType,
											isValid: v.paymentType && !y.paymentType,
											isInvalid: !!y.paymentType,
											onChange: d,
											onBlur: p,
											children: [
												h.jsx("option", { value: "CK", children: "Check" }),
												h.jsx("option", { value: "CA", children: "Waived" }),
											],
										}),
										h.jsx(R.Control.Feedback, { type: "invalid", children: y.paymentType }),
									],
								}),
								h.jsxs(R.Group, {
									controlId: "paymentCode",
									children: [
										h.jsx(R.Label, { children: "Check Number" }),
										h.jsx(R.Control, {
											name: "paymentCode",
											value: m.paymentCode,
											isValid: v.paymentCode && !y.paymentCode,
											isInvalid: !!y.paymentCode,
											onChange: d,
											onBlur: p,
										}),
										h.jsx(R.Control.Feedback, { type: "invalid", children: y.paymentCode }),
									],
								}),
								h.jsxs(R.Group, {
									controlId: "cc.notes",
									children: [
										h.jsx(R.Label, { children: "Notes" }),
										h.jsx(R.Control, {
											name: "notes",
											value: m.notes,
											isValid: v.notes && !y.notes,
											isInvalid: !!y.notes,
											onChange: d,
											onBlur: p,
										}),
										h.jsx(R.Control.Feedback, { type: "invalid", children: y.notes }),
									],
								}),
								h.jsx(lr, {}),
								h.jsx(br, { canCancel: !0, OnCancel: n }),
							],
						}),
				}),
			})
		},
		IG = Ft.div`
	border-width: 1px;
	border-color: silver;
	border-style: solid;
	padding: 10px;
	margin-bottom: 10px;
`
	IG.displayName = "CreateMembershipContainer"
	function oSt(e) {
		const { club: t } = e,
			[n, r] = _.useState(!1),
			[i, a] = _.useState(!1),
			o = Wt(),
			{ data: s, isLoading: l } = nSt((t == null ? void 0 : t.id) || ho),
			u = _.useRef(),
			d = () => {
				const b = (s == null ? void 0 : s.length) > 0 ? s[0] : null
				return b ? new h9(b) : null
			},
			p = () => {
				u.current.close()
			},
			m = (b) => {
				a(!1)
			},
			v = () => {
				var b
				if ((((b = d()) == null ? void 0 : b.year) || 0) < lt.MemberClubYear)
					return n
						? h.jsx(Xkt, {
								club: t,
								amountDue: lt.MembershipDues,
								title: `Pay ${lt.MemberClubYear} Dues Online`,
								Cancel: () => r(!1),
						  })
						: h.jsx(Ge, {
								variant: "outline-secondary",
								type: "submit",
								size: "lg",
								className: "mt-3",
								onClick: () => r(!0),
								children: "Pay Dues Now",
						  })
			},
			y = () => {
				var b
				if ((((b = d()) == null ? void 0 : b.year) || 0) < lt.MemberClubYear)
					return i
						? h.jsx(IG, {
								children: h.jsx(aSt, { club: t, onSave: (x) => m(), onCancel: () => a(!1) }),
						  })
						: o.canEnterPayment()
						? h.jsx(Ge, {
								variant: "link",
								className: "text-warning",
								onClick: () => a(!0),
								children: "Enter Dues Payment",
						  })
						: h.jsx(h.Fragment, {})
			}
		return h.jsxs(ht, {
			loading: l,
			children: [
				y(),
				h.jsx(Wr, {
					ref: u,
					initEdit: !1,
					canEdit: o.canEditClubPage(),
					viewComponent: h.jsx(eSt, { club: t, membership: d() }),
					editComponent: h.jsx(Zkt, { club: t, onClose: p }),
				}),
				v(),
			],
		})
	}
	const sSt = () => {
			const { name: e } = Sl(),
				{ data: t } = Kp(),
				{ data: n, isLoading: r } = Mae(
					(t == null ? void 0 : t.find((a) => a.system_name === e).id) || ho,
				),
				i = new p9(n)
			return h.jsx(ii, {
				fluid: !0,
				children:
					!r &&
					h.jsx(GA, {
						Column1: h.jsx(oSt, { club: i }),
						Column2: h.jsx(zkt, { club: i }),
						Column3: h.jsx(Ykt, { club: i }),
					}),
			})
		},
		RG = (e) =>
			h.jsxs(ln, {
				children: [
					h.jsx(it, { sm: 12, md: 8, lg: 9, children: e.LeftColumn }),
					h.jsx(it, { sm: 12, md: 4, lg: 3, children: e.RightColumn }),
				],
			}),
		lSt = (e) => {
			const { club: t } = e
			return h.jsxs("tr", {
				children: [
					h.jsx("td", {
						className: "text-secondary",
						style: { fontWeight: "bold" },
						children: t.isCurrent && `${lt.MemberClubYear} Member`,
					}),
					h.jsx("td", {
						children: h.jsx(Un, {
							to: "/clubs/" + t.systemName,
							className: "nav-link",
							children: t.name,
						}),
					}),
					h.jsx("td", {
						className: "text-secondary",
						children:
							t.website &&
							h.jsx("a", {
								href: t.website,
								target: "_blank",
								rel: "noopener noreferrer",
								children: h.jsx(Mme, { size: 18, color: "primary" }),
							}),
					}),
					h.jsx("td", { children: t.location }),
					h.jsx("td", { children: t.size ? t.size : "Unknown" }),
				],
			})
		},
		uSt = () => {
			var a
			const { data: e, isLoading: t } = MG(lt.MemberClubYear),
				{ data: n, isLoading: r } = Kp(),
				i = () =>
					!r && !t
						? n.map((o) => {
								var l
								const s = e.findIndex((u) => u.club === o.id && u.year === lt.MemberClubYear) >= 0
								return {
									id: o.id,
									name: o.name,
									systemName: o.system_name,
									isCurrent: s,
									website: o.website,
									location: ((l = o.golf_course) == null ? void 0 : l.name) || "unaffiliated",
									size: o.size,
								}
						  })
						: []
			return h.jsx(ht, {
				loading: t || r,
				children: h.jsxs(nc, {
					striped: !0,
					size: "sm",
					children: [
						h.jsx("thead", {
							children: h.jsxs("tr", {
								children: [
									h.jsx("th", { children: lt.MemberClubYear }),
									h.jsx("th", { children: "Club" }),
									h.jsx("th", { children: "Website" }),
									h.jsx("th", { children: "Location" }),
									h.jsx("th", { children: "Size" }),
								],
							}),
						}),
						h.jsx("tbody", {
							children: (a = i()) == null ? void 0 : a.map((o) => h.jsx(lSt, { club: o }, o.id)),
						}),
					],
				}),
			})
		},
		cSt = () => {
			const e = { key: "dues", documentTypes: ["Club Registration"] }
			return h.jsxs(_.Fragment, {
				children: [h.jsx(Rl, { pageCode: Rn.ClubRegistration }), h.jsx(Iw, { query: e })],
			})
		},
		dSt = () =>
			h.jsx(ii, {
				fluid: !0,
				children: h.jsx(RG, {
					LeftColumn: h.jsxs("div", {
						children: [h.jsx(Rl, { pageCode: Rn.MemberClubs }), h.jsx(uSt, {})],
					}),
					RightColumn: h.jsx(cSt, {}),
				}),
			}),
		fSt = () => /^((?!chrome|android).)*safari/i.test(navigator.userAgent),
		LG = (e) => Array.isArray(e) && e.every((t) => typeof t == "object" && !(t instanceof Array)),
		pSt = (e) => Array.isArray(e) && e.every((t) => Array.isArray(t)),
		hSt = (e) =>
			Array.from(e.map((t) => Object.keys(t)).reduce((t, n) => new Set([...t, ...n]), [])),
		mSt = (e, t) => {
			t = t || hSt(e)
			let n = t,
				r = t
			LG(t) && ((n = t.map((a) => a.label)), (r = t.map((a) => a.key)))
			const i = e.map((a) => r.map((o) => vSt(o, a)))
			return [n, ...i]
		},
		vSt = (e, t) => {
			const n = e
				.replace(/\[([^\]]+)]/g, ".$1")
				.split(".")
				.reduce(function (r, i, a, o) {
					const s = r[i]
					if (s == null) o.splice(1)
					else return s
				}, t)
			return n === void 0 ? (e in t ? t[e] : "") : n
		},
		gSt = (e) => (typeof e > "u" || e === null ? "" : e),
		PG = (e, t = ",", n = '"') =>
			e
				.filter((r) => r)
				.map((r) =>
					r
						.map((i) => gSt(i))
						.map((i) => `${n}${i}${n}`)
						.join(t),
				).join(`
`),
		ySt = (e, t, n, r) => PG(t ? [t, ...e] : e, n, r),
		bSt = (e, t, n, r) => PG(mSt(e, t), n, r),
		xSt = (e, t, n, r) =>
			t
				? `${t.join(n)}
${e}`
				: e.replace(/"/g, '""'),
		jG = (e, t, n, r) => {
			if (LG(e)) return bSt(e, t, n, r)
			if (pSt(e)) return ySt(e, t, n, r)
			if (typeof e == "string") return xSt(e, t, n)
			throw new TypeError('Data should be a "String", "Array of arrays" OR "Array of objects" ')
		},
		FG = (e, t, n, r, i) => {
			const a = jG(e, n, r, i),
				o = fSt() ? "application/csv" : "text/csv",
				s = new Blob([t ? "\uFEFF" : "", a], { type: o }),
				l = `data:${o};charset=utf-8,${t ? "\uFEFF" : ""}${a}`,
				u = window.URL || window.webkitURL
			return typeof u.createObjectURL > "u" ? l : u.createObjectURL(s)
		},
		BG = {
			data: ea.oneOfType([ea.string, ea.array, ea.func]).isRequired,
			headers: ea.array,
			target: ea.string,
			separator: ea.string,
			filename: ea.string,
			uFEFF: ea.bool,
			onClick: ea.func,
			asyncOnClick: ea.bool,
			enclosingCharacter: ea.string,
		},
		HG = {
			separator: ",",
			filename: "generatedBy_react-csv.csv",
			uFEFF: !0,
			asyncOnClick: !1,
			enclosingCharacter: '"',
		},
		wSt = { target: "_blank" }
	class a8 extends H.Component {
		constructor(t) {
			super(t), (this.state = {})
		}
		buildURI() {
			return FG(...arguments)
		}
		componentDidMount() {
			const {
				data: t,
				headers: n,
				separator: r,
				enclosingCharacter: i,
				uFEFF: a,
				target: o,
				specs: s,
				replace: l,
			} = this.props
			this.state.page = window.open(this.buildURI(t, a, n, r, i), o, s, l)
		}
		getWindow() {
			return this.state.page
		}
		render() {
			return null
		}
	}
	q(a8, "defaultProps", Object.assign(HG, wSt)), q(a8, "propTypes", BG)
	var Py
	let ESt =
		((Py = class extends H.Component {
			constructor(t) {
				super(t), (this.buildURI = this.buildURI.bind(this))
			}
			buildURI() {
				return FG(...arguments)
			}
			handleLegacy(t, n = !1) {
				if (window.navigator.msSaveOrOpenBlob) {
					t.preventDefault()
					const {
							data: r,
							headers: i,
							separator: a,
							filename: o,
							enclosingCharacter: s,
							uFEFF: l,
						} = this.props,
						u = n && typeof r == "function" ? r() : r
					let d = new Blob([l ? "\uFEFF" : "", jG(u, i, a, s)])
					return window.navigator.msSaveBlob(d, o), !1
				}
			}
			handleAsyncClick(t) {
				const n = (r) => {
					if (r === !1) {
						t.preventDefault()
						return
					}
					this.handleLegacy(t, !0)
				}
				this.props.onClick(t, n)
			}
			handleSyncClick(t) {
				if (this.props.onClick(t) === !1) {
					t.preventDefault()
					return
				}
				this.handleLegacy(t)
			}
			handleClick() {
				return (t) => {
					if (typeof this.props.onClick == "function")
						return this.props.asyncOnClick ? this.handleAsyncClick(t) : this.handleSyncClick(t)
					this.handleLegacy(t)
				}
			}
			render() {
				const {
						data: t,
						headers: n,
						separator: r,
						filename: i,
						uFEFF: a,
						children: o,
						onClick: s,
						asyncOnClick: l,
						enclosingCharacter: u,
						...d
					} = this.props,
					m = typeof window > "u" ? "" : this.buildURI(t, a, n, r, u)
				return h.jsx("a", {
					download: i,
					...d,
					ref: (v) => (this.link = v),
					target: "_self",
					href: m,
					onClick: this.handleClick(),
					children: o,
				})
			}
		}),
		q(Py, "defaultProps", HG),
		q(Py, "propTypes", BG),
		Py)
	const dN = ESt,
		Ly = (e) => {
			const { filter: t } = e,
				{ data: n, isLoading: r } = Nae(),
				{ data: i } = Kp(),
				a = (p) => {
					var m
					return (
						(p.roles && ((m = p.roles) == null ? void 0 : m.map((v) => v.role).join(", "))) || ""
					)
				},
				o = (p) => {
					var m
					if (t === "primary") return p.isPrimary
					if (t === "mailings") return p.useForMailings
					if (t === "captains") {
						const v =
							(m = p.roles) == null
								? void 0
								: m.findIndex((y) => y.role && y.role.indexOf("Captain") >= 0)
						return v !== void 0 && v >= 0
					}
					return !0
				},
				s = (p) => {
					if (i) return i.find((m) => m.id === p.club)
				},
				l = () => {
					const p = [
						{ label: "Home Club", key: "homeClub" },
						{ label: "First Name", key: "firstName" },
						{ label: "Last Name", key: "lastName" },
						{ label: "Email", key: "email" },
						{ label: "Phone", key: "phone" },
						{ label: "Club Url", key: "clubUrl" },
					]
					return (
						t === "mailings" &&
							(p.push({ label: "Address", key: "address" }),
							p.push({ label: "City", key: "city" }),
							p.push({ label: "State", key: "state" }),
							p.push({ label: "zip", key: "zip" })),
						p.push({ label: "Roles", key: "roles" }),
						t === "captains" && p.push({ label: "Notes", key: "notes" }),
						p
					)
				},
				u = () => {
					const p = []
					return (
						n &&
							n.length > 0 &&
							(n == null ||
								n
									.map((m) => new Pu(m))
									.filter((m) => o(m))
									.forEach((m) => {
										var v, y, b, x, E, T, C, D, O, A, N, I, P, L, B, z
										t === "mailings"
											? p.push({
													id: m.id,
													homeClub: s(m).name,
													firstName: (v = m.contact) == null ? void 0 : v.firstName,
													lastName: (y = m.contact) == null ? void 0 : y.lastName,
													email: (b = m.contact) == null ? void 0 : b.email,
													phone: (x = m.contact) == null ? void 0 : x.primaryPhone,
													clubUrl: `https://mpga.net/clubs/${s(m).system_name}`,
													address: (E = m.contact) == null ? void 0 : E.addressTxt,
													city: (T = m.contact) == null ? void 0 : T.city,
													state: (C = m.contact) == null ? void 0 : C.state,
													zip: (D = m.contact) == null ? void 0 : D.zip,
													roles: a(m),
											  })
											: t === "captains"
											? p.push({
													id: m.id,
													homeClub: s(m).name,
													firstName: (O = m.contact) == null ? void 0 : O.firstName,
													lastName: (A = m.contact) == null ? void 0 : A.lastName,
													email: (N = m.contact) == null ? void 0 : N.email,
													phone: (I = m.contact) == null ? void 0 : I.primaryPhone,
													clubUrl: `https://mpga.net/clubs/${s(m).system_name}`,
													roles: a(m),
													notes: m.notes,
											  })
											: p.push({
													id: m.id,
													homeClub: s(m).name,
													firstName: (P = m.contact) == null ? void 0 : P.firstName,
													lastName: (L = m.contact) == null ? void 0 : L.lastName,
													email: (B = m.contact) == null ? void 0 : B.email,
													phone: (z = m.contact) == null ? void 0 : z.primaryPhone,
													clubUrl: `https://mpga.net/clubs/${s(m).system_name}`,
													roles: a(m),
											  })
									})),
						p
					)
				},
				d = () =>
					t === "primary"
						? "MpgaPrimaryContacts.csv"
						: t === "mailings"
						? "MpgaMailingAddresses.csv"
						: t === "captains"
						? "MpgaTeamCaptains.csv"
						: "MpgaClubContacts.csv"
			return h.jsxs(ht, {
				loading: r,
				children: [
					h.jsx(dN, {
						data: u(),
						headers: l(),
						enclosingCharacter: '"',
						filename: d(),
						children: "Download",
					}),
					h.jsxs(nc, {
						striped: !0,
						size: "sm",
						children: [
							h.jsx("thead", {
								children: h.jsxs("tr", {
									children: [
										h.jsx("th", { children: "Home club" }),
										h.jsx("th", { children: "First name" }),
										h.jsx("th", { children: "Last name" }),
										h.jsx("th", { children: "Email" }),
										h.jsx("th", { children: "Phone" }),
										t === "mailings" && h.jsx("th", { children: "Address" }),
										t === "mailings" && h.jsx("th", { children: "City" }),
										t === "mailings" && h.jsx("th", { children: "State" }),
										t === "mailings" && h.jsx("th", { children: "Zip" }),
										h.jsx("th", { children: "Role(s)" }),
										h.jsx("th", { children: "Club Page Url" }),
										t === "captains" && h.jsx("th", { children: "Notes" }),
									],
								}),
							}),
							h.jsx("tbody", {
								children: u().map((p) =>
									h.jsxs(
										"tr",
										{
											children: [
												h.jsx("td", { children: p.homeClub }),
												h.jsx("td", { children: p.firstName }),
												h.jsx("td", { children: p.lastName }),
												h.jsx("td", { children: p.email }),
												h.jsx("td", { children: p.phone }),
												t === "mailings" && h.jsx("td", { children: p.address }),
												t === "mailings" && h.jsx("td", { children: p.city }),
												t === "mailings" && h.jsx("td", { children: p.state }),
												t === "mailings" && h.jsx("td", { children: p.zip }),
												h.jsx("td", { children: p.roles }),
												h.jsx("td", { children: p.clubUrl }),
												t === "captains" && h.jsx("td", { children: p.notes }),
											],
										},
										p.id,
									),
								),
							}),
						],
					}),
				],
			})
		},
		o8 = (e) => {
			const { current: t } = e,
				{ data: n, isLoading: r } = MG(lt.MemberClubYear),
				{ data: i, isLoading: a } = Kp(),
				o = () =>
					!a && !r
						? i.map((d) => {
								var m
								const p = n.find((v) => v.club === d.id && v.year === lt.MemberClubYear)
								return {
									id: d.id,
									name: d.name,
									systemName: d.system_name,
									isCurrent: (p == null ? void 0 : p.id) > 0,
									website: d.website,
									location: ((m = d.golf_course) == null ? void 0 : m.name) || "unaffiliated",
									size: d.size,
									paymentDate: p == null ? void 0 : p.payment_date,
									paymentMethod: s(p),
								}
						  })
						: [],
				s = (d) =>
					d
						? d.payment_type === "CK"
							? `Check (${d.payment_code})`
							: d.payment_type === "OL"
							? "Online"
							: "Other"
						: "None",
				l = () => {
					const d = [
						{ label: "Name", key: "name" },
						{ label: "System Name", key: "systemName" },
						{ label: "Home Course", key: "homeCourse" },
						{ label: "Members", key: "members" },
					]
					return (
						t &&
							(d.push({ label: "Date", key: "paymentDate" }),
							d.push({ label: "Payment Method", key: "paymentMethod" })),
						d
					)
				},
				u = () =>
					t
						? o()
								.filter((d) => d.isCurrent)
								.map((d) => ({
									id: d.id,
									name: d.name,
									systemName: d.systemName,
									homeCourse: d.location,
									members: d.size,
									paymentDate: d.paymentDate,
									paymentMethod: d.paymentMethod,
								}))
						: o().map((d) => ({
								id: d.id,
								name: d.name,
								systemName: d.systemName,
								homeCourse: d.location,
								members: d.size,
						  }))
			return h.jsxs(ht, {
				loading: a || r,
				children: [
					h.jsx(dN, {
						data: u(),
						headers: l(),
						enclosingCharacter: '"',
						filename: t ? "CurrentMpgaClubs.csv" : "MpgaClubs.csv",
						children: "Download",
					}),
					h.jsxs(nc, {
						striped: !0,
						size: "sm",
						children: [
							h.jsx("thead", {
								children: h.jsxs("tr", {
									children: [
										h.jsx("th", { children: "Name" }),
										h.jsx("th", { children: "System name" }),
										h.jsx("th", { children: "Home course" }),
										h.jsx("th", { children: "Members" }),
										t && h.jsx("th", { children: "Date" }),
										t && h.jsx("th", { children: "Payment Method" }),
									],
								}),
							}),
							h.jsx("tbody", {
								children: u().map((d) =>
									h.jsxs(
										"tr",
										{
											children: [
												h.jsx("td", { children: d.name }),
												h.jsx("td", { children: d.systemName }),
												h.jsx("td", { children: d.homeCourse }),
												h.jsx("td", { children: d.members }),
												t && h.jsx("td", { children: d.paymentDate }),
												t && h.jsx("td", { children: d.paymentMethod }),
											],
										},
										d.id,
									),
								),
							}),
						],
					}),
				],
			})
		},
		CSt = () => {
			const { data: e, isLoading: t } = Iae(),
				n = [
					{ label: "First Name", key: "firstName" },
					{ label: "Last Name", key: "lastName" },
					{ label: "Email", key: "email" },
					{ label: "Phone", key: "primaryPhone" },
					{ label: "Address", key: "addressTxt" },
					{ label: "City", key: "city" },
					{ label: "State", key: "state" },
					{ label: "Zip", key: "zip" },
					{ label: "Home Club", key: "homeClub" },
				],
				r = () => (e && e.length > 0 ? e.map((i) => new ha(i)) : [])
			return h.jsxs(ht, {
				loading: t,
				children: [
					h.jsx(dN, {
						data: r(),
						headers: n,
						enclosingCharacter: '"',
						filename: "MpgaContacts.csv",
						children: "Download",
					}),
					h.jsxs(nc, {
						striped: !0,
						size: "sm",
						children: [
							h.jsx("thead", {
								children: h.jsxs("tr", {
									children: [
										h.jsx("th", { children: "First name" }),
										h.jsx("th", { children: "Last name" }),
										h.jsx("th", { children: "Email" }),
										h.jsx("th", { children: "Phone" }),
										h.jsx("th", { children: "Address" }),
										h.jsx("th", { children: "City" }),
										h.jsx("th", { children: "State" }),
										h.jsx("th", { children: "Zip" }),
										h.jsx("th", { children: "Home club" }),
									],
								}),
							}),
							h.jsx("tbody", {
								children: r().map((i) =>
									h.jsxs(
										"tr",
										{
											children: [
												h.jsx("td", { children: i.firstName }),
												h.jsx("td", { children: i.lastName }),
												h.jsx("td", { children: i.email }),
												h.jsx("td", { children: i.primaryPhone }),
												h.jsx("td", { children: i.addressTxt }),
												h.jsx("td", { children: i.city }),
												h.jsx("td", { children: i.state }),
												h.jsx("td", { children: i.zip }),
												h.jsx("td", { children: i.homeClub }),
											],
										},
										i.id,
									),
								),
							}),
						],
					}),
				],
			})
		}
	function TSt() {
		const e = Ea(),
			t = Xa(),
			n = (r) => {
				if (e.pathname.endsWith("reports")) t(`${e.pathname}/${r}`)
				else {
					const i = e.pathname.lastIndexOf("/"),
						a = `${e.pathname.substring(0, i)}/${r}`
					t(a)
				}
			}
		return h.jsx("div", {
			children: h.jsxs(_Y, {
				vertical: !0,
				children: [
					h.jsx(Ge, { variant: "link", onClick: () => n("clubs"), children: "All Clubs" }),
					h.jsx(Ge, {
						variant: "link",
						onClick: () => n("current-clubs"),
						children: "Current Clubs",
					}),
					h.jsx(Ge, { variant: "link", onClick: () => n("contacts"), children: "All Contacts" }),
					h.jsx(Ge, {
						variant: "link",
						onClick: () => n("club-contacts"),
						children: "Club Contacts",
					}),
					h.jsx(Ge, {
						variant: "link",
						onClick: () => n("primary-contacts"),
						children: "Primary Contacts",
					}),
					h.jsx(Ge, {
						variant: "link",
						onClick: () => n("mailing-contacts"),
						children: "Mailing Contacts",
					}),
					h.jsx(Ge, { variant: "link", onClick: () => n("captains"), children: "Team Captains" }),
				],
			}),
		})
	}
	const kSt = () => {
			const { name: e } = Sl(),
				t = () => {
					switch (e) {
						case "contacts":
							return h.jsxs(H.Fragment, {
								children: [
									h.jsx("h3", { className: "text-primary", children: "All Contacts" }),
									h.jsx(CSt, {}),
								],
							})
						case "club-contacts":
							return h.jsxs(H.Fragment, {
								children: [
									h.jsx("h3", { className: "text-primary", children: "Club Contacts" }),
									h.jsx(Ly, {}),
								],
							})
						case "primary-contacts":
							return h.jsxs(H.Fragment, {
								children: [
									h.jsx("h3", { className: "text-primary", children: "Primary Contacts" }),
									h.jsx(Ly, { filter: "primary" }),
								],
							})
						case "mailing-contacts":
							return h.jsxs(H.Fragment, {
								children: [
									h.jsx("h3", { className: "text-primary", children: "Mailing Contacts" }),
									h.jsx(Ly, { filter: "mailings" }),
								],
							})
						case "captains":
							return h.jsxs(H.Fragment, {
								children: [
									h.jsx("h3", { className: "text-primary", children: "Team Captains" }),
									h.jsx(Ly, { filter: "captains" }),
								],
							})
						case "clubs":
							return h.jsxs(H.Fragment, {
								children: [
									h.jsx("h3", { className: "text-primary", children: "All Clubs" }),
									h.jsx(o8, { current: !1 }),
								],
							})
						case "current-clubs":
							return h.jsxs(H.Fragment, {
								children: [
									h.jsx("h3", { className: "text-primary", children: "Current Clubs" }),
									h.jsx(o8, { current: !0 }),
								],
							})
						default:
							return h.jsx(h.Fragment, {})
					}
				}
			return h.jsxs(ln, {
				children: [
					h.jsx(it, { md: 3, lg: 2, children: h.jsx(TSt, {}) }),
					h.jsx(it, { md: 9, lg: 10, children: t() }),
				],
			})
		},
		SSt = () =>
			h.jsxs(KA, {
				children: [
					h.jsx(Rl, { pageCode: Rn.TournamentBids }),
					h.jsx(QA, { message: new jv("Bid") }),
				],
			}),
		DSt = (e) => {
			const { currentYear: t } = e,
				n = Ea(),
				r = Xa(),
				i = () => {
					const o = []
					for (let s = 2e3; s <= lt.EventCalendarYear; s++) o.push(s)
					return o.map((s) =>
						h.jsx(
							Eg,
							{
								text: "secondary",
								className: "clickable mr-2 mb-2",
								onClick: () => a(s),
								children: s,
							},
							s,
						),
					)
				},
				a = (o) => {
					const s = n.pathname.replace(t, o.toString())
					r(s)
				}
			return h.jsx("div", { children: i() })
		},
		_St = Ft.img`
  display: block;
  margin-left: auto;
  margin-right: auto;
`,
		OSt = Bt({ caption: Oe().max(240) }),
		ASt = (e) => {
			const { photo: t, show: n, onClose: r } = e,
				[i, { isLoading: a }] = qTt(),
				o = async (s) => {
					const l = { photo: s.prepJson() }
					await i(l)
						.unwrap()
						.then(() => {
							je.success("Your changes have been saved."), r()
						})
						.catch((u) => {
							je.error(" " + u)
						})
				}
			return h.jsxs(Or, {
				size: "xl",
				show: n,
				onHide: r,
				children: [
					h.jsx(Or.Header, {
						closeButton: !0,
						children: h.jsx(Or.Title, { children: "Add or Update the Photo Caption" }),
					}),
					h.jsxs(Or.Body, {
						children: [
							h.jsx(_St, { src: t.imageUrl }),
							h.jsx(Vt, {
								validationSchema: OSt,
								onSubmit: o,
								initialValues: t,
								children: ({
									handleSubmit: s,
									handleChange: l,
									handleBlur: u,
									values: d,
									touched: p,
									errors: m,
								}) =>
									h.jsxs(R, {
										noValidate: !0,
										onSubmit: s,
										children: [
											h.jsxs(R.Group, {
												controlId: "caption",
												children: [
													h.jsx(R.Label, { children: "Caption" }),
													h.jsx(R.Control, {
														placeholder: "Caption",
														name: "caption",
														value: d.caption || "",
														isValid: p.caption && !m.caption,
														isInvalid: !!m.caption,
														onChange: l,
														onBlur: u,
													}),
													h.jsx(R.Control.Feedback, { type: "invalid", children: m.caption }),
												],
											}),
											h.jsx(WA, { selectedTags: d.tags || [], OnChange: (v) => (d.tags = v) }),
											h.jsx(Ge, {
												variant: "secondary",
												type: "submit",
												size: "sm",
												className: "mt-2",
												disabled: a,
												children: "Save",
											}),
											h.jsx(Ge, {
												className: "ml-1 mt-2",
												variant: "light",
												size: "sm",
												onClick: r,
												children: "Cancel",
											}),
										],
									}),
							}),
						],
					}),
				],
			})
		},
		$G = Ft.div`
  background-color: #fff;
  box-sizing: border-box;
  float: left;
  margin: 4px;
  overflow: hidden;
  position: relative;
  @media (max-width: 480px) {
    width: calc(100% - 4px);
  }
  @media (min-width: 481px) and (max-width: 960px) {
    width: calc(33% - 4px);
  }
  @media (min-width: 961px) and (max-width: 1440px) {
    width: calc(25% - 4px);
  }
  @media (min-width: 1441px) {
    width: calc(12% - 4px);
  }
  &:hover: {
    opacity: 0.9;
  }
  > img {
    cursor: pointer;
    max-width: 100%;
  }
  > p {
    font-size: 80%;
  }
`
	$G.displayName = "Image"
	const NSt = (e) => {
			const { photo: t, onSelect: n } = e,
				[r, i] = _.useState(!1),
				a = Wt()
			return h.jsxs(
				$G,
				{
					children: [
						h.jsx("img", { onClick: n, alt: t.caption, src: t.thumbnailUrl }),
						h.jsx("p", { className: "text-muted mb-0", children: t.caption }),
						a.canEditPhotos() &&
							h.jsx(Ge, {
								variant: "link",
								className: "text-warning",
								onClick: () => i(!0),
								children: "Edit Caption",
							}),
						h.jsx(ASt, { show: r, photo: t, onClose: () => i(!1) }),
					],
				},
				t.thumbnailUrl,
			)
		},
		UG = Ft.div`
  overflow: hidden;
  margin-left: -2px;
  margin-right: -2px;
`
	UG.displayName = "Gallery"
	const MSt = (e) => {
			const { photos: t, onSelect: n } = e
			return (t == null ? void 0 : t.length) === 0
				? h.jsx("p", {
						children:
							"We dont have any pictures for this season. Have a tournament photo to share? Send them to admin@mpga.net",
				  })
				: h.jsx(UG, {
						children:
							t == null
								? void 0
								: t.map((i, a) => h.jsx(NSt, { photo: i, onSelect: () => n(a) }, a)),
				  })
		},
		ISt = (e) => {
			const { tournament: t } = e,
				{ year: n } = Sl(),
				[r, i] = _.useState(!1),
				{ photos: a, isLoading: o } = $Tt(
					{ tournamentId: t.id, year: n ? +n : void 0 },
					{
						selectFromResult: ({ data: l }) => ({
							photos: (l == null ? void 0 : l.map((u) => new LA(u))) || [],
							isLoading: o,
						}),
					},
				),
				s = (l) => {
					i(!r)
				}
			return h.jsxs("div", {
				children: [
					h.jsxs("h3", { className: "text-primary", children: [n, " ", t.name, " Gallery"] }),
					h.jsx(ln, { children: h.jsx(it, { children: h.jsx(DSt, { currentYear: n }) }) }),
					h.jsx(ht, { loading: o, children: h.jsx(MSt, { photos: a, onSelect: (l) => s() }) }),
				],
			})
		},
		s8 = () => {
			const { name: e } = Sl(),
				{ data: t, isLoading: n } = FA(e)
			return h.jsx(ii, {
				fluid: !0,
				children: h.jsx(ht, {
					loading: n,
					children: (t == null ? void 0 : t.id) && h.jsx(ISt, { tournament: new Mp(t) }),
				}),
			})
		},
		RSt = (e) => {
			const { tournament: t } = e,
				n = { viewType: Ou.Link, variant: "info", external: !0 },
				{ data: r, isLoading: i } = sh({
					key: `${t.systemName}-results`,
					tournamentId: t.id,
					documentTypes: ["Results"],
				})
			return h.jsxs(ht, {
				loading: i,
				children: [
					h.jsx("h3", { className: "text-primary mb-2", children: "Complete Tournament Results" }),
					h.jsx(Mw, { documents: r || [], render: n }),
				],
			})
		},
		LSt = () => {
			const { name: e } = Sl(),
				t = _.useMemo(
					() =>
						dx(
							(i) => i.data,
							(i) => (i ? new Mp(i) : void 0),
						),
					[],
				),
				{ tournament: n, isLoading: r } = FA(e, {
					selectFromResult: (i) => ({ ...i, tournament: t(i) }),
				})
			return h.jsx(ii, {
				fluid: !0,
				children: h.jsx(RG, {
					LeftColumn: h.jsx(ht, { loading: r, children: n && h.jsx(xG, { tournament: n }) }),
					RightColumn: n && h.jsx(RSt, { tournament: n }),
				}),
			})
		},
		PSt = Bt({ name: Oe().max(120).required(), description: Oe().required() }),
		jSt = (e) => {
			const { tournament: t, onClose: n } = e,
				[r, { isLoading: i }] = R0t(),
				a = async (o) => {
					const s = o.prepJson()
					await r(s)
						.unwrap()
						.then(() => {
							je.success(`Your changes to ${o.name} have been saved.`), n()
						})
						.catch((l) => {
							je.error(" " + l)
						})
				}
			return h.jsx(ht, {
				loading: i,
				children: h.jsx(Vt, {
					validationSchema: PSt,
					onSubmit: a,
					initialValues: t,
					children: ({
						handleSubmit: o,
						handleChange: s,
						handleBlur: l,
						values: u,
						touched: d,
						errors: p,
					}) =>
						h.jsxs(R, {
							noValidate: !0,
							onSubmit: o,
							children: [
								h.jsxs(R.Group, {
									controlId: "tournament.Name",
									children: [
										h.jsx(R.Label, { children: "Name" }),
										h.jsx(R.Control, {
											name: "name",
											placeholder: "Name",
											value: u.name,
											isValid: d.name && !p.name,
											isInvalid: !!p.name,
											onChange: s,
											onBlur: l,
										}),
										h.jsx(R.Control.Feedback, { type: "invalid", children: p.name }),
									],
								}),
								h.jsxs(R.Group, {
									controlId: "tournament.Description",
									children: [
										h.jsx(R.Label, { children: "Description" }),
										h.jsx(_s, { name: "description", value: u.description, height: "400px" }),
									],
								}),
								h.jsx(lr, {}),
								h.jsx(br, { canCancel: !0, OnCancel: n }),
							],
						}),
				}),
			})
		},
		zG = Ft.div`
  position: absolute;
  top: 0;
  right: 0;
  img {
    width: 75px;
    height: 75px;
    background-size: contain;
    object-fit: scale-down;
  }
`
	zG.displayName = "LogoImage"
	const FSt = (e) => {
			const { tournament: t, logoUrl: n } = e,
				r = Ea(),
				i = _.useRef("")
			return (
				_.useEffect(() => {
					var a
					r.hash && (i.current = r.hash.slice(1)),
						i.current &&
							document.getElementById(i.current) &&
							((a = document.getElementById(i.current)) == null ||
								a.scrollIntoView({ behavior: "smooth", block: "center", inline: "center" }))
				}, [r]),
				h.jsxs("div", {
					id: t.systemName,
					style: { position: "relative" },
					children: [
						h.jsxs("h4", {
							className: "text-secondary mb-3",
							children: [lt.EventCalendarYear, " ", t.name],
						}),
						n && h.jsx(zG, { children: h.jsx("img", { src: n, alt: `${t.name} host` }) }),
						h.jsx(tc, { text: t.description }),
						h.jsxs(Un, {
							to: `/tournaments/detail/${t.systemName}/${lt.EventCalendarYear}`,
							className: "nav-link",
							children: [lt.EventCalendarYear, " Tournament Details"],
						}),
						h.jsxs(Un, {
							to: `/tournaments/history/${t.systemName}`,
							className: "nav-link",
							children: ["Past ", t.name, " Winners"],
						}),
					],
				})
			)
		},
		BSt = (e) => {
			const { tournament: t, logoUrl: n } = e,
				r = Wt(),
				i = _.useRef(),
				a = () => {
					i.current.close()
				}
			return h.jsx(Wr, {
				ref: i,
				initEdit: !1,
				canEdit: r.canEditPageContent(),
				viewComponent: h.jsx(FSt, { tournament: t, logoUrl: n }),
				editComponent: h.jsx(jSt, { tournament: t, onClose: a }),
			})
		},
		HSt = () => {
			const { data: e, isLoading: t } = NY(lt.EventCalendarYear)
			return h.jsx(ht, {
				loading: t,
				children:
					e == null
						? void 0
						: e.map((n) => {
								var i
								const r = new Ip(n)
								return h.jsx(
									BSt,
									{
										tournament: new Mp(n.tournament),
										logoUrl: (i = r.location) == null ? void 0 : i.logoUrl,
									},
									n.tournament.id,
								)
						  }),
			})
		},
		$St = () =>
			h.jsx(ii, {
				fluid: !0,
				children: h.jsx(DG, {
					LeftColumn: h.jsxs(h.Fragment, {
						children: [
							h.jsx("h3", { className: "text-primary mb-2", children: "Tournaments" }),
							h.jsx(HSt, {}),
						],
					}),
					RightColumn: h.jsxs(h.Fragment, {
						children: [
							h.jsx("h3", { className: "text-primary mb-2", children: "Tournament Policies" }),
							h.jsx($v, { policyCode: Pi.TournamentPlayerInformation }),
						],
					}),
				}),
			}),
		USt = () => {
			const e = ki()
			return (
				_.useEffect(() => {
					e(zy())
				}, [e]),
				h.jsx(wJ, {
					children: h.jsxs($t, {
						path: "/",
						element: h.jsx(Gme, {}),
						children: [
							h.jsx($t, { index: !0, element: h.jsx(r8, {}) }),
							h.jsx($t, { path: "home", element: h.jsx(r8, {}) }),
							h.jsx($t, { path: "tournaments", element: h.jsx($St, {}) }),
							h.jsx($t, { path: "tournaments/hard-card", element: h.jsx(nkt, {}) }),
							h.jsx($t, { path: "tournaments/code-of-conduct", element: h.jsx(hbt, {}) }),
							h.jsx($t, { path: "tournaments/detail/:name/:year", element: h.jsx(JTt, {}) }),
							h.jsx($t, { path: "tournaments/history/:name", element: h.jsx(LSt, {}) }),
							h.jsx($t, { path: "tournaments/gallery/:name", element: h.jsx(s8, {}) }),
							h.jsx($t, { path: "tournaments/gallery/:name/:year", element: h.jsx(s8, {}) }),
							h.jsx($t, { path: "tournaments/contact/:name/:year", element: h.jsx(Wbt, {}) }),
							h.jsx($t, { path: "tournaments/bid", element: h.jsx(SSt, {}) }),
							h.jsx($t, { path: "match-play", element: h.jsx(Tkt, {}) }),
							h.jsx($t, { path: "match-play/rules", element: h.jsx(Ikt, {}) }),
							h.jsx($t, { path: "match-play/results", element: h.jsx(Mkt, {}) }),
							h.jsx($t, { path: "match-play/history", element: h.jsx(vkt, {}) }),
							h.jsx($t, { path: "clubs", element: h.jsx(dSt, {}) }),
							h.jsx($t, { path: "clubs/:name", element: h.jsx(sSt, {}) }),
							h.jsx($t, { path: "about", element: h.jsx(G1t, {}) }),
							h.jsx($t, { path: "about/committee", element: h.jsx(_bt, {}) }),
							h.jsx($t, { path: "about/awards", element: h.jsx(pbt, {}) }),
							h.jsx($t, { path: "contact", element: h.jsx(Abt, {}) }),
							h.jsx($t, { path: "admin/library", element: h.jsx(Pbt, {}) }),
							h.jsx($t, { path: "admin/reports/:name", element: h.jsx(kSt, {}) }),
							h.jsxs($t, {
								path: "account",
								element: h.jsx(Ote, {}),
								children: [
									h.jsx($t, { index: !0, element: h.jsx(rfe, {}) }),
									h.jsx($t, { path: "login", element: h.jsx(ffe, {}) }),
									h.jsx($t, { path: "forgot", element: h.jsx(ufe, {}) }),
									h.jsx($t, { path: "register", element: h.jsx(yfe, {}) }),
									h.jsx($t, { path: "reset-password/:uid/:token", element: h.jsx(mfe, {}) }),
									h.jsx($t, { path: "activate/:uid/:token", element: h.jsx(ofe, {}) }),
								],
							}),
						],
					}),
				})
			)
		}
	window.location.hostname === "localhost" ||
		window.location.hostname === "[::1]" ||
		window.location.hostname.match(/^127(?:\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/)
	function zSt() {
		"serviceWorker" in navigator &&
			navigator.serviceWorker.ready.then((e) => {
				e.unregister()
			})
	}
	ws.interceptors.response.use(
		(e) => e,
		(e) => {
			if (e.response.status === 401)
				sessionStorage.removeItem(lt.BearerTokenName),
					localStorage.removeItem(lt.BearerTokenName),
					mB.dispatch(mte())
			else throw e
		},
	)
	const qSt = sX(lt.StripePublicKey)
	function VSt() {
		nl.render(
			h.jsx(c8, {
				stripe: qSt,
				children: h.jsx(SX, {
					store: mB,
					children: h.jsx(Cte, { children: h.jsx(VJ, { children: h.jsx(USt, {}) }) }),
				}),
			}),
			document.getElementById("root"),
		)
	}
	VSt()
	zSt()
})
export default WSt()
